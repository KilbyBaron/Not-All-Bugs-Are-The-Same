Summary,Issue key,Issue id,Issue Type,Status,Project key,Project name,Project type,Project lead,Project description,Project url,Priority,Resolution,Assignee,Reporter,Creator,Created,Updated,Last Viewed,Resolved,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Component/s,Component/s,Component/s,Component/s,Component/s,Due Date,Votes,Labels,Description,Environment,Original Estimate,Remaining Estimate,Time Spent,Work Ratio,Σ Original Estimate,Σ Remaining Estimate,Σ Time Spent,Security Level,Outward issue link (Blocker),Outward issue link (Cloners),Outward issue link (Duplicate),Outward issue link (Incorporates),Outward issue link (Incorporates),Outward issue link (Incorporates),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Required),Outward issue link (dependent),Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Custom field (Attachment count),Custom field (Blog - New Blog Administrators),Custom field (Blog - New Blog PMC),Custom field (Blog - Write access),Custom field (Blog Administrator?),Custom field (Blogs - Admin for blog),Custom field (Blogs - Email Address),Custom field (Blogs - Existing Blog Access Level),Custom field (Blogs - Existing Blog Name),Custom field (Blogs - New Blog Write Access),Custom field (Blogs - Username),Custom field (Bug Category),Custom field (Bugzilla - Email Notification Address),Custom field (Bugzilla - List of usernames),Custom field (Bugzilla - PMC Name),Custom field (Bugzilla - Project Name),Custom field (Bugzilla Id),Custom field (Change Category),Custom field (Complexity),Custom field (Date of First Response),Custom field (Discovered By),Custom field (Docs Text),Custom field (Enable Automatic Patch Review),Custom field (Epic Link),Custom field (Existing GitBox Approval),Custom field (External issue URL),Custom field (Git Notification Mailing List),Custom field (Git Repository Import Path),Custom field (Git Repository Name),Custom field (Git Repository Type),Custom field (GitHub Options),Custom field (Github Integration),Custom field (Github Integrations - Other),Custom field (Global Rank),Custom field (INFRA - Subversion Repository Path),Custom field (Initial Confluence Contributors),Custom field (Last public comment date),Custom field (Machine Readable Info),Custom field (New-TLP-TLPName),Custom field (Patch Info),Custom field (Priority),Custom field (Project),Custom field (Protected Branch),Custom field (Rank),Custom field (Rank (Obsolete)),Custom field (Severity),Custom field (Severity),Custom field (Space Description),Custom field (Space Key),Custom field (Space Name),Custom field (Test and Documentation Plan),Custom field (Testcase included),Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment
Make createConnectionFactory() in JDBCConfigurationImpl public,OPENJPA-1568,12458969,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,fancy,fancy,fancy,12/Mar/10 18:44,29/Mar/10 23:17,14/Mar/19 03:02,16/Mar/10 06:34,2.0.0,,,,,,,,,2.0.0-beta3,,,,,,,,,,,0,,"In process of configuring plugins in JDBCConfiguration, a javax.sql.DataSource is examined for the custom properties defined on the data source.
 public DataSource getDataSource() has undesired side effects that instantiates DBDictionary.

 DecoratingDataSource createConnectionFactory() does not have the side effects.
This private method is changed to public to be visible to the extended JDBCConfigurationImpl.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161831,,,2010-03-12 18:44:43.0,,,,,,,0|i1dtbz:,288849,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
QueryTimeOut and LockTimeOut exceptions are not raised correctly,OPENJPA-1565,12458864,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,11/Mar/10 22:51,07/Apr/10 15:18,14/Mar/19 03:02,22/Mar/10 20:11,2.0.0-beta,2.0.0-beta2,2.0.0-M1,2.0.0-M2,2.0.0-M3,,,,,2.0.0-beta3,,,,,jdbc,jpa,kernel,query,sql,,0,,"Narrowing SQL Exception to a more specific exception such as lock or query or referential integrity violation does not distinguish correctly whether a query or lock request has timed out. 
This distinction is critical for JPA 2.0 spec compliance because QueryTimeOut and LockTimeOut exceptions are not supposed to cause rollback as per the spe (Section 3.9).

",,,,,,,,,,,,,,,,OPENJPA-1594,OPENJPA-1609,OPENJPA-1614,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-03-16 16:32:47.856,,,no_permission,,,,,,,,,,,161828,,,Mon Mar 22 20:11:05 UTC 2010,,,,,,,0|i0z7pb:,203550,,,,,,,,"16/Mar/10 16:32;drwoods;Looks like this is causing new junit test failures on any DB besides Derby.

MySQL 2 tests -
1) TestTimeoutException.testQueryTimeOutExceptionWhileQueryingWithLocksOnAlreadyLockedEntities    (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError was raised but expected javax.persistence.QueryTimeoutException
at org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at org.apache.openjpa.persistence.query.TestTimeoutException.testQueryTimeOutExceptionWhileQueryingWithLocksOnAlreadyLockedEntities(TestTimeoutException.java:63)
2) TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities     (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError was raised but expected javax.persistence.LockTimeoutException
at org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at org.apache.openjpa.persistence.query.TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities(TestTimeoutException.java:93)

Microsoft SQL 2008 - 1 test -
TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities     (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError was raised but expected javax.persistence.LockTimeoutException
at org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at org.apache.openjpa.persistence.query.TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities(TestTimeoutException.java:93)


DB2 - 2 tests -
1) TestTimeoutException.testQueryTimeOutExceptionWhileQueryingWithLocksOnAlreadyLockedEntities    (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError was raised but expected javax.persistence.QueryTimeoutException
at org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at org.apache.openjpa.persistence.query.TestTimeoutException.testQueryTimeOutExceptionWhileQueryingWithLocksOnAlreadyLockedEntities(TestTimeoutException.java:63)
2) TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities     (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError was raised but expected javax.persistence.LockTimeoutException
at org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at org.apache.openjpa.persistence.query.TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities(TestTimeoutException.java:93)
","16/Mar/10 16:44;ppoddar@apache.org;1. Note the SQL Error State and Code of the SQL Exception when it fails to throw expected exception
2. Check sql-error-state-codes.xml for that database dictionary. The error states are categorized in that file. If the observed error does not occur in the list of error states, add it (the error state not the error code).
3. Also check corresponding DB dictionary implementation isFatalException() and ensure that it returns false when query/lock timeouts are intended to be raised. 
4. Returning false from isFatalException() will ensure that at facade level the transaction is not rolled back.","16/Mar/10 17:14;ppoddar@apache.org;I ran with mysql-connector-java-5.1.6 locally and the tests passed for 
MySQL.

I had given Jody a patch for DB2 errors -- will check if he can verify

Can you please send me the stacktrace of SQL error for  MS-SQL 2008?

Regards --

Pinaki 







""Donald Woods (JIRA)"" <jira@apache.org> 
03/16/2010 11:36 AM

To
Pinaki Poddar/Dallas/IBM@IBMUS
cc

Subject
[jira] Issue Comment Edited: (OPENJPA-1565) QueryTimeOut and LockTimeOut 
exceptions are not raised correctly







    [ 
https://issues.apache.org/jira/browse/OPENJPA-1565?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel&focusedCommentId=12845979#action_12845979 
] 

Donald Woods edited comment on OPENJPA-1565 at 3/16/10 4:35 PM:
----------------------------------------------------------------

Looks like this is causing new junit test failures on any DB besides 
Derby.

MySQL 2 tests -
1) 
TestTimeoutException.testQueryTimeOutExceptionWhileQueryingWithLocksOnAlreadyLockedEntities 
   (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError 
was raised but expected javax.persistence.QueryTimeoutException
at 
org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at 
org.apache.openjpa.persistence.query.TestTimeoutException.testQueryTimeOutExceptionWhileQueryingWithLocksOnAlreadyLockedEntities(TestTimeoutException.java:63)
2) 
TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities 
    (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError 
was raised but expected javax.persistence.LockTimeoutException
at 
org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at 
org.apache.openjpa.persistence.query.TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities(TestTimeoutException.java:93)

Microsoft SQL 2008 - 1 test -
TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities 
    (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError 
was raised but expected javax.persistence.LockTimeoutException
at 
org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at 
org.apache.openjpa.persistence.query.TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities(TestTimeoutException.java:93)


DB2 - 2 tests -
1) 
TestTimeoutException.testQueryTimeOutExceptionWhileQueryingWithLocksOnAlreadyLockedEntities 
   (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError 
was raised but expected javax.persistence.QueryTimeoutException
at 
org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at 
org.apache.openjpa.persistence.query.TestTimeoutException.testQueryTimeOutExceptionWhileQueryingWithLocksOnAlreadyLockedEntities(TestTimeoutException.java:63)
2) 
TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities 
    (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError 
was raised but expected javax.persistence.LockTimeoutException
at 
org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at 
org.apache.openjpa.persistence.query.TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities(TestTimeoutException.java:93)


      was (Author: drwoods):
    Looks like this is causing new junit test failures on any DB besides 
Derby.

MySQL 2 tests -
1) 
TestTimeoutException.testQueryTimeOutExceptionWhileQueryingWithLocksOnAlreadyLockedEntities 
   (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError 
was raised but expected javax.persistence.QueryTimeoutException
at 
org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at 
org.apache.openjpa.persistence.query.TestTimeoutException.testQueryTimeOutExceptionWhileQueryingWithLocksOnAlreadyLockedEntities(TestTimeoutException.java:63)
2) 
TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities 
    (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError 
was raised but expected javax.persistence.LockTimeoutException
at 
org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at 
org.apache.openjpa.persistence.query.TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities(TestTimeoutException.java:93)

Microsoft SQL 2008 - 1 test -
TestException.testThrowsEntityExistsException 
(org.apache.openjpa.persistence.exception)
junit.framework.AssertionFailedError: <openjpa-2.0.0-SNAPSHOT-runknown 
fatal store error> org.apache.openjpa.persistence.RollbackException: The 
transaction has been rolled back. See the nested exceptions for details on 
the errors that occurred. or its cause is not instanceof class 
javax.persistence.EntityExistsException
at junit.framework.Assert.fail(Assert.java:47)
at 
org.apache.openjpa.persistence.exception.TestException.assertException(TestException.java:207)

DB2 - 2 tests -
1) 
TestTimeoutException.testQueryTimeOutExceptionWhileQueryingWithLocksOnAlreadyLockedEntities 
   (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError 
was raised but expected javax.persistence.QueryTimeoutException
at 
org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at 
org.apache.openjpa.persistence.query.TestTimeoutException.testQueryTimeOutExceptionWhileQueryingWithLocksOnAlreadyLockedEntities(TestTimeoutException.java:63)
2) 
TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities 
    (org.apache.openjpa.persistence.query)
junit.framework.AssertionFailedError: junit.framework.AssertionFailedError 
was raised but expected javax.persistence.LockTimeoutException
at 
org.apache.openjpa.persistence.query.TestTimeoutException.assertError(TestTimeoutException.java:141)
at 
org.apache.openjpa.persistence.query.TestTimeoutException.testLockTimeOutExceptionWhileLockingAlreadyLockedEntities(TestTimeoutException.java:93)

 
2.0.0-beta2
query or referential integrity violation does not distinguish correctly 
whether a query or lock request has timed out. 
QueryTimeOut and LockTimeOut exceptions are not supposed to cause rollback 
as per the spe (Section 3.9).

-- 
This message is automatically generated by JIRA.
-
You can reply to this email to add a comment to the issue online.


",22/Mar/10 20:11;drwoods;Code committed by Pinaki.  Remaining test issues will be handled via OPENJPA-1594.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
EntityManager:Refresh on Removed entity does not trigger IllegalArgumentException,OPENJPA-1562,12458836,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,dianner,no1uno,no1uno,11/Mar/10 17:52,25/Mar/10 03:44,14/Mar/19 03:02,24/Mar/10 17:34,2.0.0-beta2,,,,,,,,,2.0.0-beta3,,,,,,,,,,,0,,"My application unit tests turned up some unexpected behavior from basic OpenJPA entity manager functions.  It appears, for instance, that a detached entity can still be refreshed.  I decided to write a few basic tests (attached) which report five potential errors.  This does not go into the testing of cascading behavior which would require additional work.","Mac OS X, OpenJPA 2.0.0-beta2, Spring 3.0",,,,,,,,,,,,,,,,,,,,,11/Mar/10 20:08;no1uno;openjpa1562.tar.zip;https://issues.apache.org/jira/secure/attachment/12438534/openjpa1562.tar.zip,15/Mar/10 16:44;dianner;patch.txt;https://issues.apache.org/jira/secure/attachment/12438840/patch.txt,11/Mar/10 17:53;no1uno;simple_entity_tests.txt;https://issues.apache.org/jira/secure/attachment/12438524/simple_entity_tests.txt,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2010-03-11 19:46:54.921,,,no_permission,,,,,,,,,,,161825,,,Thu Mar 25 03:44:21 UTC 2010,,,,,,,0|i1dtcn:,288852,,,,,,,,11/Mar/10 17:53;no1uno;Here are the test cases and their output.,11/Mar/10 19:45;no1uno;Basic unit test showing the failure.  Note that there is a parallel email thread in which Fay Wang could not reproduce the issue. <http://n2.nabble.com/Refreshing-detached-entities-tp4717312p4718095.html>,"11/Mar/10 19:46;drwoods;Which Spec level did you specify in your persistence.xml and what properties did you set?
A JPA 1.0 level persistence.xml will automatically use compatibility settings to behave like OpenJPA 1.x -
http://openjpa.apache.org/builds/latest/docs/manual/ref_guide_remote.html#ref_guide_detach","11/Mar/10 19:48;drwoods;Add post 2.0.0-beta2, the fix for OPENJPA-1097 has been integrated, which fixes a bug where EM.clear() was not removing some $proxy class wrappers from the entities....",11/Mar/10 20:08;no1uno;Donald: interesting suggestions.  My persistence.xml file is pulling in the 2.0 namespace and specifies version 2.0.  I am now running against the OpenJPA-2.0.0.SNAPSHOT.jar and the behavior is unchanged.,"12/Mar/10 00:48;no1uno;Donald: I think you are on the right track.  At DEBUG level, I see 'PersistenceVersion=1.0' during OpenJPA initialization.  Now to figure out why.",12/Mar/10 02:34;no1uno;Spring 3.0 is reporting the wrong version (1.0) for the PersistenceVersion.  <http://jira.springframework.org/browse/SPR-6975>,"12/Mar/10 04:05;no1uno;Considerable progress.  Now only one of the twenty tests fails.

TestEntity refreshRemoved = new TestEntity(""refresh removed"");
em.persist(refreshRemoved);
em.flush();
em.remove(refreshRemoved);
em.flush();
em.refresh(refreshRemoved);

This should throw an IllegalArgumentException, but does not.",12/Mar/10 16:57;dianner;I have reproduced this latest problem with remove/refresh and am looking into it.,13/Mar/10 01:01;no1uno;Revised the bug description to reflect the narrowed scope and changed the state to minor as there are clear workarounds.,15/Mar/10 16:44;dianner;Attached patch for this problem.,"15/Mar/10 21:31;mikedd;Thanks for the patch Dianne, but I have a couple of questions. 

1. The javadoc for lock() and refresh() is very similar regarding detached entities : 

For lock() :
     @throws IllegalArgumentException if the instance is not an

             entity or is a detached entity

For refresh() : 
     @throws IllegalArgumentException if the instance is not

             an entity or the entity is not managed

Seems like we'd want to the same thing for refresh and lock (basically the if check for REFRESH can be removed).

2. This is more of a general question - your patch didn't introduce it but the assertValidAttchedEntity() method is very similar to contains(). There is a subtle difference in that contains checks whether the type is managed by this persistence context, and assertValidAttachedEntity checks whether the StateManager is persistent. There's also a slight difference in the exceptions thrown. Still it seems like we'd want to reuse the logic, and rather than duplicating the code.","16/Mar/10 03:01;dianner;Thanks for reviewing this patch Mike.

For question #1:

When I first made the change and ran all of the tests, one set of lock tests failed because of remove followed by lock.

So, I searched through the spec related to this. Section 3.2.5 says, for a refresh operation, ""If X is a new, detched, or removed entity, the IllegalArgumentException is thrown."" In other parts of the spec  (including the javadoc that you quoted), it says an IllegalArgumentException is thrown for a Lock request on a ""detached"" entity. But, I couldn't find any such statement fot a ""removed"" entity.

For question #2

At this point, I don't have an answer. I'll do a little digging.","16/Mar/10 14:15;mikedd;Hi Dianne, you're right per the spec a managed entity is one that has a persistent identity and is associated with the persistence context. A removed entity fits that description. 

I still think we can be a bit smarted about code reuse, but that's secondary to this issue - consider both my questions answered :-)",16/Mar/10 17:41;techhusky;Committed patch.txt dated 2010-03-15 04:44 PM for Dianne under revision 923849.,24/Mar/10 17:28;no1uno;The patch works for me.  I tested with beta3 build from the staging area.,25/Mar/10 03:44;mikedd;Closing on Jerry's behalf. ,,,,,,,,,,,,,,,,,,,,
DataCacheManager initialization isn't thread safe.,OPENJPA-1559,12458596,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,curtisr7,curtisr7,curtisr7,09/Mar/10 23:15,22/Apr/10 20:30,14/Mar/19 03:02,10/Apr/10 17:41,2.0.0,,,,,,,,,2.0.0,,,,,datacache,,,,,,0,,"When running normally, some of OpenJPA configuration is lazily loaded and is not thread safe. Normally this isn't an issue if one thread has a different configured object than another.

Today I came across a problem when using the DataCache EvictionScheduler that multiple scheduler threads can get created and kicked off. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-04-10 17:41:35.905,,,no_permission,,,,,,,,,,,161822,,,Sat Apr 10 17:41:35 UTC 2010,,,,,,,0|i1dtd3:,288854,,,,,,,,10/Mar/10 15:47;curtisr7;Committed revision 921410 to trunk.,"19/Mar/10 19:46;curtisr7;The change that I committed (rev. 921410) relies on double checked locking with a primitive which I thought was safe to do.... but it appears that TestDataCacheScheduler.testMultithreadedInitialization fails intermittently on a larger test machine. To date I've been unable to recreate this problem on my dev machine. 

It appears that my fix still has a small window where this problem exists. Reopening to investigate at a later date.",19/Mar/10 19:48;curtisr7;Reducing severity as this seems fairly hard to reproduce and doesn't have that large of an impact.,"10/Apr/10 17:41;drwoods;Code checked into 2.0.0, so marking it resolved for the release notes.
If more work is required, please open a new issue and link it to this one.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Many side of a MxO relationship contains null reference if One side is loaded first.,OPENJPA-1558,12458577,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,09/Mar/10 20:32,29/Mar/10 23:17,14/Mar/19 03:02,11/Mar/10 02:47,1.2.3,1.3.0,2.0.0,,,,,,,1.3.0,2.0.0-beta3,,,,,,,,,,0,,"If you have a MxO relationship with both sides using FetchType.LAZY and load the One side first, loading the Many side will not be able to load the reference back to the one side. ",,,,,,,,,,,,,,,,,,,,,,11/Mar/10 17:16;mikedd;OPENJPA-1558.1.2.x.diff.txt;https://issues.apache.org/jira/secure/attachment/12438523/OPENJPA-1558.1.2.x.diff.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-03-09 22:05:24.411,,,no_permission,,,,,,,,,,,161821,,,Tue Mar 09 22:05:24 UTC 2010,,,,,,,0|i0z3gf:,202862,,,,,,,,09/Mar/10 22:05;drwoods;Adding Fix Versions so this doesn't slip paste our 2.0.0 radar....,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Exception thrown on first use of @Strategy in @Embeddable classes,OPENJPA-1556,12458565,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,no1uno,no1uno,09/Mar/10 18:20,23/Mar/10 18:33,14/Mar/19 03:02,10/Mar/10 22:43,2.0.0-beta2,,,,,,,,,2.0.0-beta3,,,,,,,,,,,0,,"I have an entity (SimpleEntity) which references an ElementCollection (ChildOne.class).  There is a @Strategy annotation on a field within the embeddable class.  The first time a query is built for the entity, an exception is thrown:

<openjpa-2.0.0-beta2-r422266:915978 fatal user error> org.apache.openjpa.persistence.ArgumentException: Attempt to map ""com.example.ChildOne.address"" failed: the owning entity is not mapped.
	at org.apache.openjpa.jdbc.meta.MappingInfo.assertTable(MappingInfo.java:628)
	at org.apache.openjpa.jdbc.meta.MappingInfo.createColumns(MappingInfo.java:558)
	at org.apache.openjpa.jdbc.meta.ValueMappingInfo.getColumns(ValueMappingInfo.java:178)
	at org.apache.openjpa.jdbc.meta.strats.HandlerStrategies.map(HandlerStrategies.java:65)
	at org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy.map(HandlerFieldStrategy.java:81)
	at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:146)
	... etc. ...

If the @Strategy is not present, everything works fine.  If the exception is intentionally triggered, subsequent use is successful.

Google suggests that this behavior has been seen before <http://marc.info/?l=geronimo-user&m=121545735018232&w=2> and <http://issues.apache.org/jira/browse/OPENJPA-524>, though there appears to have been no resolution in either case and this differs by use of @ElementCollection.","Mac OS X 10.6, Maven 2.2.x, Spring 3.0",,,,,,,,,,,,,,,OPENJPA-1570,,,,,,09/Mar/10 23:44;faywang;OPENJPA-1556.patch;https://issues.apache.org/jira/secure/attachment/12438343/OPENJPA-1556.patch,09/Mar/10 19:15;no1uno;openjpa1556.tar.zip;https://issues.apache.org/jira/secure/attachment/12438310/openjpa1556.tar.zip,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-03-11 14:33:35.073,,,no_permission,,,,,,,,,,,161819,,,Fri Mar 12 15:03:37 UTC 2010,,,,,,,0|i0zbtb:,204216,,,,,,,,09/Mar/10 19:15;no1uno;The attached Eclipse project uses Maven for the builds.  Import into Eclipse and build as Maven install.  There will be an exception thrown from TestSimpleDAO::testCreateEntity().  Readding the commented lines as the start of the function will cause the exception to be caught and ignored on the first pass with all subsequent interactions succeeding.,"11/Mar/10 14:33;oringel;the same exception occurs if you add the @Strategy annotation on a field of an @Embeddable or @MappedSuperclass (not part of an @ElementCollection). 
The attached patch does not fix the problem. 

To be more concrete. I try to change the default enum handling using an own EnumValueHandler. The Handler is working if you add
the Strategy to the @Entity. Adding the field to a @MappedSuperclass leads to the above exception.

@javax.persistence.Entity
@javax.persistence.Table(name = ""TESTENTITY"")
public class TestEntity extends TestEntityBase {
...
}

@MappedSuperclass
public abstract class TestEntityBase {
    @Column(name = ""TESTENUMSIMPLE"")
    @Enumerated(javax.persistence.EnumType.STRING)
    @Strategy(""jpa.test.domain.EnumStrategy"")
    private TestEnumSimple testEnumSimple;
...
}

You get the same Exception if you add the @Strategy to a @Embeddable and I also tried a own StringValueHandler with the same result.","12/Mar/10 15:03;no1uno;Oliver: Interesting.  Not sure what the protocol is for this project, but you might open a new JIRA report and link back to this one.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"When batchLimit=-1 or >1 and an exception is caused, the params and failedObject are missing from the resultant exception.",OPENJPA-1550,12458202,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,drwoods,jpaheath,jpaheath,05/Mar/10 03:32,22/Apr/10 20:30,14/Mar/19 03:02,25/Mar/10 03:57,1.2.2,1.3.0,2.0.0-beta2,,,,,,,1.2.3,1.3.0,2.0.0,2.1.0,,jdbc,,,,,,0,,"Exception reporting is different depending on the value of batchLimit.  To describe and demonstration this problem, lets take the following Entitiy:

@Entity
public class Ent1 {
    @Id
    private int pk;    
    private String name;
.....
}

As a test, lets assume that we have an Ent1 with pk=200 already defined in the DB and our test will attempt to create and persist another Ent1 with pk=200 (i.e. a duplicate key).  In so doing we get the following exception as indicated by the batchLimit settings:

batchLimit=0 or batchLimit=1
Caused by: <openjpa-1.2.2-SNAPSHOT-r422266:889769M nonfatal store error> org.apache.openjpa.persistence.EntityExistsException: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by 'SQL100301111328870' defined on 'ENT1'. {prepstmnt 33038075 INSERT INTO Ent1 (pk, name) VALUES (?, ?) [params=(int) 200, (String) twohundred]} [code=20000, state=23505]
FailedObject: siemens75007.Ent1@19d0e0b


when batchLimit=-1 or >1
Caused by: <openjpa-1.2.2-SNAPSHOT-r422266:889769M nonfatal store error> org.apache.openjpa.persistence.EntityExistsException: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by 'SQL100301111328870' defined on 'ENT1'.
FailedObject: prepstmnt 33038075 INSERT INTO Ent1 (pk, name) VALUES (?, ?) [org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement]


Notice that when batchLimit=[0,1], the exception lists the prepared statement used along with the params which caused the failure, as well as the 'FailedObject'.  Furthermore, calling 'getFailedObject' on the resultant exception will give the caller the entity which caused the failure.  In contrast, when batchLimit=-1 or a value greater than 1, we can see that the exception message is missing the prepared statement info, however, it is presented in the 'FailedObject'.  The params are also missing from the prepared statement.  A call to 'getFailedObject' on the resultant exception will NOT give the caller the entity which caused the exception.
",,,,,,,,,,,,,,,,,,,,,,18/Mar/10 05:25;jpaheath;OPENJPA-1550-13x-testcase.patch.txt;https://issues.apache.org/jira/secure/attachment/12439116/OPENJPA-1550-13x-testcase.patch.txt,24/Mar/10 22:09;jpaheath;OPENJPA-1550-13x-v2.diff.txt;https://issues.apache.org/jira/secure/attachment/12439719/OPENJPA-1550-13x-v2.diff.txt,09/Mar/10 20:32;drwoods;OPENJPA-1550-13x.patch;https://issues.apache.org/jira/secure/attachment/12438323/OPENJPA-1550-13x.patch,24/Mar/10 22:09;jpaheath;OPENJPA-1550-trunk-testcase.patch.txt;https://issues.apache.org/jira/secure/attachment/12439720/OPENJPA-1550-trunk-testcase.patch.txt,09/Mar/10 21:34;drwoods;OPENJPA-1550-trunk.patch;https://issues.apache.org/jira/secure/attachment/12438328/OPENJPA-1550-trunk.patch,16/Mar/10 17:56;jpaheath;OPENJPA-1550.diff.txt;https://issues.apache.org/jira/secure/attachment/12438943/OPENJPA-1550.diff.txt,24/Mar/10 22:09;jpaheath;OPENJPA-1550v2.diff.txt;https://issues.apache.org/jira/secure/attachment/12439718/OPENJPA-1550v2.diff.txt,,,,,,,,7.0,,,,,,,,,,,,,,,,,,,2010-03-09 20:32:33.14,,,no_permission,,,,,,,,,,,161813,,,Thu Mar 25 03:57:10 UTC 2010,,,Patch Available,,,,0|i1dte7:,288859,,,,,,,,05/Mar/10 03:55;jpaheath;Proposed code changes for this issue.,09/Mar/10 20:32;drwoods;Updated patch for 1.3.x branch,09/Mar/10 21:34;drwoods;updated patch that can be applied to trunk.  waiting for all junits and TCKs to finish before committing.,09/Mar/10 22:29;drwoods;Applied to 13x and trunk.,10/Mar/10 03:17;drwoods;Heath will be adding a testcase patch and Mike will be pulling into 1.2.3.,16/Mar/10 17:56;jpaheath;Attaching the final version of the code changes and a test case.  The patch contains both code changes and test case.,18/Mar/10 05:25;jpaheath;Adding updated patch for 1.3.x and truck which contains code changes and a new test case.,"18/Mar/10 14:14;drwoods;Mike has already applied the patches to 1.2.x branch.
Updated 1.3.x patch applied as r924766.
Working on trunk updates now, but seeing 6 test failures in the new TestBatchLimitException.",24/Mar/10 22:09;jpaheath;Adding code to allow the 'failed object' to percolate up to the RollbackException.,"24/Mar/10 22:55;jpaheath;Let me comments on the patches I just attached:

OPENJPA-1550v2.diff.txt is for 1.2.x. 
OPENJPA-1550-13x-v2.diff.txt is for 1.3.x
OPENJPA-1550-trunk-testcase.patch.txt is for trunk.

These patches add code to allow the 'failed object' to percolate up to the RollbackException which results in the use case.
In addition, the trunk version of the patch fixes the test failures as outline by Donald.

For history sake, let me comment on the other patches already committed:

These patches are for 1.3.x:
OPENJPA-1550-13x.patch - this is the initial code change committed.
OPENJPA-1550-13x-testcase.patch.txt - this one adds some additional code plus the test case.

This patch is for trunk:
OPENJPA-1550-trunk.patch - this is the initial code change committed.

And this patch is for 1.2.x:
OPENJPA-1550.diff.txt - this is the initial code change committed plus the test case.","25/Mar/10 02:58;mikedd;Thanks for the patches Heath. I've committed to 1.3.x, with the other releases coming when the sanity builds complete. ","25/Mar/10 03:57;mikedd;Committed Heath's latest patch on trunk, 2.0.x and 1.2.x. ",,,,,,,,,,,,,,,,,,,,,,,,,
NOT IN with MEMBER OF returns syntax error,OPENJPA-1547,12457889,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,02/Mar/10 17:28,23/Mar/10 18:33,14/Mar/19 03:02,09/Mar/10 18:10,1.2.2,2.0.0,2.0.0-beta2,,,,,,,2.0.0-beta3,,,,,query,,,,,,0,,"With the following entities:

@Entity
public class EntityA {
	@Id
	int id;
	int age;
	String name;
}

@Entity
public class EntityB {
	@Id
	int id;
	int age;
       @PersistentCollection(fetch=FetchType.LAZY)
	String[] nickNames;
}

OpenJPA generates wrong SQL for the JPQL:
        String jpql = ""SELECT a.name FROM EntityA a WHERE a.id not in "" + 
        ""(select b.id FROM EntityB b where ?1 MEMBER OF b.nickNames)"";
 
SELECT t0.name FROM EntityA t0 
WHERE (0 = (SELECT COUNT(*) FROM  
     WHERE (t0.id IN (
          SELECT t1.id 
	       FROM EntityB t1 
	       INNER JOIN EntityB_nickNames t2 ON t1.id = t2.ENTITYB_ID 
	       WHERE (t2.element = ?) )) ))  [params=(String) token1]

Note that if the JPQL is:
        String jpql = ""SELECT a.name FROM EntityA a WHERE a.id in "" + 
        ""(select b.id FROM EntityB b where ?1 MEMBER OF b.nickNames)"";

The push-down sql is correct:
SELECT t0.name FROM EntityA t0 
      WHERE (t0.id IN 
          (SELECT t1.id 
	        FROM EntityB t1 
		INNER JOIN EntityB_nickNames t2 ON t1.id = t2.ENTITYB_ID 
		WHERE (t2.element = ?) ));

",,,,,,,,,,,,,,,,,,,,,,02/Mar/10 19:24;faywang;OPENJPA-1547.patch;https://issues.apache.org/jira/secure/attachment/12437632/OPENJPA-1547.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-03-02 21:09:48.008,,,no_permission,,,,,,,,,,,161810,,,Tue Mar 02 21:09:48 UTC 2010,,,,,,,0|i0z33r:,202805,,,,,,,,"02/Mar/10 19:24;faywang;The patch will process the following JPQL:

SELECT a.name FROM EntityA a 
WHERE a.id not in 
   (select b.id FROM EntityB b where ?1 MEMBER OF b.nickNames)

and generate the following SQL:

SELECT t0.name FROM EntityA t0 WHERE 
(NOT (t0.id IN (
    SELECT t1.id FROM EntityB t1 
        INNER JOIN EntityB_nickNames t2 ON t1.id = t2.ENTITYB_ID 
	WHERE (t2.element = ?) )))  [params=(String) token1]
",02/Mar/10 21:09;fancy;The patch looks good to me.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA doesn't work as internal JPA inside web applicaion in JBoss AS,OPENJPA-1546,12457858,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,ratatosk,ratatosk,02/Mar/10 13:35,29/Mar/10 23:17,14/Mar/19 03:02,02/Mar/10 16:55,2.0.0-beta2,,,,,,,,,2.0.0-beta3,,,,,,,,,,,0,,"OpenJPA fails to complete the initialization phase if it is used as an internal library inside web application and this application is deployed to the JBoss AS. The problem is that PersistenceMetaDataFactory tries to parse the directory as an unparsed XML file. It takes the URL to this XML file from the list of the unparsed files. But the URL that points to a directory is added to this list. This URL is added to the unparsed files in the mapPersistentTypeNames method of the PersistenceMetaDataFactory class.
I've attached the stack trace of the original error and the patch with possible fix.
",JBoss AS 5.1,,,,,,,,,,,,,,,,,,,,,02/Mar/10 15:21;drwoods;OPENJPA-1546-13x.diff;https://issues.apache.org/jira/secure/attachment/12437613/OPENJPA-1546-13x.diff,02/Mar/10 14:41;drwoods;OPENJPA-1546.diff;https://issues.apache.org/jira/secure/attachment/12437605/OPENJPA-1546.diff,02/Mar/10 13:38;ratatosk;openjpa-jboss.patch;https://issues.apache.org/jira/secure/attachment/12437600/openjpa-jboss.patch,02/Mar/10 13:38;ratatosk;stack-trace.txt;https://issues.apache.org/jira/secure/attachment/12437601/stack-trace.txt,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2010-03-02 14:41:09.444,,,no_permission,,,,,,,,,,,161809,,,Tue Mar 02 16:55:47 UTC 2010,,,Patch Available,,,,0|i0zbtj:,204217,,,,,,,,"02/Mar/10 14:41;drwoods;Slight variation of the patch, which matches the existing checks for !URL and isClass","02/Mar/10 15:02;kwsutter;Thanks for debugging the problem, Dmitri.  Thanks for taking a first look at the patch, Donald.  Overall, the updated patch looks good.  I'd adjust the spelling of ""parced"" and format it more consistently.  But, other than that, it looks good.  Thanks.",02/Mar/10 15:21;drwoods;same patch for 13x,02/Mar/10 16:55;drwoods;committed to trunk as r918070 and 1.3.x as r918110,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Remove WebSphere version number from org/apache/ee/localizer.properties,OPENJPA-1544,12457751,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,drwoods,cathynord,cathynord,01/Mar/10 16:15,29/Mar/10 23:17,14/Mar/19 03:02,01/Mar/10 16:24,2.0.0-beta2,,,,,,,,,2.0.0-beta3,,,,,kernel,,,,,01/Mar/10 00:00,0,,"A translator reported a problem with translating due to a segmentation error
was-transaction-id-exception: Unable to determine identity of the current \
	WebSphere managed transaction. Please ensure that your are running the \
	application from within WebSphere Application Server (version 5.0.2 or \ 
	newer).

I noticed that this message and two others contain ""5.0.2'"".  I checked with Jeremy and he was ok with changing the messages to remove the version id and ""newer"".
was-transaction-id-exception: Unable to determine identity of the current \
	WebSphere managed transaction. Please ensure that your are running the \
	application from within WebSphere Application Server.
was-reflection-exception: An error occurred reflecting WebSphere proprietary \
	interfaces. Please ensure that you are running the application from within \
	WebSphere Application Server.
was-lookup-error: An error occurred looking up the WebSphere extended JTA \
	service. Please ensure that you are running the application from within \
	WebSphere Application Server.
",,,,,,,,,,,,,,,,,,,,,,01/Mar/10 16:18;cathynord;patch_1544.txt;https://issues.apache.org/jira/secure/attachment/12437489/patch_1544.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-03-01 16:24:58.081,,,no_permission,,,,,,,,,,,161807,,,Mon Mar 01 16:24:58 UTC 2010,,,Patch Available,,,,0|i1dtef:,288860,,,,,,,,01/Mar/10 16:24;drwoods;committed to trunk as r917572,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Need to change fragmented messages that are combined by PreparedQueryImpl and PreparedQueryCacheImpl to complete messages,OPENJPA-1543,12457492,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,cathynord,cathynord,25/Feb/10 22:11,29/Mar/10 23:17,14/Mar/19 03:02,03/Mar/10 17:43,2.0.0-beta2,,,,,,,,,2.0.0-beta3,,,,,kernel,,,,,01/Mar/10 00:00,0,,"This file contains a number of messages that are fragments
/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties

These fragments are put together into complete messages by PreparedQueryImpl.java and PreparedQueryCacheImpl.java

This needs to be changed so that each message is a complete message rather than putting it together as fragments as fragments are often hard to translate so that the complete message reads correctly.

Also, Kevin recommends that this message be TRACE instead of INFO.
250  TestConv  INFO   [main] openjpa.Runtime - Query ""select a FROM CacheObjectE a where a.str = 'e'"" is removed from cache excluded permanentlybecause the query result is not obtained by executing a select statement. This can happen if the query was evaluated in-memory. The result was provided by an instance of org.apache.openjpa.datacache.QueryCacheStoreQuery$CachingResultObjectProvider@26472647.  .",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161806,,,2010-02-25 22:11:04.0,,,,,,,0|i1dten:,288861,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Support openjpa.DataCache Types and ExcludedTypes configuration,OPENJPA-1542,12457487,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,25/Feb/10 21:25,29/Mar/10 23:17,14/Mar/19 03:02,26/Feb/10 15:25,2.0.0-beta,,,,,,,,,2.0.0-beta3,,,,,,,,,,,0,,"Support for the Types/ExcludedTypes configuration property was added to 1.2.x with OPENJPA-1500, but was removed when OPENJPA-1334 was added. This JIRA will be used to put the support back into the code base.",,,,,,,,,,,,,,,,,,,,,,25/Feb/10 21:25;curtisr7;OPENJPA-1542.patch;https://issues.apache.org/jira/secure/attachment/12437049/OPENJPA-1542.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161805,,,Fri Feb 26 15:25:46 UTC 2010,,,,,,,0|i0z333:,202802,,,,,,,,25/Feb/10 21:25;curtisr7;Attaching patch for now.,26/Feb/10 15:25;curtisr7;Committed revision 916714 to trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Move hard coded text in OpenJPAVersion.java to localizer.properties,OPENJPA-1538,12457460,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,drwoods,cathynord,cathynord,25/Feb/10 17:08,29/Mar/10 23:17,14/Mar/19 03:02,26/Feb/10 17:05,2.0.0-beta2,,,,,,,,,2.0.0-beta3,,,,,docs,kernel,,,,,0,,"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java
contains some hard coded text that could be moved to message properties file.

    public void appendOpenJPABanner(StringBuilder buf) {
        buf.append(VENDOR_NAME).append("" "");
        buf.append(VERSION_NUMBER);
        buf.append(""\n"");
        buf.append(""version id: "").append(VERSION_ID);
        buf.append(""\n"");
        buf.append(""Apache svn revision: "").append(REVISION_NUMBER);
        buf.append(""\n"");
    }
",,,,,,,,,,,,,,,,,,,,,,26/Feb/10 00:30;cathynord;patch1_1538.txt;https://issues.apache.org/jira/secure/attachment/12437077/patch1_1538.txt,26/Feb/10 00:30;cathynord;patch2_1538.txt;https://issues.apache.org/jira/secure/attachment/12437078/patch2_1538.txt,26/Feb/10 00:30;cathynord;patch3_1538.txt;https://issues.apache.org/jira/secure/attachment/12437079/patch3_1538.txt,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2010-02-26 17:05:18.842,,,no_permission,,,,,,,,,,,161801,,,Fri Feb 26 21:08:39 UTC 2010,,,Patch Available,,,,0|i1dtf3:,288863,,,,,,,,"26/Feb/10 00:30;cathynord;Proposed fix for OpenJPAVersion.java.

Some minor grammical fixes are also included.",26/Feb/10 17:05;drwoods;committed to trunk as r916757 and r916759.,26/Feb/10 21:08;cathynord;Thanks Donald for committing this.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SQL with outer join cannot handle null columns when inheritance is involved,OPENJPA-1536,12457359,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,24/Feb/10 22:55,23/Mar/10 18:33,14/Mar/19 03:02,25/Feb/10 05:08,2.0.0-beta,2.0.0-beta2,,,,,,,,2.0.0-beta3,,,,,sql,,,,,,0,,"Have the following entities:

@Entity
@Table(name=""CEmployee"")
@Inheritance(strategy=InheritanceType.JOINED)
@DiscriminatorColumn(name=""EMP_TYPEL"", discriminatorType=DiscriminatorType.INTEGER)
public class Employee {
    @Id
    private int id;
    
    private String lastName;
    private String firstName;

    private int vacationDays;
    
    @ManyToOne
    private Manager manager;
    
    @ManyToOne
    private Department department;
    
    @OneToOne(cascade=CascadeType.ALL)
    private CommentBlock commentBlock;
    
    @Version
    private long version;
...

}

@Entity
@Table(name=""CDepartment"")
public class Department {
    @Id
    private int id;
    
    private String departmentName;
    
    @ManyToOne
    private Manager departmentManager;
    
    @OneToMany(mappedBy=""department"")
    private List<Employee> employeeList;
...
}

@Entity
@DiscriminatorValue(""2"")
public class FTEmployee extends Employee {
    private double salary;
...

@Entity
@DiscriminatorValue(""3"")
public class Manager extends FTEmployee {
    @OneToMany(mappedBy=""manager"")
    private List<Employee> managesList;
...
}

In the test, three departments, and 11 employees are created - 3 employees are managers, each which own a department.  Two of the managers have Manager(id=1) as their manager.
Manager(id=1) is the CEO so it has no manager (this value is set null.)  

The problem is that a simple find for Employee(id=1) (which should return Manager(id=1)) returns null, the criteria of the SELECT fails to locate the correct row.  The SQL generated by the find is as follows:

SELECT t2.EMP_TYPEL, t2.version, t3.id, t3.version, t3.lastUpdate, t4.id, t7.id, 
t7.EMP_TYPEL, t7.version, t7.COMMENTBLOCK_ID, t7.DEPARTMENT_ID, t7.firstName, 
t7.lastName, t7.vacationDays, t6.salary, t4.departmentName, t2.firstName, 
t2.lastName, t10.id, t10.EMP_TYPEL, t10.version, t10.COMMENTBLOCK_ID, 
t10.DEPARTMENT_ID, t10.firstName, t10.lastName, t10.vacationDays, t9.salary, 
t2.vacationDays, t1.salary 
FROM Manager t0 
INNER JOIN FTEmployee t1 ON t0.id = t1.id 
INNER JOIN CEmployee t2 ON t1.id = t2.id 
LEFT OUTER JOIN CCommentBlock t3 ON t2.COMMENTBLOCK_ID = t3.id 
LEFT OUTER JOIN CDepartment t4 ON t2.DEPARTMENT_ID = t4.id 
LEFT OUTER JOIN Manager t8 ON t2.MANAGER_ID = t8.id 
LEFT OUTER JOIN Manager t5 ON t4.DEPARTMENTMANAGER_ID = t5.id 
LEFT OUTER JOIN FTEmployee t9 ON t8.id = t9.id 
LEFT OUTER JOIN FTEmployee t6 ON t5.id = t6.id 
LEFT OUTER JOIN CEmployee t10 ON t9.id = t10.id 
LEFT OUTER JOIN CEmployee t7 ON t6.id = t7.id 
WHERE t2.EMP_TYPEL = ? AND 
      t7.EMP_TYPEL = ? AND 
      t10.EMP_TYPEL = ? AND 
      t0.id = ?  optimize for 1 row [params=(int) 3, (int) 3, (int) 3, (int) 1]

This 0-result sql is caused by the retrieval of the eager toOne field, Manager. 
Note that the LEFT OUTER JOIN betweent t2 and t8 is to retrieve the Manager.
LEFT OUTER JOIN already takes care of possible null manager case. However, 
the where clause did not consider the possible null manager case. 
The correct clause should be: 

WHERE t2.EMP_TYPEL = ? AND 
      (t7.EMP_TYPEL = ? OR t7.EMP_TYPEL IS NULL) AND 
     (t10.EMP_TYPEL = ? OR t10.EMP_TYPEL IS NULL) AND 
      t0.id = ?  optimize for 1 row [params=(int) 3, (int) 3, (int) 3, (int) 1]

 





",,,,,,,,,,,,,,,,,,,,,,24/Feb/10 22:58;faywang;OPENJPA-1536.patch;https://issues.apache.org/jira/secure/attachment/12436918/OPENJPA-1536.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-02-24 23:20:33.883,,,no_permission,,,,,,,,,,,161799,,,Wed Feb 24 23:20:33 UTC 2010,,,Patch Available,,,,0|i0z367:,202816,,,,,,,,"24/Feb/10 23:20;fancy;Fay,
I have reviewed your patch, and it looks good to me.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inconsistency in exceptions thrown from MetaDataRepository.resolve(),OPENJPA-1535,12457344,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,rpalache,rpalache,24/Feb/10 21:34,29/Mar/10 23:17,14/Mar/19 03:02,25/Feb/10 17:31,1.0.3,1.1.0,1.2.2,2.0.0-beta,,,,,,1.3.0,2.0.0-beta3,,,,,,,,,,0,,"There is an inconsistency in the way exceptions are thrown from MetaDataRepository.resolve(ClassMetaData).
If there are more than one error encountered while resolving metadata then all these exceptions are wrapped inside MetaDataException 
and the MetaDataException is thrown. If there is only single exception thrown then that exception is thrown without wrapping inside MetaDataException.

So, in case of single error encountered any exception ( need not be MetaDataException) is thrown 
but in case of multiple errors encountered MetaDataException is thrown.

Now, there is a method loadRegisteredClassMetaData() inside same class which calls the above resolve method ( via other method calls).
This loadRegisteredClassMetaData() catches MetaDataException and logs a warning, which is an expected behavior.
But as resolve(), in case of a single error , throws an exception other than MetaDataException loadRegisteredClassMetaData() is not
able to catch this Exception.

I think this inconsistence behavior has to be fixed inside MetaDataRepository.resolve().",,,,,,,,,,,,,,,,,,,,,,25/Feb/10 02:50;rpalache;OPENJPA-1535-1.1.x.patch;https://issues.apache.org/jira/secure/attachment/12436943/OPENJPA-1535-1.1.x.patch,25/Feb/10 02:54;rpalache;OPENJPA-1535-trunk.patch;https://issues.apache.org/jira/secure/attachment/12436945/OPENJPA-1535-trunk.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-02-25 17:31:07.543,,,no_permission,,,,,,,,,,,38223,,,Thu Feb 25 17:31:07 UTC 2010,,,Patch Available,,,,0|i0z6lz:,203373,,,,,,,,25/Feb/10 02:50;rpalache;Attaching patch contributed by Hiroki Tateno.,25/Feb/10 02:54;rpalache;Attaching patch contributed by Hiroki Tateno.,25/Feb/10 17:31;drwoods;Applied patch to trunk and 13x.  Will leave it up to the other branch release managers to backport...,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JPA2 select math mix with aggregate reports syntax error,OPENJPA-1533,12457255,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,24/Feb/10 06:49,09/Mar/10 18:29,14/Mar/19 03:02,24/Feb/10 09:00,2.0.0-beta,,,,,,,,,2.0.0-beta2,,,,,query,,,,,,0,,"A problem is found in select expression involving math mix with aggregate resulted in syntax error.
Sample JPQL:  
SELECT SUM(c.age) + SUM(c.userid) FROM CompUser c
should not get syntax error.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161797,,,Wed Feb 24 09:00:19 UTC 2010,,,,,,,0|i0z37j:,202822,,,,,,,,24/Feb/10 09:00;fancy;Fix checked in under trunk revision 915725,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AssociationOverride does not work when applying to the map key of the element collection via orm.xml,OPENJPA-1527,12457126,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,23/Feb/10 09:13,06/Mar/10 13:44,14/Mar/19 03:02,24/Feb/10 17:46,2.1.0,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,23/Feb/10 09:14;faywang;OPENJPA-1527.patch;https://issues.apache.org/jira/secure/attachment/12436689/OPENJPA-1527.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-03-06 13:44:13.358,,,no_permission,,,,,,,,,,,161791,,,Sat Mar 06 13:44:13 UTC 2010,,,,,,,0|i0z34n:,202809,,,,,,,,"23/Feb/10 23:11;faywang;The cause of the problem is that the key of the map can be embeddable, which can have associationOverride specified in the orm.xml. However, currently openjpa only handles the associationOverride on the element in an element collection, which can be a map or a collection.  

The fix is to loop through the remaining _deferredMappings in the XMLPersistenceMappingParser (which does not have covered by the _embeddables), and process the associationOverride information stored in it.   ","06/Mar/10 13:44;to_rowe;Fix verified on IBM SE6 on Linux AMD64 running JSE, web, and EJB scenarios.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ManagedRuntime does not work for OSGi,OPENJPA-1524,12456798,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,timothyjward,timothyjward,19/Feb/10 16:50,29/Mar/10 23:17,14/Mar/19 03:02,22/Mar/10 19:15,2.0.0-beta,,,,,,,,,2.0.0-beta3,,,,,osgi,,,,,,1,,"In an OSGi runtime there is no TransactionManager registered in JNDI

It is possible to use an osgi:services/ lookup, but it is much safer, and better practice to look up the resource in the OSGi service registry.",,,,,,,,,,,,,,,,OPENJPA-1593,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-02-25 16:24:56.426,,,no_permission,,,,,,,,,,,161788,,,Mon Mar 22 19:15:39 UTC 2010,,,,,,,0|i0zbsn:,204213,,,,,,,,"19/Feb/10 17:16;timothyjward;One implementation suggestion would be to use a ServiceTracker to keep track of the JTA services. This would allow for lazy lookup and also provide a notification if the service is unregistered.

This should then be possible to implement as a relatively simple subclass of RegistryManagedRuntime that overrides getTransactionManager(). I don't know if you have a nice mechanism to pass a BundleContext yet, but I don't think that should pose a significant problem.","25/Feb/10 16:24;jbohn;To work around this I've added the following property to my persistence.xml - so you will need to use a name similar to this.

<property name=""openjpa.ManagedRuntime"" value=""jndi(TransactionManagerName=aries:services/javax.transaction.TransactionManager)""/>","15/Mar/10 14:04;drwoods;The r920553 change to include the Aries specific JNDI lookup is working, but I'd like to create a generic OSGiManagedRuntime class that would work for other vendors too.  But as I'm looking at the Aries transaction module, I'm not seeing how it is being registered in the ServiceRegistry with a common OSGi name that isn't Aries specific.

transaction/transaction-manager/target/sources/org/apache/aries/transaction/Activator.java:45 -
        props.put(Constants.SERVICE_PID, getName());
        bundleContext.registerService(ManagedServiceFactory.class.getName(), this, props);

where getName() is -
    public String getName() {
        return ""org.apache.aries.transaction"";
    }

Shouldn't the Aries TransactionManagerService also be registered as ""javax.transaction.TransactionManager""?
","22/Mar/10 19:15;drwoods;JNDI solution was added back on March 8th and will be in 2.0.0-beta3.
Opened OPENJPA-1593 as a subtask to look at adding an OSGiManagedRuntime in 2.1.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Remove WARN messages for uncacheable finder select statements,OPENJPA-1518,12456593,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,kwsutter,kwsutter,17/Feb/10 22:37,09/Mar/10 18:29,14/Mar/19 03:02,09/Mar/10 15:27,2.0.0-beta,,,,,,,,,2.0.0-beta2,,,,,jdbc,,,,,,0,,"http://n2.nabble.com/2-0-0-Beta-Caching-Question-td4588375.html#a4588375

From the description in this forum post, it looks like we are logging a WARN message every time we determine that a finder select statement can't be cached (for whatever reason).

Two things...

o  This message should probably not be a WARN message.  It's a TRACE message, at best.  We attempt to cache whenever we can, but if we can't cache something for whatever reason, customers don't want to see these WARN messages.  But, if we're trying to debug a caching situation, then having the TRACE message might prove useful.

o  I looked (very) briefly at the code and it's not clear as to why this particular finder can't be cached.  Some additional data in the TRACE message may help with making the finder cacheable.  Or, at least help explain why it's not cacheable.

Since Pinaki seems to have integrated these caching messages, I figured he would be a good initial assignee for the JIRA...  :-)

Thanks,
Kevin",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-03-09 15:27:34.704,,,no_permission,,,,,,,,,,,161782,,,Tue Mar 09 15:27:34 UTC 2010,,,,,,,0|i0z3a7:,202834,,,,,,,,09/Mar/10 15:27;drwoods;Fixed by r911496 that was committed using OPENJPA-924,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CacheStatistics should be disabled by default,OPENJPA-1515,12456460,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,16/Feb/10 18:00,09/Mar/10 18:29,14/Mar/19 03:02,16/Feb/10 20:03,2.0.0-beta,,,,,,,,,2.0.0-beta,,,,,datacache,,,,,,0,,org.apache.openjpa.datacache.CacheStatistics are enabled by default but collection of the data has a measurable performance impact. Collecting of the CacheStatistics should be disabled by default as a user shouldn't have to pay the price for something they have no intentions on using.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161779,,,Tue Feb 16 20:03:35 UTC 2010,,,,,,,0|i0z38v:,202828,,,,,,,,"16/Feb/10 20:03;curtisr7;Committed revision 910667 to trunk.

Updated src, test, and doc.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Documentation corrections,OPENJPA-1510,12456225,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,milosz,milosz,milosz,13/Feb/10 13:43,30/Jan/11 10:38,14/Mar/19 03:02,05/Apr/10 08:11,2.0.0-beta,,,,,,,,,2.0.0,,,,,docs,,,,,,0,,"This issue can be used for updates to user manual, javadoc, localizers to correct things like spelling or editorial changes.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161774,,,Sun Mar 07 13:20:40 UTC 2010,,,,,,,0|i1dtif:,288878,,,,,,,,"13/Feb/10 15:17;milosz;This section is not clear:

""Invalid hints or hints which can not be processed by a particular database are ignored. Otherwise, invalid hints will result in an ArgumentException being thrown.""

We have had some discussion on it [1]. Does anybody have a suggestion how to correct this?

[1] http://n2.nabble.com/What-happens-with-invalid-query-hints-td4102163.html#a4102163","19/Feb/10 10:51;milosz;Changed the confusing section to say:
""Hints which can not be processed by a particular database or are unknown to OpenJPA are ignored. Hints known to OpenJPA but supplied with an incompatible value will result in an IllegalArgumentException being thrown.""
","07/Mar/10 13:20;milosz;Moved out-of-context sections related to maps into 7.8 Maps section. Old table of contents:

7. Additional JPA Mappings
    7.1. Datastore Identity Mapping
    7.2. Surrogate Version Mapping
    7.3. Multi-Column Mappings
    7.4. Join Column Attribute Targets
    7.5. Embedded Mapping
    7.6. Collections
        7.6.1. Container Table
        7.6.2. Element Join Columns
        7.6.3. Order Column 
    7.7. One-Sided One-Many Mapping
    7.8. Maps
    7.9. Indexes and Constraints
        7.9.1. Indexes
        7.9.2. Foreign Keys
        7.9.3. Unique Constraints 
    7.10. XML Column Mapping
    7.11. LOB Streaming 
8. Key Columns
9. Key Join Columns
10. Key Embedded Mapping
11. Examples
12. Mapping Limitations
    12.1. Table Per Class

New table of contents:

7. Additional JPA Mappings
    7.1. Datastore Identity Mapping
    7.2. Surrogate Version Mapping
    7.3. Multi-Column Mappings
    7.4. Join Column Attribute Targets
    7.5. Embedded Mapping
    7.6. Collections
        7.6.1. Container Table
        7.6.2. Element Join Columns
        7.6.3. Order Column 
    7.7. One-Sided One-Many Mapping
    7.8. Maps
        7.8.1. Key Columns
        7.8.2. Key Join Columns
        7.8.3. Key Embedded Mapping
        7.8.4. Examples
    7.9. Indexes and Constraints
        7.9.1. Indexes
        7.9.2. Foreign Keys
        7.9.3. Unique Constraints 
    7.10. XML Column Mapping
    7.11. LOB Streaming 
8. Mapping Limitations
    8.1. Table Per Class
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Enum field types cannot be modified in an in-memory JPQL bulk update statement,OPENJPA-1509,12456207,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,13/Feb/10 00:07,09/Mar/10 18:29,14/Mar/19 03:02,13/Feb/10 00:09,2.0.0-beta,2.0.0-M3,,,,,,,,2.0.0-beta2,,,,,query,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161773,,,2010-02-13 00:07:54.0,,,Patch Available,,,,0|i0z2xb:,202776,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE with a non-JDBC store manager,OPENJPA-1507,12456100,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,pcl,pcl,pcl,12/Feb/10 03:20,09/Mar/10 18:29,14/Mar/19 03:02,12/Feb/10 22:37,2.0.0-beta,,,,,,,,,2.0.0-beta2,,,,,kernel,,,,,,0,,"If a QuerySQLCache plugin value is not provided, the OpenJPAConfiguration throws an NPE when accessing the database.",,,,,,,,,,,,,,,,,,,,,,12/Feb/10 03:26;pcl;OPENJPA-1507.patch;https://issues.apache.org/jira/secure/attachment/12435656/OPENJPA-1507.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161771,,,2010-02-12 03:20:55.0,,,Patch Available,,,,0|i0z3cf:,202844,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ConfigurationImpl.equals fails using a OpenJPA derived provider,OPENJPA-1506,12456026,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,11/Feb/10 16:17,23/Mar/10 18:30,14/Mar/19 03:02,02/Mar/10 15:46,2.0.0-beta2,,,,,,,,,2.0.0-beta3,,,,,lib,,,,,,0,,"TestDynamicConfiguration.testConfigurationIsEqualByValueAndHashCode failed with configuration object equality
using a OpenJPA derived provider.

    public void testConfigurationIsEqualByValueAndHashCode() {
		OpenJPAEntityManagerFactorySPI emf1 = createEMF(FRESH_EMF);
		assertNotNull(emf1);
		OpenJPAConfiguration conf1 = emf1.getConfiguration();
		
		OpenJPAEntityManagerFactorySPI emf2 = createEMF(FRESH_EMF);
		assertNotNull(emf2);
		OpenJPAConfiguration conf2 = emf2.getConfiguration();
		
		assertFalse(emf1==emf2);
		assertFalse(emf1.equals(emf2));
		assertFalse(conf1==conf2);
		assertEquals(conf1, conf2);	<<<< faild here
		assertEquals(conf1.hashCode(), conf2.hashCode());
        	assertEquals(conf1.toProperties(false), conf2.toProperties(false));
	}

The problem is in the equals() method of ConfigurationImpl:

    public boolean equals(Object other) {
	.....
        for(Value v : _vals) {
            Value thatV = conf.getValue(propName);
       	    if (!v.equals(thatV)) {
        	return false;
            }
        }
        return true;
    }

getValue search backward based on the property name as in:

    public Value getValue(String property) {
        if (property == null)
            return null;

        // search backwards so that custom values added after construction
        // are found quickly, since this will be the std way of accessing them
        for (int i = _vals.size()-1; i >= 0; i--) { 
            if (_vals.get(i).matches(property))
                return _vals.get(i);
        }
        return null;
    }

In the case of a dervied provider, it adds new EntityManagerFactoryValue to the end of the property list, which in theory override
the one defined by the openjpa provider.

However the equals method iterate the ""current"" configuration _vals list from the top but match the ""other"" configuration _vals
list found from the bottom, so even both configuration objects are exactly the same, the equals will fail.

In the case of a single openjpa provider, this problem is NOT surfaced.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161770,,,2010-02-11 16:17:30.0,,,,,,,0|i1dtiv:,288880,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Validation junits should not rely on Hibernate Impl,OPENJPA-1504,12455923,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,drwoods,drwoods,drwoods,10/Feb/10 17:37,09/Mar/10 18:29,14/Mar/19 03:02,10/Feb/10 21:30,2.0.0-beta,,,,,,,,,2.0.0-beta2,,,,,validation,,,,,,0,,"TestTraversableResolver does a ""import org.hibernate.validator.engine.PathImpl"" instead of trying to dynamically load the class for Hibernate and Agimatec, since PathImpl is a implementation specific class without a spec defined interface....
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161768,,,Wed Feb 10 21:30:53 UTC 2010,,,,,,,0|i1dtj3:,288881,,,,,,,,"10/Feb/10 21:30;drwoods;updated to agimatec-validation-0.9.6-SNAPSHOT
trunk commits in r908660",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Metamodel class loading fails with security manager,OPENJPA-1503,12455804,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,09/Feb/10 18:43,29/Mar/10 23:17,14/Mar/19 03:02,15/Mar/10 21:29,,,,,,,,,,2.0.0-beta3,,,,,kernel,,,,,,0,,metamodel classloading does not use AccessController.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161767,,,2010-02-09 18:43:32.0,,,,,,,0|i0yzm7:,202240,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
EntityManager.find may return multiple instances of Entities with String identities if id value has trailing spaces.,OPENJPA-1501,12455695,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,08/Feb/10 22:40,06/Mar/12 22:59,14/Mar/19 03:02,15/Jul/10 20:59,1.2.2,1.3.0,2.0.0,,,,,,,1.3.0,2.0.2,2.1.0,,,kernel,,,,,,0,,"As noted on the OpenJPA users mailing list at http://n2.nabble.com/EntityManager-fetch-and-query-by-key-behave-differently-tp4165833p4165833.html 

The find operation doesn't properly handle trailing whitespace in a String ID. ",,,,,,,,,,,,,,,,OPENJPA-1854,,,,,,06/Jul/10 18:37;mikedd;OPENJPA-1501.2.0.x.patch.txt;https://issues.apache.org/jira/secure/attachment/12448807/OPENJPA-1501.2.0.x.patch.txt,06/Jul/10 18:37;mikedd;OPENJPA-1501.trunk.patch.txt;https://issues.apache.org/jira/secure/attachment/12448808/OPENJPA-1501.trunk.patch.txt,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-03-06 22:59:01.574,,,no_permission,,,,,,,,,,,161765,,,Tue Mar 06 22:59:01 UTC 2012,,,Patch Available,,,,0|i0z3k7:,202879,,,,,,,,"06/Mar/12 22:59;jpaheath;HI!  The above Nabble link doesn't work for me any longer.....I've been trying it at random times over the past 24hrs.  I'm assuming the link no longer exists.  In case others experience similar behavior, I did find the same info on MarkMail here:

http://openjpa.markmail.org/search/?q=EntityManager-fetch-and-query-by-key-behave-differently#query:EntityManager-fetch-and-query-by-key-behave-differently+page:1+mid:yg5quqhot3hcreuw+state:results

Thanks,

Heath",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DataCache types and excludedTypes are case sensitive,OPENJPA-1500,12455690,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,08/Feb/10 22:10,23/Mar/10 18:31,14/Mar/19 03:02,04/Mar/10 16:07,1.0.3,1.2.2,,,,,,,,1.2.3,1.3.0,2.0.0-beta3,,,datacache,,,,,,0,,"The cache inclusion properties were inadvertently made case sensitive. In short openjpa.DataCache=true(types=foo.bar) will does not work, but openjpa.Datacache=true(Type=foo.bar) will work.

",,0,0,,0%,0,0,,,,,,,,,,,,,,,08/Feb/10 22:54;mikedd;OPENJPA-1500-1.2.x.diff.txt;https://issues.apache.org/jira/secure/attachment/12435220/OPENJPA-1500-1.2.x.diff.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161764,,,2010-02-08 22:10:26.0,,,,,,,0|i1dtjj:,288883,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Fail to set temporal parameter,OPENJPA-1496,12455387,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,05/Feb/10 06:00,08/Mar/10 13:24,14/Mar/19 03:02,09/Feb/10 18:40,2.0.0-beta,,,,,,,,,2.0.0-beta2,,,,,jdbc,,,,,,0,,"For an entity:

@Entity
public class TimeEntity {
	@Id
	@GeneratedValue
	private long id;
	
       String name;
    
       int value;
    
       @Temporal(TemporalType.TIMESTAMP)
       private java.util.Calendar cal2Timestamp;

...}


an attempt to set parameter as below fails with IllegalArgumentException:
        String jpql = ""SELECT  COUNT(a) FROM TimeEntity a WHERE a.cal2Timestamp BETWEEN ?1 AND ?2"";
        Calendar endTime = Calendar.getInstance();
        Calendar startTime = (Calendar)endTime.clone();
        startTime.add(14, -4);
        List results = em.createQuery(jpql).
            setParameter(1, startTime, TemporalType.TIMESTAMP).
            setParameter(2, endTime, TemporalType.TIMESTAMP).
            getResultList();

java.lang.IllegalArgumentException: Parameter ""Parameter<Calendar>(2)"" declared in ""SELECT  COUNT(a) FROM TimeEntity a WHERE a.value = ?1 AND a.cal2Timestamp BETWEEN ?2 AND ?3"" is set to value of ""2/4/10 9:55 PM"" of type ""java.sql.Timestamp"", but this parameter is bound to a field of type ""java.util.Calendar"".
	at org.apache.openjpa.persistence.QueryImpl.assertValueAssignable(QueryImpl.java:1079)
	at org.apache.openjpa.persistence.QueryImpl.bindValue(QueryImpl.java:1036)
	at org.apache.openjpa.persistence.QueryImpl.setParameter(QueryImpl.java:640)
	at org.apache.openjpa.persistence.QueryImpl.setParameter(QueryImpl.java:653)
	at org.apache.openjpa.persistence.QueryImpl.setParameter(QueryImpl.java:1)
	at d637638.Test637638.testTemporalType(Test637638.java:36)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at junit.framework.TestCase.runTest(Unknown Source)
	at junit.framework.TestCase.runBare(Unknown Source)
	at junit.framework.TestResult$1.protect(Unknown Source)
	at junit.framework.TestResult.runProtected(Unknown Source)
	at junit.framework.TestResult.run(Unknown Source)
	at junit.framework.TestCase.run(Unknown Source)
	at junit.framework.TestSuite.runTest(Unknown Source)
	at junit.framework.TestSuite.run(Unknown Source)
	at org.junit.internal.runners.OldTestClassRunner.run(OldTestClassRunner.java:35)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:45)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)

",,,,,,,,,,,,,,,,,,,,,,08/Feb/10 22:25;faywang;OPENJPA-1496-2.patch;https://issues.apache.org/jira/secure/attachment/12435217/OPENJPA-1496-2.patch,09/Feb/10 07:47;faywang;OPENJPA-1496-3.patch;https://issues.apache.org/jira/secure/attachment/12435263/OPENJPA-1496-3.patch,06/Feb/10 05:12;faywang;OPENJPA-1496.patch;https://issues.apache.org/jira/secure/attachment/12435061/OPENJPA-1496.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161760,,,Tue Feb 09 07:46:19 UTC 2010,,,,,,,0|i0z3lj:,202885,,,,,,,,"06/Feb/10 05:09;faywang;Current parameter processing is based on the assumption that each parameter is associated with one and only one class type. However, this is not true in the case of temporal data. Consider the following scenarios:

@Entity
public class TimeEntity {
      @Id
      @GeneratedValue
      private long id;

      String name;

       int value;
    
       @Temporal(TemporalType.TIMESTAMP)
       private java.util.Calendar cal2Timestamp;

...} 

String jpql = ""SELECT COUNT(a) FROM A a WHERE a.cal2Timestamp BETWEEN ?1 AND ?2"";
Query q = em.createQuery(jpql);
Calendar endTime = Calendar.getInstance();
Calendar startTime = (Calendar)endTime.clone();
startTime.add(14, -4);

(1)
        q.setParameter(1, startTime, TemporalType.TIMESTAMP);
        q.setParameter(2, endTime, TemporalType.TIMESTAMP);

(2) 
       q.setParameter(1, startTime);
        q.setParameter(2, endTime);

In case (1), the parameterType of the two parameters should be Timestamp, which is based on the @Temporal annotation of the Calendar field, cal2Timestamp. 

In Case (2), the parameter type of the two parameters should be Calendar. 

In order to support both cases, the attached patch stores both types in the ordered parameter map, and uses the type depending on which setParameter method is called. 



",08/Feb/10 22:25;faywang;A different approach to solve this problem.,"09/Feb/10 07:46;faywang;This patch assumes any temporal types (Date, Time, Timestamp) are assignable to each other. However, with this patch, two test cases fail: TestTemporalTypeQueryParameterBinding.testNamedParameterWithMismatchedValue
and
TestTemporalTypeQueryParameterBinding.testPositionalParameterWithMismatchedValue  

These two test cases suggest strong type checking for the temporal types.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
org.apache.openjpa.persistence.ArgumentException: A JDBC Driver or DataSource class name must be specified in the ConnectionDriverName property,OPENJPA-1495,12455320,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,veeraj21@gmail.com,veeraj21@gmail.com,04/Feb/10 15:50,24/May/10 16:40,14/Mar/19 03:02,24/May/10 16:40,,,,,,,,,,,,,,,jpa,,,,,,0,blocker,"I am using openjpa-1.2.2.jar and I am getting following error

<openjpa-1.1.0-r422266:657916 fatal user error> org.apache.openjpa.persistence.ArgumentException: A JDBC Driver or DataSource class name must be specified in the ConnectionDriverName property.
	at org.apache.openjpa.jdbc.schema.DataSourceFactory.newDataSource(DataSourceFactory.java:72)
	at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.createConnectionFactory(JDBCConfigurationImpl.java:776)
	at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getDBDictionaryInstance(JDBCConfigurationImpl.java:553)
	at org.apache.openjpa.jdbc.meta.MappingRepository.endConfiguration(MappingRepository.java:1250)
	at org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:505)
	at org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:430)
	at org.apache.openjpa.lib.conf.PluginValue.instantiate(PluginValue.java:103)
	at org.apache.openjpa.conf.MetaDataRepositoryValue.instantiate(MetaDataRepositoryValue.java:68)
	at org.apache.openjpa.lib.conf.ObjectValue.instantiate(ObjectValue.java:83)
	at org.apache.openjpa.conf.OpenJPAConfigurationImpl.newMetaDataRepositoryInstance(OpenJPAConfigurationImpl.java:843)
	at org.apache.openjpa.conf.OpenJPAConfigurationImpl.getMetaDataRepositoryInstance(OpenJPAConfigurationImpl.java:834)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.makeReadOnly(AbstractBrokerFactory.java:638)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:183)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:192)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:145)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:56)
	at org.wadsworth.bean.CheckMe.getData(CheckMe.java:22)
	at org.wadsworth.eclep.servlet.FrontContoller.doGet(FrontContoller.java:32)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:707)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)
	at weblogic.servlet.internal.StubSecurityHelper$ServletServiceAction.run(StubSecurityHelper.java:227)
	at weblogic.servlet.internal.StubSecurityHelper.invokeServlet(StubSecurityHelper.java:125)
	at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:292)
	at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:175)
	at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:3498)
	at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)
	at weblogic.security.service.SecurityManager.runAs(Unknown Source)
	at weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:2180)
	at weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:2086)
	at weblogic.servlet.internal.ServletRequestImpl.run(ServletRequestImpl.java:1406)
	at weblogic.work.ExecuteThread.execute(ExecuteThread.java:201)
	at weblogic.work.ExecuteThread.run(ExecuteThread.java:173)


********************persistence.xml contents below*******************
<?xml version=""1.0"" encoding=""UTF-8""?>
<persistence xmlns=""http://java.sun.com/xml/ns/persistence""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
    version=""1.0"">
    <persistence-unit name=""hellojpa"" transaction-type=""RESOURCE_LOCAL"">
        <provider>org.apache.openjpa.persistence.PersistenceProviderImpl</provider>
        <class>org.wadsworth.bean.CheckFac</class>
        <properties>
            <property name=""openjpa.ConnectionURL"" value=""jdbc:oracle:thin:@lyra:1521:wcdev01""/>
            <property name=""openjpa.ConnectionDriverName"" value=""oracle.jdbc.OracleDriver""/>
            <property name=""openjpa.ConnectionUserName"" value=""clep""/>
            <property name=""openjpa.ConnectionPassword"" value=""clep""/>
            <property name=""openjpa.jdbc.Schema"" value=""CLEP""/>
        </properties>
    </persistence-unit>
</persistence>
***********************
Please suggest what to do.",org.apache.openjpa.persistence.ArgumentException: A JDBC Driver or DataSource class name must be specified in the ConnectionDriverName property.,345600,345600,,0%,345600,345600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-02-04 20:55:08.72,,,no_permission,,,,,,,,,,,161759,,,Tue Feb 09 15:30:43 UTC 2010,,,,,,,0|i0z3j3:,202874,,,,,,,,"04/Feb/10 20:55;techhusky;Rajeev,

It looks like you've specified the incorrect driver package in your persistence.xml.  Try:  oracle.jdbc.driver.OracleDriver

-Jeremy","05/Feb/10 20:06;veeraj21@gmail.com;Hi Jeremy, 
Thanks for the Immediate reply. I made the change and still getting the same error. One quick update,
1.  I get this issue when I run the application from eclipse. 
2. If I export a war file and deploy is on the server, things work successfully.
Regards
Rajeev","09/Feb/10 15:30;techhusky;Hate to ask, but are you sure the Oracle JDBC driver jar is in your build and/or runtime classpath?  I've seen that exception/msg if a driver class cannot be loaded.  Also you may get a more helpful exception if you enable OpenJPA trace.

<property  name=""openjpa.Log""  value=""DefaultLevel=TRACE""/>

-Jeremy",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Criteria query IN predicate generates incorrect SQL ,OPENJPA-1494,12455142,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,fancy,fancy,03/Feb/10 06:17,09/Mar/10 18:29,14/Mar/19 03:02,05/Feb/10 19:13,2.0.0-beta,,,,,,,,,2.0.0-beta2,,,,,query,,,,,,0,,"Junit regression uncovered following problems:
1.a testcase error in TestTypesafeCriteria.testValues5() : this test is currently annotated @AllowFailure.
      the expected sql string is incorrect. 
         String sql = ""SELECT t0.name, t2.id, t2.label FROM CR_ITEM t0 ""
            + ""INNER JOIN CR_ITEM_photos t1 ON t0.id = t1.ITEM_ID ""
            + ""INNER JOIN CR_PHT t2 ON t1.VALUE_ID = t2.id WHERE ""
            + ""(0 = (SELECT COUNT(*) FROM CR_ITEM_photos t3 WHERE ""
            + ""(t3.VALUE_ID = ? OR t3.VALUE_ID = ? OR t3.VALUE_ID = ? OR t3.VALUE_ID = ? OR t3.VALUE_ID = ?) ""
            + ""AND (t0.id = t3.ITEM_ID) AND t0.id = t3.ITEM_ID) ""
            + ""AND 0 < (SELECT COUNT(*) FROM CR_ITEM_photos WHERE CR_ITEM_photos.ITEM_ID = t0.id))"";

      in  the last SELECT COUNT(*), the FROM table does not have table alias assigned.
 2. NOT IN expression is transformed into a QueryExpression which resulting SQL subselects with SELECT COUNT(*) -- there could be a problem in how query expression tree is built in Criteria Query for IN-Expression.
     
3: ((CriteriaQueryImpl)q).toCQL() produces the following JPQL string which has syntax error.
     JPQL=SELECT i.name, i.photos FROM Item i INNER JOIN i.photos ? WHERE i.photos IN ([org.apache.openjpa.persistence.criteria.Photo@22de22de, org.apache.openjpa.persistence.criteria.Photo@23122312, org.apache.openjpa.persistence.criteria.Photo@23462346, org.apache.openjpa.persistence.criteria.Photo@226e226e, org.apache.openjpa.persistence.criteria.Photo@22aa22aa])

if toCQL() produced  the following JPQL, then semantically they would be equavilence:
      SELECT i.name, p FROM Item i INNER JOIN i.photos p where p  NOT IN ?1

      but JPQL BNF does not allow Object-value 'p' in [NOT] IN conditional expression.
     
 4. There is no JPQL equivalence query for the criteria query in  testValues5().
     a closer JPQL string could be:
       SELECT i.name, p FROM Item i INNER JOIN i.photos p where p.id NOT IN ?1
       where ?1 is a collection-valued-parameter that contains a list of Photo IDs.
     The above JPQL generates following SQL:
      8500  test  TRACE  [main] openjpa.Query - Executing query: [SELECT i.name, p FROM Item i INNER JOIN i.photos p WHERE p.id not IN ?1] with parameters: {1=[0, 0, 0, 0, 0]}
8750  test  TRACE  [main] openjpa.jdbc.SQL - <t 108529272, conn 1628201228> executing prepstmnt 1532713819 SELECT t0.name, t2.id, t2.label FROM CR_ITEM t0 INNER JOIN CR_ITEM_photos t1 ON t0.id = t1.ITEM_ID INNER JOIN CR_PHT t2 ON t1.VALUE_ID = t2.id WHERE (NOT (t1.VALUE_ID IN (?, ?, ?, ?, ?)))  [params=(int) 0, (int) 0, (int) 0, (int) 0, (int) 0]

   as shown in the above, a NOT IN JPQL generated a NOT IN SQL.

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-02-05 19:13:35.256,,,no_permission,,,,,,,,,,,161758,,,Fri Feb 05 19:13:35 UTC 2010,,,,,,,0|i0z3kn:,202881,,,,,,,,05/Feb/10 19:13;faywang;The code fix is checked into JIRA-1493.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
org.apache.openjpa.kernel.Bootstrap uses the application classloader to load OpenJPA internals,OPENJPA-1491,12454958,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,timothyjward,timothyjward,01/Feb/10 17:15,11/Nov/14 14:52,14/Mar/19 03:02,12/Mar/10 21:01,2.0.0-beta,,,,,,,,,2.0.0-beta3,,,,,osgi,,,,,,2,,"When attempting to create an EntityManagerFactory in an OSGi environment the org.apache.openjpa.kernel.Bootstrap class attempts to instantiate a BrokerFactory using reflection. When the Bootstrap class attempts to load this class it only ever uses the ClassLoader passed in by the PersistenceUnitInfo. This means that the default broker (contained within OpenJPA) can never be loaded. The client bundle should not have to import the internals of OpenJPA to make this work, so OpenJPA should attempt to load the class using its own bundle classloader. This is the expected behaviour for an OSGi bundle.

Additionally, the implementation uses Class.forName() which should be used carefully in an OSGi envrionment (to see why read http://blog.bjhargrave.com/2007/09/classforname-caches-defined-class-in.html ). It should be fine here because the variant that takes a ClassLoader is used.

The following exception is generated when OpenJPA attempts to use the application classloader to load an internal class.

<openjpa-2.0.0-SNAPSHOT-r422266:905001 fatal user error> org.apache.openjpa.persistence.ArgumentException: Could not invoke the static newInstance method on the named factory class ""<<openjpa-2.0.0-SNAPSHOT-r422266:905001 fatal user error> org.apache.openjpa.util.UserException: The named BrokerFactory ""org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory"" is not valid.>"".
	at org.apache.openjpa.kernel.Bootstrap.newBrokerFactory(Bootstrap.java:70)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.getBrokerFactory(PersistenceProviderImpl.java:145)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:180)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:62)
	at org.apache.aries.jpa.container.impl.EntityManagerFactoryManager.createEntityManagerFactories(EntityManagerFactoryManager.java:227)
	at org.apache.aries.jpa.container.impl.EntityManagerFactoryManager.bundleStateChange(EntityManagerFactoryManager.java:121)
	at org.apache.aries.jpa.container.impl.PersistenceBundleManager.modifiedBundle(PersistenceBundleManager.java:197)
	at org.apache.aries.util.tracker.MultiBundleTracker$InternalBundleTracker.modifiedBundle(MultiBundleTracker.java:108)
	at org.osgi.util.tracker.BundleTracker$Tracked.customizerModified(BundleTracker.java:453)
	at org.osgi.util.tracker.AbstractTracked.track(AbstractTracked.java:237)
	at org.osgi.util.tracker.BundleTracker$Tracked.bundleChanged(BundleTracker.java:413)
	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.dispatchEvent(BundleContextImpl.java:916)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:220)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:149)
	at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEventPrivileged(Framework.java:1350)
	at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEvent(Framework.java:1301)
	at org.eclipse.osgi.framework.internal.core.BundleHost.stopWorker(BundleHost.java:490)
	at org.eclipse.osgi.framework.internal.core.AbstractBundle.suspend(AbstractBundle.java:546)
	at org.eclipse.osgi.framework.internal.core.Framework.suspendBundle(Framework.java:1098)
	at org.eclipse.osgi.framework.internal.core.PackageAdminImpl.suspendBundle(PackageAdminImpl.java:314)
	at org.eclipse.osgi.framework.internal.core.PackageAdminImpl.processDelta(PackageAdminImpl.java:460)
	at org.eclipse.osgi.framework.internal.core.PackageAdminImpl.doResolveBundles(PackageAdminImpl.java:241)
	at org.eclipse.osgi.framework.internal.core.PackageAdminImpl$1.run(PackageAdminImpl.java:176)
	at java.lang.Thread.run(Thread.java:735)
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:905001 fatal user error> org.apache.openjpa.persistence.ArgumentException: The named BrokerFactory ""org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory"" is not valid.
	at org.apache.openjpa.kernel.Bootstrap.getFactoryClass(Bootstrap.java:159)
	at org.apache.openjpa.kernel.Bootstrap.invokeFactory(Bootstrap.java:111)
	at org.apache.openjpa.kernel.Bootstrap.newBrokerFactory(Bootstrap.java:62)
	... 23 more
Caused by: java.lang.ClassNotFoundException: org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory
	at java.lang.Class.forName(Class.java:169)
	at org.apache.openjpa.kernel.Bootstrap.getFactoryClass(Bootstrap.java:157)
	... 25 more",OSGi,,,,,,,,,,,,,,,,,,,,,12/Mar/10 18:57;drwoods;OPENJPA-1491-trunk.patch;https://issues.apache.org/jira/secure/attachment/12438631/OPENJPA-1491-trunk.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-03-12 18:57:16.086,,,no_permission,,,,,,,,,,,161755,,,Fri Aug 27 14:43:03 UTC 2010,,,,,,,0|i0zbrz:,204210,,,,,,,,12/Mar/10 18:57;drwoods;proposed changes to fix ARIES-158,12/Mar/10 21:01;drwoods;trunk r922397,"14/Jun/10 12:50;jeanphi;Issue seems closed and fixed in v2.0.0, but I experience this problem in the v2.0.0 relase:
Caused by: <openjpa-2.0.0-r422266:935683 fatal user error> org.apache.openjpa.persistence.ArgumentException: The named BrokerFactory ""org.apache.openjpa.jdbc.ke
rnel.JDBCBrokerFactory"" is not valid.
        at org.apache.openjpa.kernel.Bootstrap.getFactoryClass(Bootstrap.java:159)
        at org.apache.openjpa.kernel.Bootstrap.invokeFactory(Bootstrap.java:111)
        at org.apache.openjpa.kernel.Bootstrap.newBrokerFactory(Bootstrap.java:62)
        ... 30 more
Caused by: java.lang.ClassNotFoundException: org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory
        at java.net.URLClassLoader$1.run(URLClassLoader.java:202)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:307)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:247)
        at org.apache.openjpa.kernel.Bootstrap.getFactoryClass(Bootstrap.java:157)
        ... 32 more

Is this problem really fixed, or does a workaround exist?","14/Jun/10 14:42;drwoods;This fix only applies to OSGi environments where Apache Aries JPA 0.1-incubating is being used.
Are you trying to run OpenJPA as an OSGi bundle?  If so, are you using Apache Aries in a custom assembly or the latest Apache Geronimo 3.0-SNAPSHOT builds?

To be more specific - OpenJPA does not include support for the OSGi Enterprise Specification r4 v4.2 section 127 JPA Service Specification, but relies on Apache Aries JPA (http://incubator.apache.org/aries/jpaproject.html) which wrappers OpenJPA to deliver that support.","14/Jun/10 15:13;jeanphi;Well, I'm not too sure. I'm using Felix Karaf which does not come with JPA. I'm using OpenJPA to provide both API and implementation of JPA.

To be clear on the top of Karaf, I'm putting those bundles:
+ OpenJPA Aggregate Jar (2.0.0)
+ Apache Geronimo JSR-317 JPA 2.0 Spec API (1.0)
+ Commons Collections (3.2.1)
+ Commons Lang (2.5)
+ Commons Pool (1.5.3)

","27/Aug/10 14:43;drwoods;You need Aries JPA + OpenJPA to support JPA on Felix - http://incubator.apache.org/aries/
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lazy fetched embeddable should not be materialized in the query result,OPENJPA-1486,12446928,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,28/Jan/10 16:55,23/Mar/10 18:33,14/Mar/19 03:02,09/Mar/10 18:11,2.0.0-beta,2.0.0-beta2,,,,,,,,2.0.0-beta3,,,,,,,,,,,0,,"Currenlty openjpa will return an empty embeddable object as an entity attribute in the query result even if that embeddable attribute is lazily fetched. Moreover, the load bit in the StateManagerImpl is also on for that embeddable attribute. The expected behavior is that null value should be set to the embeddable attribute and the load bit should be off. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161750,,,2010-01-28 16:55:12.0,,,,,,,0|i0z2vr:,202769,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
isLoaded util method does not behave per spec for collection attributes and basic type,OPENJPA-1485,12446828,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,27/Jan/10 16:14,09/Mar/10 18:29,14/Mar/19 03:02,19/Feb/10 15:25,2.0.0-beta,,,,,,,,,2.0.0-beta2,,,,,,,,,,27/Jan/10 00:00,0,,"Section 3.2.9  of the spec states:

A collection-valued attribute is considered to be loaded if the collection was loaded from the database
or the value of the attribute was assigned by the application, and, if the attribute references a collection
instance (i.e., is not null), each element of the collection (e.g. entity or embeddable) is considered to be
loaded.

OpenJPA currently does not behave according to spec if an entity is loaded by the DB and the collection attribute is set to null.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-01-28 00:09:53.152,,,no_permission,,,,,,,,,,,161749,,,Thu Jan 28 00:09:53 UTC 2010,,,,,,,0|i0z9dj:,203821,,,,,,,,"28/Jan/10 00:09;faywang;A basic type is in the default fetch group. If a fetch plan is used to load an entity, and that fetch plan removes the default fetch group, the basic type will not be loaded. In this case, this basic type should be regarded as lazy loaded. The isLoaded util method should return true for this entity because all eager-fetched attributes are loaded.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
count (Distinct e) in JPQL gives wrong result when the id field is a compound primary key,OPENJPA-1483,12446713,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,faywang,faywang,26/Jan/10 18:36,03/May/10 16:16,14/Mar/19 03:02,09/Feb/10 18:30,2.0.0-beta,,,,,,,,,1.2.3,1.3.0,2.0.0-beta2,,,,,,,,,0,,"This is a fundamental problem with count when compound primary key is involved. 

	(1) If no relation navigation is involved:
	String jpql = ""SELECT COUNT (DISTINCT e) FROM G2 e"";

	With the property below:
	<property name=""openjpa.jdbc.DBDictionary""
		value=""db2(useWildCardForCount=true)"" />

	Openjpa will generate the following sql and return the correct count:

	SELECT COUNT(*) FROM G2 t0  optimize for 1 row

	(2) If there is relation navigation invloved:
	String jpql = ""SELECT COUNT (DISTINCT f1.g2) FROM F1 f1"";
	
	The property of useWildCardForCount will not generate correct sql with right result. However, given the object-relational impedance mismatch, there is no corresponding SQL construct for count of multiple primary keys, and there is no clean and generic solution to solve this problem. The only workaround is to use native SQL with table expression:

	SELECT COUNT(*)
	FROM (SELECT DISTINCT G1.G1PK, G1.G2PK 	FROM F1 t0 INNER JOIN G2 t1 ON t0.G1PK = t1.G1PK AND t0.G2PK = t1.G2PK)) TX;	

	Rather than giving a wrong answer, OpenJPA should give an Unsupported exception.

",,,,,,,,,,,,,,,,,,,,,,30/Apr/10 23:39;jpaheath;OPENJPA-1483-1.2.x.patch.txt;https://issues.apache.org/jira/secure/attachment/12443346/OPENJPA-1483-1.2.x.patch.txt,30/Apr/10 23:39;jpaheath;OPENJPA-1483-1.3.x.patch.txt;https://issues.apache.org/jira/secure/attachment/12443347/OPENJPA-1483-1.3.x.patch.txt,31/Jan/10 02:58;faywang;OPENJPA-1483-2.patch;https://issues.apache.org/jira/secure/attachment/12431896/OPENJPA-1483-2.patch,30/Jan/10 00:43;faywang;OPENJPA-1483.patch;https://issues.apache.org/jira/secure/attachment/12431841/OPENJPA-1483.patch,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2010-01-30 19:45:16.843,,,no_permission,,,,,,,,,,,161747,,,Fri Apr 30 23:39:40 UTC 2010,,,Patch Available,,,,0|i0z9tz:,203895,,,,,,,,"28/Jan/10 16:38;faywang;Limited support for count(distinct compound key) will be supported when count(compound primary key) appears in the projection list. This projection list will have only one projection item, ie, count, in it.  OpenJPA will use generate the following SQL: 

(1) 
String jpql = ""SELECT COUNT (DISTINCT e) FROM G2 e"";
generated SQL: 
SELECT COUNT(*) FROM G2 t0

(2) 
String jpql = ""SELECT COUNT (DISTINCT f1.g2) FROM F1 f1""; 
generated SQL:
SELECT COUNT(*) FROM (SELECT DISTINCT G1.G1PK, G1.G2PK FROM F1 t0 INNER JOIN G2 t1 ON t0.G1PK = t1.G1PK AND t0.G2PK = t1.G2PK) 

For count(compound key), OpenJPA will generate count(*) in the SQL.

An unsupported exception will be thrown in all other situations.","30/Jan/10 00:43;faywang;The patch will produce the following sql:

(1) ""select count (distinct f1) from F1 f1"",
SELECT COUNT(*) FROM (SELECT  DISTINCT t0.F1PK, t0.F2PK FROM F1 t0 ) s  optimize for 1 row

(2) ""select count (distinct f1.pk) from F1 f1"",
SELECT COUNT(*) FROM (SELECT  DISTINCT t0.F1PK, t0.F2PK FROM F1 t0 ) s  optimize for 1 row

(3)""SELECT COUNT (DISTINCT f1.g2) FROM F1 f1"",
SELECT COUNT(*) FROM (SELECT  DISTINCT t1.G1PK, t1.G2PK FROM F1 t0 INNER JOIN G2 t1 ON t0.G1PK = t1.G1PK AND t0.G2PK = t1.G2PK ) s  optimize for 1 row

(4) ""SELECT COUNT (DISTINCT f1.g2.pk) FROM F1 f1"",
SELECT COUNT(*) FROM (SELECT  DISTINCT t1.G1PK, t1.G2PK FROM F1 t0 INNER JOIN G2 t1 ON t0.G1PK = t1.G1PK AND t0.G2PK = t1.G2PK ) s  optimize for 1 row

(5)""select count (f1) from F1 f1"",
SELECT COUNT(*) FROM F1 t0  optimize for 1 row

(6)""select count (f1.pk) from F1 f1"",
SELECT COUNT(*) FROM F1 t0  optimize for 1 row

(7) ""SELECT COUNT (f1.g2) FROM F1 f1"",
SELECT COUNT(*) FROM F1 t0 INNER JOIN G2 t1 ON t0.G1PK = t1.G1PK AND t0.G2PK = t1.G2PK  optimize for 1 row

(8)""SELECT COUNT (f1.g2.pk) FROM F1 f1"",
SELECT COUNT(*) FROM F1 t0 INNER JOIN G2 t1 ON t0.G1PK = t1.G1PK AND t0.G2PK = t1.G2PK  optimize for 1 row
","30/Jan/10 19:45;milosz;Hi Fay, does your patch make useWildCardForCount property obsolete? I understand your description that with the patch we would always use wild card in SELECT COUNT. If so, we could remove the useWildCardForCount property in 2.1.0.
","31/Jan/10 02:58;faywang;Since not all databases support common table expression, a DBDictioinary attribute ""supportsCommonTableExpression"" is introduced. A test case is also included to run on DB2. For those databases that do not support common table expression, openjpa will throw UnsupportedException instead of giving a misleading result for Count (Distinct compound PK).  ","31/Jan/10 03:02;faywang;Hi Milosz,  no, we will not *always* use Count(*)  for select count in all scenarios. The Count(*) will be used only when  SELECT COUNT(compound PK). Could you please review  OPENJPA-1483-2.patch. Thanks!  ","31/Jan/10 08:35;milosz;Hi Fay, of course, my question was wrong. I forgot you stated it clearly even in issue description that the problem is only with compound PKs. Sorry for the confusion.

As for the reviewing the new patch - yes, I reviewed it but since this is you who is the expert in that matter, I am learning from the patch rather than judging :) I would only think these small issues:

1. I think that by ""common table expression"" people usually mean ""WITH cte_name ... SELECT ... FROM cte_name ..."" syntax where this cte can also be recursive. What we need for counting compund PKs, is the database ability to execute subqueries in FROM clause. Thus, I would name the new property ""supportsSubselectInFrom"". What do you think?

2. We should document the new property in the user manual.

3. When the patch is applied, it would be good to open a new issue to investigate the value of the new property for other databases. I believe quite many of them support subqueries in FROM clause.

4. In the test case I would change

+        if (!(dict instanceof DB2Dictionary)) 
+            return;

to testing the value of the new property. That way, the test case will automatically be executed also on other databases which have the support.

","01/Feb/10 17:36;faywang;Hi Milosz, thank you for pointing out this. Common table expression and table expression semantically are the same, but syntactically, they are quite different. For cte, you can define once and use it multiple times. it is like a function definition of a program. In this JIRA, it is table expression, but not common table expression that is required:

SELECT COUNT(*)
FROM (SELECT DISTINCT G1.G1PK, G1.G2PK
FROM F1 t0 INNER JOIN G2 t1 ON t0.G1PK = t1.G1PK AND t0.G2PK = t1.G2PK)) TX;
 ","01/Feb/10 20:37;fancy;Hi Fay,
1. for newly added unsupported messages, could you add message id to  localizer.properties ?
2. could you move the block of the code in JDBCStoreQuery that handles the isCountDistinctMultiCols to SelectConstructor.evaluate() so that kernel.exp.Count visibility remains private at package level ?","30/Apr/10 23:39;jpaheath;Added OPENJPA-1483-1.2.x.patch.txt for 1.2.x code and OPENJPA-1483-1.3.x.patch.txt for 1.3.x code, as their names imply. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,
NoSuchMethodError when calling setVersion on an enhanced property access Entity,OPENJPA-1482,12446709,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,curtisr7,curtisr7,26/Jan/10 18:04,29/Mar/10 23:17,14/Mar/19 03:02,04/Mar/10 19:12,1.2.2,1.3.0,2.0.0-beta,2.0.0-M3,,,,,,1.2.3,1.3.0,2.0.0-beta3,,,kernel,,,,,,0,,"I get the following exception when I call setVersion(..) on an enhanced property access Entity.

java.lang.NoSuchMethodError: org/apache/openjpa/persistence/detachment/model/NoDetachedStateEntityPropertyAccess.pcsetPcVersionInit(Z)V
        at org.apache.openjpa.persistence.detachment.model.NoDetachedStateEntityPropertyAccess.setVersion(NoDetachedStateEntityPropertyAccess.java)

It appears that the bytecode that is generated by the enhancer added an invalid method call to the setVersion() method.",,,,,,,,,,,,,,,,,,,,,,26/Jan/10 18:14;curtisr7;OPENJPA-1482-1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12431439/OPENJPA-1482-1.2.x.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-01-26 20:07:44.313,,,no_permission,,,,,,,,,,,161746,,,Tue Jan 26 20:07:44 UTC 2010,,,,,,,0|i0z2uf:,202763,,,,,,,,26/Jan/10 18:14;curtisr7;Attaching a patch for the changes I propose for the 1.2.x branch and a test case. I'm not sure I'm sold on this being the proper change for trunk.,26/Jan/10 20:07;mikedd;Tentatively targeting for 1.2.3. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA is no longer available as an OSGi bundle,OPENJPA-1478,12446308,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,timothyjward,timothyjward,22/Jan/10 12:35,09/Mar/10 18:29,14/Mar/19 03:02,22/Jan/10 16:53,2.0.0-M3,,,,,,,,,1.3.0,2.0.0-beta,,,,integration,,,,,,0,,"The Apache Aries project is building an OSGi based application container that includes container JPA integration.

OpenJPA 2.0.0-M3 was available as an OSGi bundle, but is using an old version of the JPA 2.0 API (ValidationMode is in the wrong package), and so throws NoSuchMethodError on calls to createContainerEntityManagerFactory. Unfortunately, the latest build snapshots of 2.0.0 are no longer OSGi bundles, which means that OpenJPA can no longer be used with Aries.

I have two questions:

Why is OpenJPA no longer available as an OSGi bundle?

Will OpenJPA be available as an OSGi bundle in future, or should the Aries project re-package OpenJPA for use in the Aries container?

For use with Aries it would also be ideal if the OpenJPA bundle registered the OpenJPA PersistenceProviderImpl as a service in the OSGi service registry, adding the implementation class name as a service property with the key ""javax.persistence.provider"".

I would be happy to provide any assistance I can in re-enabling this functionality.",OSGi,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-01-22 14:14:30.939,,,no_permission,,,,,,,,,,,161742,,,Fri Jan 22 16:53:07 UTC 2010,,,,,,,0|i0z2v3:,202766,,,,,,,,"22/Jan/10 14:14;rickmcguire;Geronimo has a similar requirement for its 3.0 release.  We can repackage this if necessary, but a better solution would be to have the bundle manifest entries directly enabled in openjpa. ","22/Jan/10 14:42;drwoods;The plan was to create a openjpa-osgi artifact that includes the OSGi metadata and RFC 143 code, so we have a competitive offering to Eclipselink....  I'll try to get the openjpa artifact updated today before I cut the Beta branch, but long-term, we need a better solution than creating a jar that is not OSGi complete.","22/Jan/10 16:53;drwoods;fixed in trunk for beta as r902169
fixed in 1.3.x branch as r902170",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Multithreaded attempt to set Query parameter occassionally fails,OPENJPA-1477,12446255,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,21/Jan/10 19:36,29/Mar/10 23:17,14/Mar/19 03:02,15/Mar/10 21:29,,,,,,,,,,2.0.0-beta3,,,,,,,,,,,0,,"Query.setParameter fails intermittently on multi-threaded environment.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161741,,,2010-01-21 19:36:52.0,,,,,,,0|i0yzwn:,202287,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.IllegalMonitorStateException in ConcurrentDataCache.writeUnlock(),OPENJPA-1467,12445849,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,18/Jan/10 19:26,24/Feb/10 14:38,14/Mar/19 03:02,18/Jan/10 19:34,2.0.0-M1,2.0.0-M2,2.0.0-M3,,,,,,,2.0.0-beta,,,,,datacache,,,,,,0,,"
I encountered the following exception when doing some load testing:
Caused by: java.lang.IllegalMonitorStateException
 	at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:139)
 	at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1187)
 	at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:443)
 	at org.apache.openjpa.util.CacheMap.writeUnlock(CacheMap.java:203)
 	at org.apache.openjpa.datacache.ConcurrentDataCache.writeUnlock(ConcurrentDataCache.java:108)
 	at org.apache.openjpa.datacache.DataCacheStoreManager.cacheStateManager(DataCacheStoreManager.java:382)
 	at org.apache.openjpa.datacache.DataCacheStoreManager.initialize(DataCacheStoreManager.java:353)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
 	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
 	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:998)
 	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:956)
 	... 43 more

At first glance it seemed impossible that this exception was happening... Everywhere that CacheMap.writeUnlock()  is called there is a corresponding CacheMap.writeLock() prior to that call. 

I discovered that the bug is in org.apache.openjpa.datacache.ConcurrentDataCache.removeAllInternal(Class<?> cls, boolean subs). The problem is that this method modifies the underlying cache, but doesn't obtain a writeLock first.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161731,,,Mon Jan 18 19:34:59 UTC 2010,,,,,,,0|i0z9nj:,203866,,,,,,,,"18/Jan/10 19:34;curtisr7;Reverted ConcurrentDataCache.removeAllInternal(...) back to an earlier revision to make it functionally correct. There are still some perf issues, but those will be addressed by another JIRA.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PreparedQuery fails with enum query parameter,OPENJPA-1464,12445657,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,15/Jan/10 19:10,09/Mar/10 18:29,14/Mar/19 03:02,18/Jan/10 19:50,,,,,,,,,,2.0.0-beta,,,,,,,,,,,0,,Reparametrization of a prepared query fails if the original query uses enum-valued parameters.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161728,,,2010-01-15 19:10:48.0,,,,,,,0|i0yzv3:,202280,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JPQL new operator arguments should be more flexible in matching constructor arguments,OPENJPA-1463,12445648,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,15/Jan/10 17:38,09/Mar/10 18:29,14/Mar/19 03:02,15/Jan/10 17:40,,,,,,,,,,2.0.0-beta,,,,,,,,,,,0,,"A JPQL query 
    ""select new Range(MIN(p.id), MAX(p.id)) from PObject p""

where p.id is int and Range has constructor (long,long) should be supported.
This is done by matching the constructors of Range type with the supplied arguments (int,int) in a more flexible manner.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161727,,,Fri Jan 15 17:40:08 UTC 2010,,,,,,,0|i0za53:,203945,,,,,,,,"15/Jan/10 17:40;ppoddar@apache.org;The change was committed before this JIRA.

See Revision 899532.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect Oracle CREATE TABLE DDL for XML column,OPENJPA-1461,12445588,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,15/Jan/10 02:50,11/Jun/10 10:34,14/Mar/19 03:02,15/Jan/10 05:20,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jdbc,,,,,,0,,"A regression is found that the DDL for XML type is incorrectly generated for Oracle backend.

<openjpa-2.0.0-SNAPSHOT-rexported nonfatal general error> org.apache.openjpa.persistence.PersistenceException: ORA-00907: missing right parenthesis
 {stmnt 562241923 CREATE TABLE TORDER (oid NUMBER NOT NULL, amount NUMBER, delivered NUMBER, shipAddress XMLType(255), version NUMBER, CUSTOMER_COUNTRYCODE VARCHAR2(255), CUSTOMER_ID NUMBER, PRIMARY KEY (oid))} [code=907, state=42000]
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:553)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:453)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:155)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:159)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:117)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:207)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:194)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:152)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:200)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:151)
	at org.apache.openjpa.persistence.xmlmapping.query.TestXMLCustomerOrder.setUp(TestXMLCustomerOrder.java:75)
	at junit.framework.TestCase.runBare(TestCase.java:125)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:501)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:477)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:177)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: ORA-00907: missing right parenthesis
 {stmnt 562241923 CREATE TABLE TORDER (oid NUMBER NOT NULL, amount NUMBER, delivered NUMBER, shipAddress XMLType(255), version NUMBER, CUSTOMER_COUNTRYCODE VARCHAR2(255), CUSTOMER_ID NUMBER, PRIMARY KEY (oid))} [code=907, state=42000]


Correct DDL should be:
CREATE TABLE TORDER (oid NUMBER NOT NULL, amount NUMBER, delivered NUMBER, shipAddress XMLType, version NUMBER, CUSTOMER_COUNTRYCODE VARCHAR2(255), CUSTOMER_ID NUMBER, PRIMARY KEY (oid))",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-01-15 19:50:51.086,,,no_permission,,,,,,,,,,,161725,,,Fri Jun 11 10:34:51 UTC 2010,,,,,,,0|i0yywf:,202124,,,,,,,,15/Jan/10 05:20;fancy;Fix available at svn r899528,"15/Jan/10 19:50;milosz;Hi Catalina, I am wondering whether your commit to TestUpdateWithSubSelect.java is related to the fix or an oversight?
","11/Jun/10 10:33;mrossi;Hi,
I think this is still broken even in the very latest 2.1.0-SNAPSHOT (I've built it myself from SVN).

Stacktrace:

Caused by: <openjpa-2.1.0-SNAPSHOT-r422266:953182M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: ORA-00907: missing right parenthesis
 {stmnt 13803851 CREATE TABLE authority (ID NUMBER NOT NULL, authorityName XMLType(128) NOT NULL, PRIMARY KEY (ID))} [code=907, state=42000]
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:556)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:456)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:155)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:159)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:117)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:199)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:156)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:213)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:151)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.invokeProxyMethod(AbstractEntityManagerFactoryBean.java:423)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$ManagedEntityManagerFactoryInvocationHandler.invoke(AbstractEntityManagerFactoryBean.java:485)
	at $Proxy20.createEntityManager(Unknown Source)
	at com.iontrading.ionweb.persistence.SchemaCreationHandler.start(SchemaCreationHandler.java:181)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1536)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1477)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1409)
	... 27 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: ORA-00907: missing right parenthesis
 {stmnt 13803851 CREATE TABLE ion_authority (ID NUMBER NOT NULL, authorityName XMLType(128) NOT NULL, PRIMARY KEY (ID))} [code=907, state=42000]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:273)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:257)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$700(LoggingConnectionDecorator.java:70)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingStatement.executeUpdate(LoggingConnectionDecorator.java:967)
	at org.apache.openjpa.lib.jdbc.DelegatingStatement.executeUpdate(DelegatingStatement.java:136)
	at org.apache.openjpa.jdbc.schema.SchemaTool.executeSQL(SchemaTool.java:1200)
	at org.apache.openjpa.jdbc.schema.SchemaTool.createTable(SchemaTool.java:956)
	at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:533)
	at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:348)
	at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:325)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:504)
	... 50 more


The class I am trying to persist:
 */
@Entity
@Table(name=""authority"")
@NamedQueries( { 
		@NamedQuery(name = ""AllIonAuthorities"", query = ""SELECT x FROM IonAuthority x"") 
})
public class Authority {
@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	@Column(name = ""ID"")
	private Integer id;

	@Enumerated( EnumType.STRING ) 
	@Column(nullable=false, length=128, updatable=true, insertable=true)
	@Persistent
	@Strategy(""org.apache.openjpa.jdbc.meta.strats.EnumValueHandler"")
	private AuthorityValues authorityName;


-----------

@XmlType(name = ""IonAuthorityValues"")
@XmlEnum
public enum AuthorityValues {

    AUTH1,
    AUTH2,
","11/Jun/10 10:34;mrossi;the result is the same even without the following annotations

@Persistent 
@Strategy(""org.apache.openjpa.jdbc.meta.strats.EnumValueHandler"") 


I am still trying to find a way to disable the use of XmlType - I just want it to be a string",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Fix scope visibility of orm.xml when it is packaged in both ear file and war file,OPENJPA-1460,12445570,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,14/Jan/10 23:29,09/Mar/10 18:29,14/Mar/19 03:02,09/Mar/10 14:57,2.0.0-beta,2.0.0-M3,,,,,,,,2.0.0-beta2,,,,,jpa,,,,,,0,,"Per JPA 2.0 spec, section 8.2.2:
An EJB-JAR, WAR, application client jar, or EAR can define a persistence unit. When referencing a persistence unit using the unitName annotation element or persistence-unit-name deployment descriptor element, the visibility scope of the persistence unit is determined by its point of definition:

(1) A persistence unit that is defined at the level of an EJB-JAR, WAR, or application client jar is scoped to that EJB-JAR, WAR, or application jar respectively and is visible to the components defined in that jar or war.

(2) A persistence unit that is defined at the level of the EAR is generally visible to all components in the application. However, if a persistence unit of the same name is defined by an EJB-JAR, WAR, or application jar file within the EAR, the persistence unit of that name defined at EAR level will not be visible to the components defined by that EJB-JAR, WAR, or application jar file unless the persistence unit reference uses the persistence unit name # syntax to specify a path name to disambiguate the reference. When the # syntax is used, the path name is relative to the referencing application component jar file. For example, the syntax ../lib/persistenceUnitRoot. jar#myPersistenceUnit refers to a persistence unit whose name, as specified in the name element of the persistence.xml file, is myPersistenceUnit and for which the relative path name of the root of the persistence unit is ../lib/persistenceUnitRoot. jar. The # syntax may be used with both the unitName annotation element
or persistence-unit-name deployment descriptor element to reference a persistence unit defined at EAR level.
",,,,,,,,,,,,,,,,,,,,,,15/Jan/10 00:49;faywang;OPENJPA-1460-1.patch;https://issues.apache.org/jira/secure/attachment/12430331/OPENJPA-1460-1.patch,22/Jan/10 04:41;faywang;OPENJPA-1460-2.patch;https://issues.apache.org/jira/secure/attachment/12431094/OPENJPA-1460-2.patch,22/Jan/10 21:51;faywang;OPENJPA-1460-3.patch;https://issues.apache.org/jira/secure/attachment/12431151/OPENJPA-1460-3.patch,09/Feb/10 18:01;drwoods;OPENJPA-1460-4.patch;https://issues.apache.org/jira/secure/attachment/12435318/OPENJPA-1460-4.patch,09/Feb/10 23:11;faywang;OPENJPA-1460-5.patch;https://issues.apache.org/jira/secure/attachment/12435370/OPENJPA-1460-5.patch,15/Jan/10 00:19;faywang;OPENJPA-1460.patch;https://issues.apache.org/jira/secure/attachment/12430323/OPENJPA-1460.patch,,,,,,,,,6.0,,,,,,,,,,,,,,,,,,,2010-02-09 18:01:51.415,,,no_permission,,,,,,,,,,,87576,,,Tue Mar 09 14:57:01 UTC 2010,,,Patch Available,,,,0|i0z2yf:,202781,,,,,,,,15/Jan/10 00:49;faywang;fix NPE.,17/Jan/10 23:43;faywang;The fix checked into the JIRA assume that the orm.xml to be used should reside in the same location as the persistence.xml that is used to create EntityManagerFactory.,"22/Jan/10 04:43;faywang;Per spec:
8.2.1.6.2 Object/relational Mapping Files
A object/relational mapping XML file named orm.xml may be specified in the META-INF directory in the root of the persistence unit or in the META-INF directory of any jar file referenced by the persistence.xml. Alternatively, or in addition, one or more mapping files may be referenced by the mapping-file elements of the persistence-unit element. These mapping files may be present anywhere on the class path.

As a result: 
the entity manager factory will look look for orm.xml file 	
	1.  in the same location (jar file\meta-inf directory) as where the persistence.xml that defined the pu of the EMF was found.
	2.  in the meta-inf directory of any jar file explicitly mentioned in the <jarfile> tag in the PU.

finally any <mapping-file> files are also loaded.  




",22/Jan/10 21:51;faywang;This patch fixes the violation of the principle of spec-agnostic  OpenJPAConfiguration.  ,09/Feb/10 18:01;drwoods;Updated patch that can be applied to the latest trunk (r908071) code,09/Feb/10 20:59;ppoddar@apache.org;This change should not expose the persistent environment setting on to OpenJPAConfiguration interface. That method does not have a clear semantics to be on the configuration interface. Please keep the method on OpenJPAConfigurationImpl and do a conditional cast to solve the problem at hand.. ,09/Feb/10 23:11;faywang;Made changes according to Pinaki's suggestion.,"16/Feb/10 16:05;drwoods;Fay, why did you reopen this?  Is there more work or docs updates to do?
","09/Mar/10 14:57;drwoods;all patches were applied and included in Beta2, so closing this.  there is a open subtask for remaining optional work.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Named parameters are not handled by OpenJPA correctly,OPENJPA-1458,12445430,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,13/Jan/10 19:21,23/Apr/10 19:43,14/Mar/19 03:02,09/Mar/10 18:12,2.0.0-M3,,,,,,,,,2.0.0-beta3,,,,,,,,,,,0,,"Named parameters are not handled correctly as shown below

9093  erww  TRACE  [main] openjpa.Query - Executing query: [select o from OrderJPA o where o.OrderId in (select max(o1.OrderId) from OrderJPA o1 where ((o1.CustomerId = :customerId) and (o1.DistrictId = :districtId) and (o1.WarehouseId = :warehouseId))) and (o.WarehouseId = :warehouseId) and (o.CustomerId = :customerId) and (o.DistrictId = :districtId)] with parameters: {customerId=10, districtId=1, warehouseId=12}
9194  erww  TRACE  [main] openjpa.jdbc.SQL - <t 29744585, conn 23467239> executing prepstmnt 15580729 SELECT t0.O_D_ID, t0.O_ID, t0.O_W_ID, t0.O_ALL_LOCAL, t0.O_CARRIER_ID, t0.O_C_ID, t0.O_ENTRY_D, t0.O_OL_CNT FROM ORDERS t0 WHERE (t0.O_ID IN (SELECT MAX(t1.O_ID) FROM ORDERS t1 WHERE (t1.O_C_ID = ? AND t1.O_D_ID = ? AND t1.O_W_ID = ?) ) AND t0.O_W_ID = ? AND t0.O_C_ID = ? AND t0.O_D_ID = ?)  optimize for 1 row [params=(short) 10, (short) 1, (short) 12, (short) 12, (short) 12, (short) 12]

Release 1.2 and 1.3 works fine. This problem only happens in the trunk.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-01-17 21:54:19.652,,,no_permission,,,,,,,,,,,161723,,,Sun Jan 17 21:54:19 UTC 2010,,,,,,,0|i0z2t3:,202757,,,,,,,,"17/Jan/10 21:54;achim.b;Hi Fay.

I spend some time to get the failure.
I added a few test cases and entities but was not able to do so.
Is there a way to get the failing entity?

But, maybe these file can help to make OpenJPA a little bit better.

Best regards
Achim",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Remove Java.net maven repostiory from tck pom.xml,OPENJPA-1457,12445426,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,13/Jan/10 19:00,14/Jan/10 20:31,14/Mar/19 03:02,14/Jan/10 20:31,1.0.4,1.2.2,1.3.0,,,,,,,1.0.4,1.2.2,1.3.0,,,build / infrastructure,,,,,,0,,"The Java.net maven 1 repository contains a placeholder for some of the OpenJPA 1.2.2 artifacts (ie openjpa-lib and openjpa-kernel). Unfortunately the maven release plugin detects the placeholder and downloads it as a jar and copies it into your local repository. 

Having the jar in your local repository causes problems with the javadoc tool and the release plugin cannot continue.

Unfortunately this issue is not detected when doing a dryRun of the release:prepare goal - at least in my environment it only shows up when you start the release for real. 

We use the Geronimo JPA spec jars elsewhere in the build - moving the TCK configuration to use them as well would resolve this issue.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161722,,,2010-01-13 19:00:31.0,,,,,,,0|i0z2sn:,202755,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SynchronizeMapping ALTER TABLE ADD COLUMN fails with column already exist exception,OPENJPA-1455,12444936,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,07/Jan/10 16:57,23/Mar/10 18:34,14/Mar/19 03:02,22/Mar/10 18:53,2.0.0,,,,,,,,,2.0.0-beta3,,,,,jdbc,,,,,,0,,"SynchronizeMapping ALTER TABLE ADD COLUMN fails with column already exist exception. The failure happens when there are multiple tables with the same name but in different schema. When OpenJPA detects a missing column from one table with schema X, it tried to to add the column to another table in default schema, resulting in column already exist exception. ",,,,,,,,,,,,,,,,OPENJPA-842,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-01-10 09:44:12.732,,,no_permission,,,,,,,,,,,161720,,,Mon Jan 11 23:45:18 UTC 2010,,,,,,,0|i0z9m7:,203860,,,,,,,,"10/Jan/10 09:44;milosz;Hi Fay, I have a few concerns with the committed code:

1. Do schema generation and other things work if you specify DB2 JDBC URL property currentSchema=my_schema? Does metaData.getUserName() return ""my_schema"" in this case?
2. If the above is false, have you considered issuing ""VALUES CURRENT SCHEMA"" query instead of calling ""metaData.getUserName()""?

In other words, I am afraid that the current schema not always equals user name with DB2 (and maybe some other databases also) and whether by fixing this issue we are creating another one.
",11/Jan/10 23:45;faywang;Thanks to Milosz for pointing out the problem of getting current schema from DB2. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA 2.0.0-M3 attempts to mutate unmodifiable map in Glassfish,OPENJPA-1452,12444508,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,baboune,baboune,02/Jan/10 18:53,28/Apr/10 22:43,14/Mar/19 03:02,08/Jan/10 18:23,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,"OpenJPA Attempts to modiy an umodifiable map in Glassfish.

Similar issue to:
https://issues.apache.org/jira/browse/OPENJPA-498

To reproduce:
+ Place the open jpa libs in [glassfish]/domain/domains1/lib
+ Deploy any app or jar using openjpa as the persistence provider
    <provider>org.apache.openjpa.persistence.PersistenceProviderImpl</provider>

trace:
[#|2010-01-02T19:42:27.581+0100|INFO|sun-glassfish-comms-server1.5|javax.enterprise.system.tools.deployment|_ThreadID=17;_ThreadName=Timer-12;|deployed with moduleid = gs-apps_EJB|#]

[#|2010-01-02T19:42:27.834+0100|WARNING|sun-glassfish-comms-server1.5|javax.enterprise.system.core.classloading|_ThreadID=17;_ThreadName=Timer-12;_RequestID=68741cc4-049e-4f05-a6f5-fab7d336f48e;|The log message is null.
java.lang.UnsupportedOperationException
	at java.util.Collections$UnmodifiableMap.remove(Collections.java:1288)
	at org.apache.openjpa.lib.conf.Configurations.removeProperty(Configurations.java:681)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:157)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:59)
	at com.sun.enterprise.server.PersistenceUnitLoaderImpl.load(PersistenceUnitLoaderImpl.java:149)
	at com.sun.enterprise.server.PersistenceUnitLoaderImpl.load(PersistenceUnitLoaderImpl.java:84)
	at com.sun.enterprise.server.AbstractLoader.loadPersistenceUnits(AbstractLoader.java:895)
	at com.sun.enterprise.server.EJBModuleLoader.doLoad(EJBModuleLoader.java:165)
	at com.sun.enterprise.server.AbstractLoader.load(AbstractLoader.java:238)
	at com.sun.enterprise.server.StandAloneEJBModulesManager.moduleDeployed(StandAloneEJBModulesManager.java:233)
	at com.sun.enterprise.server.StandAloneEJBModulesManager.moduleDeployed(StandAloneEJBModulesManager.java:188)
	at com.sun.enterprise.server.StandAloneEJBModulesManager.moduleDeployed(StandAloneEJBModulesManager.java:420)
	at com.sun.enterprise.admin.event.AdminEventMulticaster.invokeModuleDeployEventListener(AdminEventMulticaster.java:1005)
	at com.sun.enterprise.admin.event.AdminEventMulticaster.handleModuleDeployEvent(AdminEventMulticaster.java:992)
	at com.sun.enterprise.admin.event.AdminEventMulticaster.processEvent(AdminEventMulticaster.java:470)
	at com.sun.enterprise.admin.event.AdminEventMulticaster.multicastEvent(AdminEventMulticaster.java:182)
	at com.sun.enterprise.admin.server.core.DeploymentNotificationHelper.multicastEvent(DeploymentNotificationHelper.java:308)
	at com.sun.enterprise.deployment.phasing.DeploymentServiceUtils.multicastEvent(DeploymentServiceUtils.java:231)
	at com.sun.enterprise.deployment.phasing.ServerDeploymentTarget.sendStartEvent(ServerDeploymentTarget.java:298)
	at com.sun.enterprise.deployment.phasing.ApplicationStartPhase.runPhase(ApplicationStartPhase.java:132)
	at com.sun.enterprise.deployment.phasing.DeploymentPhase.executePhase(DeploymentPhase.java:108)
	at com.sun.enterprise.deployment.phasing.PEDeploymentService.executePhases(PEDeploymentService.java:966)
	at com.sun.enterprise.deployment.phasing.PEDeploymentService.deploy(PEDeploymentService.java:280)
	at com.sun.enterprise.deployment.phasing.PEDeploymentService.deploy(PEDeploymentService.java:298)
	at com.sun.enterprise.admin.mbeans.ApplicationsConfigMBean.deploy(ApplicationsConfigMBean.java:584)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.sun.enterprise.admin.MBeanHelper.invokeOperationInBean(MBeanHelper.java:381)
	at com.sun.enterprise.admin.MBeanHelper.invokeOperationInBean(MBeanHelper.java:364)
	at com.sun.enterprise.admin.config.BaseConfigMBean.invoke(BaseConfigMBean.java:477)
	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:836)
	at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:761)
	at sun.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.sun.enterprise.admin.util.proxy.ProxyClass.invoke(ProxyClass.java:90)
	at $Proxy1.invoke(Unknown Source)
	at com.sun.enterprise.admin.server.core.jmx.SunoneInterceptor.invoke(SunoneInterceptor.java:304)
	at com.sun.enterprise.interceptor.DynamicInterceptor.invoke(DynamicInterceptor.java:174)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployer.invokeDeploymentService(AutoDeployer.java:583)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployer.deployJavaEEArchive(AutoDeployer.java:564)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployer.deploy(AutoDeployer.java:495)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployer.deployAll(AutoDeployer.java:270)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployControllerImpl$AutoDeployTask.run(AutoDeployControllerImpl.java:374)
	at java.util.TimerThread.mainLoop(Timer.java:512)
	at java.util.TimerThread.run(Timer.java:462)
|#]

[#|2010-01-02T19:42:27.837+0100|WARNING|sun-glassfish-comms-server1.5|javax.enterprise.system.core|_ThreadID=17;_ThreadName=Timer-12;_RequestID=68741cc4-049e-4f05-a6f5-fab7d336f48e;|CORE5020: Error while loading ejb module|#]

","Ubuntu-karmic koala
SLES 10.2

Using sailfin v1 b60g (based on glassfish v2.1)",,,,,,,,,,,,,,,,,,,,,02/Jan/10 20:20;baboune;Configurations.java;https://issues.apache.org/jira/secure/attachment/12429283/Configurations.java,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-01-08 16:05:34.241,,,no_permission,,,,,,,,,,,161717,,,Wed Apr 28 22:43:47 UTC 2010,,,,,,,0|i0zbrr:,204209,,,,,,,,"02/Jan/10 18:58;baboune;list of jars added to the [GLASFFISH]/domains/domain1/lib directory:
commons-collections-3.2.1.jar  
commons-pool-1.5.2.jar  ext
openjpa-all-2.0.0-M3.jar
commons-lang-2.1.jar
serp-1.13.1.jar

Note that I had to put the openjpa-all jar and not openjpa-2.0.0-M3, otherwise I was getting a Exception in thread ""main"" java.lang.NoClassDefFoundError: javax/persistence/spi/ProviderUtil.  That is the case even if I deploy the libs in the [GLASSFISH]/lib directory.


","02/Jan/10 20:18;baboune;Hi,

I took a subversion snapshot of the source code and reintroduced the change in Configurations.java:
Index: Configurations.java
===================================================================
--- Configurations.java    (revision 895268) 
+++ Configurations.java    (working copy) 
@@ -677,8 +677,10 @@
     public static Object removeProperty(String partialKey, Map props) {
         if (partialKey == null || props == null || props.isEmpty())
             return null;
-        String fullKey = ProductDerivations.getConfigurationKey(partialKey, props); 
-        return props.remove(fullKey); 
+     if (containsProperty(partialKey, props)) 
+        return props.remove(ProductDerivations.getConfigurationKey(partialKey, props)); 
+    else  
+        return null; 
     }
 
     /**

Recompile the project and used the new open-jpa jar generated.

Now I get this:
[#|2010-01-02T21:15:39.566+0100|WARNING|sun-glassfish-comms-server2.0|javax.enterprise.system.stream.err|_ThreadID=16;_ThreadName=Timer-7;_RequestID=e78ed0fe-72e4-4798-8ab5-1430c502d733;|
java.lang.NoSuchMethodError: javax.persistence.spi.PersistenceUnitInfo.getValidationMode()Ljavax/persistence/ValidationMode;
	at org.apache.openjpa.persistence.PersistenceUnitInfoImpl.toOpenJPAProperties(PersistenceUnitInfoImpl.java:457)
	at org.apache.openjpa.persistence.PersistenceProductDerivation.load(PersistenceProductDerivation.java:260)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:158)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:59)
	at com.sun.enterprise.server.PersistenceUnitLoaderImpl.load(PersistenceUnitLoaderImpl.java:149)
	at com.sun.enterprise.server.PersistenceUnitLoaderImpl.load(PersistenceUnitLoaderImpl.java:84)
	at com.sun.enterprise.server.AbstractLoader.loadPersistenceUnits(AbstractLoader.java:915)
	at com.sun.enterprise.server.EJBModuleLoader.doLoad(EJBModuleLoader.java:165)
	at com.sun.enterprise.server.AbstractLoader.load(AbstractLoader.java:240)
	at com.sun.enterprise.server.StandAloneEJBModulesManager.moduleDeployed(StandAloneEJBModulesManager.java:233)
	at com.sun.enterprise.server.StandAloneEJBModulesManager.moduleDeployed(StandAloneEJBModulesManager.java:188)
	at com.sun.enterprise.server.StandAloneEJBModulesManager.moduleDeployed(StandAloneEJBModulesManager.java:420)
	at com.sun.enterprise.admin.event.AdminEventMulticaster.invokeModuleDeployEventListener(AdminEventMulticaster.java:1005)
	at com.sun.enterprise.admin.event.AdminEventMulticaster.handleModuleDeployEvent(AdminEventMulticaster.java:992)
	at com.sun.enterprise.admin.event.AdminEventMulticaster.processEvent(AdminEventMulticaster.java:470)
	at com.sun.enterprise.admin.event.AdminEventMulticaster.multicastEvent(AdminEventMulticaster.java:182)
	at com.sun.enterprise.admin.server.core.DeploymentNotificationHelper.multicastEvent(DeploymentNotificationHelper.java:308)
	at com.sun.enterprise.deployment.phasing.DeploymentServiceUtils.multicastEvent(DeploymentServiceUtils.java:231)
	at com.sun.enterprise.deployment.phasing.ServerDeploymentTarget.sendStartEvent(ServerDeploymentTarget.java:298)
	at com.sun.enterprise.deployment.phasing.ApplicationStartPhase.runPhase(ApplicationStartPhase.java:132)
	at com.sun.enterprise.deployment.phasing.DeploymentPhase.executePhase(DeploymentPhase.java:108)
	at com.sun.enterprise.deployment.phasing.PEDeploymentService.executePhases(PEDeploymentService.java:966)
	at com.sun.enterprise.deployment.phasing.PEDeploymentService.deploy(PEDeploymentService.java:280)
	at com.sun.enterprise.deployment.phasing.PEDeploymentService.deploy(PEDeploymentService.java:298)
	at com.sun.enterprise.admin.mbeans.ApplicationsConfigMBean.deploy(ApplicationsConfigMBean.java:584)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.sun.enterprise.admin.MBeanHelper.invokeOperationInBean(MBeanHelper.java:390)
	at com.sun.enterprise.admin.MBeanHelper.invokeOperationInBean(MBeanHelper.java:373)
	at com.sun.enterprise.admin.config.BaseConfigMBean.invoke(BaseConfigMBean.java:477)
	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:836)
	at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:761)
	at sun.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.sun.enterprise.admin.util.proxy.ProxyClass.invoke(ProxyClass.java:90)
	at $Proxy1.invoke(Unknown Source)
	at com.sun.enterprise.admin.server.core.jmx.SunoneInterceptor.invoke(SunoneInterceptor.java:304)
	at com.sun.enterprise.interceptor.DynamicInterceptor.invoke(DynamicInterceptor.java:170)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployer.invokeDeploymentService(AutoDeployer.java:583)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployer.deployJavaEEArchive(AutoDeployer.java:564)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployer.deploy(AutoDeployer.java:495)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployer.deployAll(AutoDeployer.java:270)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployControllerImpl$AutoDeployTask.run(AutoDeployControllerImpl.java:374)
	at java.util.TimerThread.mainLoop(Timer.java:512)
	at java.util.TimerThread.run(Timer.java:462)
|#]


Seems there are lots of problem running openJPA 2 on glassfish...

","02/Jan/10 20:20;baboune;Updated Configurations,java, fixes the unmodifiable exception but triggers another....

java.lang.NoSuchMethodError: javax.persistence.spi.PersistenceUnitInfo.getValidationMode()Ljavax/persistence/ValidationMode","08/Jan/10 16:05;drwoods;Testing the patch now against trunk.

As far as the ValidationMode problem, the M3 release used the JPA 2.0 PFD2 APIs, which there were some changes to the API dealing with the location of the validation interfaces in the final spec.  Maybe your level of Glassfish is using the final JPA2 spec apis?  If so, you'll have to grab a nightly 2.0.0-SNAPSHOT build from trunk, which uses the final JPA2 APIs.
","08/Jan/10 18:23;drwoods;Returned code back to what was in 1.2/1.3, which called containsProperty()","24/Jan/10 20:43;baboune;I tired again with the latest nightly build and the error is still there.
Apache svn revision: 422266:897056

java.lang.UnsupportedOperationException
at java.util.Collections$UnmodifiableMap.remove(Collections.java:1288)
at org.apache.openjpa.lib.conf.Configurations.removeProperty(Configurations.java:681)
at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:157)
at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:59)
at com.sun.enterprise.server.PersistenceUnitLoaderImpl.load(PersistenceUnitLoaderImpl.java:149)
at com.sun.enterprise.server.PersistenceUnitLoaderImpl.load(PersistenceUnitLoaderImpl.java:84)
at com.sun.enterprise.server.AbstractLoader.loadPersistenceUnits(AbstractLoader.java:895)
at com.sun.enterprise.server.EJBModuleLoader.doLoad(EJBModuleLoader.java:165)
at com.sun.enterprise.server.AbstractLoader.load(AbstractLoader.java:238)
at com.sun.enterprise.server.StandAloneEJBModulesManager.moduleDeployed(StandAloneEJBModulesManager.java:233) 

Should I reopen this?","24/Jan/10 21:03;baboune;Tried tp download the latest svn repository files and build from there.  The original problem is gone.  But I still get:
[#|2010-01-24T22:00:56.608+0100|WARNING|sun-glassfish-comms-server1.5|javax.enterprise.system.stream.err|_ThreadID=16;_ThreadName=Timer-7;_RequestID=ac39b253-89d1-4910-b76b-a305b28e5877;|java.lang.NoSuchMethodError: javax.persistence.spi.PersistenceUnitInfo.getValidationMode()Ljavax/persistence/ValidationMode;
	at org.apache.openjpa.persistence.PersistenceUnitInfoImpl.toOpenJPAProperties(PersistenceUnitInfoImpl.java:457)
	at org.apache.openjpa.persistence.PersistenceProductDerivation.load(PersistenceProductDerivation.java:313)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:158)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:62)
	at com.sun.enterprise.server.PersistenceUnitLoaderImpl.load(PersistenceUnitLoaderImpl.java:149)
	at com.sun.enterprise.server.PersistenceUnitLoaderImpl.load(PersistenceUnitLoaderImpl.java:84)
	at com.sun.enterprise.server.AbstractLoader.loadPersistenceUnits(AbstractLoader.java:895)
	at com.sun.enterprise.server.EJBModuleLoader.doLoad(EJBModuleLoader.java:165)
	at com.sun.enterprise.server.AbstractLoader.load(AbstractLoader.java:238)
	at com.sun.enterprise.server.StandAloneEJBModulesManager.moduleDeployed(StandAloneEJBModulesManager.java:233)
	at com.sun.enterprise.server.StandAloneEJBModulesManager.moduleDeployed(StandAloneEJBModulesManager.java:188)
	at com.sun.enterprise.server.StandAloneEJBModulesManager.moduleDeployed(StandAloneEJBModulesManager.java:420)
	at com.sun.enterprise.admin.event.AdminEventMulticaster.invokeModuleDeployEventListener(AdminEventMulticaster.java:1005)
	at com.sun.enterprise.admin.event.AdminEventMulticaster.handleModuleDeployEvent(AdminEventMulticaster.java:992)
	at com.sun.enterprise.admin.event.AdminEventMulticaster.processEvent(AdminEventMulticaster.java:470)
	at com.sun.enterprise.admin.event.AdminEventMulticaster.multicastEvent(AdminEventMulticaster.java:182)
	at com.sun.enterprise.admin.server.core.DeploymentNotificationHelper.multicastEvent(DeploymentNotificationHelper.java:308)
	at com.sun.enterprise.deployment.phasing.DeploymentServiceUtils.multicastEvent(DeploymentServiceUtils.java:231)
	at com.sun.enterprise.deployment.phasing.ServerDeploymentTarget.sendStartEvent(ServerDeploymentTarget.java:298)
	at com.sun.enterprise.deployment.phasing.ApplicationStartPhase.runPhase(ApplicationStartPhase.java:132)
	at com.sun.enterprise.deployment.phasing.DeploymentPhase.executePhase(DeploymentPhase.java:108)
	at com.sun.enterprise.deployment.phasing.PEDeploymentService.executePhases(PEDeploymentService.java:966)
	at com.sun.enterprise.deployment.phasing.PEDeploymentService.deploy(PEDeploymentService.java:280)
	at com.sun.enterprise.deployment.phasing.PEDeploymentService.deploy(PEDeploymentService.java:298)
	at com.sun.enterprise.admin.mbeans.ApplicationsConfigMBean.deploy(ApplicationsConfigMBean.java:584)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.sun.enterprise.admin.MBeanHelper.invokeOperationInBean(MBeanHelper.java:381)
	at com.sun.enterprise.admin.MBeanHelper.invokeOperationInBean(MBeanHelper.java:364)
	at com.sun.enterprise.admin.config.BaseConfigMBean.invoke(BaseConfigMBean.java:477)
	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:836)
	at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:761)
	at sun.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.sun.enterprise.admin.util.proxy.ProxyClass.invoke(ProxyClass.java:90)
	at $Proxy1.invoke(Unknown Source)
	at com.sun.enterprise.admin.server.core.jmx.SunoneInterceptor.invoke(SunoneInterceptor.java:304)
	at com.sun.enterprise.interceptor.DynamicInterceptor.invoke(DynamicInterceptor.java:174)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployer.invokeDeploymentService(AutoDeployer.java:583)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployer.deployJavaEEArchive(AutoDeployer.java:564)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployer.deploy(AutoDeployer.java:495)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployer.deployAll(AutoDeployer.java:270)
	at com.sun.enterprise.deployment.autodeploy.AutoDeployControllerImpl$AutoDeployTask.run(AutoDeployControllerImpl.java:374)
	at java.util.TimerThread.mainLoop(Timer.java:512)
	at java.util.TimerThread.run(Timer.java:462)
|#]


Raise new issue?","25/Jan/10 16:14;techhusky;Does the version of Glassfish you are using support JPA 2.0/EE6?  It looks like you are trying to use OpenJPA 2.0 with JPA 1.0 level spec API.  The 2.0 level spec API jar  (either from Geronimo or a version provided by Sun) is required to run OpenJPA 2.0.

Note:  The OpenJPA M3 release does not match the final JPA 2.0 specification, but the most current trunk level code does.  If you get an EE6 version of Glassfish, be sure to use the most current OpenJPA trunk level code.","29/Jan/10 20:27;baboune;Glassfish 2.1 does not support EE6/JPA 2.0.
So no openJPA for us then... I would have thought that OpenJPA 2 would be backward compatible with JPA 2","29/Jan/10 21:35;techhusky;OpenJPA 2.0 is backward compatible with OpenJPA 1.0 from an application standpoint  (ie. your apps that run on OpenJPA 1.x will continue to run on OpenJPA 2.0), but not from an environment perspective.  Your runtime environment must have the correct libraries and versions of those libraries required by OpenJPA 2.0.  This typically isn't a problem in JSE environments since you just include the required jars in your classpath and run the app.  However, it is often a problem in JEE environments since the app server vendors provide the libraries for whatever JEE spec level they support and typically don't provide a way to plug in a newer spec level of those libraries.  Thus, you need to pick up a new release of the app server with support for the newer spec level.  OpenJPA 2.0 should work with the JEE6 version of Glassfish.  (But, I haven't tried it)  There's also a WebSphere JPA 2.0 alpha[1] available that is based on OpenJPA 2.0.

[1]  https://www14.software.ibm.com/iwm/web/cc/earlyprograms/websphere/wsasjpaoa/",06/Feb/10 09:55;baboune;Verified with latest nightly build.,"28/Apr/10 22:43;ppoddar@apache.org;> Glassfish 2.1 does not support EE6/JPA 2.0.
> So no openJPA for us then... I would have thought that OpenJPA 2 would be backward compatible with JPA 2

To run OpenJPA 2.0 (or possibly other JPA 2.0 compliant JPA provider, my observations/experiments are based on OpenJPA only), please try the following

  1. Grab a JPA 2.0 Specification JAR from somewhere. JPA 2.0 specifcation jar is not only a set of interface classes but also has concrete implementation classes. 
      The errors reported in this issue can be traced to the fact that 
          a) Glassfish V2.x includes EclipseLink library which in turn includes JPA spec classes 
          b) those spec classes are JPA 1.0 

  2. Place that jar (say jpa-spec-2.0.jar) into <root>/domains/domain1/lib/ext 
      where <root> is glassfish v2.x install point
                 domain1 is the name of the domain

      That lib/ext directory is also a good place for common libraries such as JDBC driver

  3. Place openjpa 2.x libraries into <root>/domains/domain1/applibs. 

  4. Deploy your application with --libraries option. The options should specify openjpa 2.x library name(s). You can do the same from the web-based admin console on the page
(Web Applications -> Deploy) and fill-in 'Libraries' field.  
",,,,,,,,,,,,,,,,,,,,,,,,,
Support Enum as external value,OPENJPA-1445,12444086,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,23/Dec/09 11:21,09/Mar/10 18:29,14/Mar/19 03:02,18/Jan/10 19:50,2.0.0-beta,,,,,,,,,2.0.0-beta,,,,,kernel,,,,,,0,,@ExternalValues should support enums,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-12-28 18:52:37.574,,,no_permission,,,,,,,,,,,161710,,,Mon Dec 28 18:52:37 UTC 2009,,,,,,,0|i0yzgn:,202215,,,,,,,,"28/Dec/09 18:52;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Criteria Query with fetch joins does not return correct DISTINCT result,OPENJPA-1444,12444071,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,23/Dec/09 07:56,09/Mar/10 18:29,14/Mar/19 03:02,18/Jan/10 19:50,2.0.0-beta,,,,,,,,,2.0.0-beta,,,,,query,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-12-28 18:52:39.315,,,no_permission,,,,,,,,,,,161709,,,Mon Dec 28 18:52:39 UTC 2009,,,,,,,0|i0z75z:,203463,,,,,,,,"28/Dec/09 18:52;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"java.sql.Date, java.math.BigDecimal, or java.math.BigInteger types as derived primary keys are not Enhanced correctly",OPENJPA-1442,12444057,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,23/Dec/09 03:12,09/Mar/10 18:29,14/Mar/19 03:02,23/Dec/09 22:38,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,,,,,,,0,,"When using java.sql.Date, java.math.BigDecimal, or java.math.BigInteger types are derived primary keys the following error and stack trace result (in all environments: JSE,EJB,WEB):

**Exception: Unexpected exception caught while running tests.
    java.lang.VerifyError:JVMVRFY012 stack shape inconsistent; class=suite/r80/base/common/datamodel/entities/Entity0416, method=pcNewObjectIdInstance()Ljava/lang/Object;, pc=62
	at java.lang.J9VMInternals.verifyImpl(Native Method)
	at java.lang.J9VMInternals.verify(J9VMInternals.java:72)
	at java.lang.J9VMInternals.initialize(J9VMInternals.java:134)
	at java.lang.Class.forNameImpl(Native Method)
	at java.lang.Class.forName(Class.java:169)
	at org.apache.openjpa.meta.MetaDataRepository.classForName(MetaDataRepository.java:1461)
	at org.apache.openjpa.meta.MetaDataRepository.loadPersistentTypes(MetaDataRepository.java:1434)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.loadPersistentTypes(AbstractBrokerFactory.java:273)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.initializeBroker(AbstractBrokerFactory.java:229)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:203)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:152)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:200)

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-12-28 18:52:30.5,,,no_permission,,,,,,,,,,,161707,,,Mon Dec 28 18:52:33 UTC 2009,,,,,,,0|i0z8qf:,203717,,,,,,,,"28/Dec/09 18:52;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
","28/Dec/09 18:52;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"NPE when enhancing a Serializable, versioned class",OPENJPA-1441,12443939,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,21/Dec/09 20:38,26/Nov/15 17:50,14/Mar/19 03:02,22/Dec/09 15:13,1.2.2,1.3.0,2.0.0-beta,,,,,,,1.2.2,1.3.0,2.0.0-beta,,,kernel,,,,,,0,,"I'm unable to enhance a Serializable class that has a version field when I have the DetachState property set as follows: openjpa.DetachState=fgs(DetachedStateField=true).

The exception I'm seeing is : 

-----
null
Exception in thread ""main"" <openjpa-2.0.0-SNAPSHOT-r422266:890859 nonfatal general error> org.apache.openjpa.util.GeneralException: An error occurred while enhancing com.test.acme.annuity.common.bean.jpa.AbstractPersistebleObject. Exception message: null
	at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:545)
	at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:4652)
	at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:4594)
	at main.EnhancerDriver.main(EnhancerDriver.java:19)
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.enhance.PCEnhancer.addGetManagedValueCode(PCEnhancer.java:4320)
	at org.apache.openjpa.enhance.PCEnhancer.addGetManagedValueCode(PCEnhancer.java:4278)
	at org.apache.openjpa.enhance.PCEnhancer.writeExternal(PCEnhancer.java:4266)
	at org.apache.openjpa.enhance.PCEnhancer.addWriteExternal(PCEnhancer.java:4203)
	at org.apache.openjpa.enhance.PCEnhancer.addDetachExternalize(PCEnhancer.java:3991)
	at org.apache.openjpa.enhance.PCEnhancer.addAttachDetachCode(PCEnhancer.java:3761)
	at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:532)
	... 3 more
-----",,,,,,,,,,,,,,,,OPENJPA-1400,,,,,,22/Dec/09 15:11;curtisr7;OPENJPA-1441.1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12428734/OPENJPA-1441.1.2.x.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-12-28 18:36:33.481,,,no_permission,,,,,,,,,,,161706,,,Thu Nov 26 17:50:58 UTC 2015,,,,,,,0|i0z8sv:,203728,,,,,,,,21/Dec/09 20:39;curtisr7;OPENJPA-1400 introduced this bug.,22/Dec/09 15:11;curtisr7;Attaching a patch for the 1.2.x branch.,22/Dec/09 15:13;curtisr7;Committed changes to 1.3.x and trunk. ,"28/Dec/09 18:36;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
","28/Dec/09 18:36;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
","28/Dec/09 18:52;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
","28/Dec/09 19:24;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
","26/Nov/15 17:50;leboulanger.aurelien@gmail.com;Hello,

I have the same issue with openjpa-2.4.0 (with tomEE 1.7.2)

```
openjpa-2.4.0-nonfinal-1598334-r422266:1599166 nonfatal general error> org.apache.openjpa.util.GeneralException: An error occurred while enhancing com.dsi.entities.Widget. Exception message: null
                at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:578)
                at org.apache.openjpa.enhance.PCClassFileTransformer.transform0(PCClassFileTransformer.java:153)
                at org.apache.openjpa.enhance.PCClassFileTransformer.transform(PCClassFileTransformer.java:126)
                at org.apache.openjpa.persistence.PersistenceProviderImpl$ClassTransformerImpl.transform(PersistenceProviderImpl.java:291)
                at org.apache.openejb.persistence.PersistenceUnitInfoImpl$PersistenceClassFileTransformer.transform(PersistenceUnitInfoImpl.java:356)
                at sun.instrument.TransformerManager.transform(TransformerManager.java:188)
                at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)
                at java.lang.ClassLoader.defineClass1(Native Method)
                at java.lang.ClassLoader.defineClass(ClassLoader.java:760)
                at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
                at org.apache.catalina.loader.WebappClassLoader.findClassInternal(WebappClassLoader.java:2957)
                at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:1210)
                at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1690)
                at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1571)
                at org.apache.tomee.catalina.LazyStopWebappClassLoader.loadClass(LazyStopWebappClassLoader.java:129)
                at org.hibernate.internal.util.ReflectHelper.classForName(ReflectHelper.java:187)
                at org.hibernate.ejb.packaging.NativeScanner.getClassesInJar(NativeScanner.java:136)
                at org.hibernate.ejb.Ejb3Configuration.addScannedEntries(Ejb3Configuration.java:485)
                at org.hibernate.ejb.Ejb3Configuration.scanForClasses(Ejb3Configuration.java:852)
                at org.hibernate.ejb.Ejb3Configuration.configure(Ejb3Configuration.java:597)
                at org.hibernate.ejb.HibernatePersistence.createContainerEntityManagerFactory(HibernatePersistence.java:73)
                at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:287)
                at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:310)
                at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1514)
                at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1452)
                at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519)
                at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456)
                at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:294)
                at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:225)
                at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:291)
                at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193)
                at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1105)
                at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:915)
                at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:472)
                at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:383)
                at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:283)
                at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:111)
                at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4992)
                at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5490)
                at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)
                at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:901)
                at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:877)
                at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:649)
                at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:1083)
                at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:553)
                at org.apache.catalina.startup.HostConfig.check(HostConfig.java:1671)
                at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
                at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
                at java.lang.reflect.Method.invoke(Method.java:483)
                at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:301)
                at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819)
                at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801)
                at org.apache.catalina.manager.ManagerServlet.check(ManagerServlet.java:1485)
                at org.apache.catalina.manager.HTMLManagerServlet.upload(HTMLManagerServlet.java:286)
                at org.apache.catalina.manager.HTMLManagerServlet.doPost(HTMLManagerServlet.java:206)
                at javax.servlet.http.HttpServlet.service(HttpServlet.java:646)
                at javax.servlet.http.HttpServlet.service(HttpServlet.java:727)
                at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)
                at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)
                at org.apache.catalina.filters.CsrfPreventionFilter.doFilter(CsrfPreventionFilter.java:213)
                at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)
                at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)
                at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
                at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)
                at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)
                at org.apache.catalina.filters.SetCharacterEncodingFilter.doFilter(SetCharacterEncodingFilter.java:108)
                at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)
                at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)
                at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:220)
                at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)
                at org.apache.tomee.catalina.OpenEJBValve.invoke(OpenEJBValve.java:44)
                at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:610)
                at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171)
                at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)
                at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:950)
                at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)
                at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408)
                at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1070)
                at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:611)
                at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:314)
                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
                at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
                at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NullPointerException
                at org.apache.openjpa.enhance.PCEnhancer.getfield(PCEnhancer.java:4052)
                at org.apache.openjpa.enhance.PCEnhancer.addGetManagedValueCode(PCEnhancer.java:4543)
                at org.apache.openjpa.enhance.PCEnhancer.addGetManagedValueCode(PCEnhancer.java:4519)
                at org.apache.openjpa.enhance.PCEnhancer.addProvideFieldsMethods(PCEnhancer.java:1379)
                at org.apache.openjpa.enhance.PCEnhancer.addPCMethods(PCEnhancer.java:1155)
                at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:566)
                ... 84 more
```",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Metamodel instantiation fails on InputStream properties,OPENJPA-1439,12443865,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,mikhail.vorozhtsov,mikhail.vorozhtsov,20/Dec/09 17:10,09/Mar/10 18:29,14/Mar/19 03:02,23/Dec/09 15:40,2.0.0,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,"EntityManagerFactory.getMetamodel() fails if entity class has a property of type InputStream:
Caused by: java.lang.IllegalStateException: Field ""my.Entity.fullText"" is not recognized by its type code ""30"" to be included in the meta model.
        at org.apache.openjpa.persistence.meta.AbstractManagedType.<init>(AbstractManagedType.java:176)
        at org.apache.openjpa.persistence.meta.Types$Identifiable.<init>(Types.java:119)
        at org.apache.openjpa.persistence.meta.Types$Entity.<init>(Types.java:199)
        at org.apache.openjpa.persistence.meta.MetamodelImpl.instantiate(MetamodelImpl.java:253)
        at org.apache.openjpa.persistence.meta.MetamodelImpl.find(MetamodelImpl.java:224)
        at org.apache.openjpa.persistence.meta.MetamodelImpl.<init>(MetamodelImpl.java:89)
        at org.apache.openjpa.persistence.EntityManagerFactoryImpl.getMetamodel(EntityManagerFactoryImpl.java:310)
        at org.apache.openjpa.persistence.EntityManagerFactoryImpl.getMetamodel(EntityManagerFactoryImpl.java:57)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-12-23 15:40:29.476,,,no_permission,,,,,,,,,,,161704,,,Mon Dec 28 18:52:31 UTC 2009,,,,,,,0|i0yzjz:,202230,,,,,,,,23/Dec/09 15:40;ppoddar@apache.org;As per the original reporter the problem has been is fixed.,"28/Dec/09 18:36;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
","28/Dec/09 18:36;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
","28/Dec/09 18:52;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Fail to remove an entity which has derived identity,OPENJPA-1438,12443825,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,19/Dec/09 00:28,23/Mar/10 18:34,14/Mar/19 03:02,09/Mar/10 18:08,2.0.0,,,,,,,,,2.0.0-beta3,,,,,jdbc,,,,,,0,,"Given the following entity definitions:

@Entity
@IdClass(PersonId.class)
public class MedicalHistory implements Serializable {

    private static final long serialVersionUID = 1L;
    @Id
    @OneToOne
    private Person patient;
    private String doctorName;
          .....

-------------------------------
@Entity
@IdClass(PersonId.class)
public class Person implements Serializable {

    @Id
    String firstName;
    @Id
    String lastName;
    String ssn;
          ...
-------------------------------
public class PersonId implements java.io.Serializable {

    String firstName;
    String lastName;

-------------------------------
Removing MedicalHistory as shown below throws ClassCastException:

MedicalHistory newMHistory = em.find(MedicalHistory.class, personId);
em.remove(newMHistory);
et.commit();


Caused by: <openjpa-0.0.0-rnull nonfatal general error> org.apache.openjpa.persistence.PersistenceException: test.Person cannot be cast to java.lang.String
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1939)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1455)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:903)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:551)
	... 20 more
Caused by: java.lang.ClassCastException: test.Person cannot be cast to java.lang.String
	at org.apache.openjpa.jdbc.sql.DBDictionary.setTyped(DBDictionary.java:1284)
	at org.apache.openjpa.jdbc.sql.RowImpl.flush(RowImpl.java:892)
	at org.apache.openjpa.jdbc.sql.RowImpl.flush(RowImpl.java:852)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:114)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushAndUpdate(BatchingPreparedStatementManagerImpl.java:80)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:97)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:85)
	at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:550)
	at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:120)
	at org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager.flush(BatchingConstraintUpdateManager.java:59)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:103)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:76)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:676)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	at org.apache.openjpa.datacache.DataCacheStoreManager.flush(DataCacheStoreManager.java:540)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2116)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2013)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1931)
	... 24 more

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161703,,,2009-12-19 00:28:23.0,,,,,,,0|i0z2xr:,202778,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Multi-1xm relation of same type in entity yields extra null in result collection,OPENJPA-1435,12443551,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,allee8285,allee8285,16/Dec/09 16:55,24/Feb/10 14:34,14/Mar/19 03:02,16/Dec/09 20:36,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jdbc,,,,,,0,,"When multiple same 1xm relationship is defined in an entity, fetching the entity yields one extra null element in the collection.

@Entity
public class Util1xmLf {
    private int id;
    private int version;
    public Collection<Util1xmRt> uniRightLzy = new HashSet<Util1xmRt>();
    public Collection<Util1xmRt> uniRightEgr = new HashSet<Util1xmRt>();

    @Id public int getId() {        return id;    }
    @Version public int getVersion() {        return version;    }
    @OneToMany// (fetch = FetchType.LAZY)
    public Collection<Util1xmRt> getUniRightLzy() {        return uniRightLzy;    }
    public void setUniRightLzy(Collection<Util1xmRt> uniRightLzy) {        this.uniRightLzy = uniRightLzy;    }
    public void addUniRightLzy(Util1xmRt uniRightLzy) {        getUniRightLzy().add(uniRightLzy);    }
    @OneToMany(fetch = FetchType.EAGER)
    public Collection<Util1xmRt> getUniRightEgr() {        return uniRightEgr;    }
    public void setUniRightEgr(Collection<Util1xmRt> uniRightEgr) {        this.uniRightEgr = uniRightEgr;    }
    public void addUniRightEgr(Util1xmRt uniRightEgr) {        getUniRightEgr().add(uniRightEgr);    }
}

@Entity
public class Util1xmRt {
    private int id;
    private int version;

    @Id public int getId() {        return id;    }
    @Version public int getVersion() {        return version;    }
    public String getLastName() {        return lastName;    }
    public void setLastName(String lastName) {        this.lastName = lastName;    }
}

    public void testLoadedOneToManyCount() {
        EntityManager em = emf.createEntityManager();
        Util1xmLf e1 = em.find(Util1xmLf.class, TestUtil1xm_TestRow_Id);
        // SELECT t0.firstName, t1.UTIL1XMLF_ID, t2.id, t2.lastName FROM Util1xmLf t0 
        //      LEFT OUTER JOIN Util1xmLf_Util1xmRt t1 ON t0.id = t1.UTIL1XMLF_ID 
        //      LEFT OUTER JOIN Util1xmRt t2 ON t1.UNIRIGHTEGR_ID = t2.id WHERE t0.id = ? 
        //      [params=(int) 100]

        assertNotNull(""Found Util1xmLf(id="" + TestUtil1xm_TestRow_Id + "")"", e1);
        
        Collection<Util1xmRt> eRs = e1.getUniRightLzy();
        // SELECT t1.id, t1.lastName FROM Util1xmLf_Util1xmRt t0 
        //      INNER JOIN Util1xmRt t1 ON t0.UNIRIGHTLZY_ID = t1.id WHERE t0.UTIL1XMLF_ID = ? 
        //      [params=(int) 100]
        assertNotNull(""Util1xmRt uniRightLzy != null"", eRs);
        assertEquals(""Util1xmRt uniRightLzy.size == 2"", eRs.size(), 2);
        
        Collection<Util1xmRt> eEs = e1.getUniRightEgr();
        assertNotNull(""Util1xmRt uniRightEgr != null"", eEs);
        // Failing test: Getting 3 in eager collection, one null entry
        assertEquals(""Util1xmRt uniRightEgr.size == 2"", eEs.size(), 2); <<<< Failure returning 3 entries

        em.close();
    }

Here are the SQLs issued
batching prepstmnt 800337844 INSERT INTO Util1xmRt (id, lastName) VALUES (?, ?) [params=(int) 411, (String) loaded lastName1]
batching prepstmnt 800337844 INSERT INTO Util1xmRt (id, lastName) VALUES (?, ?) [params=(int) 412, (String) loaded lastName2]
batching prepstmnt 800337844 INSERT INTO Util1xmRt (id, lastName) VALUES (?, ?) [params=(int) 421, (String) loaded eager lastName3]
batching prepstmnt 800337844 INSERT INTO Util1xmRt (id, lastName) VALUES (?, ?) [params=(int) 422, (String) loaded eager lastName4]
executing prepstmnt 1258900233 INSERT INTO Util1xmLf (id, firstName) VALUES (?, ?) [params=(int) 400, (String) loaded firstName]
batching prepstmnt 1396069174 INSERT INTO Util1xmLf_Util1xmRt (UTIL1XMLF_ID, UNIRIGHT_ID) VALUES (?, ?) [params=(int) 400, (int) 412]
batching prepstmnt 1396069174 INSERT INTO Util1xmLf_Util1xmRt (UTIL1XMLF_ID, UNIRIGHT_ID) VALUES (?, ?) [params=(int) 400, (int) 411]
batching prepstmnt 1771465110 INSERT INTO Util1xmLf_Util1xmRt (UTIL1XMLF_ID, UNIRIGHTEGR_ID) VALUES (?, ?) [params=(int) 400, (int) 422]
batching prepstmnt 1771465110 INSERT INTO Util1xmLf_Util1xmRt (UTIL1XMLF_ID, UNIRIGHTEGR_ID) VALUES (?, ?) [params=(int) 400, (int) 421]
executing prepstmnt 1429165359 SELECT t0.firstName, t1.UTIL1XMLF_ID, t2.id, t2.lastName FROM Util1xmLf t0 LEFT OUTER JOIN Util1xmLf_Util1xmRt t1 ON t0.id = t1.UTIL1XMLF_ID LEFT OUTER JOIN Util1xmRt t2 ON t1.UNIRIGHTEGR_ID = t2.id WHERE t0.id = ?  [params=(int) 400]

In DB2 CLI,

db2 => SELECT t0.firstName, t1.UTIL1XMLF_ID, t2.id, t2.lastName FROM Util1xmLf t0 LEFT OUTER JOIN Util1xmLf_Util1xmRt t1 ON t0.id = t1.UTIL1XMLF_ID LEFT OUTER JOIN Util1xmRt t2 ON t1.UNIRIGHTEGR_ID = t2.id WHERE t0.id = 400

FIRSTNAME                 UTIL1XMLF_ID ID          LASTNAME
------------------------- ------------ ----------- -------------------------
loaded firstName                   400           - -
loaded firstName                   400           - -
loaded firstName                   400         422 loaded eager lastName4
loaded firstName                   400         421 loaded eager lastName3

  4 record(s) selected.

Change the 2nd Left Outer Join to Right Outer Join yields

db2 => SELECT t0.firstName, t1.UTIL1XMLF_ID, t2.id, t2.lastName FROM Util1xmLf t0 LEFT OUTER JOIN Util1xmLf_Util1xmRt t1 ON t0.id = t1.UTIL1XMLF_ID RIGHT OUTER JOIN Util1xmRt t2 ON t1.UNIRIGHTEGR_ID = t2.id WHERE t0.id = 400

FIRSTNAME                 UTIL1XMLF_ID ID          LASTNAME
------------------------- ------------ ----------- -------------------------
loaded firstName                   400         422 loaded eager lastName4
loaded firstName                   400         421 loaded eager lastName3

  2 record(s) selected.

db2 =>

Noticed the force uniRightLzy fetch used the following SQL, which yielded the correct result:

SELECT t1.id, t1.lastName FROM Util1xmLf_Util1xmRt t0 INNER JOIN Util1xmRt t1 ON t0.UNIRIGHT_ID = t1.id WHERE t0.UTIL1XMLF_ID = ?  [params=(int) 400]",,,,,,,,,,,,,,,,,,,,,,16/Dec/09 17:04;allee8285;OPENJPA-1435.test.patch;https://issues.apache.org/jira/secure/attachment/12428190/OPENJPA-1435.test.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161700,,,2009-12-16 16:55:31.0,,,,,,,0|i0z4vz:,203094,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
openjpa.Compatibility property for JPA 2.0 behavior may be overwritten if this property is an argument to createEntityManagerFactory,OPENJPA-1432,12443492,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,16/Dec/09 04:26,09/Mar/10 18:29,14/Mar/19 03:02,09/Mar/10 14:47,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,kernel,,,,,,0,,"The JPA 2.0 version is detected from persistence.xml and then set to the Compatibility object in ConfigurationImpl. However, this Compatibility object will be nullified if the following property is passed as an argument to createEntityManagerFactory:   

Map<Object,Object> map = new HashMap<Object,Object>();
map.put(""openjpa.Compatibility"", ""StrictIdentityValues=true"");
EntityManagerFactory emf = Persistence.createEntityManagerFactory(""test"", map);
",,,,,,,,,,,,,,,,,,,,,,18/Dec/09 19:24;faywang;OPENJPA-1432-1.patch;https://issues.apache.org/jira/secure/attachment/12428463/OPENJPA-1432-1.patch,16/Dec/09 06:53;faywang;OPENJPA-1432.patch;https://issues.apache.org/jira/secure/attachment/12428134/OPENJPA-1432.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-12-18 21:44:23.809,,,no_permission,,,,,,,,,,,161698,,,Tue Mar 09 14:47:53 UTC 2010,,,Patch Available,,,,0|i0z8m7:,203698,,,,,,,,18/Dec/09 19:24;faywang;This patch is another solution to this problem. ,"18/Dec/09 21:44;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
",09/Mar/10 14:47;drwoods;open another JIRA if more work is required,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Temporal annotation overrides the @Column annotation when using in conjunction with @ElementCollection,OPENJPA-1431,12443432,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,faywang,faywang,faywang,15/Dec/09 18:44,24/Feb/10 14:34,14/Mar/19 03:02,15/Dec/09 23:50,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,"1) With these annotations:
    @CollectionTable(name = ""collectionTemporalOrderColumnTable"", joinColumns = @JoinColumn(name = ""parent_id""))
    @ElementCollection(fetch = FetchType.EAGER)
    @Temporal(TemporalType.DATE)
    @Column(name = ""value"")
    @OrderColumn(name = ""valueOrderColumn"")
    //@Temporal(TemporalType.DATE)
    private Collection<Date> collectionDate;

The collectionTemporalOrderColumnTable is created with the following columns: PARENT_ID, VALUE, VALUEORDERCOLUMN

(2) With these annotations:
    @CollectionTable(name = ""collectionTemporalOrderColumnTable"", joinColumns = @JoinColumn(name = ""parent_id""))
    @ElementCollection(fetch = FetchType.EAGER)
    //@Temporal(TemporalType.DATE)
    @Column(name = ""value"")
    @OrderColumn(name = ""valueOrderColumn"")
    @Temporal(TemporalType.DATE)
    private Collection<Date> collectionDate;

The collectionTemporalOrderColumnTable is created with the following columns: PARENT_ID, ELEMENT, VALUEORDERCOLUMN


",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-01-04 17:30:17.304,,,no_permission,,,,,,,,,,,161697,,,Mon Jan 04 17:30:17 UTC 2010,,,,,,,0|i1dszr:,288794,,,,,,,,"04/Jan/10 17:30;to_rowe;Fix verified on Linux AMD64 w/ Sun SE6 for JSE, web, and EJB scenarios.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Literal value in projection can not be parameterized for all databases,OPENJPA-1425,12443051,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,11/Dec/09 00:36,09/Mar/10 18:29,14/Mar/19 03:02,18/Jan/10 19:50,,,,,,,,,,2.0.0-beta,,,,,,,,,,,0,,"Derby does not support parameters in projection terms.

JPQL: select 'xyz' from Person p 
OpenJPA will generate a parametrized SQL wih parameter 'xyz' that Derby does not like. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161692,,,2009-12-11 00:36:47.0,,,,,,,0|i0yzn3:,202244,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Out of bounds exception using fetch plan,OPENJPA-1424,12443011,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,dastultz,dastultz,10/Dec/09 18:33,20/Sep/10 15:39,14/Mar/19 03:02,03/May/10 19:27,1.2.1,,,,,,,,,1.2.3,1.3.0,2.0.1,2.1.0,,kernel,,,,,,0,,"Hello, I'm getting the following:

java.lang.ArrayIndexOutOfBoundsException: 2
at org.apache.openjpa.meta.ClassMetaData.getExtraFieldDataIndex(ClassMetaData.java:859)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:358)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:278)
at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:894)
at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:852)
at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:774)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:982)
at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:278)
at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2400)
at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.loadEagerJoin(RelationFieldStrategy.java:541)
at org.apache.openjpa.jdbc.meta.FieldMapping.loadEagerJoin(FieldMapping.java:807)-- 

I've attached a unit test that exposes it. I've done my best to pare things down but it seems anything else I remove makes it go away (there are several things that could be removed to make it go away). The unit test passes when the exception is thrown. 

In short, this works:

Query query = em.createQuery(""select o from Case as o"" +
    "" left join fetch o.scheduledAssignments"" +
    "" where o.scheduleDay = :sd"");
query.setParameter(""sd"", sd);
List<Case> allCases = query.getResultList();

But this doesn't:

Query query = em.createQuery(""select o from Case as o"" +
    "" where o.scheduleDay = :sd"");
query.setParameter(""sd"", sd);
FetchPlan fetchPlan = ((QueryImpl) query).getFetchPlan();
fetchPlan.addField(Case.class, ""scheduledAssignments"");
List<Case> allCases = query.getResultList();

The test case runs against PostgreSQL. I would really appreciate it if someone could verify the test passes under some other database or if it fails, under PostgreSQL. Of course it would be even better if an OpenJPA expert could find the problem.

I will also accept suggestions for building a better unit test package.

Thanks for your help.","Mac OSX, Java 1.5, Tomcat 5, PostgreSQL 8.4",,,,,,,,,,,,,,,,,,,,,12/Aug/10 04:08;jpaheath;OPENJPA-1424-1.2.x.patch.txt;https://issues.apache.org/jira/secure/attachment/12451859/OPENJPA-1424-1.2.x.patch.txt,10/Dec/09 18:39;dastultz;test.zip;https://issues.apache.org/jira/secure/attachment/12427620/test.zip,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-01-14 15:42:07.15,,,no_permission,,,,,,,,,,,161691,,,Mon Sep 20 15:39:50 UTC 2010,,,,,,,0|i0zbrj:,204208,,,,,,,,"10/Dec/09 18:39;dastultz;Unit test. Probably not a well-written one. I'm open to suggestions to improve it.

I run against PostgreSQL. The file database/create_jpa.sql can be used to build the database (called from the file database/build.sh).",14/Jan/10 15:42;mikedd;Tentatively targeting for 1.3.0 and 1.2.3. ,"12/Aug/10 04:08;jpaheath;I'm attaching a patch (OPENJPA-1424-1.2.x.patch.txt) for 1.2.x.  This patch contains:
  
1) A back port of ClassMedaData from the trunk version of the fix.  This is the only change from trunk which I back ported.....the other change doesn't easily port and the initial test case passes with the ClassMetaData changes.
2) A stripped down version of the initial test case provided by Daryl.  I think I've stripped down the test as far as I can (any further and I couldn't reproduce the issue).  

Thanks,

Heath","16/Aug/10 14:15;mikedd;Technically this was fixed in 2.0.0 - but it missed the release notes. I've targeted for 2.0.1, and 2.1.0 - so it'll be picked up in their release notes and changes.txt. ","20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Reduce lock contention in JDBCStoreManager,OPENJPA-1421,12442758,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,08/Dec/09 18:45,10/Dec/09 14:47,14/Mar/19 03:02,08/Dec/09 18:59,1.2.2,1.3.0,,,,,,,,1.2.2,1.3.0,,,,kernel,,,,,,0,,"When testing on a high end machine, we found a bottleneck in calling JDBCStoreManager.getCacheMapFromQuerySQLCache(...). To fix the problem, had each caller will hold onto the cacheMap that is returned from getCacheMapFromQuerySQLCache(...) rather than call it multiple times.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-12-09 17:46:19.298,,,no_permission,,,,,,,,,,,161688,,,Thu Dec 10 14:47:47 UTC 2009,,,,,,,0|i0z607:,203275,,,,,,,,08/Dec/09 18:59;curtisr7;Committed changes to 1.2.x and 1.3.x. This problem does not exist on trunk.,"09/Dec/09 17:46;ppoddar@apache.org;> This problem does not exist on trunk. 
trunk should not have this method at all. ","10/Dec/09 14:47;curtisr7;>trunk should not have this method at all. 

Correct.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Access path metadata set incorrectly for fetch joins in Criteria Query,OPENJPA-1419,12442739,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,08/Dec/09 15:35,09/Mar/10 18:29,14/Mar/19 03:02,18/Jan/10 19:50,2.0.0-beta,,,,,,,,,2.0.0-beta,,,,,query,,,,,,0,,Access path metadata not set correctly in Criteria Query. Results in NPE during computation of dirty access paths.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161686,,,2009-12-08 15:35:41.0,,,,,,,0|i0yzrb:,202263,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE when update using CASE statement on Derby,OPENJPA-1413,12442403,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,03/Dec/09 23:14,24/Feb/10 14:35,14/Mar/19 03:02,03/Dec/09 23:47,2.0.0-M3,,,,,,,,,1.3.0,2.0.0-beta,,,,jdbc,,,,,,0,,"Derby Error:
<openjpa-2.0.0-SNAPSHOT-r422266:883808 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: null
<openjpa-2.0.0-SNAPSHOT-r422266:883808 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: null
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:822)
        at org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:893)
        at org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:889)
        at org.apache.openjpa.kernel.DelegatingQuery.updateAll(DelegatingQuery.java:565)
        at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:341)
        at apitests.Client.queryAPITest22(Client.java:133)
        at apitests.Client.main(Client.java:77)
Caused by: java.lang.NullPointerException
        at org.apache.openjpa.jdbc.kernel.exps.CompareEqualExpression.appendTo(CompareEqualExpression.java:109)
        at org.apache.openjpa.jdbc.kernel.exps.WhenCondition.appendTo(WhenCondition.java:70)
        at org.apache.openjpa.jdbc.kernel.exps.GeneralCaseExpression.appendTo(GeneralCaseExpression.java:114)
        at org.apache.openjpa.jdbc.sql.DBDictionary.appendUpdates(DBDictionary.java:2149)
        at org.apache.openjpa.jdbc.sql.DBDictionary.toBulkOperation(DBDictionary.java:2017)
        at org.apache.openjpa.jdbc.sql.DBDictionary.toUpdate(DBDictionary.java:1950)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeBulkOperation(JDBCStoreQuery.java:511)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeUpdate(JDBCStoreQuery.java:451)
        at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeUpdate(ExpressionStoreQuery.java:761)
        at org.apache.openjpa.kernel.QueryImpl.update(QueryImpl.java:1049)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:817)
        ... 6 more

The following fails agsint Derby:
Query q = em.createQuery(
                    ""update Department d  set d.name= "" +
                    "" CASE   WHEN d.id = 1 THEN 'SoilEngineering'"" +
                    ""        WHEN d.id = 2 THEN 'Mettalurgy'"" +
                    ""        ELSE 'Aero'"" +
                    "" END"");

result_size = q.executeUpdate();  // <--- Error here",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161680,,,2009-12-03 23:14:33.0,,,,,,,0|i0z9q7:,203878,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Class linkage exception when creating an EMF with OpenJPA M3,OPENJPA-1410,12442243,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,techhusky,techhusky,techhusky,02/Dec/09 18:13,12/Apr/11 07:40,14/Mar/19 03:02,22/Mar/10 12:41,2.0.0-beta,2.0.0-beta2,2.0.0-M3,,,,,,,2.0.0-beta3,,,,,validation,,,,,,2,,"Posted by Seth Jackson on the user forum[1].

It appears something was modified in OpenJPA 2.0 M3 from M2 that causes a
LinkageError.

In my current environment, I've tested both Glassfish and Tomcat using M2
and M3. M2 runs without problems, but M3 throws a linkage error as follows:

Caused by: java.lang.LinkageError: loader constraint violation: loader
(instance of sun/misc/Launcher$AppClassLoader) previously initiated loading
for a different type with name
""org/apache/openjpa/conf/OpenJPAConfiguration""
       at java.lang.ClassLoader.defineClass1(Native Method)
       at java.lang.ClassLoader.defineClass(ClassLoader.java:621)
       at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
       at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
       at java.net.URLClassLoader.access$000(URLClassLoader.java:56)
       at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
       at java.security.AccessController.doPrivileged(Native Method)
       at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
       at java.lang.ClassLoader.loadClass(ClassLoader.java:307)
       at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
       at java.lang.ClassLoader.loadClass(ClassLoader.java:252)
       at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:320)
       at
org.apache.openjpa.persistence.validation.ValidationUtils.setupValidation(ValidationUtils.java:53)
       at
org.apache.openjpa.persistence.PersistenceProviderImpl.loadValidator(PersistenceProviderImpl.java:290)
       at
org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:97)
       at
org.apache.openjpa.persistence.OpenJPAPersistence.createEntityManagerFactory(OpenJPAPersistence.java:128)
       at
org.apache.openjpa.persistence.OpenJPAPersistence.createEntityManagerFactory(OpenJPAPersistence.java:111)
       at test_test.user.UserAction.execute(UserAction.java:39)


I've already confirmed that the OpenJPA classes in question do NOT exist in
any other JARs in the path.

ValidationUtils.setupValidation(ValidationUtils.java:53) calls the
OpenJPAConfiguration.getConfigurationLog(). The object being referenced is
JDBCConfigurationImpl, which in other classes retrieves the log reference
perfectly fine, before it gets to the offending line.

Seth's follow up[2]:

After further review, using Glassfish 2.1.1 I received this error message in
the server log:

Caused by: java.lang.LinkageError: loader constraint violation: when
resolving method
""org.apache.openjpa.persistence.validation.ValidationUtils.setupValidation(Lorg/apache/openjpa/conf/OpenJPAConfiguration;)Z""
the class loader (instance of org/apache/catalina/loader/WebappClassLoader)
of the current class,
org/apache/openjpa/persistence/PersistenceProviderImpl, and the class loader
(instance of sun/misc/Launcher$AppClassLoader) for resolved class,
org/apache/openjpa/persistence/validation/ValidationUtils, have different
Class objects for the type org/apache/openjpa/conf/OpenJPAConfiguration used
in the signature

So it appears to be the WebappClassLoader and the AppClassLoader are both
loading the OpenJPAConfiguration from the same JAR file, causing the error
when the class is trying to be resolved in this particular method.

[1] http://n2.nabble.com/Struts-2x-OpenJPA-2-0-M3-Tomcat-or-Glassfish-tp4087312p4087312.html
[2] http://n2.nabble.com/Struts-2x-OpenJPA-2-0-M3-Tomcat-or-Glassfish-tp4087312p4093228.html","Tomcat and Glassfish, OpenJPA M3",,,,,,,,,,,,,,,OPENJPA-640,OPENJPA-1590,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-12-03 18:45:44.962,,,no_permission,,,,,,,,,,,161677,,,Tue Mar 23 19:48:54 UTC 2010,,,,,,,0|i0ywlr:,201752,,,,,,,,"03/Dec/09 18:45;ppoddar@apache.org;Hi Jeremy,
  You write in Nabble post
  ""The code in PersistenceProviderImpl that sets up validation looks like it might be suspect to classloading issues. ""

  Here is the code in PersistenceProviderImpl.createEntityManagerFactory()  
             // TODO - Can this be moved back to BrokerImpl.initialize()?
            // Create appropriate LifecycleEventManager
            loadValidator(_log, conf);

Can you please describe why at the first place, we went to this unusual path for initializing/loading Validation-aware lifecycle manager plugin? This may help understanding possible resolution as per initialization of any other plugins.","16/Dec/09 14:19;hellonico;As a note I can only reproduce this on Windows, OSX and Linux are working fine. ",16/Dec/09 14:24;seth.jackson;I will confirm that I was encountering this on Windows XP and was not running on any other platform. Thanks.,"04/Jan/10 15:45;struberg;this also happens to me on Linux (Fedora 11 x86_64) if running on tomcat-6 (tried 6.0.18 and 6.0.20) but _not_ on jetty-6!

I'm using the openjpa-all-2.0.0-M3 package dependency.

Caused by: java.lang.LinkageError: loader constraint violation: loader (instance of sun/misc/Launcher$AppClassLoader) previously initiated loading for a different type with name ""org/apache/openjpa/conf/OpenJPAConfiguration""
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:616)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
	at java.net.URLClassLoader.access$000(URLClassLoader.java:56)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:303)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:316)
	at org.apache.openjpa.persistence.validation.ValidationUtils.setupValidation(ValidationUtils.java:53)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.loadValidator(PersistenceProviderImpl.java:290)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:97)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:151)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:59)
	at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:159)
	at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:71)
	at org.apache.webbeans.resource.spi.se.ResourceServiceImpl.getPersistenceUnit(ResourceServiceImpl.java:111)
	at org.apache.webbeans.resource.spi.se.ResourceServiceImpl.getPersistenceContext(ResourceServiceImpl.java:125)
	at org.apache.webbeans.resource.spi.se.ResourceServiceImpl.getResource(ResourceServiceImpl.java:59)
	at org.apache.webbeans.resource.OpenWebBeansResourcePlugin.injectResources(OpenWebBeansResourcePlugin.java:61)
","17/Feb/10 01:23;hellonico;So I removed validation since it is optional, and tried to move on.
But stumbled against a very similar Linkage error.

Caused by: java.lang.LinkageError: loader constraint violation: loader (instance of sun/misc/Launcher$AppClassLoader) 
previously initiated loading for a different type with name ""org/apache/openjpa/kernel/BrokerFactory""
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
        at java.net.URLClassLoader.access$000(URLClassLoader.java:56)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:276)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
        at org.apache.openjpa.persistence.JPAFacadeHelper.toEntityManagerFactory(JPAFacadeHelper.java:70)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:111)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:153)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:64)
        at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:150)","17/Feb/10 07:28;hellonico;For those of use that do not need an agent and a validator, commenting out those two lines in PersistenceProviderImpl:
            //loadAgent(factory);
            //loadValidator(factory);

fixes the bad behavior. 
It looks like the factory is loaded in some different classloader and then clashes only when calling a method on it. 

Making a working jar file available using only the svn rev and the fix above, to people who needs it:
http://www.intalio.org/public/maven2/org/apache/openjpa/openjpa-all/2.0.0-svn-910423/openjpa-all-2.0.0-svn-910423.jar


","20/Feb/10 10:25;crispyoz;I tried this new Jar by Nicolas but I get the same issue, I have no other JPA API in my path and I went so far as to reboot my machine. I was using OpenJPA 1.2.1  and now trying to switch to 2.0.0Beta.

Using Win7. Here is my stack trace.

20/02/2010 9:19:26 PM org.apache.catalina.core.StandardContext listenerStart
SEVERE: Exception sending context initialized event to listener instance of class com.trm.app.listeners.StartupServletListener
java.lang.LinkageError: loader constraint violation: loader (instance of sun/misc/Launcher$AppClassLoader) previously initiated loading for a different type with name ""org/apache/openjpa/conf/OpenJPAConfiguration""
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:621)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
	at java.net.URLClassLoader.access$000(URLClassLoader.java:56)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:307)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:252)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:320)
	at org.apache.openjpa.persistence.validation.ValidationUtils.setupValidation(ValidationUtils.java:53)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.loadValidator(PersistenceProviderImpl.java:316)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:100)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:151)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:62)
	at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:150)
	at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:70)
	","09/Mar/10 18:18;josetex@gmail.com;Hi. I also tried the jar getting the same problem. Christophe, eventually,
did you make it work?
","09/Mar/10 21:27;techhusky;I was able to reproduce this problem on Tomcat 6.0.20, but not Glassfish 3.    I don't know if OpenJPA 2.0 can be made to work with Glassfish 2.x since that level of server is Java EE 5 and OpenJPA 2.0 is uses the JPA 2.0 API, which is Java EE 6 technology.  Glassfish provides its own JPA 1.0 persistence library and it may collide with the JPA 2.0 persistence library required for OpenJPA 2.0.  The exception doesn't point to that type of issue though.  And the app looks to be application managed so the 2.0 library may be overriding the 1.0 library without ill effects to the container.

Tomcat 6 also includes JPA 1.0 persistence API classes, but only a small subset.  That could causing the same type of API collision issue on that platform.  But, again, the failure doesn't indicate this to be the problem.  I'll continue to debug the issue further and provide a fix, if possible.","09/Mar/10 22:17;drwoods;In Catalina -
src/main/java/org/apache/catalina/core/DefaultInstanceManager.processAnnotations()
...
                } else if (field.isAnnotationPresent(PersistenceContext.class)) {
                    PersistenceContext annotation =
                        field.getAnnotation(PersistenceContext.class);
                    lookupFieldResource(context, instance, field, annotation.name());
                } else if (field.isAnnotationPresent(PersistenceUnit.class)) {
                    PersistenceUnit annotation =
                        field.getAnnotation(PersistenceUnit.class);
                    lookupFieldResource(context, instance, field, annotation.name());
                }
...
","10/Mar/10 15:19;techhusky;Thanks, Donald.  ..nothing there that should cause breakage.  Another concern is that Catalina includes lib/annotations-api.jar.  That jar contains a few javax.persistence classes:

javax/persistence/PersistenceContext.class
javax/persistence/PersistenceContextType.class
javax/persistence/PersistenceContexts.class
javax/persistence/PersistenceProperty.class
javax/persistence/PersistenceUnit.class
javax/persistence/PersistenceUnits.class

Depending on the classloader configuration, adding the JPA 2.0 spec API to the application may foul up the environment.  I'm guessing not though, since the server should break even when a complete JPA 1.0 API is added to the classpath.  TBD...","10/Mar/10 16:13;jbb;I can still reproduce it using 2.0.0 beta 2 on Linux. On MacOSX it is OK.
Using Tomcat 6.0.24 under Linux Ubuntu, JDK 1.6.0_18

If I remove annotations-api.jar from tomcat/lib, nothing works, it explode before the servlet init().","12/Mar/10 10:53;jbb;Found a workaround :

0. rename  tomcat/lib/annotations-api.jar to  tomcat/lib/annotations-api.jar.original
1. repackage the tomcat/lib/annotations-api.jar file by removing javax/persistence folder
    (use to rebuild jar file : jar cvfm annotations-api.jar META-INF/MANIFEST.MF -C annotation-api .)
2. Add the following files to the tomcat/lib :
    geronimo-jpa_2.0_spec-1.0.jar
    geronimo-jta_1.1_spec-1.1.1.jar

This will force JVM classloader to use JPA 2.0 files","12/Mar/10 13:50;jbb;I'm sorry, this was not a workaround : the error is still there ... ","12/Mar/10 14:46;jbb;I tested with Tomcat via our IDE but also directly with Tomcat, deloying by hand to ensure the IDE classpath will not interfere.
It is confirmed : it doesn't work.","12/Mar/10 21:21;techhusky;I found that this problem is not related to loading bean validation.  Instead, it is a problem with the OpenJPA enhancer.  When running with Sun JDK, OpenJPA's dynamic enhancer kicks in by default.  This is flubbing up the classloader.  A simple workaround is to do the enhancement at build time and add this property to your persistence.xml to shut off the dynamic enhancer:

      <property name=""openjpa.DynamicEnhancementAgent"" value=""false""/>

I also tried OpenJPA's runtime enhancer (now turned off by default in OpenJPA 2.0) and hit the same problem. So it looks to be a general classloader-related problem when using OpenJPA's runtime enhancer running under Catalina (Tomcat & Glassfish).  I have dug into the problem yet, though.

FYI - To simplify usage of OpenJPA 2.0 you can simply include openjpa-all-2.0.0-beta2.jar in the WEB-APP/lib directory of your application.  That jar contains all the dependencies necessary to use OpenJPA 2.0.

I have not tried to configure Tomcat to use the agent-based enhancer.  I'll give that a try and post the result.  I suspect that I'll see the same problem though.  Please let me know if the workaround above gets you around the exception.
","12/Mar/10 22:00;techhusky;Oddly, I'm also seeing the ""fallback"" runtime enhancer start up.  That is causing the same types of classloading type exceptions as the dynamic enhancer.  I could swear that it was disabled in 2.0.    You may also need to add this property as well to disable that enhancer:

<property name=""openjpa.RuntimeUnenhancedClasses"" value=""unsupported""/>

With both of these enhancers disabled, you'll get a reasonable exception/error message if your classes were not build time enhanced.  Something to the tune of...  

org.apache.openjpa.persistence.ArgumentException: This configuration disallows runtime optimization, but the following listed types were not enhanced at build time or at class load time with a javaagent: ""[class my.Class]"". ","16/Mar/10 19:34;techhusky;This can of worms is still open...  getting closer though.  I do not see the same classloading failures when running Tomcat with the agent-based enhancer.  However, the entity classes in my web app are not being enhanced by the enhancer.  If I flip on the runtime enhancer with this configuration via:

<property name=""openjpa.RuntimeUnenhancedClasses"" value=""supported""/>

the subclassing runtime enhancer now works.  (go figure)

Similar to the agent-based enhancer, the dynamic enhancer gets loaded by the system classloader.  This is problematic under a normal Tomcat config since the OpenJPA library has already been loaded by the web app classloader or the common classloader (if OpenJPA is provided as a common/shared lib).  After the dynamic agent loads OpenJPA into the system classloader, class redefinition/linkage exceptions arise.","17/Mar/10 20:16;techhusky;I committed a change under rev 924395 that disables the dynamic enhancer if the OpenJPA instrumentation factory is not loaded by the system classloader.  In a multi-tier classloader environment (Tomcat, JEE app server, etc.)  the OpenJPA jar was being loaded by the container classloader and then loaded a second time into the system classloader (as an agent).  This lead to linkage issues since OpenJPA classes were loaded from multiple loaders and there ended up being a mix of classes in the execution path.  

After correcting this issue, the subclassing enhancer is working again (but that has its own set of deficiencies and is not recommended) - but agent-based enhancement (-javaagent:...) is not.  This is not a result of my change, there is some other issue.  I plan on looking into that next.

As of rev 924395 the openjpa.DynamicEnhancementAgent=false property should no longer be required, but build time enhancement of entities may still be necessary.","18/Mar/10 19:37;techhusky;Experimentation and a quick search for similar issues is showing that use of the OpenJPA's agent enhancer with Tomcat never worked?!? The agent gets tied to the base class loader and enhances classes available to that loader at startup. Each app has their own lazily instantiated class loader. Enhancement has already taken place by the time those loaders get instantiated. This looked like a regression, but it it is actually a separate and much larger issue than the one raised in this JIRA. I will not pursue that issue at this time.

Please verify that you no longer see the original problem/exception with latest 2.0 build. If you were relying on runtime enhancement you will need to re-enable it by specifying:

<property name=""openjpa.RuntimeUnenhancedClasses"" value=""supported""/>

A more recommended solution is to enhance your entities and build time.","19/Mar/10 16:24;jbb;I confirm the problem is solved by adding that 2 properties.
By the way, we were enhancing at build-time.

<property name=""openjpa.DynamicEnhancementAgent"" value=""false""/>
<property name=""openjpa.RuntimeUnenhancedClasses"" value=""unsupported""/>

I still don't understand how it worked on Mac plateform and not on Linux...","22/Mar/10 12:41;drwoods;Jean-Baptiste BRIAUD confirmed the patch works and allows built time enhanced entities to work on Tomcat, since the agent enhancer is not being incorrectly loaded.

Opened OPENJPA-1590 to track the remaining issue of the agent enhancer not working with Tomcat.","23/Mar/10 15:50;seth.jackson;Using the latest available OpenJPA 2.0.0 Beta 2, Tomcat 6, Java 1.5, and Windows XP:

Persistence.XML:
<property name=""openjpa.RuntimeUnenhancedClasses"" value=""supported""/>

Using ANT to run PCEnhancerTask at build time:

<taskdef name=""openjac"" classname=""org.apache.openjpa.ant.PCEnhancerTask"">
<classpath refid=""classpath""/>
</taskdef>
<openjac>
<classpath refid=""classpath""/>
<config propertiesfile=""./src/META-INF/persistence.xml""/>
</openjac>

Upon building, I receiving the message: ""No targets given. Running on all classes in your persistence classes list...""

Confirmed all entities are in the persistence XML.

Deploy WAR to Tomcat. Started Tomcat and navigated to web page. Clicked button that attempted to retrieve an entity from the database and the following exception occurred:

c:\tomcat\temp\org.apache.openjpa.enhance.InstrumentationFactory3419745326061675422.jar was created and it may not get cleaned up properly.
java.lang.ClassNotFoundException: org.apache.openjpa.enhance.InstrumentationFactory
at java.net .URLClassLoader$1.run(URLClassLoader.java:200)
at java.security.AccessController.doPrivileged(Natuve Method)
at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
at java.lang.ClassLoader.loadClass(ClassLoader.java:303)
at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
...*SNIP*
at sun.instrument.InstrumentationImpl.loadClassAndCallAgentmain(InstrumentationImpl.java:348)


After this, all OpenJPA queries immediately throw QueryTimeoutException, even though I have javax.persistence.query.timeout set to 0 in the persistence.XML.

Still unable to use OpenJPA 2.0 on Tomcat.


I apologize ahead of time, I had to hand type this out as the error in on a separate PC.","23/Mar/10 16:58;techhusky;The code change was checked into trunk after beta2 was released.  For beta2, with compile-time enhanced entities, you'll need to add these properties to your persistence.xml:

<property name=""openjpa.DynamicEnhancementAgent"" value=""false""/>
<property name=""openjpa.RuntimeUnenhancedClasses"" value=""unsupported""/>

",23/Mar/10 17:23;seth.jackson;Confirmed. Modified persistence XML properties and my previous error is gone. Thank you and good work!,23/Mar/10 19:48;techhusky;That is great news.  Thanks for verifying!,,,,,,,,,,,
Improve type preservation for currentDate/Time  expression in queries,OPENJPA-1409,12442150,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,01/Dec/09 21:35,09/Mar/10 18:29,14/Mar/19 03:02,18/Jan/10 18:52,,,,,,,,,,2.0.0-beta,,,,,kernel,,,,,,0,,"CurrentDate/Time query expressions upcasts to java.util.Date. 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-01-18 18:52:39.717,,,no_permission,,,,,,,,,,,161676,,,Mon Jan 18 18:52:39 UTC 2010,,,,,,,0|i0yyif:,202061,,,,,,,,"18/Jan/10 18:52;drwoods;Code checked in over a month ago.  If there are still issues to be resolved, please reopen.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException at DataCacheStoreManager.loadAll,OPENJPA-1407,12442119,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,rpalache,rpalache,rpalache,01/Dec/09 17:34,21/Sep/16 14:21,14/Mar/19 03:02,16/Dec/09 17:45,1.1.0,,,,,,,,,1.2.0,,,,,datacache,,,,,,0,,"the following exception stack trace is seen in kodo :

    [java] Caused by: java.lang.ClassCastException: com.sample.TestTableId
     [java]  at org.apache.openjpa.datacache.DataCacheStoreManager.loadAll(DataCacheStoreManager.java:461)
     [java]  at org.apache.openjpa.kernel.DelegatingStoreManager.loadAll(DelegatingStoreManager.java:121)
     [java]  at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:984)
     [java]  at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:1027)
     [java]  at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:913)
     [java]  at org.apache.openjpa.kernel.AbstractPCData.toRelationFields(AbstractPCData.java:217)
     [java]  at org.apache.openjpa.kernel.AbstractPCData.toNestedFields(AbstractPCData.java:184)
     [java]  at org.apache.openjpa.kernel.AbstractPCData.toField(AbstractPCData.java:78)
     [java]  at org.apache.openjpa.kernel.PCDataImpl.loadField(PCDataImpl.java:197)
     [java]  at org.apache.openjpa.kernel.PCDataImpl.load(PCDataImpl.java:147)
     [java]  at org.apache.openjpa.datacache.DataCacheStoreManager.initialize(DataCacheStoreManager.java:343)
     [java]  at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
     [java]  at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
     [java]  at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:894)
     [java]  at kodo.kernel.KodoBroker.initialize(KodoBroker.java:65)

Reason behind the above exception is because when application identity class is used;
In openJPA, ObjectId is generated by enhancer generated method pcnewObjectIdInstance and it returns wrapped identity class
 like as follows.
     public Object pcNewObjectIdInstance()
     {
          return new ObjectId(ApplicationIdentityIdClass.class, new AppId());
     }
 So, the change was not affected to OpenJPA code.
 However, in OpenJPA derived products like Kodo, pcNewObjectIdInstance returns raw application identity class instance.
 Due to this  ""oidList.add((OpenJPAId) sm.getObjectId())"" throws classcast exception. 
",,,,,,,,,,,,,,,,,,,,,,15/Dec/09 22:08;rpalache;OPENJPA-1407-1.1.x.patch;https://issues.apache.org/jira/secure/attachment/12428088/OPENJPA-1407-1.1.x.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-12-16 17:39:59.884,,,no_permission,,,,,,,,,,,161674,,,Wed Dec 16 17:45:54 UTC 2009,,,Patch Available,,,,0|i0z7tr:,203570,,,,,,,,01/Dec/09 17:36;rpalache;http://n2.nabble.com/Need-process-help-for-a-code-change-that-does-not-have-an-openJPA-testcase-td4092236.html,11/Dec/09 18:32;rpalache;Added proper comments in the patch.,15/Dec/09 22:08;rpalache;Attached PATCH along with testcase.,"15/Dec/09 22:21;rpalache;Right now only Kodo has issues with current code. Kodo uses 1.1.x branch and not the trunk.
As there are no other persistence providers that has this issue other than kodo, I think it is safe to ignore this patch on trunk.

Regards,
Ravi.","16/Dec/09 17:39;dezzio;Applied Ravi's patch to branch 1.1.x, and added numerous comments at revision 891341","16/Dec/09 17:45;dezzio;As Ravi mentioned, it is not clear that this patch is required or suitable for other branches.  The actual change is minor, and as the referenced thread notes, there are several ways that the issue might be addressed if there were a general need.  ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
(In)Compatibility section in OpenJPA doc needs some work...,OPENJPA-1406,12442107,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,kwsutter,kwsutter,01/Dec/09 15:46,29/Mar/10 23:17,14/Mar/19 03:02,22/Mar/10 21:54,2.0.0,,,,,,,,,1.3.0,2.0.0-beta3,,,,docs,,,,,29/Jan/10 00:00,0,,"This problem started out with a discussion on the dev mailing list...

http://n2.nabble.com/JIRA-references-in-documentation-td4058419.html#a4059679

From this discussion, it sounds like our current documentation approach is close, but needs a couple of improvements.  This JIRA can be used to do these doc changes.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161673,,,2009-12-01 15:46:28.0,,,,,,,0|i0z4k7:,203041,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inheritance using Join Strategy may fail in cross join JPQL,OPENJPA-1401,12441721,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,faywang,faywang,25/Nov/09 22:55,09/Mar/10 18:29,14/Mar/19 03:02,18/Dec/09 17:47,2.0.0-M3,,,,,,,,,1.3.0,2.0.0-beta,,,,jdbc,,,,,,0,,"Cross joining two entities with join table inheritance strategy may fail in the following test case: Contractor extends from Employee with Join table strategy. A JPQL ""SELECT e FROM Department d, Contractor e where d.OID = e.dept.OID and d.description = 'Accounting' will fail with the exception below:

3922  inheritance2  TRACE  [main] openjpa.Query - Executing query: SELECT e FROM Department d, Contractor e where d.OID = e.dept.OID and d.description = 'IT'
3969  inheritance2  TRACE  [main] openjpa.jdbc.SQL - <t 8970973, conn 12468716> executing prepstmnt 24489446 SELECT t1.OID FROM Department t0 JOIN Contractor t1 ON (1 = 1) WHERE (t0.OID = t1.Dept_No AND t0.description = ?)  [params=(String) IT]
3969  inheritance2  TRACE  [main] openjpa.jdbc.SQL - <t 8970973, conn 12468716> [0 ms] spent
3984  inheritance2  TRACE  [main] openjpa.jdbc.JDBC - <t 8970973, conn 0> [0 ms] close
Exception in thread ""main"" <openjpa-0.0.0-rnull nonfatal general error> org.apache.openjpa.persistence.PersistenceException: Employee: e ({e|Contractor=1, Department=0})
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4677)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4630)
	at org.apache.openjpa.jdbc.sql.DB2Dictionary.newStoreException(DB2Dictionary.java:539)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:138)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:118)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:70)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.handleCheckedException(SelectResultObjectProvider.java:155)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.handleCheckedException(QueryImpl.java:2068)
	at org.apache.openjpa.lib.rop.WindowResultList.getInternal(WindowResultList.java:150)
	at org.apache.openjpa.lib.rop.AbstractNonSequentialResultList$Itr.hasNext(AbstractNonSequentialResultList.java:171)
	at org.apache.openjpa.lib.rop.ResultListIterator.hasNext(ResultListIterator.java:53)
	at org.apache.openjpa.kernel.DelegatingResultList$DelegatingListIterator.hasNext(DelegatingResultList.java:391)
	at inheritance2.TestInheritance2.main(TestInheritance2.java:71)
Caused by: java.sql.SQLException: Employee: e ({e|Contractor=1, Department=0})
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.findObject(SelectImpl.java:2402)
	at org.apache.openjpa.jdbc.sql.ResultSetResult.translate(ResultSetResult.java:497)
	at org.apache.openjpa.jdbc.sql.ResultSetResult.getObjectInternal(ResultSetResult.java:362)
	at org.apache.openjpa.jdbc.sql.AbstractResult.getObject(AbstractResult.java:696)
	at org.apache.openjpa.jdbc.meta.strats.PrimitiveFieldStrategy.getPrimaryKeyValue(PrimitiveFieldStrategy.java:300)
	at org.apache.openjpa.jdbc.meta.ClassMapping.getObjectId(ClassMapping.java:187)
	at org.apache.openjpa.jdbc.meta.ClassMapping.getObjectId(ClassMapping.java:146)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:941)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:280)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2328)
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.load(PCPath.java:890)
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.load(PCPath.java:873)
	at org.apache.openjpa.jdbc.kernel.ProjectionResultObjectProvider.getResultObject(ProjectionResultObjectProvider.java:79)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.getResultObject(QueryImpl.java:2032)
	at org.apache.openjpa.lib.rop.WindowResultList.getInternal(WindowResultList.java:131)
	... 4 more

",,,,,,,,,,,,,,,,,,,,,,25/Nov/09 22:59;faywang;OPENJPA-1401-testcase.jar;https://issues.apache.org/jira/secure/attachment/12426155/OPENJPA-1401-testcase.jar,25/Nov/09 23:09;faywang;OPENJPA-1401.patch;https://issues.apache.org/jira/secure/attachment/12426156/OPENJPA-1401.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-12-18 21:44:21.007,,,no_permission,,,,,,,,,,,161668,,,Fri Dec 18 21:44:21 UTC 2009,,,,,,,0|i0z4wn:,203097,,,,,,,,25/Nov/09 22:59;faywang;Attach test case.,"18/Dec/09 21:44;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unable to persist a relationship to a detached Entity ,OPENJPA-1400,12441523,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,23/Nov/09 22:19,21/Dec/09 20:39,14/Mar/19 03:02,08/Dec/09 15:02,1.2.1,2.0.0-M3,,,,,,,,1.2.2,1.3.0,2.0.0-beta,,,kernel,,,,,,0,,"I ran into a problem where OpenJPA is unable to persist a relationship from an attached Entity to a detached Entity. The problem occurs if the detached Entity does not have a DetachedState {openjpa.DetachState=loaded(DetachedStateField=false)} and the version is zero. When trying to flush the scenario described, the following exception is thrown by OpenJPA:

<openjpa-2.0.0-SNAPSHOT-r422266:882172M nonfatal user error> org.apache.openjpa.persistence.InvalidStateException: Encountered unmanaged object in persistent field ""org.apache.openjpa.persistence.detachment.model.NoDetachedStateEntityFieldAccess.relationship"" during flush.  However, this field does not allow cascade persist. Set the cascade attribute for this field to CascadeType.PERSIST or CascadeType.ALL (JPA annotations) or ""persist"" or ""all"" (JPA orm.xml), or enable cascade-persist globally, or manually persist the related field value prior to flushing. You cannot flush unmanaged objects or graphs that have persistent associations to unmanaged objects.

This scenario should work, but OpenJPA incorrectly determines that the detached Entity was never actually a part of a persistence context. If version field is anything other than zero the flush of the relationship works as expected. This problem is in the enhanced bytecode we assume that when no StateManager is present a version of zero means that an Entity isn't detached. 
    // Decompiled Entity bytecode	
    public Boolean pcIsDetached()
    {
        if(pcStateManager != null)
            if(pcStateManager.isDetached())
                return Boolean.TRUE;
            else
                return Boolean.FALSE;
        if(pcGetDetachedState() != null && pcGetDetachedState() != PersistenceCapable.DESERIALIZED)
            return Boolean.TRUE;
        if(_version != 0)
            return Boolean.TRUE;
        else
            return Boolean.FALSE;
    }

I will attach a patch which recreates this problem and also provides a solution. My solution to this problem is to add a boolean to the enhanced bytecode to keep track of whether or not the version field has been set. This fixes the problem for most cases, but there are still holes. In addition to the patch, I'll also post two decompiled Entities. One of those is enhanced with the existing code and the other is with my proposed changes.

Notes:
- For the sake of time, I did not fix this problem when using unenhanced classes.
- This problem still exists if the detached Entity has been serialized at any point.",,,,,,,,,,,,,,,,,,,,,,07/Dec/09 20:40;curtisr7;OPENJPA-1400-1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12427226/OPENJPA-1400-1.2.x.patch,23/Nov/09 22:20;curtisr7;OPENJPA-1400.patch;https://issues.apache.org/jira/secure/attachment/12425894/OPENJPA-1400.patch,23/Nov/09 22:20;curtisr7;decompiled_entities.zip;https://issues.apache.org/jira/secure/attachment/12425895/decompiled_entities.zip,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161667,,,Tue Dec 08 15:02:14 UTC 2009,,,,,,,0|i0yzl3:,202235,,,,,,,,"23/Nov/09 22:20;curtisr7;Attaching code changes, test case, and decompiled Entities.",07/Dec/09 20:40;curtisr7;Attaching 1.2.x patch.,"08/Dec/09 15:02;curtisr7;Changes committed to 1.2.x, 1.3.x, and trunk.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"NULL in columns part of an @IdClass composite key leads to ""disappearing"" (null) returned objects",OPENJPA-1397,12441180,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,vorburger,vorburger,19/Nov/09 13:43,09/Mar/10 18:29,14/Mar/19 03:02,18/Dec/09 13:22,1.2.1,2.0.0-M3,,,,,,,,1.2.2,1.3.0,2.0.0-beta,,,jdbc,kernel,,,,,0,,"As discussed on http://openjpa.markmail.org/search/?q=#query:list%3Aorg.apache.openjpa.users+page:1+mid:yua5kf7vd5m7wrnw+state:results, there is a bug in OpenJPA iff ... ""any @Id field of a composite key mapped via an @IdClass identity is NULL"" (enough keywords to allow future searching? ;).

The attached test case provides running code illustrating this with two simple entities and a failing JUnit.

While relational database do NOT appear to allow NULL value for columns which are part of a PRIMARY KEY CONSTRAINT, this kind of situation and mapping can (and in our case has!) occurred when mapping to legacy schemas with tables where a certain number / subset of columns are in fact the ""logical"" identifying set, without there being a physical PK constraint (nothing says you HAVE to have a physical PK). -- Both JPA Spec and OpenJPA doc make no statement if this is supposed to work or not work, they say nothing about this (as far as I could see; I checked before filing this; and nobody on the list made any statements re. this). It would be interesting to know if and how other JPA implementations handle this.

Assuming this is a small internal implementation bug and not a conceptual / design issue (note it's NOT the @IdClass instance that is null, it's only some fields within an Id, with others being available; and uniqueness of the combination guaranteed by data in DB of course!), it would be great if this could be make to work as one would naturally expect. (Or, at the very least, OpenJPA should fail and issue a clear error message, instead of just returning null; fix much better though.)",,,,,,,,,,,,,,,,,,,,,,19/Nov/09 13:44;vorburger;openJPA_NullId.zip;https://issues.apache.org/jira/secure/attachment/12425469/openJPA_NullId.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-12-18 21:44:20.4,,,no_permission,,,,,,,,,,,161664,,,Fri Dec 18 21:44:20 UTC 2009,,,,,,,0|i0za5j:,203947,,,,,,,,"18/Dec/09 21:44;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
metadata-complete in the orm file does not override @Transition annotation ,OPENJPA-1396,12441146,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,19/Nov/09 05:58,09/Mar/10 18:29,14/Mar/19 03:02,19/Nov/09 15:15,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,"In the orm.xml:

	<embeddable class=""embeddable.Address"" metadata-complete=""true""/

where embeddable.Address is defined as:

@Embeddable
public class Address {
    @Transient
    protected String street;

    protected String city;
    
    protected String state;
...
}

According to the spec (12.2.5.1): ""If the metadata-complete attribute of the embeddable element is specified as true, any annotations on the embeddable class (and its fields and properties) are ignored. When metadata-complete is specified as true and attributes and sub-elements of the embeddable element are omitted, the default values for those attributes and elements are applied."". However, the value of the street field in the Address class is not persistent.  ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161663,,,2009-11-19 05:58:51.0,,,,,,,0|i0z9of:,203870,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Pessimistic Lock not honour when ORDER BY clause is used,OPENJPA-1394,12441056,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,18/Nov/09 15:38,24/Feb/10 14:00,14/Mar/19 03:02,19/Nov/09 23:39,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,query,,,,,,0,,"
  query = em.createQuery(
    ""select e.department from Employee e where e.id < 10 order by e.department.id"").setFirstResult(3);
  query.setLockMode(LockModeType.PESSIMISTIC_READ);
  q = query.getResultList();

yields the following SQL statement but with no lock on the Employee row:

openjpa.Runtime: Info: The database is unable to lock this query.  Each object matching the query will be locked individually after it is loaded; however, it is technically possible that another transaction could modify the data before the lock is obtained.  See the documentation on Object Locking for details.
""SELECT t1.ID, t1.NAME, t0.FK_DEPT FROM CTS1.EMPLOYEE t0 LEFT OUTER JOIN CTS1.DEPARTMENT t1 ON t0.FK_DEPT = t1.ID WHERE (t0.ID < CAST(? AS BIGINT)) ORDER BY t0.FK_DEPT ASC "" 
openjpa.jdbc.SQL: Trace: <t 2035185998, conn 1784113751> executing prepstmnt 1845128698 SELECT t1.ID, t1.NAME, t0.FK_DEPT FROM CTS1.EMPLOYEE t0 LEFT OUTER JOIN CTS1.DEPARTMENT t1 ON t0.FK_DEPT = t1.ID WHERE (t0.ID < CAST(? AS BIGINT)) ORDER BY t0.FK_DEPT ASC  [params=(long) 10]",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161661,,,2009-11-18 15:38:01.0,,,,,,,0|i0z9pr:,203876,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CriteriaBuilder.countDistinct() does not return correct result,OPENJPA-1393,12440994,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,18/Nov/09 00:19,09/Mar/10 18:29,14/Mar/19 03:02,30/Nov/09 18:12,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,,,172800,172800,,0%,172800,172800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161660,,,2009-11-18 00:19:39.0,,,,,,,0|i0yyzb:,202137,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CriteriaBuilder.size() must return Integer as value,OPENJPA-1392,12440993,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,18/Nov/09 00:18,09/Mar/10 18:29,14/Mar/19 03:02,30/Nov/09 18:12,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,,,172800,172800,,0%,172800,172800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161659,,,2009-11-18 00:18:12.0,,,,,,,0|i0yyxr:,202130,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Handle generic/unspecified  type arguments for persistent fields during metamodel generation,OPENJPA-1391,12440971,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,17/Nov/09 20:43,09/Mar/10 18:29,14/Mar/19 03:02,30/Nov/09 18:13,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,NPE thrown when metamodel generator encounters a untyped or wildcard type parameter in a collection-valued field,,172800,172800,,0%,172800,172800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161658,,,2009-11-17 20:43:52.0,,,,,,,0|i0yyvj:,202120,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Criteria API untyped join(String attr) implies any attribute not a singular attribute,OPENJPA-1390,12440961,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,17/Nov/09 18:07,09/Mar/10 18:29,14/Mar/19 03:02,30/Nov/09 18:13,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,Untyped From.join(String attr) is unlike typed From.join() because the given attr in untyped version can be of any attribute type and not necessarily a singular attribute. ,,172800,172800,,0%,172800,172800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161657,,,2009-11-17 18:07:30.0,,,,,,,0|i0z9wf:,203906,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JPQL named parameter using a reserved word resulting in ArgumentException,OPENJPA-1388,12440838,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,16/Nov/09 18:14,09/Mar/10 18:29,14/Mar/19 03:02,17/Nov/09 23:36,1.3.0,,,,,,,,,1.3.0,2.0.0-beta,,,,query,,,,,,0,,"In JPA2, additional reserved words are introduced in the JPQL language. For example,  KEY, VALUE, ENTRY, CASE, etc.
These keywords is causing existing application that migrate to JPA2 regressed in ArgumentException (JPQL parser error).
For example,

     JPQL:  select c from Customer c where c.name = :value

:value is a named parameter, but 'value' is a reserved word in JPA2.

The above query used to work in OpenJPA-1.2.x but not in OpenJPA-2.x",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161655,,,Wed Nov 18 19:34:46 UTC 2009,,,,,,,0|i0yzav:,202189,,,,,,,,17/Nov/09 23:36;fancy;Using reserved words as named parameter is allowed in JPQL query.,18/Nov/09 19:34;fancy;Same fix applied to 1.3 branch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Metamodel Generator does not handle field types that can hide another,OPENJPA-1386,12440584,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,13/Nov/09 05:46,09/Mar/10 18:31,14/Mar/19 03:02,16/Nov/09 09:37,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,"If an entity declares fields of types that can hide each other by their simple name e.g.
java.sql.Date sDate;
java.util.Date uDate;

Metamodel generator generates code that are not compilable because the field types are not qualified and hidden properly.",,86400,86400,,0%,86400,86400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161653,,,2009-11-13 05:46:22.0,,,,,,,0|i0zb2n:,204096,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Parameter in having clause of Criteria query not recognized,OPENJPA-1385,12440555,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,12/Nov/09 22:35,09/Mar/10 18:31,14/Mar/19 03:02,12/Nov/09 23:11,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jpa,query,,,,,0,,Visitor that collects query parameters ignores having clause.,,300,300,,0%,300,300,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161652,,,Thu Nov 12 23:14:14 UTC 2009,,,,,,,0|i0yxg7:,201889,,,,,,,,"12/Nov/09 23:14;ppoddar@apache.org;This page not showing the SubVersion commits. But you can see it in Nabble [1].

[1] http://n2.nabble.com/svn-commit-r835628-openjpa-trunk-openjpa-persistence-src-main-java-org-apache-openjpa-persistence-cra-tc3996219.html#a3996219",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassNotFoundException for custom DBDictionary used by EJB,OPENJPA-1384,12440529,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,bjreed,bjreed,bjreed,12/Nov/09 18:43,09/Mar/10 18:31,14/Mar/19 03:02,08/Jan/10 00:07,1.2.1,,,,,,,,,1.2.2,1.3.0,2.0.0-beta,,,jdbc,,,,,,0,,"Trying to use EJB3 and Servlets, I have a custom DBDictionary that I would like to use.  If I use the default DBDictionary, everything works fine.

When OpenJPA tries to load the custom DBDictionary, I get a ClassNotFound Exception

[11/2/09 14:04:54:077 EST] 00000030 BusinessExcep E   CNTR0020E: EJB    
threw an unexpected (non-declared) exception during invocation of method ""preLoadCache"" on bean 
""BeanId(STA_Test#STA_Service-EJB_Test.jar#AllowableValueEjb, null)"".    Exception data:  com.siemens.soarian.se.soa.exception.SoarianUnknownException: Exception 
ID: ErrorNamespace:se.sta.unknownRuntimeInRSF DisplayErrorCode:SRN00001 ErrorMessage:Exception caught at RSF in method:  
............        
Caused by: <openjpa-1.2.1-SNAPSHOT+OPENJPA-679-Final-r422266:746282     
fatal user error> org.apache.openjpa.persistence.ArgumentException:     
com.siemens.soarian.se.persist.extensions.SoarianSQLServerJPADBDictionary                                                                       
 at org.apache.openjpa.jdbc.sql.DBDictionaryFactory.newDBDictionary(DBDictionaryFactory.java:128)                                                   
 at org.apache.openjpa.jdbc.sql.DBDictionaryFactory.newDBDictionary(DBDictionaryFactory.java:66)                                                    
 at  org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getDBDictionaryInstance(JDBCConfigurationImpl.java:538)                                      
at   org.apache.openjpa.jdbc.meta.MappingRepository.endConfiguration(MappingRepository.java:1265)                                                    
 at   org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:505)                                                           
 at  org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:430)                                                           
 at  org.apache.openjpa.lib.conf.PluginValue.instantiate(PluginValue.java:103
at org.apache.openjpa.conf.MetaDataRepositoryValue.instantiate(MetaDataRepositoryValue.java:68)                                                    
 at    org.apache.openjpa.lib.conf.ObjectValue.instantiate(ObjectValue.java:83)
 at   org.apache.openjpa.conf.OpenJPAConfigurationImpl.newMetaDataRepositoryInstance(OpenJPAConfigurationImpl.java:863)                               
 at  org.apache.openjpa.conf.OpenJPAConfigurationImpl.getMetaDataRepositoryInstance(OpenJPAConfigurationImpl.java:854)                               
 at org.apache.openjpa.kernel.AbstractBrokerFactory.makeReadOnly(AbstractBrokerFactory.java:638)                                                    
 at    org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:183)                                                       
 at  org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)                                                   
 at  org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityMana(EntityManagerFactoryImpl.java:192)                                     
 at com.ibm.ws.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:63)                                           
 at  com.ibm.ws.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:27)                                           
 at    com.ibm.ws.jpa.management.JPAEMPool.getEntityManager(JPAEMPool.java:126)
at com.ibm.ws.jpa.management.JPATxEntityManager.getEMInvocationInfo(JPATxEntityManager.java:226)                                                   
 at  com.ibm.ws.jpa.management.JPAEntityManager.getDelegate(JPAEntityManager.java:367)                                                               
 at   org.apache.openjpa.persistence.OpenJPAPersistence.cast(OpenJPAPersistence.java:63)                                                              
 at  com.siemens.soarian.se.soa.server.EMFHelper.verifyConnectionMeetsStandards(EMFHelper.java:167)                                                  
 at  com.siemens.soarian.se.soa.server.EMFHelper.getContainerEntityManager(EMFHelper.java:229)                                                       
 at   com.siemens.soarian.se.soa.server.EMFHelper.getEntityManager(EMFHelper.java:109)                                                                
at com.siemens.soarian.se.av.dao.AdaptabilityDAO.setupEM(AdaptabilityDAO.java:92)                                                                  
 at com.siemens.soarian.se.av.dao.AdaptabilityDAO.<init>(AdaptabilityDAO.java:84)                                                                   
 at com.siemens.soarian.se.av.applicationtask.AllowableValueCacheAT.<init>(AllowableValueCacheAT.java:37)                                           
at  com.siemens.soarian.se.av.applicationservice.AllowableValueAS.clearCache(AllowableValueAS.java:84)                                              
 at com.siemens.soarian.se.av.ejb.AllowableValueServiceBean$3.execute(AllowableValueServiceBean.java:277)                                           
 at com.siemens.soarian.se.soa.server.RSFAction.go(RSFAction.java:92)   
 ... 42 more                                                            
Caused by: java.lang.ClassNotFoundException:                            
com.siemens.soarian.se.persist.extensions.SoarianSQLServerJPADBDictionary                                                                       
 at java.lang.Class.forNameImpl(Native Method)                          
 at java.lang.Class.forName(Class.java:169)                             
 at  org.apache.openjpa.jdbc.sql.DBDictionaryFactory.newDBDictionary(DBDictionaryFactory.java:119)                                                   
 ... 71 more                                                            
...                                                                     
...                                                                     
The root cause is what I am looking at here:                            
.                                                                       
.                                                                       
Caused by: java.lang.ClassNotFoundException:                            
com.siemens.soarian.se.persist.extensions.SoarianSQLServerJPADBDictionar
y                                                                       
 at java.lang.Class.forNameImpl(Native Method)                          
 at java.lang.Class.forName(Class.java:169)                             
 at                                                                     
org.apache.openjpa.jdbc.sql.DBDictionaryFactory.newDBDictionary(DBDictio
naryFactory.java:119)                                                   
 ... 71 more                                                            
",EJB3 Web environment,,,,,,,,,,,,,,,,,,,,,12/Nov/09 18:48;bjreed;OPENJPA-1384.patch;https://issues.apache.org/jira/secure/attachment/12424745/OPENJPA-1384.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-01-06 11:26:55.223,,,no_permission,,,,,,,,,,,161651,,,Wed Jan 06 11:26:55 UTC 2010,,,Patch Available,,,,0|i0z9pb:,203874,,,,,,,,"12/Nov/09 18:48;bjreed;In the DBDictionaryFactory.newDBDictionary method, OpenJPA tries to load the DBDictionary.  Adding another catch to the code so that if a ClassNotFoundException is caught by the original attempt, then OpenJPA should try to load the class with the current thread's class loader.",06/Jan/10 11:26;struberg;it seems like this patch got applied (at least in 2.0.0 trunk),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
tests rely on US date formatting without setting the correct Locale,OPENJPA-1383,12440500,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,struberg,struberg,12/Nov/09 15:02,09/Mar/10 15:50,14/Mar/19 03:02,14/Nov/09 22:37,2.0.0-M2,,,,,,,,,2.0.0-beta,,,,,,,,,,,0,,"A few tests fail if built on a non-US locale (using de.AT here):

{noformat}
java.text.ParseException: Unparseable date: ""10/01/2008 1:51 AM""
 at java.text.DateFormat.parse(DateFormat.java:337) 
 at org.apache.openjpa.persistence.query.results.TestJPQLMultiSelectTypedResults.populate(TestJPQLMultiSelectTypedResults.java:73)
 at org.apache.openjpa.persistence.query.results.TestJPQLMultiSelectTypedResults.setUp(TestJPQLMultiSelectTypedResults.java:55)
{noformat}

tests in error:
{noformat}
  testMultipleConstructor(org.apache.openjpa.persistence.query.results.TestJPQLMultiSelectTypedResults)
  testMultipleConstructorMixWithMultiSelect(org.apache.openjpa.persistence.query.results.TestJPQLMultiSelectTypedResults)
  testMultiSelect(org.apache.openjpa.persistence.query.results.TestJPQLMultiSelectTypedResults)
  testMultiSelect(org.apache.openjpa.persistence.criteria.results.TestTypedResults)
  testTypedJPQLQuery(org.apache.openjpa.persistence.criteria.results.TestTypedResults)
  testDateQuery(org.apache.openjpa.persistence.criteria.results.TestTypedResults)
{noformat}

Please manually set the proper Locale in the tests
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-11-12 17:26:24.4,,,no_permission,,,,,,,,,,,161650,,,Sat Nov 14 22:37:15 UTC 2009,,,,,,,0|i0z9xr:,203912,,,,,,,,12/Nov/09 17:26;mikedd;Checked in changes to use DateFormat.SHORT and Locale.US - let me know if this works for you. ,"14/Nov/09 21:03;struberg;retested - works now, txs!","14/Nov/09 22:37;mikedd;Glad it worked, thanks Mark. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
IllegalStateException on query method call after named query is created twice.,OPENJPA-1381,12440421,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,allee8285,allee8285,11/Nov/09 15:53,09/Mar/10 18:31,14/Mar/19 03:02,18/Jan/10 19:50,2.0.0,,,,,,,,,2.0.0-beta,,,,,kernel,,,,,,0,,"When a query method is called (e.g. setLockMode) on a named query that has been created twice, an IllegalStateException is thrown:

  Query q1 = em.createNamedQuery(""xxxx"");
  ,,,,
  Query q2 = em.createNamedQuery(""xxxx"");
  q2.setLockMode(READ);


11078  test  TRACE  [Thread-4] Tests - Caught exception and continue: java.lang.IllegalStateException: Query is neither a JPQL SELECT nor a Criteria API query.
11078  test  TRACE  [Thread-4] DumpStack - java.lang.IllegalStateException: Query is neither a JPQL SELECT nor a Criteria API query.
	at org.apache.openjpa.persistence.QueryImpl.assertJPQLOrCriteriaQuery(QueryImpl.java:377)
	at org.apache.openjpa.persistence.QueryImpl.setLockMode(QueryImpl.java:396)
	at org.apache.openjpa.persistence.QueryImpl.setLockMode(QueryImpl.java:1)
	at org.apache.openjpa.persistence.lockmgr.SequencedActionsTest.launchCommonSequence(SequencedActionsTest.java:409)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-11-12 07:24:55.937,,,no_permission,,,,,,,,,,,161648,,,Thu Nov 12 15:10:08 UTC 2009,,,,,,,0|i0zb3j:,204100,,,,,,,,"11/Nov/09 16:01;allee8285;The problem is in PreparedQueryImpl, in which getLanauge() always return QueryLanguages.LANG_PREPARED_SQL regardless of the source of the cached Query. It is not sensitive to the query source.

In EntityManagerImpl.createNamedQuery:

    public OpenJPAQuery createNamedQuery(String name) {
        try {
            ....
            PreparedQuery pq = JPQLParser.LANG_JPQL.equals(meta.getLanguage())
                ? getPreparedQuery(qid) : null;
            org.apache.openjpa.kernel.Query del = (pq == null)
                ? _broker.newQuery(meta.getLanguage(), meta.getQueryString())
                : _broker.newQuery(pq.getLanguage(), pq);
            
The first time the named query is created, there is no query cached, a new Query is created using the metadata's language attribute (i.e. JPQL). The second time the named query is created, it is found in query cache, and the preparedQuery's language is used, which is ALWAYS SQL, that caused the ISEx when tested in the setLockMode() call path.

","11/Nov/09 17:51;allee8285;Work around of this limitation is to specify query hint ""openjpa.hint.IgnorePreparedQuery"" to true.

What is the reason cached query is treated as SQL and subsequently does not allow query methods that requires JPQL/Criteria API as the source language?","11/Nov/09 20:06;allee8285;The limitation/requirement of using the query cache is documented in the manual.

The query cache is enabled by default, which is a problem for a JPA compliance application that has the reported usage pattern.

Pinaki agrees using this JIRA to either:
- make the Query cache disabled by default.
- invalidate the cache at the appropriate call path
- potentially using QueryImpl.ignorePreparedQuery() to automatically by-pass the problem.

Albert Lee.","12/Nov/09 05:30;allee8285;The IllegalStateException semantics also apply to the Query.getLockMode() method call, per spec.  Similar usage of the ignorePreparedQuery() can be applied to getLockMode(), however it will lose the effectiveness of the cache (i.e. invalidate and rebuild) since getLockMode does not change the query's structure.
","12/Nov/09 07:24;ppoddar@apache.org;Albert, see if this works. Otherwise I will reopen.","12/Nov/09 15:10;allee8285;Pinaki,

The fix works for setLockMode() but still need implementation to protect getLockMode(). See my previous comment.

Thanks for getting this in so quickly.
Albert Lee. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Query not getting evicted from QueryCache,OPENJPA-1380,12440367,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,fancy,fancy,11/Nov/09 00:54,24/Feb/10 14:02,14/Mar/19 03:02,12/Nov/09 21:50,1.2.1,,,,,,,,,1.3.0,2.0.0-beta,,,,,,,,,,0,,"I'm running on OpenJPA 1.2.1

The following query is added to the QueryCache:

Query: org.apache.openjpa.kernel.QueryImpl@3afe3afe;
candidate class: class com.ibm.usmi.datamodel.system.OperatingSystem;
query: SELECT distinct
OPERATINGSYSTEM1.OID,OPERATINGSYSTEM1.Guid,OPERATINGSYSTEM1.ObjectType,OPERATINGSYSTEM1.Name,REMOTESERVICEACCESSPOINT1.OID,REMOTESERVICEACCESSPOINT1.Guid,REMOTESERVICEACCESSPOINT1.ObjectType,REMOTESERVICEACCESSPOINT1.Name
FROM OperatingSystem
OPERATINGSYSTEM1,System_accessedVia_RemoteServiceAccessPoint
SYSTEM_ACCESSEDVIA_REMOTESERVICEACCESSPOINT1,RemoteServiceAccessPoint
REMOTESERVICEACCESSPOINT1,RelationshipInfo RELATIONSHIPINFO1 WHERE
OPERATINGSYSTEM1.OID = SYSTEM_ACCESSEDVIA_REMOTESERVICEACCESSPOINT1.sourceId
AND REMOTESERVICEACCESSPOINT1.OID =
SYSTEM_ACCESSEDVIA_REMOTESERVICEACCESSPOINT1.targetId AND
(OPERATINGSYSTEM1.Guid = ?1) AND (OPERATINGSYSTEM1.OID = ?2) AND
((OPERATINGSYSTEM1.BuildNumber = ?3)) AND (REMOTESERVICEACCESSPOINT1.Guid =
?4) AND (REMOTESERVICEACCESSPOINT1.OID = ?5) AND
((REMOTESERVICEACCESSPOINT1.Port = ?6)) AND RELATIONSHIPINFO1.changedDate >
?7 and RELATIONSHIPINFO1.sourceOID=OPERATINGSYSTEM1.OID and
RELATIONSHIPINFO1.relationshipType = ?8 and
RELATIONSHIPINFO1.targetOID=REMOTESERVICEACCESSPOINT1.OID

Later on, a record in RelationshipInfo is changed, which changes what should
be returned from this query.  I'd expect this to cause the cached query to
get evicted from the QueryCache, but it is not.  If I get the
QueryResultCache, and evictAll RelationshipInfo.class, it still doesn't get
removed.  This seems to be because the AccessPath only contains
OperatingSystem.  I'd expect this to contain all entities that this query
deals with:
                {OperatingSystem,
System_accessedVia_RemoteServiceAccessPoint, RemoteServiceAccessPoint,
RelationshipInfo}
But the AccessPath only seems to contain the entity of what is returned from
the query.

What do I need to do so this query gets evicted like I'd expect.

This problem can be easily reproduced by the following query:

  String jpql = ""select p.name, c.name from OneOneParent p, OneOneChild c where "" + 
            ""p.id = c.id and c.name = ?1"";

	The query cache key is:

""org.apache.openjpa.datacache.QueryKey@d11db9a4
[
    query:[select p.name, c.name from OneOneParent p, OneOneChild c where p.id = c.id and c.name = ?1],
    access path:[queryCache.OneOneParent],
    subs:true,
    ignoreChanges:false,
    startRange:0,
    endRange:9223372036854775807,timeout:-1
]"".

This problem can be resolved if access path in QueryKey also contains queryCache.OneOneChild.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161647,,,2009-11-11 00:54:42.0,,,,,,,0|i0z9rr:,203885,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Locking problem when using timestamp QueryCache eviction policy.,OPENJPA-1379,12440211,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,09/Nov/09 20:47,09/Nov/09 22:10,14/Mar/19 03:02,09/Nov/09 22:10,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,datacache,,,,,,0,,"I ran into a bug in AbstractQueryCache when using the timestamp QueryCache eviction policy. This is only a problem when running in a multithreaded environment.

The net of the problem is that in AbstractQueryCache.onTypesChanged(TypesChangedEvent ev) we call writeLock(), but when using the non-default eviction policy we never call writeUnlock(). As a result, any other threads requesting a writeLock on the cache will block indefinitely.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161646,,,Mon Nov 09 22:10:48 UTC 2009,,,,,,,0|i0yzd3:,202199,,,,,,,,09/Nov/09 22:10;curtisr7;This issue is fixed in trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JPA property to enum conversion failure,OPENJPA-1377,12440071,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,06/Nov/09 22:43,24/Feb/10 14:02,14/Mar/19 03:02,19/Nov/09 21:45,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,kernel,,,,,,0,,"Exception occurred during JPA property to equivalent enum conversion:

java.lang.IllegalArgumentException: No enum const class javax.persistence.ValidationMode.callback
        at java.lang.Enum.valueOf(Enum.java:196)
        at org.apache.openjpa.persistence.JPAProperties.getEnumValue(JPAProperties.java:156)
        at org.apache.openjpa.persistence.JPAProperties.getEnumValue(JPAProperties.java:147)
        at org.apache.openjpa.persistence.PersistenceUnitInfoImpl.fromUserProperties(PersistenceUnitInfoImpl.java:325)
        at org.apache.openjpa.persistence.PersistenceProductDerivation$ConfigurationParser.endElement(PersistenceProductDerivation.java:734)

        at org.apache.openjpa.lib.meta.XMLMetaDataParser.endElement(XMLMetaDataParser.java:456)
        at org.apache.xerces.parsers.AbstractSAXParser.endElement(Unknown Source)
        at org.apache.xerces.impl.xs.XMLSchemaValidator.endElement(Unknown Source)
        at org.apache.xerces.impl.XMLNSDocumentScannerImpl.scanEndElement(Unknown Source)
        at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source)
        at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)
        at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)
        at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)
        at org.apache.xerces.parsers.XMLParser.parse(Unknown Source)
        at org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source)
        at org.apache.xerces.jaxp.SAXParserImpl$JAXPSAXParser.parse(Unknown Source)
        at org.apache.xerces.jaxp.SAXParserImpl.parse(Unknown Source)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parseNewResource(XMLMetaDataParser.java:393)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:334)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:311)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:284)
        at org.apache.openjpa.persistence.PersistenceProductDerivation$ConfigurationParser.parse(PersistenceProductDerivation.java:671)
        at org.apache.openjpa.persistence.PersistenceProductDerivation.parseResources(PersistenceProductDerivation.java:479)
        at org.apache.openjpa.persistence.PersistenceProductDerivation.load(PersistenceProductDerivation.java:449)
        at org.apache.openjpa.persistence.PersistenceProductDerivation.load(PersistenceProductDerivation.java:271)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:83)
        at com.ibm.websphere.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:73)
        at com.ibm.websphere.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:43)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:151)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:59)
        at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:159)
        at suite.r80.base.jpaspec.validation.basic.JSE_BasicTest.setupTestEnvironmentModeBasicEMFPropOvrCallback(JSE_BasicTest.java:486)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161644,,,Fri Nov 06 22:47:23 UTC 2009,,,,,,,0|i0z9nz:,203868,,,,,,,,"06/Nov/09 22:47;allee8285;Per spec:

3.6.1.1 Enabling Automatic Validation
The validation-mode element of the persistence.xml file determines whether the automatic
lifecycle event validation is in effect. The values of the validation-mode element are AUTO,
CALLBACK, NONE. The default validation mode is AUTO.

If the application creates the entity manager factory using the Persistence.createEntityManagerFactory
method, the validation mode can be specified using the javax.persistence.
validation.mode map key, which will override the value specified (or defaulted) in the
persistence.xml file. The map values for this key are ""auto"", ""callback"", ""none""

Enum values are in upper case and corresponding properties are in lowercase. Need to convert to upper case before converting to its enum value.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@SequenceGenerator allocationSize incorrect implementation,OPENJPA-1376,12439900,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,milosz,yyvess,yyvess,04/Nov/09 23:49,08/Nov/13 20:47,14/Mar/19 03:02,13/Mar/11 09:57,1.2.1,2.0.0-M3,2.1.0,,,,,,,1.2.3,1.3.0,2.0.2,2.1.2,2.2.0,competitive,jdbc,performance,,,,0,,"OpenJpa use allocationSize parameter on NativeJDBCSeq to set the sequence cache value.

But one ""JSR 220: Enterprise JavaBeansTM,Version 3.0"" , the allocationSize is : ""The amount to increment by when allocating sequence
numbers from the sequence.""

Allocating is used to limit the number of access to the sequence or table not to set the sequence cache value !

If allocationSize=50, the sequence need to be call one time on each 50 call on AbstractJDBCSeq.next().

1 call on AbstractJDBCSeq.next(). call the sequence or table 
2 call : return previous value + 1;
3 call : return previous value + 2;
...
51 call :re-call the sequence
52 return previous value + 1
...




",All,28800,28800,,0%,28800,28800,,,,,,,,,OPENJPA-2196,OPENJPA-2069,,,,,08/Feb/11 04:20;dagenix;cache-native-seq-values.diff;https://issues.apache.org/jira/secure/attachment/12470539/cache-native-seq-values.diff,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-02-08 04:20:27.171,,,no_permission,,,,,,,,,,,2513,,,Thu Feb 02 16:28:36 UTC 2012,,,,,,,0|i1dsfj:,288703,,,,,,,,"08/Feb/11 04:20;dagenix;The attached patch modifies the NativeJDBCSeq class to make use of the increment parameter.  The modified class will only get the next value of the database sequence object once every increment number of invocations.

The patch also modifies the meta-data parsers to use the allocationSize parameter to the SequenceGenerator's to set the increment size.","27/Feb/11 11:22;milosz;Palmer, thanks for the patch. I have modified it, e.g. allocate property is used instead of increment to be more consistent with table-based sequence, but the idea is the same. Committed.

I also got rid of the auto-configuration support which was marked deprecated from the beginning of OpenJPA (2006) which was interferring with this change.

Since this change poses some burden during migration, I will update the manual soon.
","11/Sep/11 14:00;milosz;Added other Fix Versions since code has been checked in.

On branches earlier than 2.2, the behaviour is gated by the useNativeSequenceCache property of DBDictionary. Set it to true to enable this new functionality.
",11/Sep/11 14:06;milosz;Should be: Set it to FALSE to enable this new functionality.,"11/Sep/11 14:14;milosz;Heath, I think the following code, found in a branch, needs correction. Won't we get too many ""INCREMENT BY""s ?

       if (seq.getIncrement() > 1 && useNativeSequenceCache){

               buf.append("" INCREMENT BY "").append(seq.getIncrement());

       }

       else if ((seq.getIncrement() > 1) || (seq.getAllocate() > 1)){

           buf.append("" INCREMENT BY "").append(seq.getIncrement() * seq.getAllocate());

       }

      if (seq.getIncrement() > 1)

           buf.append("" INCREMENT BY "").append(seq.getIncrement());","14/Sep/11 17:13;jpaheath;Hello Milosz!!  Excellent catch!!  Thank you!  If you would please, could you double check my work here to make sure we are on the same page?  That is, in 1.2.x and 1.3.x, it looks like my changes to DBDictionary are correct.  However, looking at the DBDictionary changes in 2.0.x and 2.1.x, I forgot to remove this 'if' block:

 if (seq.getIncrement() > 1)

           buf.append("" INCREMENT BY "").append(seq.getIncrement()); 

Sound correct or am I still missing something?","15/Sep/11 17:15;milosz;Hi Heath! It sounds correct now. I will have a look at the other files and will let you know if I find anything.
",02/Feb/12 16:28;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OutOfMemory runs in container environment in a long stress run,OPENJPA-1375,12439892,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,04/Nov/09 21:56,24/Feb/10 14:03,14/Mar/19 03:02,06/Nov/09 15:48,1.3.0,2.0.0-M3,,,,,,,,1.3.0,2.0.0-beta,,,,kernel,,,,,,0,,"Long stress run in the app server/container environment caused a OutOfMemoery exception with a heap dump that showed the following:

 FetchConfigurationImpl$ConfigurationState
 + WsJpaFetchConfigurationImpl
    + Array of Object
       + IdentityHashMap
          + EntityManagerImpl

What happened is the container pooled the entity manager and clear the context when a transaction is completed. However the IdentityHashMap in EntityManagerImpl, which maps the fetch configuration to fetch plan, is not being flush/clear. This caused the growth of the IdentityHashMap and eventually the OOM in a long run.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161643,,,2009-11-04 21:56:14.0,,,,,,,0|i0z9qf:,203879,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Generating identifiers by using sequence table may fail during sequence table initialization,OPENJPA-1372,12439611,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,milosz,milosz,31/Oct/09 21:26,30/Sep/12 20:58,14/Mar/19 03:02,07/Sep/10 22:49,1.2.1,2.0.0-M3,,,,,,,,2.0.2,2.1.0,,,,jdbc,kernel,,,,,0,,"When sequence table does not exist and mutliple threads get EntityManagers from EntityManageFactory, an insert into sequence table may fail because of duplicate primary key value.

EMF is created lazily by default and users reported various problems with concurrent initialization (e.g. failures in resolving aliases in JPQL queries, IIRC) of EMF. This issue might have the same roots.

Issue and test case originally reported by Pinaki in OPENJPA-466.
",,,,,,,,,,,,,,,,OPENJPA-2269,OPENJPA-466,,,,,31/Oct/09 21:29;milosz;GeneratedIdObject.java;https://issues.apache.org/jira/secure/attachment/12423767/GeneratedIdObject.java,31/Oct/09 21:29;milosz;TestSequenceGenerationOnMT.java;https://issues.apache.org/jira/secure/attachment/12423768/TestSequenceGenerationOnMT.java,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-09-07 22:49:56.317,,,no_permission,,,,,,,,,,,161641,,,Thu Jan 13 16:45:27 UTC 2011,,,,,,,0|i1dsfz:,288705,,,,,,,,"07/Sep/10 22:49;mikedd;Testcase added to 2.x releases - so I'm marking as resolved. If there's another way to trigger this problem we can either open another issue (if 2.0.2 or 2.1.0 have been released), or reopen this one (if neither has been released).",13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Insert is called instead of Update when merge() with derived Identity,OPENJPA-1371,12439580,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,faywang,faywang,30/Oct/09 22:51,22/Apr/10 20:33,14/Mar/19 03:02,24/Mar/10 17:47,2.0.0-M3,,,,,,,,,2.0.0-M3,,,,,kernel,,,,,,0,,Insert is called instead of Update when merge() with derived Identity:,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161640,,,Sun Nov 01 00:43:56 UTC 2009,,,,,,,0|i0z7sf:,203564,,,,,,,,"30/Oct/09 23:36;faywang;The following test scenario is provided by Constantine Kulak <code@mail.by>:

There are three entities where PrognosisEntry has derived identity:

***** Source for Prognosis.java:

 @Entity(name = ""Prognosis"")
 @Table(name = ""PROGNOSIS"")
 @IdClass(Prognosis.PrognosisId.class)
 @Inheritance(strategy = InheritanceType.JOINED)
 public class Prognosis {

     protected List<PrognosisEntry> entries;
    protected String station;
    protected String type;

    @OneToMany(targetEntity = PrognosisEntry.class, cascade = {CascadeType.MERGE}, mappedBy=""prognosis"", fetch=FetchType.EAGER)
    public List<PrognosisEntry> getEntries() {
        if (entries == null) {
            entries = new ArrayList<PrognosisEntry>();
        }
        return this.entries;
    }

    public void setEntries(List<PrognosisEntry> entries) {
        this.entries = entries;
    }

    @Id
    @Column(name = ""STATION"")
    public String getStation() {
        return station;
    }

    public void setStation(String value) {
        this.station = value;
    }

    @Id
    @Column(name = ""TYPE_"")
    public String getType() {
        return type;
    }

    public void setType(String value) {
        this.type = value;
    }

    public boolean equals(Object object) { ... }
    public int hashCode() { ... }

    public static class PrognosisId {
        protected String station;
        protected String type;

        public String getStation() {
            return station;
        }

        public void setStation(String value) {
            this.station = value;
        }

        public String getType() {
            return type;
        }

        public void setType(String value) {
            this.type = value;
        }

          public boolean equals(Object object) { ... }
        public int hashCode() { ... }
    }
 }


 ***** Source for PrognosisEntry.java:

 @Entity(name = ""PrognosisEntry"")
 @Table(name = ""PROGNOSISENTRY"")
 @Inheritance(strategy = InheritanceType.JOINED)
 @IdClass(PrognosisEntry.PrognosisEntryId.class)
 public class PrognosisEntry {

    protected String timestamp;
    protected String localState;
    protected Prognosis prognosis;

    protected Stock stock;

    @Id
    @ManyToOne(targetEntity = Stock.class, cascade = { CascadeType.MERGE }, fetch = FetchType.EAGER)
    public Stock getStock() {
        return stock;
    }

    public void setStock(Stock stock) {
        this.stock = stock;
    }

    @Id
    @ManyToOne(targetEntity = Prognosis.class, cascade = { CascadeType.MERGE }, fetch = FetchType.EAGER)
    public Prognosis getPrognosis() {
        return prognosis;
    }

    public void setPrognosis(Prognosis prognosis) {
        this.prognosis = prognosis;
    }

    @Column(name = ""TIMESTAMP_"", length = 255)
    public String getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(String value) {
        this.timestamp = value;
    }

    @Basic
    @Column(name = ""LOCALSTATE"", length = 255)
    public String getLocalState() {
        return localState;
    }

    public void setLocalState(String value) {
        this.localState = value;
    }

    public boolean equals(Object object) { ... }
    public int hashCode() { ... }

    public static class PrognosisEntryId {

        protected Prognosis.PrognosisId prognosis;
        protected String stock;

        public String getStock() {
            return stock;
        }

        public void setStock(String stock) {
            this.stock = stock;
        }

        public Prognosis.PrognosisId getPrognosis() {
            return prognosis;
        }

        public void setPrognosis(Prognosis.PrognosisId prognosis) {
            this.prognosis = prognosis;
        }

        public boolean equals(Object object) { ... }
        public int hashCode() { ... }
    }
 }


 ***** Source for Stock.java:

 @Entity(name = ""Stock"")
 @Table(name = ""STOCK"")
 @Inheritance(strategy = InheritanceType.JOINED)
 public class Stock {
    protected String index;
    protected String length;

    @Id
    @Column(name = ""INDEX_"")
    public String getIndex() {
        return index;
    }

    public void setIndex(String value) {
        this.index = value;
    }
      @Basic
    @Column(name = ""LENGTH_"", length = 255)
    public String getLength() {
        return length;
    }

    public void setLength(String value) {
        this.length = value;
    }

    public boolean equals(Object object) { ... }
    public int hashCode() { ... }
}

The test scenario: 
(1) create a Prognosis entity with a list of PrognosisEntry.
(2) call em.merge(newEntity) and commit
(3) call em.clear()
(4) call em.merge(newEntity)

Step (4) generate insert statement to insert PrognosisEntry again, resulting in unique constraint violation from the database.

It appears that the ApplicationIds.create(pc, meta) where pc is PrognosisEntry, the oid does not have complete id values.









","01/Nov/09 00:43;faywang;During merge, openjpa needs to retrieve id from the entity to decide whether this is a new entity or a detached one. If it thinks it is a new entity, an INSERT will be perform. Otherwise, an Update statement will be executed. 
If  (1) an entity has the compound primary key using IdClass, and 
    (2) some field in the IdClass is a derived identity from a OneToOne/ManyToOne field,
    (3) that value in that field has not yet become managed (i.e., does not have the StateManagerImpl yet),
this field in the IdClass will not be populated, as the primary key of the OneToOne/ManyToOne field usually can not be fetched back without an associated StateManagerImpl, unless it has a single-value primary key. 

Currently openjpa returns the null value for this field in the IdClass regardlessly in the above situation.  The patch provides a relief when this derived identity-relation field has a single value primary key. It should fix the problem reported by Constantine. However, the limitation for nested/multi-level compound primary (e.g. Stock entity has compound primary key using IdClass, and some value in the idClass is a derived-identity relation field, ...) during merge remains.   
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"JPA2 missing implementation for createNamedQuery(String name, Class<T> resultClass)",OPENJPA-1370,12439572,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,30/Oct/09 20:40,09/Mar/10 18:31,14/Mar/19 03:02,02/Nov/09 17:33,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,"Missing implementation for createNamedQuery(String name, Class<T> resultClass), when attempted, it reports 
UnsupportedOperationException()",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161639,,,2009-10-30 20:40:25.0,,,,,,,0|i0z9mn:,203862,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
H2 Database Engine does support cross join,OPENJPA-1367,12439523,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,milosz,tmueller,tmueller,30/Oct/09 13:00,09/Mar/10 18:31,14/Mar/19 03:02,08/Feb/10 19:30,1.2.1,2.0.0-beta,2.0.0-M1,2.0.0-M2,2.0.0-M3,,,,,1.3.0,2.0.0-beta2,,,,docs,jdbc,sql,,,,1,,"The documentation says that the H2 database does not support cross joins:

http://openjpa.apache.org/builds/1.2.1/apache-openjpa-1.2.1/docs/manual/dbsupport_h2.html
http://openjpa.apache.org/builds/2.0.0-M3/apache-openjpa-2.0.0-M3/docs/manual/main.html

H2 does support cross join since a long time (I don't remember what version). See: http://www.h2database.com/html/grammar.html#table_expression (CROSS). A condition is not required for cross join.

I think the documentation should be changed, and probably the H2Dictionary should be changed as well (crossJoinClause = ""CROSS JOIN""; requiresConditionForCrossJoin = false;).


",,,,,,,,,,,,,,,,,,,,,,22/Jan/10 05:22;prashantbhat;OPENJPA-1367.patch;https://issues.apache.org/jira/secure/attachment/12431097/OPENJPA-1367.patch,22/Jan/10 05:22;prashantbhat;openjpa-h2-test-results.txt;https://issues.apache.org/jira/secure/attachment/12431098/openjpa-h2-test-results.txt,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-01-22 05:22:43.926,,,no_permission,,,,,,,,,,,161636,,,Fri Feb 05 18:05:21 UTC 2010,,,,,,,0|i16s5j:,247693,,,,,,,,"22/Jan/10 05:22;prashantbhat;I've run the test cases using H2 Database-1.2.127 with current trunk revision: r901901 Please refer to the attached test-results.txt file for more details. 

Descriptions for the changes in attached patch:
1. H2Dictionary changes:
    a)  as per this issue comment: crossJoinClause = ""CROSS JOIN""; requiresConditionForCrossJoin = false;
    b) Return Types.BOOLEAN for Types.BIT in getPreferredType(type) because of warning message shown while running MappingTool. The message looked like this:
        4396  workflow-entities  WARN   [main] openjpa.jdbc.Schema - Existing column ""ACTIVE"" on table         ""OPENJPA.WORKFLOW_TASK_GROUP"" is incompatible with the same column in the given schema definition. Existing column:
         Full Name: WORKFLOW_TASK_GROUP.ACTIVE
        Type: unknown(16)
         Size: 1
         Default: null
         Not Null: false
         Given column:
         Full Name: workflow_task_group.active
         Type: bit
         Size: 0
         Default: null
         Not Null: false

   c) H2 requires limit to be present for using offset. http://www.h2database.com/html/grammar.html#select

2. Changes to sql-error-state-codes.xml :   added missing error-codes (caused some test failures!)
3. TestMultipleSchemaNames.java :   Similar to Postgres, H2 requires schema to be created as as it does not create them automatically.

4. And in the documentation: I've changed the comment 'H2 does not support cross joins' to 'None' 
    But as the following test cases fail,  may be it should be explained here. I'll leave it to someone with more knowledge about these failures.
   a) module openjpa-peristence-jdbc -> All the tests completed successfully, except for the error in following test:
          org.apache.openjpa.persistence.sequence.TestSequence   => error in: testMultiThreadedNativeSequences
   b) module openjpa-peristence-locking  Tests run: 185, Failures: 43, Errors: 0, Skipped: 0

Hope this patch can be integrated into OpenJpa-2.0!

Thanks,
Prashant","23/Jan/10 15:32;milosz;Hi, Prashant,

Thank you very much for your patch! I will look into it.

Briefly looking, I have a question on the LIMIT clause. Do you know whether ""LIMIT 0"" means ""return all rows"" or ""return no rows""? If ""return no rows"", we would need to issue ""LIMIT big_constant"" instead.
","23/Jan/10 18:32;prashantbhat;Actually I tried it with H2, it returns 'all rows' for 'limit 0'.  and Long.MAX_VALUE should also work. So, either of them should be fine.

Thanks,
Prashant","31/Jan/10 11:47;milosz;Prashant, I have applied your patch into 2.0.x branch, with slight modifications:
- Removed a few variable assignments in H2Dictionary since DBDictionary already assigns the same values to them.
- Modified a bit SQL error codes file. A caveat here is the difference between SQL state and SQL error code. It is handled by DBDictionary.matchErrorState method which uses SQL states to determine exception type unless the method is overriden. I found some H2 source file [1] helpful here.

As for org.apache.openjpa.persistence.sequence.TestSequence, it is failing because of a deadlock in INSERT statement. I believe this is because H2 uses table level locking and this test executes a lot of parallel inserts into two tables. I also ran the test with MVCC option turned on in H2 which is supposed to use row level locking but I ended up with OutOfMemoryError (although I only tried in-memory database). Anyway having only one test failing in openjpa-persistence-jdbc module is a very good result.

Unfortunately I am currently not familiar with internals of openjpa-peristence-locking tests and do not have enough time to dig into them now. As you have noted in your attachment, the results are better with MVCC option turned on. I can only guess that the tests fail mainly due to different locking semantics in H2 than the tests assume.

I am going to apply the patch also to the 1.3.x branch and then mark the issue resolved. If you would like to continue work on the mentioned failing tests, please open a new issue.


Thomas, thank you for pointing the CROSS JOIN issue. The patch applied contains the fix.


[1] http://kickjava.com/src/org/h2/message/Message.java.htm
","04/Feb/10 04:45;prashantbhat;Milosz Tylenda, thanks for reviewing and applying the patch.

I've noticed an exception 'Connection not closed' being shown in database log (*.trace.db) for almost every test although the test passes! 
trace.db file grows upto 9.5mb after running full persistence-jdbc tests. Is it because the entity manager is not closed at the end of each test? Or is some other configuration missing for h2?
for ex.: mvn -Ptest-h2 -Dtest=TestException test

throws the following exception:
[code]
02-04 12:08:42 jdbc[13]: Connection not closed
java.lang.Exception: Stack Trace
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:121)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:94)
	at org.h2.Driver.connect(Driver.java:58)
	at org.apache.commons.dbcp.DriverConnectionFactory.createConnection(DriverConnectionFactory.java:38)
	at org.apache.commons.dbcp.PoolableConnectionFactory.makeObject(PoolableConnectionFactory.java:294)
	at org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1148)
	at org.apache.commons.dbcp.PoolingDataSource.getConnection(PoolingDataSource.java:96)
	at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:880)
	at org.apache.openjpa.lib.jdbc.DelegatingDataSource.getConnection(DelegatingDataSource.java:131)
	at org.apache.openjpa.lib.jdbc.DecoratingDataSource.getConnection(DecoratingDataSource.java:106)
	at org.apache.openjpa.jdbc.sql.DBDictionaryFactory.newDBDictionary(DBDictionaryFactory.java:91)
	at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getDBDictionaryInstance(JDBCConfigurationImpl.java:595)
	at org.apache.openjpa.jdbc.meta.MappingRepository.endConfiguration(MappingRepository.java:1489)
	at org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:507)
	at org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:432)
	at org.apache.openjpa.lib.conf.PluginValue.instantiate(PluginValue.java:104)
	at org.apache.openjpa.conf.MetaDataRepositoryValue.instantiate(MetaDataRepositoryValue.java:68)
	at org.apache.openjpa.lib.conf.ObjectValue.instantiate(ObjectValue.java:83)
	at org.apache.openjpa.conf.OpenJPAConfigurationImpl.newMetaDataRepositoryInstance(OpenJPAConfigurationImpl.java:920)
	at org.apache.openjpa.conf.OpenJPAConfigurationImpl.getMetaDataRepositoryInstance(OpenJPAConfigurationImpl.java:911)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.makeReadOnly(AbstractBrokerFactory.java:619)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:188)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:152)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:200)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:151)
	at org.apache.openjpa.persistence.exception.TestException.testIllegalArgumennExceptionOnInvalidNamedQuery(TestException.java:188)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runTest(AbstractPersistenceTestCase.java:514)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:501)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:477)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:177)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
	at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:345)
	at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009)
[/code]","05/Feb/10 18:05;milosz;Prashant, most likely some (or even most of) connections are still open at the end of test but not because of not closing EntityManagers. The cause is rather a connection pool (Apache DPCP) being used by the test suite. I haven't seen the exceptions you mention, maybe because I did not enable trace log in H2.

Looking at your stack trace, I would say you use H2 in kind of one-connection-only mode. Is this the case? I am not very familiar with H2.

I don't have answer for your question on H2 configuration. I would try tweaking DBCP connection properties and H2 settings. If you have an IDE with OpenJPA source, you can also try running some test from there, without DBCP. Below I am including my settings for your reference:

        <profile>
            <id>test-h2-milosz</id>
            <properties>
                <test-custom>true</test-custom>
                <openjpa.custom.driverjar>/alt/jdbc/h2-1.1.118.jar</openjpa.custom.driverjar>
                <openjpa.custom.driverclass>org.h2.Driver</openjpa.custom.driverclass>
                <openjpa.custom.url>jdbc:h2:mem:oj;DB_CLOSE_DELAY=-1</openjpa.custom.url>
                <openjpa.custom.username>sa</openjpa.custom.username>
                <openjpa.custom.password></openjpa.custom.password>
                <dbcp.args>
                     MaxActive=100,MaxIdle=10,MaxWait=10000,timeBetweenEvictionRunsMillis=2000,minEvictableIdleTimeMillis=1000
                </dbcp.args>
            </properties>
        </profile>
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"ReverseMappingTool omits nullable, length, etc. when ClassMapping.setEmbedded(true) is called",OPENJPA-1360,12438938,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,ljnelson,ljnelson,23/Oct/09 15:53,29/Mar/10 23:17,14/Mar/19 03:02,08/Mar/10 21:48,1.2.2,,,,,,,,,1.3.0,2.0.0-beta3,,,,tooling,,,,,,0,,"In my ReverseCustomizer, I call classMapping.setEmbedded(true).  This is because for a variety of reasons I need the code that is generated by the ReverseMappingTool to be @MappedSuperclasses, not @Entities.

Indeed when I do this, the resulting class is a @MappedSuperclass (great!) BUT all of the length and nullable and other @Column attributes are missing.  In other words, all simple fields receive only a @Basic annotation, with no attributes, and nothing else.  In addition, the class declaration receives a @Table annotation with no attributes.  (I'm using the command line flag that instructs the ReverseMappingTool to generate annotations.)

Ideally I'd like the generated source code to look identical to the source code that would be generated for a ClassMapping where setEmbedded(true) was never called, except of course that I want the @Entity annotation to be replaced with @MappedSuperclass.

Obviously if there is a better way from within a ReverseCustomizer for me to accomplish my (very odd) goals (mandated by a strange development process and a 30-year-old database), I am all ears.",,,,,,,,,,,,,,,,OPENJPA-1492,,,,,,08/Mar/10 18:08;drwoods;OPENJPA-1360-trunk.patch;https://issues.apache.org/jira/secure/attachment/12438211/OPENJPA-1360-trunk.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-03-08 18:08:26.632,,,no_permission,,,,,,,,,,,161629,,,Mon Mar 08 18:08:26 UTC 2010,,,,,,,0|i0z6h3:,203351,,,,,,,,"26/Oct/09 22:10;ljnelson;It looks like, at least for the annotations path, AnnotationPersistenceMetaDataSerializer is the culprit.  At line 202 or thereabouts, in the isMappingMode(ClassMetaData meta) method, it includes a check to see if the supplied meta isEmbeddedOnly().  If it is, then there is nothing else you can do from the standpoint of your ReverseCustomizer: that metdata is deemed to NOT be in mapping mode.  That of course means that when the Java code is written out, all fields are output with only a @Basic annotation and nothing else.

The (rather cumbersome) workaround is to subclass both this serializer and PersistenceMappingFactory and supply a PersistenceMappingFactory implementation that returns new instances of an AnnotationPersistenceMetaDataSerializer that is capable of omitting this isEmbeddedOnly() check from its own implementation of the isMappingMode(ClassMetaData meta) method.","27/Oct/09 19:29;ljnelson;Talking to myself it seems....  :-)

I've successfully implemented the workaround as described in my prior comment.

The isMappingMode(ClassMetaData) method of my serializer now looks like this:

@Override
public boolean isMappingMode(final ClassMetaData meta) {
  return 
    this.isMappingMode() && 
    (meta.getSourceMode() & MetaDataModes.MODE_MAPPING) != 0 &&
    (meta.getEmbeddingMetaData() == null || this.isMappingMode(meta.getEmbeddingMetaData()));
}","29/Jan/10 20:28;ljnelson;This bug is still present in openjpa 1.2.2, even with the new ClassMapping.isAbstract() method.",08/Mar/10 18:08;drwoods;Proposed patch based on 1.3.x changes.  Need to run a full set of junits and TCK before committing to trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Recent snaphot versions of openjpa have problem with postgresPreparedStatementImpl constructor making Postgres impossible to use,OPENJPA-1355,12438580,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,ppoddar@apache.org,yazuna,yazuna,20/Oct/09 15:13,09/Mar/10 18:31,14/Mar/19 03:02,12/Nov/09 04:42,2.0.0-beta,,,,,,,,,2.0.0-beta,,,,,jdbc,,,,,,0,,"When calling prepared statement for the first time, following exception started to occur after upgrading to the latest snaphots (it worked in M3):
 
java.lang.ExceptionInInitializerError: null
     org.apache.openjpa.lib.util.ConcreteClassGenerator.newInstance(ConcreteClassGenerator.java:132)
     org.apache.openjpa.jdbc.sql.PostgresDictionary$PostgresConnection.prepareStatement(PostgresDictionary.java:697)
     org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:328)
     org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1560)
     org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:317)
     org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:546)
     org.apache.openjpa.jdbc.sql.SelectImpl.prepareStatement(SelectImpl.java:452)
     org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:389)
     org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:363)
     org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:427)
     org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:230)
     org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:220)
     org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:94)
     org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.open(QueryImpl.java:2027)
     org.apache.openjpa.lib.rop.WindowResultList.<init>(WindowResultList.java:57)
     org.apache.openjpa.jdbc.kernel.JDBCFetchConfigurationImpl.newResultList(JDBCFetchConfigurationImpl.java:278)
     org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1239)
     org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1000)
     org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:856)
     org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:787)
     org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:525)
     org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:291)
     org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:303)
     gaia.cu7.dal.VariStore.fetchSourcesHistogram(VariStore.java:733)
     gaia.cu7.dal.VariStore.getSourcesHistogram(VariStore.java:689)
     gaia.cu7.omimpl.test.SourceImplTest.testHistogramCreation(SourceImplTest.java:930)
     sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
     sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
     sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
     java.lang.reflect.Method.invoke(Method.java:597)
     org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
     org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
     org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
     org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
     org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
     org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
     org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:73)
     org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:46)
     org.junit.runners.ParentRunner.runChildren(ParentRunner.java:180)
     org.junit.runners.ParentRunner.access$000(ParentRunner.java:41)
     org.junit.runners.ParentRunner$1.evaluate(ParentRunner.java:173)
     org.junit.runners.ParentRunner.run(ParentRunner.java:220)
Caused by: java.lang.IllegalArgumentException: wrong number of arguments
     sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
     sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
     sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
     java.lang.reflect.Constructor.newInstance(Constructor.java:513)
     org.apache.openjpa.lib.util.ConcreteClassGenerator.newInstance(ConcreteClassGenerator.java:130)


This might be related to the svn revision:
Revision 813149 - (view) (annotate) - [select for diffs]
Modified Wed Sep 9 22:43:49 2009 UTC (5 weeks, 5 days ago) by ppoddar

OPENJPA-1285: Dynamic JDBC 4 Wrappers use constructor to save reflection cost


seems the offending statement from org.apache.openjpa.jdbc.sql.PostgresDictionary$PostgresConnection.prepareStatement(PostgresDictionary.java:697) 
has wrong number of parameters:
            ...
return ConcreteClassGenerator.
                newInstance(postgresPreparedStatementImpl,
                    PreparedStatement.class,
                        super.prepareStatement(sql, rsType, rsConcur, false),
                    Connection.class, PostgresConnection.this,
                    PostgresDictionary.class, _dict);

Are the type classes really needed here?

Could you confirm it passes your internal tests for postgres on the openjpa trunk if you think this problem is caused by something else?

Best regards,
Krzysztof

","-S1 snapshots from maven. pg jdbc driver 8.[3|4], pg 8.4",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-10-22 22:08:16.57,,,no_permission,,,,,,,,,,,161624,,,Thu Oct 22 22:08:16 UTC 2009,,,,,,,0|i0yvsf:,201620,,,,,,,,"22/Oct/09 22:08;ppoddar@apache.org;Hi Krzysztof,
  Thanks for finding this out. 
  Fixed now -- can you try the fix?
 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Configuring DBCP connection pool with connection properties breaks when user/pasword is specifed and javax.* configuration is set to DBCP Driver,OPENJPA-1354,12438475,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,19/Oct/09 18:29,09/Mar/10 18:31,14/Mar/19 03:02,12/Nov/09 04:43,,,,,,,,,,2.0.0-beta,,,,,,,,,,,0,,"Property combination on openjpa.* works
   <property name=""openjpa.ConnectionDriver"" value=""org.apache.commons.dbcp.BasicDataSource""/> 
   <property name=""openjpa.ConnectionProperties"" value=""DriverClassName=com.mysql.jdbc.Driver,Url=jdbc:mysql://localhost/test,Username=scott,Password=tiger,MaxActive=40""/>

But mixing them as
        <property name=""javax.persistence.jdbc.driver"" value=""org.apache.commons.dbcp.BasicDataSource""/> 
        <property name=""openjpa.ConnectionProperties"" value=""DriverClassName=com.mysql.jdbc.Driver,Url=jdbc:mysql://localhost/test,Username=scott,Password=tiger,MaxActive=40""/>

breaks because dbcp.BasicDataSource.getConnection(user, pwd) throws UnSupportedOperationException
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161623,,,Mon Oct 19 18:41:50 UTC 2009,,,,,,,0|i0yzf3:,202208,,,,,,,,19/Oct/09 18:41;ppoddar@apache.org;Breaks only if initialization is multi-threaded,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Merge fails if an entity has an element collection which is contructed using Arrays.asList,OPENJPA-1352,12438171,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,15/Oct/09 06:50,24/Feb/10 14:07,14/Mar/19 03:02,16/Oct/09 15:28,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,kernel,,,,,,0,,"When an entity has an element collection, which is constructed using Arrays.asList, the following exception is thrown:

java.lang.IllegalAccessError:java.util.Arrays$ArrayList
	at java.lang.ClassLoader.defineClassImpl(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:265)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:202)
	at serp.bytecode.BCClassLoader.findClass(BCClassLoader.java:50)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:643)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:609)
	at java.lang.Class.forNameImpl(Native Method)
	at java.lang.Class.forName(Class.java:169)
	at org.apache.openjpa.util.GeneratedClasses.loadBCClass(GeneratedClasses.java:67)
	at org.apache.openjpa.util.ProxyManagerImpl.getFactoryProxyCollection(ProxyManagerImpl.java:363)
	at org.apache.openjpa.util.ProxyManagerImpl.copyCollection(ProxyManagerImpl.java:182)
	at org.apache.openjpa.kernel.AttachStrategy.copyCollection(AttachStrategy.java:344)
	at org.apache.openjpa.kernel.AttachStrategy.attachCollection(AttachStrategy.java:321)
	at org.apache.openjpa.kernel.AttachStrategy.attachField(AttachStrategy.java:218)
	at org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:153)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:251)
	at org.apache.openjpa.kernel.AttachStrategy.attachField(AttachStrategy.java:202)
	at org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:153)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:251)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:104)
	at org.apache.openjpa.kernel.BrokerImpl.attach(BrokerImpl.java:3322)
	at org.apache.openjpa.kernel.DelegatingBroker.attach(DelegatingBroker.java:1176)
	at org.apache.openjpa.persistence.EntityManagerImpl.merge(EntityManagerImpl.java:858)
",,,,,,,,,,,,,,,,,,,,,,15/Oct/09 07:12;faywang;OPENJPA-1352.patch;https://issues.apache.org/jira/secure/attachment/12422192/OPENJPA-1352.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161621,,,Fri Oct 16 15:27:51 UTC 2009,,,,,,,0|i0z9n3:,203864,,,,,,,,"15/Oct/09 07:12;faywang;Although Arrays.asList returns a List object, its class is Arrays.ArrayList. This is a static private inner class and can only be constructed from within Arrays. During merge/persist, openjpa needs to construct a proxyCollection by instantiating a new List object based on the class type of the original collection. This attempt fails because Arrays.ArrayList can not be loaded/constructed from outside Arrays.

The attached patch is to return null value if the class can not be loaded instead of throwing the exception. A test case will be attached later. ","16/Oct/09 15:27;faywang;A new patch is checked into trunk (r-825700), which captures the exception and tries alternative way to instantiate proxyCollection/Map.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.ClassCastException: javax.naming.Reference incompatible with javax.sql.DataSource,OPENJPA-1351,12438142,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,14/Oct/09 23:30,24/Feb/10 14:07,14/Mar/19 03:02,16/Oct/09 15:23,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,,,,,,,0,,"The following exception is thrown when a downlevel jcc driver is used: 

java.lang.ClassCastException: javax.naming.Reference incompatible with javax.sql.DataSource
at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getConnectionFactory2(Unknown Source)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
at java.lang.reflect.Method.invoke(Unknown Source)
at org.apache.openjpa.lib.conf.ConfigurationImpl.instantiateAll(Unknown Source)
at org.apache.openjpa.conf.OpenJPAConfigurationImpl.instantiateAll(Unknown Source)
at org.apache.openjpa.kernel.AbstractBrokerFactory.makeReadOnly(Unknown Source)
at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(Unknown Source)
at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(Unknown Source)
at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(Unknown Source)
",,,,,,,,,,,,,,,,,,,,,,15/Oct/09 19:22;faywang;OPENJPA-1351.patch;https://issues.apache.org/jira/secure/attachment/12422265/OPENJPA-1351.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161620,,,2009-10-14 23:30:39.0,,,,,,,0|i0z9rb:,203883,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Race condition in the MetaDataRepository,OPENJPA-1350,12438100,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,14/Oct/09 15:58,25/Feb/10 21:44,14/Mar/19 03:02,25/Feb/10 21:07,1.0.3,1.2.1,2.0.0-M3,,,,,,,1.2.3,1.3.0,2.0.0-beta,,,kernel,,,,,,0,,"There is a race condition in the MetaDataRepository where if multiple threads try to get MetaData for the same alias, one or more of the threads can get incorrect data. This can only occur on the first (few) thread(s). After init is complete, the problem does not occur.

The error that is observed is the following:
<openjpa-2.0.0-SNAPSHOT-r422266:824454M fatal user error> org.apache.openjpa.util.MetaDataException: Could not locate metadata for the class using alias ""MdrTestEntity"". Perhap
s you meant MdrTestEntity, which is a close match. This could mean that you have mis-spelled the alias, or that OpenJPA failed to properly load the metadata for the type whose
alias is ""MdrTestEntity"". Registered alias mappings: ""{MdrTestEntity=[class org.apache.openjpa.persistence.meta.MdrTestEntity]}""",,,,,,,,,,,,,,,,,,,,,,11/Nov/09 19:58;fyrewyld;OJ1350_1.0.x.patch;https://issues.apache.org/jira/secure/attachment/12424640/OJ1350_1.0.x.patch,07/Dec/09 19:28;fyrewyld;OPENJPA-1350-1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12427215/OPENJPA-1350-1.2.x.patch,21/Oct/09 16:19;curtisr7;OPENJPA-1350-1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12422820/OPENJPA-1350-1.2.x.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2009-12-07 19:28:23.665,,,no_permission,,,,,,,,,,,161619,,,Mon Dec 07 19:28:23 UTC 2009,,,,,,,0|i0z9s7:,203887,,,,,,,,21/Oct/09 16:19;curtisr7;Attaching a patch which includes a new test case and the code fix for the 1.2.x release.,07/Dec/09 19:28;fyrewyld;Patch for OpenJPA 1.2.x,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compatibility options are not set appropriately for spec level when emf is created by JEE container,OPENJPA-1349,12438038,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,14/Oct/09 03:23,09/Mar/10 18:31,14/Mar/19 03:02,14/Oct/09 04:02,2.0.0-beta,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,13/Oct/09 00:00,0,,"OpenJPA sets default values for compatibility and other config options based upon the persistence level.  This is working properly in a JSE environment, but not in a JEE container.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161618,,,2009-10-14 03:23:13.0,,,,,,,0|i0yxiv:,201901,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Query [get|set]LockMode & Em getLockMode not throwing correct exceptions,OPENJPA-1344,12437821,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,12/Oct/09 00:51,09/Mar/10 18:31,14/Mar/19 03:02,12/Oct/09 20:40,2.0.0-M2,2.0.0-M3,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,"[get|set]LockMode method in Query interface do not throw correct exception per spec.

- No check on the query type and throw IllegalStateException
- Thrown TransactionRequiredException for LockModeType.None. (3.8.8 Queries and Lock Mode....If a lock mode other than NONE is specified for a query, the query must be executed within a transaction or the TransactionRequiredException will be thrown.)

/**
* Set the lock mode type to be used for the query execution.
* @param lockMode
* @return the same query instance
* @throws IllegalStateException if the query is found not to be
* a Java Persistence query language SELECT query
* or a Criteria API query
*/
Query setLockMode(LockModeType lockMode);

-----------------------------

getLockMode method in EntityManager interface do not throw correct exception per spec.

- No check in active transaction and throw TransactionRequiredException
- No check if entity is attached and throw IllegalArgumentException

/**
* Get the current lock mode for the entity instance.
* @param entity
* @return lock mode
* @throws TransactionRequiredException if there is no
* transaction
* @throws IllegalArgumentException if the instance is not a
* managed entity and a transaction is active
*/
public LockModeType getLockMode(Object entity);",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161613,,,2009-10-12 00:51:17.0,,,,,,,0|i1dsin:,288717,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect example of openjpa.Sequence property,OPENJPA-1343,12437810,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jtnowosatka,milosz,milosz,11/Oct/09 11:26,02/Feb/12 16:25,14/Mar/19 03:02,21/Jul/11 21:52,2.0.0,,,,,,,,,2.2.0,,,,,docs,,,,,,0,,"This example in the user manual:

Example 9.9.  System Sequence Configuration
<property name=""openjpa.Sequence"" value=""table(Table=OPENJPASEQ, Increment=100)""/>

gives an exception saying ""table"" is an incorrect alias.
",,,,,,,,,,,,,,,,OPENJPA-1642,,,,,,21/Jul/11 20:48;jtnowosatka;OPENJPA-1343.patch;https://issues.apache.org/jira/secure/attachment/12487352/OPENJPA-1343.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-07-21 16:49:39.886,,,no_permission,,,,,,,,,,,67223,,,Thu Feb 02 16:25:58 UTC 2012,,,,,,,0|i1dsiv:,288718,,,,,,,,21/Jul/11 16:49;jtnowosatka;Attached patch replaces the incorrect example with a working one.,21/Jul/11 21:52;mikedd;Thanks for the patch Jacob. ,02/Feb/12 16:25;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PostRemove not invoked after database record was deleted,OPENJPA-1341,12437651,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,08/Oct/09 21:55,20/Oct/09 04:02,14/Mar/19 03:02,20/Oct/09 04:02,2.0.0,,,,,,,,,2.0.0-beta,,,,,kernel,,,,,,0,,"It has been reported that PostRemove is not invoked after database delete but invoked after flush().
This is in disagreement with JPA 2.0 Spec (Section 3.5.2) which states

""
 1. The PostPersist and PostRemove callback methods are invoked for an entity after the entity has been made persistent or removed. 
 2. These callbacks will also be invoked on all entities to which these operations are cascaded. 
 3. The PostPersist and PostRemove methods will be invoked after the database insert and delete operations respectively. 
     These database operations may occur directly after the persist, merge, or remove operations have been invoked or they 
     may occur directly after a flush operation has occurred (which may be at the end of the transaction). 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161611,,,2009-10-08 21:55:02.0,,,,,,,0|i0z60n:,203277,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Allow comparison for VALUE(e) that maps to basic type,OPENJPA-1338,12437409,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,06/Oct/09 16:10,09/Mar/10 18:31,14/Mar/19 03:02,06/Oct/09 16:33,2.0.0,,,,,,,,,2.0.0-M3,,,,,query,,,,,,0,,"Single persisted entity x with embeddable e.  e has a map of 3 pairs of Integer keys/values (1/100,2/200,3/300).

This query should be allowed...
SELECT e FROM entityTable x JOIN x.mapKeyIntegerEmbed e JOIN e.notMapKeyInteger i WHERE VALUE(i) = 200

OpenJPA complains that ""identifier ""i"" in ""VALUE"" operator is not valid in conditional expression. Per JSR 317, section 4.4.4 this operator is optionally allowed.  
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161608,,,2009-10-06 16:10:54.0,,,,,,,0|i0z6f3:,203342,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Alternating manual delim id tests fail,OPENJPA-1335,12437130,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,dianner,dianner,dianner,02/Oct/09 16:19,22/Apr/10 20:32,14/Mar/19 03:02,24/Mar/10 17:37,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,,,,,,,0,,Some manual delim id test pass initially. but fail on the 2nd and alternating runs. The schema and sequences are not cleaned up and not detected on the alternating runs.,,,,,,,,,,,,,,,,,,,,,,02/Oct/09 16:25;dianner;patch.txt;https://issues.apache.org/jira/secure/attachment/12421121/patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-10-20 16:49:43.05,,,no_permission,,,,,,,,,,,161605,,,Tue Oct 20 16:49:43 UTC 2009,,,,,,,0|i0z7r3:,203558,,,,,,,,"02/Oct/09 16:25;dianner;A previous fix fixed this problem for auto delimiting, but not for manual delimiting. This patch now fixes that.

Note: This is a temporary fix until a more global name solution is implemented.","20/Oct/09 16:49;techhusky;The updates in patch.txt, dated 2009-10-02 04:25 PM, were included in patch auto_delim_id_patch.txt attached to OPENJPA-1115 and got committed as part of revision 827727.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Oracle driver returns incorrect update count on batched insert,OPENJPA-1333,12437036,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,01/Oct/09 16:06,09/Mar/10 18:31,14/Mar/19 03:02,02/Oct/09 16:22,2.0.0-M3,,,,,,,,,2.0.0-M3,,,,,jdbc,,,,,01/Oct/09 00:00,0,,The org.apache.openjpa.persistence.kernel.TestProxies2 jUnit test fails with an OptimisticLockException when using the 10.2.0.4 Oracle JDBC driver.  The source of the failure is that one of the batched insert operations is returning an update count that is less than expected.  There is are no SQL exception or SQL warnings.,Oracle 10g Server.  Oracle 10.2.0.4 JDBC driver.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-10-01 19:00:48.044,,,no_permission,,,,,,,,,,,161603,,,Fri Oct 02 16:22:48 UTC 2009,,,,,,,0|i0yz8v:,202180,,,,,,,,"01/Oct/09 16:13;techhusky;This problem can be corrected by:

- Disabling statement batching by setting the batchLimit to zero.  This has performance implications but produces the correct behavior on the version 10 JDBC driver.  Statement batching can be disabled by setting the following persistence property:

<property name=""openjpa.jdbc.DBDictionary"" value=""batchLimit=0""/>

or

- Using version 11.2.0.1 of the Oracle JDBC driver.  The issue is corrected in this level of JDBC driver.",01/Oct/09 19:00;drwoods;We need to doc this....,01/Oct/09 19:47;techhusky;Agree.  I'll update the Oracle section of the docs.,02/Oct/09 16:22;techhusky;Docs updated under rev 821077.  ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Move cacheable class configuration to ClassMetaData,OPENJPA-1328,12436629,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,fyrewyld,fyrewyld,25/Sep/09 18:38,09/Mar/10 18:31,14/Mar/19 03:02,13/Nov/09 01:37,1.2.0,1.2.1,,,,,,,,1.0.4,1.2.2,1.3.0,2.0.0-beta,,datacache,,,,,,0,,"I'm proposing to move the cacheable class configuration processing from the datacache classes to ClassMetaData.  The feature, introduced in OPENJPA-1045, effectively works by returning null for ClassMetaData.getDataCacheName(), where classes which should not be cached return null, otherwise the name of the datacache they may be cached by is returned.  

THe problem is that some third party datacache plugins are not reentrant, and the existing ClassMetaData.isCacheable() makes use of the method call getRepository().getConfiguration().getDataCacheManagerInstance().  This invokes the initialization of the datacache, which may result in further initialization/copying of CMD objects, which reenter the isCacheable() method.  If a third party datacache plugin is not reentrant safe, this can cause a failure in the form of Exceptions or hung threads.",,,,,,,,,,,,,,,,,,,,,,01/Oct/09 14:17;fyrewyld;OpenJPA_1.2.x_OJ1328.patch;https://issues.apache.org/jira/secure/attachment/12421021/OpenJPA_1.2.x_OJ1328.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-11-12 04:40:47.606,,,no_permission,,,,,,,,,,,161598,,,Thu Nov 12 04:40:47 UTC 2009,,,,,,,0|i0z9ov:,203872,,,,,,,,"01/Oct/09 14:17;fyrewyld;Proposed fix, patch for the 1.2.x stream","12/Nov/09 04:40;ppoddar@apache.org;ClassMetaData is not the right place for holding cache information, imo.
Firstly, for practical use cases, caches are hardly partitioned by types. 
Secondly, the cache eligibility logic may be more user configurable than assigning all instances of a type statically to a single named cache.

DataCacheManager seems to be much better abstraction to implement cache assignment to instances (even if only based on types).
These changes are incorporated in trunk for OPENJPA-1334.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ReverseMappingTool and SchemaTool failing for Sybase,OPENJPA-1326,12436426,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,bjreed,bjreed,bjreed,23/Sep/09 15:42,27/Apr/10 16:20,14/Mar/19 03:02,11/Dec/09 19:08,1.2.1,,,,,,,,,1.2.2,1.3.0,2.0.0-beta,,,sql,,,,,,0,,"invoking the org.apache.openjpa.jdbc.ant.ReverseMappingToolTask or the org.apache.openjpa.jdbc.ant.SchemaToolTask on a Sybase database gives the following stack trace

java.sql.SQLException: S0022: Invalid column name 'TABLE_SCHEM'.
 	at com.sybase.jdbc3.jdbc.ErrorMessage.raiseError(ErrorMessage.java:559)
 	at com.sybase.jdbc3.tds.TdsResultSet.findColumn(TdsResultSet.java:624)
 	at com.sybase.jdbc3.jdbc.SybResultSet.findColumn(SybResultSet.java:602)
	at com.sybase.jdbc3.jdbc.SybResultSet.getString(SybResultSet.java:349)
 	at org.apache.openjpa.jdbc.sql.DBDictionary.newPrimaryKey(DBDictionary.java:3769)
 	at org.apache.openjpa.jdbc.sql.DBDictionary.getPrimaryKeysFromGetPrimaryKeys(DBDictionary.java:3751)
	at org.apache.openjpa.jdbc.sql.DBDictionary.getPrimaryKeys(DBDictionary.java:3728)
 	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generatePrimaryKeys(SchemaGenerator.java:586)
	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generatePrimaryKeys(SchemaGenerator.java:593)
 	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generatePrimaryKeys(SchemaGenerator.java:367)
 	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateSchemas(SchemaGenerator.java:274)
	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateSchemas(SchemaGenerator.java:243)
	at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:1433)
	at org.apache.openjpa.jdbc.ant.SchemaToolTask.executeOn(SchemaToolTask.java:138)
	at org.apache.openjpa.lib.ant.AbstractTask.execute(AbstractTask.java:172)
 	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
	at org.apache.tools.ant.Task.perform(Task.java:364)
	at org.apache.tools.ant.Target.execute(Target.java:341)
 	at org.apache.tools.ant.Target.performTasks(Target.java:369)
	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)
	at org.apache.tools.ant.helper.SingleCheckExecutor.executeTargets(SingleCheckExecutor.java:37)
 	at org.apache.tools.ant.Project.executeTargets(Project.java:1068)
 	at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:382)
	at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.java:107)
 	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
	at org.apache.tools.ant.Task.perform(Task.java:364)
	at org.apache.tools.ant.Target.execute(Target.java:341)
 	at org.apache.tools.ant.Target.performTasks(Target.java:369)
	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)
 	at org.apache.tools.ant.helper.SingleCheckExecutor.executeTargets(SingleCheckExecutor.java:37)
 	at org.apache.tools.ant.Project.executeTargets(Project.java:1068)
 	at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:382)
	at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.java:107)
	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
 	at org.apache.tools.ant.Task.perform(Task.java:364)
 	at org.apache.tools.ant.Target.execute(Target.java:341)
	at org.apache.tools.ant.Target.performTasks(Target.java:369)
	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)
 	at org.apache.tools.ant.Project.executeTarget(Project.java:1185)
 	at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:40)
 	at org.apache.tools.ant.Project.executeTargets(Project.java:1068)
 	at org.apache.tools.ant.Main.runBuild(Main.java:687)
	at org.apache.tools.ant.Main.startAnt(Main.java:200)
 	at org.apache.tools.ant.launch.Launcher.run(Launcher.java:246)
	at org.apache.tools.ant.launch.Launcher.main(Launcher.java:67)

The data looks good from the driver, but when doing the getString calls, it has problems finding the columns that are aliased AS something else (ie, table_owner AS TABLE_SCHEM).  A quick fix is to just use the original column names when getting the data from Sybase.

pk.setSchemaName(pkMeta.getString(""table_owner"")); (search by column name) works, but
pk.setSchemaName(pkMeta.getString(""TABLE_SCHEM"")); (search by column label) does not.

",Sybase,,,,,,,,,,,,,,,OPENJPA-1641,,,,,,23/Sep/09 15:44;bjreed;OPENJPA-1326.patch;https://issues.apache.org/jira/secure/attachment/12420378/OPENJPA-1326.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-09-23 19:08:02.033,,,no_permission,,,,,,,,,,,38524,,,Sat Dec 12 14:45:25 UTC 2009,,,Patch Available,,,,0|i0yyc7:,202033,,,,,,,,"23/Sep/09 15:51;bjreed;Forgot to mention, I have not tried this on trunk yet.","23/Sep/09 19:08;milosz;Rick, have you experimented with Sybase driver properties like BE_AS_JDBC_COMPLIANT_ AS_POSSIBLE
 or GET_BY_NAME_USES_COLUMN_LABEL?
","24/Sep/09 17:24;bjreed;Thanks for the suggestions.

We already had BE_AS_JDBC_COMPLIANT_ AS_POSSIBLE set.  I tried GET_BY_NAME_USES_COLUMN_LABEL, but it still failed to find 'TABLE_SCHEM'

--B.J.","11/Dec/09 19:08;mikedd;Thanks for the patch BJ. Committed in 1.2.x, 1.3.x, and trunk. ","12/Dec/09 14:45;milosz;B.J., Rick, I am sorry, just noticed I confused your names in a previous comment.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Resolution of XML-based embeddable metadata fails during enhancement,OPENJPA-1325,12436419,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,23/Sep/09 14:19,18/Jan/10 19:59,14/Mar/19 03:02,18/Jan/10 19:59,2.0.0-M3,,,,,,,,,2.0.0-M3,,,,,jpa,,,,,23/Sep/09 00:00,0,,"Embeddable meta-data defined in XML may fail to resolve during the enhancement phase in a container environment when all classes are not listed in the pu.  The metadata parser currently defers embedabble metadata population until after the access type of the embeddable is determined.    Instead, the parser should wait until the embeddable is fully resolved before populating value metadata in embedding types since classes may be enhanced in any order.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-09-28 18:36:45.947,,,no_permission,,,,,,,,,,,161596,,,Mon Sep 28 18:36:45 UTC 2009,,,,,,,0|i0yzpr:,202256,,,,,,,,28/Sep/09 18:36;to_rowe;Fix verified on Linux AMD64 with WebSphere web and EJB containers.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Documentation inaccuracies,OPENJPA-1321,12436236,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,milosz,bkalbfus,bkalbfus,21/Sep/09 18:43,09/Mar/10 18:31,14/Mar/19 03:02,10/Oct/09 19:59,1.2.1,,,,,,,,,1.3.0,2.0.0-beta,,,,docs,,,,,,0,,"Example 9.8. Named Seq Sequence:    @SequenceGenerator properties gave me compile errors
@SequenceGenerator(name=""AuthorSeq"" sequence=""table(Table=AUTO_SEQ, Increment=100)"")
should be
@SequenceGenerator (name=""AuthorSeq"", sequenceName=""table(Table=AUTO_SEQ, Increment=100)"")

4.4.3. OracleDictionary Properties:  
According to the logs when I set this up to be not set, 
AutoAssignSequenceName: The global name of the sequence that OpenJPA will assume to hold the value of primary key
value for rows that use auto-increment. If left unset, OpenJPA will use a the sequence named ""SEQ_<table name>"".
should be
AutoAssignSequenceName: The global name of the sequence that OpenJPA will assume to hold the value of primary key
value for rows that use auto-increment. If left unset, OpenJPA will use a the sequence named ""<table name>_<column name>_SEQ"".

",http://openjpa.apache.org/builds/1.2.1/apache-openjpa-1.2.1/docs/manual/manual.pdf,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-10-10 19:59:25.045,,,no_permission,,,,,,,,,,,161593,,,Sat Oct 10 19:59:25 UTC 2009,,,Patch Available,,,,0|i1dskn:,288726,,,,,,,,"10/Oct/09 19:59;milosz;Brian, thanks for the remarks. I have committed the correction to the trunk and 1.3.x branch. Also replaced Increment attribute with allocationSize as Increment has no effect.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
shouldn't always use CAST with UPPER and LOWER for DB2,OPENJPA-1308,12436067,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,bjreed,bjreed,18/Sep/09 14:23,09/Mar/10 18:31,14/Mar/19 03:02,23/Oct/09 17:41,1.0.3,1.2.1,2.0.0-M2,2.0.0-M3,,,,,,1.0.4,1.2.2,1.3.0,2.0.0-beta,,sql,,,,,,0,,"Using DB2, when a user uses the UPPER or LOWER function, the field is automatically CAST to a varchar.  It would be nice if OpenJPA were a little smarter and only used CAST when necessary.  Using the CAST causes any indexes not to be used so performance won't be what it should.

I saw some other DB2 functions that also are always CAST, so we may need to improve these also.",DB2,,,,,,,,,,,,,,,,,,,,,20/Oct/09 16:42;bjreed;OPENJPA-1308-1.0.x.patch;https://issues.apache.org/jira/secure/attachment/12422700/OPENJPA-1308-1.0.x.patch,20/Oct/09 16:42;bjreed;OPENJPA-1308-1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12422701/OPENJPA-1308-1.2.x.patch,20/Oct/09 16:42;bjreed;OPENJPA-1308-trunk.patch;https://issues.apache.org/jira/secure/attachment/12422702/OPENJPA-1308-trunk.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2009-10-23 17:41:58.421,,,no_permission,,,,,,,,,,,38260,,,Fri Oct 23 17:41:58 UTC 2009,,,Patch Available,,,,0|i1dsmv:,288736,,,,,,,,"15/Oct/09 15:06;bjreed;Attached patches to be considered for inclusion to OpenJPA.  No real differences in the patches except that the 1.0.x patch includes a new test case that wasn't already present in 1.0.x (the other 2 just modify the existing test case).

For the most part, the change is that when UPPER or LOWER are used, DB2Dictionary looks to see what the database column is defined as before doing the cast.  In this way, if the column is already a VARCHAR, then indexes would still be used since no cast would be generated.",19/Oct/09 15:09;bjreed;Replacing old patches with new ones...Slightly better ,20/Oct/09 16:42;bjreed;new patches include all changes from code review,"23/Oct/09 17:41;mikedd;Thanks for the patches, BJ. The fix is in the latest SNAPSHOT builds. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Ehcache product derivation isn't detected when running in WebSphere,OPENJPA-1302,12435743,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,15/Sep/09 18:48,09/Mar/10 18:31,14/Mar/19 03:02,15/Sep/09 19:45,1.0.3,1.1.0,1.2.1,2.0.0-M2,,,,,,2.0.0-M3,,,,,lib,,,,,,0,,"I tried to configure Ehcache using the instructions documented on their website [1] and found that using the 'ehcache' alias (for openjpa.QueryCache and openjpa.DataCacheManager) does not work in WAS. It does work when running in a JSE environment.

After digging around for awhile I found that when I added ehcache as an application shared library, those classes were not available to the static initializer in org.apache.openjpa.lib.conf.ProductDerivations. Since the ehcache product derivation wasn't found, the 'ehcache' alias wasn't registered.

[1] http://ehcache.org/documentation/openjpa_provider.html","Win XP, WAS V7.0.0.5",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161575,,,2009-09-15 18:48:53.0,,,,,,,0|i0zau7:,204058,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Query with Escape '\' fails in MySQL,OPENJPA-1295,12435487,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,11/Sep/09 23:10,22/Sep/09 20:14,14/Mar/19 03:02,11/Sep/09 23:17,1.0.3,1.1.0,1.2.1,1.3.0,2.0.0-M2,,,,,2.0.0-M3,,,,,jdbc,,,,,,0,,"The following jpql fails in MySQL: 

Select e from Employee e where e.name LIKE :name ESCAPE '\'

The exception trace:

You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''\')' at line 1 {prepstmnt 1239002810 SELECT t0.empId, t0.hireDate, t0.hireTime, t0.hireTimestamp, t0.name, t0.someLong, t0.statusId FROM SUBQ_EMPLOYEE t0 WHERE (t0.name LIKE ? ESCAPE '\') [params=(String) M\%%]} [code=1064, state=42000]
at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4587)
at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4540)

The test case is org.apache.openjpa.persistence.query.TestQueryEscapeCharacters.testEscapedQuery  
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161568,,,2009-09-11 23:10:43.0,,,,,,,0|i0yx4n:,201837,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Nested JDBC calls fail for certain database,OPENJPA-1294,12435480,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,11/Sep/09 21:59,09/Mar/10 18:31,14/Mar/19 03:02,12/Nov/09 06:38,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,jdbc,kernel,query,sql,,,0,,"Some use cases require a new database connection to perform operation because the current connection is busy/open.
Typical use case is asking for size of the result set (obtained by a SELECT COUNT(*) query) while the original result set is still being open.

Some databases (e.g. MySQL as per observation) do not allow the new COUNT query on the same connection because the original result set is still open.

A JDBCStore.getNewConnection() is added -- but use it with caution, remember to close it and use it only when required.",MySQL,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-09-12 18:28:22.691,,,no_permission,,,,,,,,,,,161567,,,Tue Sep 15 15:05:21 UTC 2009,,,,,,,0|i0zazz:,204084,,,,,,,,"12/Sep/09 18:28;milosz;Hi Pinaki. I guess the databases affected are those with DBDictionary.supportsMultipleNontransactionalResultSets = false. The name suggests that the problem should occur only while using auto-commit.
","15/Sep/09 15:05;milosz;I am reopening since I am afraid that by unconditionally opening a new connection (thus a new transaction) we are unnecessarily increasing chances for deadlock and lowering transaction isolation level in a write intensive environments. See examples below, I have made them using command line SQL clients but JDBC connections usually work the same way:

1. MySQL with REPEATABLE READ isolation (the default for MySQL) - lowering isolation.

Without opening a new connection in SelectImpl.getCount:

OPENJPA TX 1: select * from address where country='USA';
OK, returns 1 row.
OTHER TX 2: insert into address(id, country) values(60, 'USA');
OK.
OTHER TX 2: commit;
OK. (does not block in MySQL)
OPENJPA TX 1: select count(*) from address where country='USA';
OK, returns 1 (thus consistent with result in TX 1)

When opening a new connection in SelectImpl.getCount:

OPENJPA TX 1: select * from address where country='USA';
OK, returns 1 row.
OTHER TX 2: insert into address(id, country) values(60, 'USA');
OK.
OTHER TX 2: commit;
OK. (does not block in MySQL)
OPENJPA TX 3: select count(*) from address where country='USA';
OK, returns 2 (inconsistent with result in TX 1)


2. DB2 with SERIALIZABLE isolation (maybe other databases as well) - possible deadlock.

Without opening a new connection in SelectImpl.getCount:

OPENJPA TX 1: select * from address where country='USA';
OK, returns 1 row.
OTHER TX 2: insert into address(id, country) values(60, 'USA');
Blocks until TX 1 commits.
OPENJPA TX 1: select count(*) from address where country='USA';
OK, returns 1
OPENJPA TX 1: commit
OK
OTHER TX 2: commit
OK

When opening a new connection in SelectImpl.getCount:

OPENJPA TX 1: select * from address where country='USA';
OK, returns 1 row.
OTHER TX 2: insert into address(id, country) values(60, 'USA');
Blocks until TX 1 commits.
OPENJPA TX 3: select count(*) from address where country='USA';
Blocks until TX 2 commits. Means deadlock because TX 1 and 3 are from the same OpenJPA thread.


As you can see the problem boils down to the case when an external data modification occurs in between two OpenJPA transactions.

What do yo think? Am I missing something?

If I am correct, I suggest we try:
1. While in transaction, always use the same connection for SELECT COUNT. I expect databases handle that (needs some tests).

2. While in autocommit, open a new connection but only for databases with DBDictionary.supportsMultipleNontransactionalResultSets = false.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JUnit test failure when using Derby 10.5.3.0,OPENJPA-1293,12435457,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,drwoods,drwoods,drwoods,11/Sep/09 18:58,09/Mar/10 18:31,14/Mar/19 03:02,20/Jan/10 20:48,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,third-party,,,,,,0,,"Only hit one test failure in o-p-j when using Derby 10.5.3.0 -

Tests run: 15, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 9.901 sec <<< FAILURE!
testVariableHaving(org.apache.openjpa.persistence.jdbc.query.TestJDBCGrouping)  Time elapsed: 0.246 sec  <<< ERROR!
<openjpa-2.0.0-SNAPSHOT-r422266:813659M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: Java exception: ': java.lang.NullPointerException'. {SELECT MAX(t0.longField), t2.byteField FROM AllFieldTypes t0 INNER JOIN AllFieldTypes_AllFieldTypes t1 ON t0.id = t1.ALLFIELDTYPES_ID JOIN AllFieldTypes t2 ON (1 = 1) WHERE (t1.SELFONEMANY_ID = t2.id) GROUP BY t2.byteField HAVING SUM(t2.intField) = ?} [code=0, state=XJ001]
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4587)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4540)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:88)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:64)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.handleCheckedException(SelectResultObjectProvider.java:155)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.handleCheckedException(QueryImpl.java:2068)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:40)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1239)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1000)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:856)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:787)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:525)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:291)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:303)
	at org.apache.openjpa.persistence.QueryImpl.getSingleResult(QueryImpl.java:322)
	at org.apache.openjpa.persistence.query.GroupingTestCase.testVariableHaving(GroupingTestCase.java:294)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runTest(AbstractPersistenceTestCase.java:514)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:501)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:477)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:177)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
	at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:345)
	at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009)
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: Java exception: ': java.lang.NullPointerException'. {SELECT MAX(t0.longField), t2.byteField FROM AllFieldTypes t0 INNER JOIN AllFieldTypes_AllFieldTypes t1 ON t0.id = t1.ALLFIELDTYPES_ID JOIN AllFieldTypes t2 ON (1 = 1) WHERE (t1.SELFONEMANY_ID = t2.id) GROUP BY t2.byteField HAVING SUM(t2.intField) = ?} [code=0, state=XJ001]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:248)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$000(LoggingConnectionDecorator.java:70)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:282)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:187)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:155)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:187)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1537)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:176)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:544)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:524)
	at org.apache.openjpa.jdbc.sql.SelectImpl.prepareStatement(SelectImpl.java:450)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:391)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:363)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:427)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:230)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:220)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:94)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.open(QueryImpl.java:2027)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:34)
	... 39 more
NestedThrowables:
java.sql.SQLException: Java exception: ': java.lang.NullPointerException'.
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:95)
	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:142)
	at org.apache.derby.impl.jdbc.Util.javaException(Util.java:299)
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:403)
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2204)
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.<init>(EmbedPreparedStatement.java:147)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement20.<init>(EmbedPreparedStatement20.java:82)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement30.<init>(EmbedPreparedStatement30.java:63)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement40.<init>(EmbedPreparedStatement40.java:40)
	at org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Driver40.java:105)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(EmbedConnection.java:1542)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(EmbedConnection.java:1395)
	at org.apache.commons.dbcp.DelegatingConnection.prepareStatement(DelegatingConnection.java:262)
	at org.apache.commons.dbcp.PoolingDataSource$PoolGuardConnectionWrapper.prepareStatement(PoolingDataSource.java:307)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:189)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:279)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:187)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:155)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:187)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1537)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:176)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:544)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:524)
	at org.apache.openjpa.jdbc.sql.SelectImpl.prepareStatement(SelectImpl.java:450)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:391)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:363)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:427)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:230)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:220)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:94)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.open(QueryImpl.java:2027)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:34)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1239)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1000)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:856)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:787)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:525)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:291)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:303)
	at org.apache.openjpa.persistence.QueryImpl.getSingleResult(QueryImpl.java:322)
	at org.apache.openjpa.persistence.query.GroupingTestCase.testVariableHaving(GroupingTestCase.java:294)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runTest(AbstractPersistenceTestCase.java:514)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:501)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:477)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:177)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
	at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:345)
	at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009)
Caused by: java.sql.SQLException: Java exception: ': java.lang.NullPointerException'.
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:119)
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:70)
	... 72 more
Caused by: java.lang.NullPointerException
	at org.apache.derby.impl.sql.compile.ColumnReference.remapColumnReferencesToExpressions(ColumnReference.java:851)
	at org.apache.derby.impl.sql.compile.AggregateNode.getNewExpressionResultColumn(AggregateNode.java:560)
	at org.apache.derby.impl.sql.compile.GroupByNode.addAggregateColumns(GroupByNode.java:708)
	at org.apache.derby.impl.sql.compile.GroupByNode.addNewColumnsForAggregation(GroupByNode.java:553)
	at org.apache.derby.impl.sql.compile.GroupByNode.addAggregates(GroupByNode.java:240)
	at org.apache.derby.impl.sql.compile.GroupByNode.init(GroupByNode.java:184)
	at org.apache.derby.iapi.sql.compile.NodeFactory.getNode(NodeFactory.java:273)
	at org.apache.derby.impl.sql.compile.SelectNode.genProjectRestrict(SelectNode.java:1305)
	at org.apache.derby.impl.sql.compile.SelectNode.modifyAccessPaths(SelectNode.java:1974)
	at org.apache.derby.impl.sql.compile.DMLStatementNode.optimizeStatement(DMLStatementNode.java:323)
	at org.apache.derby.impl.sql.compile.CursorNode.optimizeStatement(CursorNode.java:556)
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:367)
	at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:88)
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(GenericLanguageConnectionContext.java:802)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.<init>(EmbedPreparedStatement.java:129)
	... 65 more


Results :

Tests in error: 
  testVariableHaving(org.apache.openjpa.persistence.jdbc.query.TestJDBCGrouping)

Tests run: 15, Failures: 0, Errors: 1, Skipped: 0

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161566,,,2009-09-11 18:58:00.0,,,,,,,0|i1dsp3:,288746,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Oracle driver throws exception due to incorrect mapping of XMLType column,OPENJPA-1289,12435247,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,09/Sep/09 19:49,08/Dec/10 14:48,14/Mar/19 03:02,27/Jan/10 16:02,1.2.2,2.0.0-M3,,,,,,,,1.2.3,1.3.0,2.0.0-beta,,,,,,,,,0,,"Many variations of org.apache.openjpa.persistence.xmlmapping.query.TestXMLCustomerOrder are failing on Oracle with this exception:

<openjpa-2.0.0-SNAPSHOT-rexported nonfatal general error> org.apache.openjpa.persistence.PersistenceException: Invalid column type: getCLOB not implemented for class oracle.jdbc.driver.T4CVarcharAccessor
<snip/>
Caused by: java.sql.SQLException: Invalid column type: getCLOB not implemented for class oracle.jdbc.driver.T4CVarcharAccessor
at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:112)
at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:146)
at oracle.jdbc.driver.Accessor.unimpl(Accessor.java:358)
at oracle.jdbc.driver.Accessor.getCLOB(Accessor.java:1328)
at oracle.jdbc.driver.OracleResultSetImpl.getCLOB(OracleResultSetImpl.java:1305)
at oracle.jdbc.driver.OracleResultSetImpl.getClob(OracleResultSetImpl.java:1471)
at org.apache.commons.dbcp.DelegatingResultSet.getClob(DelegatingResultSet.java:515)
at org.apache.openjpa.lib.jdbc.DelegatingResultSet.getClob(DelegatingResultSet.java:612)
at org.apache.openjpa.jdbc.sql.DBDictionary.getClob(DBDictionary.java:690)
at org.apache.openjpa.jdbc.sql.OracleDictionary.getClobString(OracleDictionary.java:562)
at org.apache.openjpa.jdbc.sql.ResultSetResult.getStringInternal(ResultSetResult.java:471)
at org.apache.openjpa.jdbc.sql.ResultSetResult.getObjectInternal(ResultSetResult.java:399)
at org.apache.openjpa.jdbc.sql.AbstractResult.getObject(AbstractResult.java:696)
at org.apache.openjpa.jdbc.meta.strats.HandlerStrategies.loadDataStore(HandlerStrategies.java:220)
at org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy.load(HandlerFieldStrategy.java:186)
at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:913)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1021)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:973)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:393)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:292)
<snip/>
The Oracle driver does not allow the clob operations to operate on fields of XMLType.  OpenJPA maps fields of type XMLType to CLOB and uses CLOB getter/setters, resulting in the exception above.  The mapping should be changed such that the CLOB operations are not used for XML data.",Oracle 10i and 11 server.  10.x and 11.2.0.1.0 thin JDBC driver,,,,,,,,,,,,,,,OPENJPA-1461,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-09-10 18:14:52.745,,,no_permission,,,,,,,,,,,161562,,,Sun Apr 18 19:32:54 UTC 2010,,,,,,,0|i0z90n:,203763,,,,,,,,"10/Sep/09 18:14;milosz;Hello Jeremy. Maybe this problem is revealed by the OPENJPA-525 fix. Before that fix we were unintentionally called get getString on CLOBs, now we are calling getClobString.","09/Jan/10 12:13;milosz;Hi Jeremy. Are you still seeing the failure?

I noticed that for some reason the test case fails at table creation phase because it started adding column length to XMLTYPE:

PersistenceException: ORA-00907: missing right parenthesis
 {stmnt 16108506 CREATE TABLE TORDER (oid NUMBER NOT NULL, amount NUMBER, delivered NUMBER, shipAddress XMLType(255), version NUMBER, CUSTOMER_COUNTRYCODE VARCHAR2(255), CUSTOMER_ID NUMBER, PRIMARY KEY (oid))} [code=907, state=42000]

It helped to add ""XMLTYPE"" to fixedSizeTypeNameSet. After that the test passes (I executed it from Eclipse).

My environment is Java 5, Oracle 10g Express Edition Release 10.2.0.1.0, Oracle JDBC driver 10.2.0.3.0

","15/Jan/10 19:52;milosz;It seems that the CREATE TABLE problem has been resolved by Catalina in OPENJPA-1461.
","27/Jan/10 16:02;techhusky;This problem has been fixed by Catalina under OPENJPA-1461.  Thanks, Milosz for keeping an eye on these issues.",18/Apr/10 19:32;milosz;Applied a similar fix to the 1.3.x branch.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Relationships in mapped superclass must be unidirectional,OPENJPA-1286,12434783,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,faywang,faywang,03/Sep/09 21:49,22/Sep/09 20:11,14/Mar/19 03:02,09/Sep/09 21:28,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,kernel,,,,,,0,,,,,,,,,,,,OPENJPA-1270,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-09-10 16:42:21.247,,,no_permission,,,,,,,,,,,161559,,,Thu Sep 10 16:42:21 UTC 2009,,,,,,,0|i0yz0v:,202144,,,,,,,,"10/Sep/09 16:42;ppoddar@apache.org;Could this check be made at an outer layer?
Having spec version in FieldMetaData does not look good. Should be taken unless we have no other option....",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Fix missing 1.0 schema license headers,OPENJPA-1284,12434676,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,drwoods,drwoods,02/Sep/09 21:19,09/Mar/10 18:31,14/Mar/19 03:02,06/Oct/09 16:43,1.0.3,1.1.0,1.2.1,1.3.0,2.0.0-M3,,,,,1.3.0,2.0.0-M3,,,,third-party,,,,,,0,,"Discovered the Sun license header is not in the included persistence_1_0.xsd and orm_1_0.xsd files as provided by Sun at -
http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd
http://java.sun.com/xml/ns/persistence/orm_1_0.xsd
",,,,,,,,,,,,,,,,,,,,,,02/Sep/09 21:38;drwoods;OPENJPA-1284-13x.patch;https://issues.apache.org/jira/secure/attachment/12418438/OPENJPA-1284-13x.patch,02/Sep/09 21:22;drwoods;OPENJPA-1284-notice.patch;https://issues.apache.org/jira/secure/attachment/12418436/OPENJPA-1284-notice.patch,02/Sep/09 21:22;drwoods;OPENJPA-1284-schemas.patch;https://issues.apache.org/jira/secure/attachment/12418435/OPENJPA-1284-schemas.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,38609,,,Tue Oct 06 16:43:32 UTC 2009,,,Patch Available,,,,0|i0zasf:,204050,,,,,,,,"02/Sep/09 21:22;drwoods;OPENJPA-1284-schemas.patch can be applied to the other branches.
OPENJPA-1284-notice.patch can be applied to trunk and 1.3.0.",02/Sep/09 21:38;drwoods;Patch applied to the 1.3.x branch.,"02/Sep/09 21:38;drwoods;Mike, I'll let you decide on when to apply this to the 1.0.x/1.2.x branches....",06/Oct/09 16:43;drwoods;We can open a new issue for the older branches...,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect SQL for JPQL query selecting Map value from an elementCollection of a Map and the map the value is an embeddable,OPENJPA-1283,12434675,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,02/Sep/09 21:14,09/Mar/10 18:31,14/Mar/19 03:02,03/Sep/09 00:55,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,,,,,,,0,,"SELECT VALUE(f) FROM Policy p, IN (p.funds) f WHERE f.fundName = :fName and p.annuityHolderId = :holderId 

	Where Policy has an ElementCollection as a Map: 

    @ElementCollection(targetClass = Fund.class, fetch=FetchType.EAGER)
    @CollectionTable(name=""POLICY_FUNDS"",joinColumns={@JoinColumn(name=""FK_POLICY_ID"")})
    @MapKeyColumn(name = ""FUND_ID"")
    public Map<Integer, IFund> getFunds() {
        return Funds;
    }

The generated SQL was incorrect:

SELECT t2.id FROM INSPOLICY t0 
    INNER JOIN POLICY_FUNDS t1 ON t0.id = t1.FK_POLICY_ID, 
    INSPOLICY t2 
WHERE (t1.fundName = ? AND t0.FK_ANNUITY_HOLDER_ID = ?)

The correct SQL should projecting out t1.*.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161557,,,Thu Sep 03 00:55:40 UTC 2009,,,,,,,0|i0z933:,203774,,,,,,,,03/Sep/09 00:55;fancy;Fix checked in trunk svn r810744,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Reparameter is not working properly for some sql if PreparedQueryCache is on,OPENJPA-1281,12434574,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,02/Sep/09 01:44,22/Sep/09 20:09,14/Mar/19 03:02,02/Sep/09 15:31,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,jdbc,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161555,,,2009-09-02 01:44:19.0,,,,,,,0|i0yyan:,202026,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Query results are not inserted into StoreCache properly,OPENJPA-1279,12434547,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,01/Sep/09 19:47,22/Sep/09 20:09,14/Mar/19 03:02,16/Sep/09 14:48,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,datacache,,,,,,0,,"Query results aren't being inserted into the datacache properly (bad checking for DataCacheStoreMode in DataCacheStoreManager). 

Adding testcases and updating store manager to handle appropriately. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161553,,,2009-09-01 19:47:30.0,,,,,,,0|i0yyfj:,202048,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The table attribute in the MapKeyColumn annotation is not honored,OPENJPA-1269,12434240,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,28/Aug/09 04:25,22/Sep/09 19:57,14/Mar/19 03:02,28/Aug/09 04:29,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161543,,,2009-08-28 04:25:27.0,,,,,,,0|i0yxuf:,201953,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TestReaderLob.testUpdateWithNull() fails on MySQL,OPENJPA-1263,12433905,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,amy,amy,25/Aug/09 04:33,31/May/10 18:37,14/Mar/19 03:02,12/Dec/09 16:42,1.1.0,1.2.0,1.2.1,1.3.0,,,,,,1.3.0,2.0.0-beta,,,,jdbc,,,,,,0,,"the case failed with:
testUpdateWithNull(org.apache.openjpa.jdbc.meta.strats.TestReaderLob)  Time elapsed: 0.11 sec  <<< FAILURE!
junit.framework.AssertionFailedError
	at junit.framework.Assert.fail(Assert.java:47)
	at junit.framework.Assert.assertTrue(Assert.java:20)
	at junit.framework.Assert.assertNull(Assert.java:233)
	at junit.framework.Assert.assertNull(Assert.java:226)
	at org.apache.openjpa.jdbc.meta.strats.AbstractLobTest.testUpdateWithNull(AbstractLobTest.java:136)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:490)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:466)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:168)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
	at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:345)
	at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009)
","Windows XP
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_14-b03)
MySQL: 5.1.37-community MySQL Community Server (GPL) ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-12-12 16:42:11.005,,,no_permission,,,,,,,,,,,161537,,,Mon May 31 18:37:12 UTC 2010,,,,,,,0|i1dsqf:,288752,,,,,,,,"12/Dec/09 16:42;milosz;Works correctly, probably after changes made under OPENJPA-1248.
","31/May/10 18:37;milosz;The change has been back-ported to branch 1.3.x.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong sequence is generated for custom native sequence generator from getIdGenerator.,OPENJPA-1260,12433797,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,rpalache,rpalache,23/Aug/09 12:25,21/Sep/16 14:21,14/Mar/19 03:02,11/Sep/09 15:07,1.3.0,2.0.0,,,,,,,,1.2.0,1.3.0,2.0.0-M3,,,sql,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,24/Aug/09 20:46;rpalache;OPENJPA-1260-trunk.patch;https://issues.apache.org/jira/secure/attachment/12417522/OPENJPA-1260-trunk.patch,23/Aug/09 12:50;rpalache;OPENJPA-1260-trunk.patch;https://issues.apache.org/jira/secure/attachment/12417398/OPENJPA-1260-trunk.patch,07/Dec/09 05:12;rpalache;openJPA-1260_1.1.x.patch;https://issues.apache.org/jira/secure/attachment/12427136/openJPA-1260_1.1.x.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2009-08-24 14:45:50.391,,,no_permission,,,,,,,,,,,37809,,,Mon Dec 14 16:57:09 UTC 2009,,,Patch Available,,,,0|i1dsqn:,288753,,,,,,,,"23/Aug/09 12:46;rpalache;OpenJPAEntityManager.getIdGenerator.next() fails to generate correct sequence number when class uses native sequence geneartor.

The cause of the issue is OpenJPAEntityManager.getIdGenerator.next() goes against the default sequence openjpa_sequence rather than the defined sequence.
So the SQL on openjpaentitymanager.getIdGenerator.next() is 
SELECT SEQUENCE_VALUE FROM OPENJPA_SEQUENCE_TABLE WHERE ID = ? FOR UPDATE
even though a native sequence generator is defined.

@Id
    @GeneratedValue(strategy=GenerationType.SEQUENCE, 
        generator=""entityE2_seq_gen_name"")
    @SequenceGenerator(name=""entityE2_seq_gen_name"", 
                       sequenceName=""entityE2_seq_gen"")
    private int id;",23/Aug/09 12:50;rpalache;Testcase & Fix.,"24/Aug/09 14:45;mikedd;Hi Ravi,

The patch looks good but I'd recommend moving the testcase to a different package, org.apache.openjpa.persistence.jdbc.sequence or just org.apache.openjpa.persistence.sequence. The testcase isn't using delimited identifiers so it'd be a bit misleading to put it in that package. 

Otherwise the patch looks great. ",24/Aug/09 17:43;rpalache;Uploaded patch with new package and class name.,"11/Sep/09 15:06;drwoods;Modified patch committed to trunk by Kevin Sutter in r813597 and back ported to 1.3.0 by Donald Woods in r813868.
","11/Sep/09 15:07;drwoods;Mike, please reopen if you want to apply this to 1.2.x or 1.0.x.
",14/Dec/09 16:57;dezzio;Applied Ravi's 1.1.x patch at revision 890402,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
get java.lang.ClassCastException when IdClass contains an Enum Field,OPENJPA-1256,12433510,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,19/Aug/09 21:04,22/Sep/09 19:54,14/Mar/19 03:02,20/Aug/09 18:28,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,kernel,,,,,,0,,"Suppose EntityA and EntityB are defined as follows:

@Entity
class EntityA {
   @Id
    int id;
  
   @OneToOne(fetch=fetchType=LAZE)
   EntityB entityB;
   
   ...
}

@Entity
@IdClass(BId.class)
class EntityB {

    @Id
    int intId;

   @Id
    BType bType;
...

    public enum BType { A1, A2, A3, A4 };
     ...
}


ClassCast Exception is thrown in the following situation:

    EntityA a = em.find(EntityA.class, 1)
    EntityB b = a.getEntityB();


",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161531,,,Wed Aug 19 21:34:20 UTC 2009,,,,,,,0|i0z8zb:,203757,,,,,,,,"19/Aug/09 21:34;faywang;The specific ClassCastException is:

java.lang.ClassCastException: BType cannot be cast to 
org.apache.openjpa.util.ObjectId
   
test.EntityB.pcCopyKeyFieldsToObjectId(EntityB.java) 
org.apache.openjpa.enhance.PCRegistry.copyKeyFieldsToObjectId(PCRegistry.java:172)

org.apache.openjpa.util.ApplicationIds.fromPKValues(ApplicationIds.java:219)  

org.apache.openjpa.jdbc.meta.ClassMapping.getObjectId(ClassMapping.java:216)
   
org.apache.openjpa.jdbc.meta.ClassMapping.getObjectId(ClassMapping.java:147)
   
org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:934)
   
org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:280)
   
org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2349)
org.apache.openjpa.jdbc.meta.strats.RelationToManyInverseKeyFieldStrategy.loadElement(RelationToManyInverseKeyFieldStrategy.java:87)
org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.load(StoreCollectionFieldStrategy.java:554)
    org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:919)
   
org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:641)
   
org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
    org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
   
org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:3035)
   
org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:3113)
   
org.apache.openjpa.kernel.StateManagerImpl.beforeAccessField(StateManagerImpl.java:1606)
   
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JoinColumn annotation not allowed in conjunction with *ToMany annotation,OPENJPA-1253,12433473,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,curtisr7,curtisr7,19/Aug/09 15:18,11/Oct/11 10:49,14/Mar/19 03:02,28/Sep/09 16:22,2.0.0-M1,2.0.0-M2,2.0.0-M3,,,,,,,2.0.0-M3,,,,,jdbc,,,,,,0,,"I receive the following exception if I have an Entity with a One(Many)ToMany relationship with another Entity. 

<openjpa-2.0.0-SNAPSHOT-r422266:805588 fatal user error> org.apache.openjpa.persistence.ArgumentException: You have supplied columns for ""....Entity"", but this mapping cannot have columns in this context.

To recreate the failure, add a @JoinColumn annotation to one of the *ToMany relationships in org.apache.openjpa.persistence.jdbc.annotations.AnnoTest1. 
example:
    @MapKey(name = ""basic"")
    @OneToMany(mappedBy = ""oneManyOwner"")
    @JoinColumn(name = ""asdf"")
    protected Map<String, AnnoTest2> inverseOwnerMapKey = new HashMap();

Then run:
trunk\openjpa-parent\openjpa-persistence-jdbc>mvn test -Dtest=org.apache.openjpa.persistence.jdbc.annotations.TestOneToMany",,,,,,,,,,,,,,,,OPENJPA-1607,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-09-15 17:31:06.532,,,no_permission,,,,,,,,,,,59107,,,Tue Oct 11 10:49:21 UTC 2011,,,,,,,0|i0zbxj:,204235,,,,,,,,"15/Sep/09 17:31;faywang;According to JPA 2.0 spec (Section 11.1.21), 

The table in which the JoinColumn annotion is found depends upon the context. 
(1) If the join is for a OneToOne or ManyToOne mapping using a foreign key mapping strategy, the foreign key column is in the table of the source entity or embeddable. 

(2) If the join is for a unidirectional OneToMany mapping using a foreign key mapping strategy, the foreign key is in the table of the target entity. 

(3) If the join is for a ManyToMany mapping or for a one-to-one or bidirectional 
ManyToOne/OneToMany mapping using a join table, the foreign key is in a join table. 

(4) If the join is for an element collection, the foreign key is in a collection table.

In comparison to the JPA 1.0 spec (Section 9.1.6):
The table in which it is found depends upon the context. 
(1) If the join is for a OneToOne or Many-ToOne mapping, the foreign key column is in the table of the source entity. 

(2) If the join is for a ManyToMany, the foreign key is in a join table.

The JoinColumn annotation in v2.0 apparently becomes more flexible as it is allowed to  appear for a OneToMany mapping. ","17/Sep/09 17:11;faywang;JPA 2.0 supports non-default mapping (sec 2.9): 

""In addition, this specification also requires support for the following alternative mapping strategies: the mapping of unidirectional one-to-many relationships by means of foreign key mappings; the mapping of unidirectional and bidirectional one-to-one relationships, bidirectional many-to-one/one-to-many relationships, and unidirectional many-to-one relationships by means of join table mappings. The JoinColumn and JoinTable annotations or corresponding XML elements must be used to specify such non-default mappings. See sections 11.1.21 and 11.1.23.""

For *toMany relation, the non-default and default mappings, according to the spec, are:

(1) uni-/OneToMany/foreign key strategy 
(2) uni-/OneToMany/join table strategy (default)
(3) bi-/OneToMany/foreign key strategy (default)
(4) bi-/OneToMany/join table strategy 
(5) uni-/ManyToMany/join table strategy (default)
(6) bi-/ManyToMany/join table strategy (default)

For (1), the spec provides the following example (Sec 11.1.36):
Example 3: Unidirectional One-to-Many association using a foreign key mapping
In Customer class:
@OneToMany(orphanRemoval=true)
@JoinColumn(name=""CUST_ID"") // join column is in table for Order
public Set<Order> getOrders() {return orders;}

For (4), Bi-directional One-to-Many association using the join table mapping
In Customer class:
@OneToMany(mappedBy=""customer"")
    @JoinTable(
        name=""Customer_Orders"",
        joinColumns=
          @JoinColumn(name=""Order_ID"", referencedColumnName=""ID""),
         inverseJoinColumns=
          @JoinColumn(name=""Cust_ID"", referencedColumnName=""ID"")
    )

public Set<Order> getOrders() {return orders;}

Note that in this scenario, @JoinTable is required. Simply applying @JoinColumn without @JoinTable will result in an exception thrown by openjpa.

Similarly for ManyToMany mapping, @JoinTable is required as shown by the example in the spec (11.1.25). Simply applying @JoinColumn will fail with an exception:
@ManyToMany
@JoinTable(
    name=""CUST_PHONE"",
    joinColumns=
       @JoinColumn(name=""CUST_ID"", referencedColumnName=""ID""),
    inverseJoinColumns= 
       @JoinColumn(name=""PHONE_ID"", referencedColumnName=""ID"")
)
public Set<PhoneNumber> getPhones() { return phones; }

The failing example provided in this JIRA is not valid:
    @MapKey(name = ""basic"")
    @OneToMany(mappedBy = ""oneManyOwner"")
    @JoinColumn(name = ""asdf"")
    protected Map<String, AnnoTest2> inverseOwnerMapKey = new HashMap();

This is a bi-directional OneToMany assocation. If the default foreign key strategy is intended, no JoinColumn annotation should be applied. If the non-default join table strategy is intened, the JoinTable annotation should be applied.",18/Sep/09 22:21;faywang;Create/Update/Delete/Find for the non-default OneToMany mapping is in r-816795. The findBy operation of the owner side (which has ManyToOne relation) for bi-/OneToMany/foreignKey mapping still fails.,"19/Sep/09 16:13;fs5;> Create/Update/Delete/Find for the non-default OneToMany

Please also consider this use case:

Model: Person --> * Address (unidirectional, one-to-many, join-column)
public class Person {
	@OneToMany(cascade = CascadeType.ALL)
	@JoinColumn(name = ""PERSON_ID"")
	private List<Address> addresses = new ...
}

Use-case:
Person p1 = em.find(Person.class, new Long(1));
Address a = p1.getAddresses.remove(0);
Person p2 = new Person();
p2.getAddresses().add(a);
em.persist(p2)


Currently it throws:

2234  default  TRACE  [main] openjpa.jdbc.SQL - <t 13101223, conn 12437939> executing prepstmnt 32053837 SELECT TEST.PERSON_SEQ.NEXTVAL FROM DUAL
2235  default  TRACE  [main] openjpa.jdbc.SQL - <t 13101223, conn 12437939> [0 ms] spent
2341  default  TRACE  [main] openjpa.jdbc.SQL - <t 13101223, conn 19396509> executing prepstmnt 620055 UPDATE TEST.Address SET PERSON_ID = ? WHERE id = ? [params=(null) null, (long) 2]
2342  default  TRACE  [main] openjpa.jdbc.SQL - <t 13101223, conn 19396509> [1 ms] spent
2342  default  TRACE  [main] openjpa.Runtime - An exception occurred while ending the transaction.  This exception will be re-thrown.
<openjpa-2.0.0-SNAPSHOT-r422266:816795 fatal store error> org.apache.openjpa.util.StoreException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2249)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2096)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1994)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1912)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1436)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:895)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:557)
	at oopex.openjpa2.jpa2.relationships.OneToManyUnidirectionalJoinColumnMain.shuffle(OneToManyUnidirectionalJoinColumnMain.java:157)
	at oopex.openjpa2.jpa2.relationships.OneToManyUnidirectionalJoinColumnMain.main(OneToManyUnidirectionalJoinColumnMain.java:59)
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:816795 fatal user error> org.apache.openjpa.util.InvalidStateException: Attempt to set column ""Address.PERSON_ID"" to two different values: (null)""null"", (class java.lang.Long)""2"" This can occur when you fail to set both sides of a two-sided relation between objects, or when you map different fields to the same column, but you do not keep the values of these fields in synch.
	at org.apache.openjpa.jdbc.sql.PrimaryRow.setObject(PrimaryRow.java:344)
	at org.apache.openjpa.jdbc.sql.RowImpl.flushJoinValues(RowImpl.java:289)
	at org.apache.openjpa.jdbc.sql.RowImpl.flushForeignKey(RowImpl.java:222)
	at org.apache.openjpa.jdbc.sql.RowImpl.setForeignKey(RowImpl.java:197)
	at org.apache.openjpa.jdbc.sql.PrimaryRow.setForeignKey(PrimaryRow.java:172)
	at org.apache.openjpa.jdbc.meta.strats.RelationToManyInverseKeyFieldStrategy.updateInverse(RelationToManyInverseKeyFieldStrategy.java:334)
	at org.apache.openjpa.jdbc.meta.strats.RelationToManyInverseKeyFieldStrategy.insert(RelationToManyInverseKeyFieldStrategy.java:204)
	at org.apache.openjpa.jdbc.meta.strats.RelationToManyInverseKeyFieldStrategy.insert(RelationToManyInverseKeyFieldStrategy.java:190)
	at org.apache.openjpa.jdbc.meta.FieldMapping.insert(FieldMapping.java:608)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.insert(AbstractUpdateManager.java:230)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.populateRowManager(AbstractUpdateManager.java:162)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:95)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:76)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:677)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	... 9 more


Persisting the p2-object before transferring the address-object or issuing a em.flush() before transferring the address-object will not bring up the error.","21/Sep/09 16:25;faywang;Frank, Thank you for your comment. Your example shows a uni-directional one-to-many using foreign key strategy. I will take a look at this problem. ",21/Sep/09 20:24;faywang;The fix for the exception reported by Frank is checked into openjpa-trunk r-817399.,"12/Feb/10 17:52;daringazz;Is there an equivalent fix for version 1.2.1? i have encountered the same issue there.

Example:

public class BaseLog{
        @OneToMany(fetch=EAGER)
	@JoinColumn(name=""PROVIDER_ID"", referencedColumnName=""CODIGOMICO"")
	private Set<RufteEnte> rufteEnte;
....
}

public class RufteEnte implements Serializable {
	private static final long serialVersionUID = 1L;

	@Id
	private long id;

	private String codigomico;
...
}

java.lang.AssertionError: Exception:<openjpa-1.2.1-r752877:753278 fatal user error> org.apache.openjpa.persistence.ArgumentException: You have supplied columns for ""org.venture.jpa.BaseLog.rufteEnte"", but this mapping cannot have columns in this context.
	at org.junit.Assert.fail(Assert.java:91)
	at org.venture.jpa.TestBaseLogDAO.testGetBaseLog(TestBaseLogDAO.java:17)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:73)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:46)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:180)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:41)
	at org.junit.runners.ParentRunner$1.evaluate(ParentRunner.java:173)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:220)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:46)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)

","12/May/10 15:08;kwakeroni;Jimmy,

I believe there is no fix for versions 1.* because the JPA 1.0 standard does not seem to support JoinColumn on a OneToMany. (See Fay Wang's initial comment).

I also have this problem because I have moved from another JPA implementation that does support this, but that is against the standard.","19/Apr/11 08:48;deryaaltuntas;I am using open JPA 2.1.0 .I am receiving same error
 <openjpa-2.1.0-r422266:1071316 fatal user error> org.apache.openjpa.persistence.ArgumentException: You have supplied columns for ""com.siemens.EntityBean.DBAccessManager.Role.authorizations"", but this mapping cannot have columns in this context.
	at org.apache.openjpa.jdbc.meta.MappingInfo.assertNoSchemaComponents(MappingInfo.java:382)
	at org.apache.openjpa.jdbc.meta.strats.RelationToManyInverseKeyFieldStrategy.map(RelationToManyInverseKeyFieldStrategy.java:120)
	at org.apache.openjpa.jdbc.meta.strats.RelationCollectionInverseKeyFieldStrategy.map(RelationCollectionInverseKeyFieldStrategy.java:95)
	at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:146)
	at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:82)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:496)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:461)
	at org.apache.openjpa.jdbc.meta.ClassMapping.resolveMapping(ClassMapping.java:854)
	at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1801)
	at org.apache.openjpa.meta.MetaDataRepository.processBuffer(MetaDataRepository.java:822)
	at org.apache.openjpa.meta.MetaDataRepository.resolveMapping(MetaDataRepository.java:777)
	at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:657)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:411)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:384)
	at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:283)
	at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:254)
	at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:222)
	at org.apache.openjpa.enhance.ManagedClassSubclasser.prepareUnenhancedClasses(ManagedClassSubclasser.java:134)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.loadPersistentTypes(AbstractBrokerFactory.java:315)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.initializeBroker(AbstractBrokerFactory.java:239)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:213)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:156)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:227)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:154)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:60)
	at org.jboss.jpa.deployment.ManagedEntityManagerFactory.getNonTxEntityManager(ManagedEntityManagerFactory.java:72)
	at org.jboss.jpa.deployment.ManagedEntityManagerFactory.getTransactionScopedEntityManager(ManagedEntityManagerFactory.java:171)
	at org.jboss.jpa.deployment.PersistenceUnitDeployment.getTransactionScopedEntityManager(PersistenceUnitDeployment.java:178)
	at org.jboss.jpa.impl.tx.TransactionScopedEntityManager.getEntityManager(TransactionScopedEntityManager.java:262)
	at org.jboss.jpa.impl.tx.TransactionScopedEntityManager.find(TransactionScopedEntityManager.java:191)
	at com.siemens.EntityBean.DBAccessManager.UserService.find(UserService.java:22)
	at com.siemens.SessionBean.FileManager.FileManagerBean.printUsers(FileManagerBean.java:86)
	at com.siemens.SessionBean.FileManager.FileManagerBean.copyFile(FileManagerBean.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)","19/Apr/11 08:48;deryaaltuntas;I am using open JPA 2.1.0 .I am receiving same error
 <openjpa-2.1.0-r422266:1071316 fatal user error> org.apache.openjpa.persistence.ArgumentException: You have supplied columns for ""com.siemens.EntityBean.DBAccessManager.Role.authorizations"", but this mapping cannot have columns in this context.
	at org.apache.openjpa.jdbc.meta.MappingInfo.assertNoSchemaComponents(MappingInfo.java:382)
	at org.apache.openjpa.jdbc.meta.strats.RelationToManyInverseKeyFieldStrategy.map(RelationToManyInverseKeyFieldStrategy.java:120)
	at org.apache.openjpa.jdbc.meta.strats.RelationCollectionInverseKeyFieldStrategy.map(RelationCollectionInverseKeyFieldStrategy.java:95)
	at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:146)
	at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:82)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:496)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:461)
	at org.apache.openjpa.jdbc.meta.ClassMapping.resolveMapping(ClassMapping.java:854)
	at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1801)
	at org.apache.openjpa.meta.MetaDataRepository.processBuffer(MetaDataRepository.java:822)
	at org.apache.openjpa.meta.MetaDataRepository.resolveMapping(MetaDataRepository.java:777)
	at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:657)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:411)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:384)
	at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:283)
	at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:254)
	at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:222)
	at org.apache.openjpa.enhance.ManagedClassSubclasser.prepareUnenhancedClasses(ManagedClassSubclasser.java:134)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.loadPersistentTypes(AbstractBrokerFactory.java:315)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.initializeBroker(AbstractBrokerFactory.java:239)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:213)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:156)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:227)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:154)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:60)
	at org.jboss.jpa.deployment.ManagedEntityManagerFactory.getNonTxEntityManager(ManagedEntityManagerFactory.java:72)
	at org.jboss.jpa.deployment.ManagedEntityManagerFactory.getTransactionScopedEntityManager(ManagedEntityManagerFactory.java:171)
	at org.jboss.jpa.deployment.PersistenceUnitDeployment.getTransactionScopedEntityManager(PersistenceUnitDeployment.java:178)
	at org.jboss.jpa.impl.tx.TransactionScopedEntityManager.getEntityManager(TransactionScopedEntityManager.java:262)
	at org.jboss.jpa.impl.tx.TransactionScopedEntityManager.find(TransactionScopedEntityManager.java:191)
	at com.siemens.EntityBean.DBAccessManager.UserService.find(UserService.java:22)
	at com.siemens.SessionBean.FileManager.FileManagerBean.printUsers(FileManagerBean.java:86)
	at com.siemens.SessionBean.FileManager.FileManagerBean.copyFile(FileManagerBean.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)","25/Aug/11 16:00;mikedd;Sorry this is a late reply. 

I ran across this problem too. Check the version for the xsd in your persistence.xml file. If it's set to 1.0 I got an error similar to the one you posted. If you change the version to 2.0 you should get past the problem. ","11/Sep/11 07:22;koenr;Checked the version in persistence.xml, and in orm.xml, both are 2.0, yet specyfing a join-column tag in a OneToMany relationship still throws the above error in OpenJPA 2.1.1 (r422266).","11/Oct/11 10:49;andras;for anyone who is google-ing this, i got the same exception despite being on the 2.0 spec, the problem was the entity referred in the relationship was not listed in persistence.xml..

<class>package.RelatedEntity</class>",,,,,,,,,,,,,,,,,,,,,,,,
@ElementCollection with eagar fetch of a List<String> collection is causing a ClassCastException on a em.find(entity).,OPENJPA-1250,12433250,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,faywang,faywang,17/Aug/09 16:44,19/Aug/09 16:20,14/Mar/19 03:02,17/Aug/09 18:53,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161526,,,2009-08-17 16:44:47.0,,,,,,,0|i0z6if:,203357,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
LOB streaming does not work as expected,OPENJPA-1248,12433149,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,milosz,milosz,milosz,15/Aug/09 11:04,31/May/10 18:35,14/Mar/19 03:02,21/Mar/10 10:27,1.1.0,1.2.0,1.2.1,1.2.2,1.3.0,,,,,1.3.0,2.0.0-beta3,,,,jdbc,,,,,,0,,"TestReaderLob does not pass with any of the databases indicated in the test case: Oracle, MySQL, PostgreSQL, SQL Server. TestInputStreamLob passes only with MySQL and PostgreSQL.","Oracle, MySQL, PostgreSQL, SQL Server",,,,,,,,,,,,OPENJPA-1263,,,,,,,,,25/Aug/09 04:00;amy;TestReaderLob_oracle.log;https://issues.apache.org/jira/secure/attachment/12417566/TestReaderLob_oracle.log,15/Aug/09 11:07;milosz;failures.txt;https://issues.apache.org/jira/secure/attachment/12416658/failures.txt,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-08-25 04:00:59.496,,,no_permission,,,,,,,,,,,161524,,,Mon May 31 18:35:28 UTC 2010,,,,,,,0|i0zbqn:,204204,,,,,,,,15/Aug/09 11:07;milosz;Sample stack traces attached.,25/Aug/09 04:00;amy;similar error on oracle,"22/Sep/09 19:16;milosz;Some Oracle-specific antidote for this problem has been committed in OPENJPA-1249.
","27/Sep/09 09:46;milosz;Removed dead OracleDictionary.insertBlobForStreamingLoad(Row row, Column col, Object ob).","09/Nov/09 20:47;techhusky;These tests are two of the few remaining failures in the o-j-p project when running on Oracle.  (Version XE/10 using the 11.2.0.1 driver)  I found a few issues and came up with a couple of options for fixing them.

First, when inserting a LOB OpenJPA currently inserts a null value into the LOB column.  When this value is retrieved from the result set (res.getBlob) it is null - and not an updatable blob.  This is currently causing an NPE.  If an Oracle empty_[b,c]lob() is inserted, the rs will return an updatable lob.  However, this changes behavior a bit since null != empty and some of the test assertions that assert a persistent stream attribute is NULL will fail.  Another option is to continue to insert a NULL value then when doing the update, create a temporary lob (using Oracle APIs) and do the update.  I've found this to be troublesome - especially when connection pooling is used - since the Oracle APIs assert that the connection they are provided is an Oracle connection.  I put together a DBCP/JDBC 4 reflection-based solution but it is cumbersome.   Worse yet, DBCP requires a special property be set to get access to the underlying connection.

I think the cleanest solution would be to use empty_lob() and change the behavior of the tests to expect an empty stream when using Oracle.  A hybrid solution would handle cases where an existing value is null...  but this might be overkill.

The second issue (after correcting the first) was that the test was failing with an exception indicating that the connection is closed when reading from the updated BLOB.  This issue is related to OpenJPA connection management and the need for Oracle streaming LOBs to maintain an open connection.  The issue was corrected on Oracle by setting the property openjpa.ConnectionRetainMode=transaction, indicating that em should use the same connection for the duration of the transaction.  Some applications may need to use mode ""always"", depending on transactional patterns and when the LOB is accessed - but that can result in an inefficient use of connections in a pooled environment.  This needs to be documented in the OpenJPA manual as part of this JIRA.  Unfortunately, this did not correct similar test failures on SQL Server.  SQL Server will require additional investigation.

Unless someone(s) is/are in strong disagreement, I'll be committing code to trunk which fixes the Oracle failures by using empty_[c,b]lob() instead of inserting null. The tests will be modified to assert that the stream is empty (instead of null) when running with Oracle.  I'll also attach a patch to OPENJPA-1249 (since the patch is Oracle specific) that uses native Oracle methods to handle null LOBs as an alternative solution.  Finally, the Oracle section of the manual will be updated to include the ConnectionRetainMode requirement for streaming LOBs.  ","10/Nov/09 08:49;milosz;Hi Jeremy! I have a thought for the first Oracle issue. Have you considered a solution similar to the one we use when handling non-streaming CLOBs with Oracle? I mean OracleDictionary.getClobString method: we use isEmptyLob() from Oracle API and return null if the CLOB is actually empty. Is this what you are referring to as a potential overkill?
",10/Nov/09 15:30;techhusky;Hi Milosz.  Thanks for your comments.  Excellent suggestion.  It sparked a new idea that does not require messy reflection code or changing external behavior.  I'm going to give it a try and will post a patch if it works out.  Stay tuned...,"10/Nov/09 18:10;techhusky;I committed a partial fix for Oracle under revision 834564. With the exception of adding the ConnectionRetainMode setting to the test config, the tests pass as-is (ie. expected behavior is unchanged). I also doc'd the ConnectionRetainMode requirement in the Oracle section of the manual.

One potential issue may still remain. If a LOB column contains a null (ex. inserted by an external application) and OpenJPA tries to update that value a failure may still result. The cumbersome patch I submitted for OpenJPA-1249 will handle that case, but I have a more direct approach in mind that uses SQL instead of native APIs.","10/Nov/09 20:15;milosz;Well done, a small aikido-like fix in OracleDictionary :)

I am currently trying to fix the PostgreSQL issues.
","11/Nov/09 11:46;milosz;Using Reader with PostgreSQL is questionable because their Large Object API supports binary streams only. I was thinking of emulating Reader but the amount of changes made me be in favour of just documenting that only InputStream can be used with PostgreSQL. The Reader support could be added if demand surfaces.

Another PostgreSQL quirk is similar to Oracle API problems. We cast Connection to PGConnection which fails if the Connection is wrapped, for example, by DBCP. Currently the TestInputStreamLob passes when run without pooling (e.g. from an IDE) but not with the test suite (which uses DBCP).


","12/Nov/09 16:40;techhusky;Hi Milosz.  I agree.  It my not be worth the risk and/or effort if a huge number of changes are required to support Reader, especially given there hasn't been a request to support it on PostgreSQL.  It might be a fun exercise, though.  :-)

Take a look at my patch for OPENJPA-1249.  The bit of code that gets an underlying DBCP connection could be split out into a utility class and put to use for the PostgreSQL streaming support.  The patch also includes a pom update with the connection property setting required to access the underlying DBCP connection.  ","01/Dec/09 21:17;milosz;I have updated PostgresDictionary with Jeremy's ideas on connection unwrapping. Now the test passes with DBCP and PostgreSQL.

I will also update the user manual.
","20/Dec/09 14:27;milosz;The problem with SQL Server is that an InputStream obtained from ResultSet.getBinaryStream can't be used after its result set is closed. OpenJPA closes the ResultSet before user has a chance to read from the InputStream.

I am investigating these ideas:
1. Using ResultSet.getBlob.getBinaryStream instead of ResultSet.getBinaryStream.
2. Proxying the ResultSet to defer its closing.
","27/Dec/09 10:48;milosz;Looking closer at MySQL reveals its limitations. When reading LOB contents, the whole contents are actually brought into memory. Chances are this can be worked around in:
1. MySQLDictionary.getLOBStream / getCharacterStream.
2. Modifying column list in SELECT.

Details can be found in MySQL docs [1]. For now I have added a note on the limitation to the user manual.

Not sure whehter a similar limitation exists when writing LOB contents to the database.

[1] http://dev.mysql.com/doc/refman/5.1/en/connector-j-reference-implementation-notes.html
","03/Jan/10 18:07;milosz;Modified SQLServerDictionary to use ResultSet.getBlob.getBinaryStream (and its CLOB counterpart). Unfortunately, this poses a problem similar to the one with MySQL - when reading LOB contents, the whole contents are actually brought into memory. Added a note on the limitation to the user manual.

ResultSet.getBinaryStream provides true streaming but suffers from the problem described earlier.

I did not check whether streaming actually takes place when writing LOB contents to the database. Also, I tried only MS 2.0 driver.

Now the LOB streaming tests pass with all 4 databases.
",21/Mar/10 10:27;milosz;Resolving since the tests now pass. Further work can be continued in a new issue for post 2.0 versions.,"31/May/10 18:35;milosz;The change has been back-ported to branch 1.3.x.
",,,,,,,,,,,,,,,,,,,,
Activation profiles should be more inclusive,OPENJPA-1244,12432995,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,13/Aug/09 14:42,13/Aug/09 15:03,14/Mar/19 03:02,13/Aug/09 15:03,1.0.3,,,,,,,,,1.0.4,,,,,build / infrastructure,,,,,,0,,"The build configuration for the jdk5 modules in 1.0.x should be activated for and JDK >= 1.5, not just 1.5.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161520,,,2009-08-13 14:42:08.0,,,,,,,0|i1dst3:,288764,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
migrate Informix functionality from 1.2 to 1.0.x,OPENJPA-1243,12432986,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,mikedd,bjreed,bjreed,13/Aug/09 13:05,22/Apr/10 20:32,14/Mar/19 03:02,13/Aug/09 15:04,1.0.4,,,,,,,,,1.0.4,,,,,jdbc,,,,,,0,,"The following JIRAs need to be migrated back to the 1.0 line so that Informix can be used.  These fixes went into 1.2.0 and are stable.

https://issues.apache.org/jira/browse/OPENJPA-605
https://issues.apache.org/jira/browse/OPENJPA-606
https://issues.apache.org/jira/browse/OPENJPA-629

I have combined the 3 JIRA's into one patch to make the update easier.",Informix for OpenJPA 1.0,,,,,,,,,,,,OPENJPA-605,OPENJPA-606,OPENJPA-629,,,,,,,13/Aug/09 13:06;bjreed;OPENJPA-1243.patch.patch;https://issues.apache.org/jira/secure/attachment/12416436/OPENJPA-1243.patch.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-08-13 15:04:44.697,,,no_permission,,,,,,,,,,,38613,,,Thu Aug 13 15:04:44 UTC 2009,,,Patch Available,,,,0|i0yvov:,201604,,,,,,,,13/Aug/09 15:04;mikedd;Thanks for the patch B.J. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unable to cascade delete an entity in an embeddable,OPENJPA-1242,12432914,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,faywang,faywang,12/Aug/09 21:41,13/Aug/09 16:02,14/Mar/19 03:02,13/Aug/09 16:02,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,kernel,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-08-13 15:17:12.115,,,no_permission,,,,,,,,,,,161519,,,Thu Aug 13 15:17:12 UTC 2009,,,,,,,0|i0yz5z:,202167,,,,,,,,13/Aug/09 15:17;drwoods;2.0.0-M3 includes I10 work,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Explicit access type set incorrectly within collection of embeddable with nested embeddable,OPENJPA-1239,12432817,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,11/Aug/09 19:53,09/Mar/10 18:31,14/Mar/19 03:02,09/Sep/09 19:35,2.0.0-M3,,,,,,,,,2.0.0-M3,,,,,jpa,,,,,12/Aug/09 00:00,0,,OpenJPA does not set the appropriate access type (explicit field or property) when a nested embeddable is used within an element collection of the nesting embeddable.  ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161516,,,2009-08-11 19:53:29.0,,,,,,,0|i0z9t3:,203891,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Make AllowFailure configurable,OPENJPA-1234,12432636,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,09/Aug/09 20:38,23/Mar/10 18:33,14/Mar/19 03:02,04/Mar/10 16:11,,,,,,,,,,2.0.0-beta3,,,,,build / infrastructure,,,,,,0,,"The Allowfailure annotation dumps the stack of any exceptions which occur. There are currently a lot of classes / methods which use AllowFailure and this leads to a large log file filled with exceptions which are not particularly informative. 

AllowFailure should be configurable so that the tests may be skipped or at least no log misleading information. ",,0,0,,0%,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161511,,,2009-08-09 20:38:17.0,,,,,,,0|i0z96n:,203790,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Keys in an EmbeddedCollection are returned as PCData objects when DataCache is enabled,OPENJPA-1232,12432553,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,07/Aug/09 19:34,09/Mar/10 15:53,14/Mar/19 03:02,07/Aug/09 21:32,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,datacache,,,,,,0,,"A mapping like this fails when a DataCache is in use: 

    @ElementCollection
    private Map<Embeddable, Embeddable> embeddableMap;

The keyset contains PCData instances instead of Embeddables.",,0,0,,0%,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161509,,,Fri Aug 07 21:32:29 UTC 2009,,,,,,,0|i0yyo7:,202087,,,,,,,,07/Aug/09 21:32;mikedd;Fixed in svn revision 802211,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
javax.persistence.validation.mode property in createEMF map failed to create emf,OPENJPA-1230,12432427,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,06/Aug/09 17:28,11/Aug/09 14:01,14/Mar/19 03:02,11/Aug/09 01:35,2.0.0-M3,,,,,,,,,2.0.0-M3,,,,,validation,,,,,,0,,"Per spec 3.6.1.1 Enabling Automatic Validation
...... the validation mode can be specified using the javax.persistence.validation.mode map key, which will override the value specified (or defaulted) in the persistence.xml file. The map values for this key are ""auto"", ""callback"", ""none"".

Using lower case validation mode value as javax.persistence.validation.mode key in createEntityManagerFactory failed to create a emf with the following exception.

188  Basic_OvrNone_JSE  ERROR  [main] openjpa.Runtime - Failed to create a provider for ""Basic_JSE"".
java.lang.IllegalArgumentException: No enum const class javax.persistence.spi.ValidationMode.callback
        at java.lang.Enum.valueOf(Enum.java:207)
        at org.apache.openjpa.persistence.PersistenceUnitInfoImpl.setValidationMode(PersistenceUnitInfoImpl.java:544)
        at org.apache.openjpa.persistence.PersistenceUnitInfoImpl.fromUserProperties(PersistenceUnitInfoImpl.java:319)
        at org.apache.openjpa.persistence.PersistenceProductDerivation$ConfigurationParser.endElement(PersistenceProductDerivation.java:698)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.endElement(XMLMetaDataParser.java:456)
        at org.apache.xerces.parsers.AbstractSAXParser.endElement(Unknown Source)
        at org.apache.xerces.impl.xs.XMLSchemaValidator.endElement(Unknown Source)
        at org.apache.xerces.impl.XMLNSDocumentScannerImpl.scanEndElement(Unknown Source)
        at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source)
        at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)
        at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)
        at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)
        at org.apache.xerces.parsers.XMLParser.parse(Unknown Source)
        at org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source)
        at org.apache.xerces.jaxp.SAXParserImpl$JAXPSAXParser.parse(Unknown Source)
        at org.apache.xerces.jaxp.SAXParserImpl.parse(Unknown Source)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parseNewResource(XMLMetaDataParser.java:393)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:334)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:311)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:284)
        at org.apache.openjpa.persistence.PersistenceProductDerivation$ConfigurationParser.parse(PersistenceProductDerivation.java:634)
        at org.apache.openjpa.persistence.PersistenceProductDerivation.parseResources(PersistenceProductDerivation.java:438)
        at org.apache.openjpa.persistence.PersistenceProductDerivation.load(PersistenceProductDerivation.java:405)
        at org.apache.openjpa.persistence.PersistenceProductDerivation.load(PersistenceProductDerivation.java:223)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:90)
        at com.ibm.websphere.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:73)
        at com.ibm.websphere.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:43)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:140)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:63)
        at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:152)
        at suite.r80.base.jpaspec.validation.basic.JSE_BasicTest.setupTestEnvironmentModeBasicOvrCallback(JSE_BasicTest.java:446)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-08-11 14:01:48.667,,,no_permission,,,,,,,,,,,161507,,,Tue Aug 11 14:01:48 UTC 2009,,,,,,,0|i1ds1j:,288640,,,,,,,,"11/Aug/09 14:01;drwoods;Fix went into Iteration 10, so it should be marked as fixed in 2.0.0-M3 which we are going to release after I10 is done....",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SQL generation error when using data cache,OPENJPA-1227,12432298,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,david minor,david minor,05/Aug/09 16:26,09/Mar/10 18:31,14/Mar/19 03:02,14/Sep/09 15:58,1.2.1,,,,,,,,,1.3.0,2.0.0-M3,,,,datacache,jdbc,sql,,,,0,,"When the DataCacheStoreManager loads an object whose (table join strategy) superclass contains an eager to-many field, and this is the only field selected in the superclass, and when one or more fields are selected in the subclass, openjpa fails to create a join between the subclass and superclass.",,,,,,,,,,,,,,,,,,,,,,05/Aug/09 16:52;david minor;openjpa_superclass_join.patch;https://issues.apache.org/jira/secure/attachment/12415627/openjpa_superclass_join.patch,01/Sep/09 19:02;david minor;test-abstract-hierarchy-with-cache.patch;https://issues.apache.org/jira/secure/attachment/12418283/test-abstract-hierarchy-with-cache.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-09-14 15:58:08.137,,,no_permission,,,,,,,,,,,161504,,,Mon Sep 14 15:58:08 UTC 2009,,,Patch Available,,,,0|i0zbqf:,204203,,,,,,,,05/Aug/09 16:28;david minor;See http://n2.nabble.com/SQL-generation-error-td3379974.html for some discussion.,"05/Aug/09 16:52;david minor;The attached patch forces a join to the superclass table in the specific circumstances that I'm seeing the bug. However,

 1. The join is added to the base mapping select, but I am guessing it would be best to put it in the eager select only.
 2. While it only gets applied in the specific case I'm seeing, I don't understand the code well enough to know that it won't get applied in other cases which my application doesn't cover.

Hopefully someone who understands this code better can use this patch to figure out what's triggering this particular bug, and come up with a more robust solution.",01/Sep/09 19:02;david minor;Test case patch against 1.2.1 which demonstrates the issue. Fetch groups turned out to be key to recreating.,"14/Sep/09 15:58;drwoods;Committed to trunk as r814706.
Committed to 1.3.x as r814712.

Mike/David, please reopen if you want to apply to other branches.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA MySQL BigDecimal ignoring Precision/Scale column Annotation when generating tables ,OPENJPA-1224,12432116,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,crispyoz,crispyoz,04/Aug/09 01:57,16/Oct/12 20:39,14/Mar/19 03:02,22/Dec/09 16:39,1.2.1,,,,,,,,,1.3.0,2.0.0-beta,,,,jpa,,,,,,1,,"Create an entity with a BigDecimal member. Using runtime enhancement and automatic schema generation. When OpneJPA creates the table it creates a column of type DECIMAL but will always ignore the precision set on the column annotation and use the default of (10,0) causing BigDecimal data to round up to the nearest whole number.

Sample of basic Entity:

@Entity
public class Asset implements Serializable{
	private static final long serialVersionUID = 1L;

	@Id
        @GeneratedValue(strategy=SEQUENCE, generator=""ASSET_SEQ"")
	private String uniqueid;

	@Column(precision=10,scale=6,)
	private BigDecimal rate;
     

	public Asset() {
		this.rate = rate;
	}

	public void setRate(BigDecimal rate) {
		this.rate = rate;
	}

	public BigDecimal getRate() {
		return rate;
	}
}

Code to generate schema and save entity:

Asset asset = new Asset();
asset.setRate(BigDecimal bd = new BigDecimal(100.004));

Now called persist/merge on the entity to generate the table schema and save the entity. The table is generated and the ""rate"" column is set to type DECIMAL(10,0) instead of DECIMAL(10,6). The table create script looks like this:
DROP TABLE IF EXISTS `trm`.`asset`;
CREATE TABLE  `trm`.`asset` (
  `uniqueid` varchar(255) NOT NULL,
  `rate` decimal(10,0) NOT NULL,
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

doubles work ok.
","OpenJPA 1.2.1, MySQL 5.1.32 (InnoDB), ",,,,,,,,,,,,,,,OPENJPA-213,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-09-25 15:09:47.86,,,no_permission,,,,,,,,,,,161501,,,Mon Dec 28 18:36:32 UTC 2009,,,,,,,0|i0a4xb:,57071,,,,,,,,"25/Sep/09 15:09;jorgeu;I have the same problem when using hibernate as my JPA provider.
It seems that both projects doesn't include money handlers test cases.

By now i'm editing the database schema by hand after automatic table creation occurs.",22/Dec/09 16:39;curtisr7;The original issue reported by this JIRA has been fixed in trunk and 1.3.x.,"28/Dec/09 18:36;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Change openjpa-integration module pom's to reflect proper artifact-id,OPENJPA-1221,12432086,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,03/Aug/09 20:14,09/Mar/10 18:31,14/Mar/19 03:02,17/Aug/09 15:44,2.0.0,,,,,,,,,2.0.0-M3,,,,,build / infrastructure,,,,,,0,,"Minor updates to the openjpa-integration pom files to contain the proper artifact-id.  This will help with the automatic creation of projects via the m2 (maven2) eclipse plugin.  Discussed on Dev forum [1]...  This change is in preparation for another integration set of tests for the L2 cache.

[1]  http://n2.nabble.com/openjpa-integration-td3365002.html#a3365002",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-08-17 15:44:30.543,,,no_permission,,,,,,,,,,,161498,,,Mon Aug 17 15:44:30 UTC 2009,,,,,,,0|i0zavr:,204065,,,,,,,,17/Aug/09 15:44;drwoods;looks like all applicable work is done.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cache.evict(Clazz) should remove subclasses as well,OPENJPA-1218,12431940,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,kwsutter,kwsutter,31/Jul/09 21:44,09/Mar/10 18:31,14/Mar/19 03:02,31/Jul/09 22:54,2.0.0,2.0.0-M1,2.0.0-M2,,,,,,,2.0.0-M3,,,,,datacache,,,,,,0,,"This problem was discovered while working a separate issue with the EHCache plugin developer (Craig Andrews).  The complete exchange can be found on this EHCache bug tracker [1].  According to the latest JPA 2.0 spec, the contract for Cache.evict(Clazz) is as follows:

/**
* Remove the data for entities of the specified class (and its
* subclasses) from the cache.
*/
public void evict(Class cls);

But, we are not removing the subclasses.  We need to change our implementation of Cache.evict(Clazz) to be consistent with the spec.

Also, as we were digging into this area of the code, the internal OpenJPA DataCache implementation of the removeAllInternal(Clazz, boolean) method is not taking the boolean into account.  We should correct this implementation at the same time.

Thanks,
Kevin





[1]  https://sourceforge.net/tracker/index.php?func=detail&aid=2828752&group_id=93232&atid=603559",,0,0,,0%,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161495,,,2009-07-31 21:44:50.0,,,,,,,0|i0zavj:,204064,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Ensure comparisons do not contain two parameters with Derby (ie SELECT ... WHERE ? = ?),OPENJPA-1217,12431899,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,mikedd,mikedd,31/Jul/09 13:52,22/Sep/09 19:52,14/Mar/19 03:02,27/Aug/09 22:09,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,jdbc,,,,,,0,,"The problem appears to be Derby specific and can be seen by running o.a.o.p.c.TestTypesafeCriteria.testTrue() and testFalse(). 

It's not related to criteria - the problem exists in the JPQL query. I believe I've seen this issue before but couldn't find it in JIRA. The relevant stack traces follow: 

Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:799520 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: It is not allowed for both operands of '=' to be ? parameters. {SELECT t0.id, t0.DTYPE, t0.name FROM CR_PSN t0 WHERE (? = ?)} [code=30000, state=42X35]
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4554)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4507)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:88)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:64)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.handleCheckedException(SelectResultObjectProvider.java:155)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:40)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1232)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:993)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:849)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:780)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:525)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:287)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:299)
	at org.apache.openjpa.persistence.criteria.CriteriaTest.executeQueryAndCollectSQL(CriteriaTest.java:379)
	... 23 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: It is not allowed for both operands of '=' to be ? parameters. {SELECT t0.id, t0.DTYPE, t0.name FROM CR_PSN t0 WHERE (? = ?)} [code=30000, state=42X35]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:245)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$000(LoggingConnectionDecorator.java:69)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:279)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:188)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:156)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:188)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1519)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:177)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:530)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:510)
	at org.apache.openjpa.jdbc.sql.SelectImpl.prepareStatement(SelectImpl.java:450)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:391)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:363)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:427)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:230)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:220)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:94)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:34)
	... 31 more
",Derby Embedded,0,0,,0%,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-08-27 22:09:20.59,,,no_permission,,,,,,,,,,,161494,,,Thu Aug 27 22:09:20 UTC 2009,,,,,,,0|i0z62n:,203286,,,,,,,,27/Aug/09 22:09;ppoddar@apache.org;See OPENJPA-1013,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Enable string navigation in a From expression.,OPENJPA-1211,12431808,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,30/Jul/09 14:35,09/Mar/10 15:55,14/Mar/19 03:02,31/Jul/09 22:01,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,,,,,,,0,,From and Root expressions need their own implementation of public <Y> Path<Y> get(String attName) to produce a path when using the string based API. ,,0,0,,0%,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161488,,,2009-07-30 14:35:03.0,,,,,,,0|i0yxyf:,201971,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bean validation call to provider not Java 2 Enabled,OPENJPA-1206,12431718,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,29/Jul/09 17:10,06/Aug/09 17:32,14/Mar/19 03:02,01/Aug/09 14:30,2.0.0,2.0.0-M2,,,,,,,,2.0.0-M3,,,,,validation,,,,,,0,,"With Java 2 security enabled, Bean validation processing caused following security violation exception.

java.security.AccessControlException: Access denied (java.lang.RuntimePermission accessDeclaredMembers)
	at java.security.AccessController.checkPermission(AccessController.java:108)
	at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)
	at com.ibm.ws.security.core.SecurityManager.checkPermission(SecurityManager.java:211)
	at java.lang.SecurityManager.checkMemberAccess(SecurityManager.java:1664)
	at java.lang.Class.checkMemberAccess(Class.java:109)
	at java.lang.Class.getDeclaredMethods(Class.java:673)
.........  BV provider call path........
	at org.apache.openjpa.persistence.validation.ValidatorImpl.validate(ValidatorImpl.java:289)
	at org.apache.openjpa.validation.ValidatingLifecycleEventManager.fireEvent(ValidatingLifecycleEventManager.java:122)
	at org.apache.openjpa.kernel.BrokerImpl.fireLifecycleEvent(BrokerImpl.java:788)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2538)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2390)
	at org.apache.openjpa.kernel.DelegatingBroker.persist(DelegatingBroker.java:1039)
	at org.apache.openjpa.persistence.EntityManagerImpl.persist(EntityManagerImpl.java:692)

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161484,,,Sat Aug 01 14:29:36 UTC 2009,,,,,,,0|i0z93j:,203776,,,,,,,,"30/Jul/09 01:18;allee8285;Encountered another code path that requires doPriv.

java.lang.ExceptionInInitializerError
	at java.lang.J9VMInternals.initialize(J9VMInternals.java:222)
    ..... provider code path......
	at javax.validation.Validation.buildDefaultValidatorFactory(Validation.java:45)
	at org.apache.openjpa.persistence.validation.ValidatorImpl.getDefaultValidatorFactory(ValidatorImpl.java:395)
	at org.apache.openjpa.persistence.validation.ValidatorImpl.initialize(ValidatorImpl.java:130)
	at org.apache.openjpa.persistence.validation.ValidatorImpl.<init>(ValidatorImpl.java:102)
	at org.apache.openjpa.persistence.validation.ValidationUtils.setupValidation(ValidationUtils.java:99)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.loadValidator(PersistenceProviderImpl.java:270)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:181)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:63)
	at com.ibm.ws.jpa.management.JPAPUnitInfo.createEMFactory(JPAPUnitInfo.java:1561)
	at com.ibm.ws.jpa.management.JPAPUnitInfo.createEntityManagerFactory(JPAPUnitInfo.java:1333)
	at com.ibm.ws.jpa.management.JPAPxmlInfo.extractPersistenceUnits(JPAPxmlInfo.java:490)
	at com.ibm.ws.jpa.management.JPAScopeInfo.processPersistenceUnit(JPAScopeInfo.java:140)
	at com.ibm.ws.jpa.management.JPAApplInfo.processModulePUs(JPAApplInfo.java:169)
	at com.ibm.ws.jpa.management.JPAComponentImpl.startingDeployedModule(JPAComponentImpl.java:878)
	at com.ibm.ws.jpa.management.JPAComponentImpl.stateChanged(JPAComponentImpl.java:722)
	at com.ibm.ws.runtime.component.ApplicationMgrImpl.stateChanged(ApplicationMgrImpl.java:1072)
	at com.ibm.ws.runtime.component.DeployedApplicationImpl.fireDeployedObjectEvent(DeployedApplicationImpl.java:1296)
	at com.ibm.ws.runtime.component.DeployedModuleImpl.setState(DeployedModuleImpl.java:216)
	at com.ibm.ws.runtime.component.DeployedModuleImpl.start(DeployedModuleImpl.java:616)
	at com.ibm.ws.runtime.component.DeployedApplicationImpl.start(DeployedApplicationImpl.java:938)
	at com.ibm.ws.runtime.component.ApplicationMgrImpl.startApplication(ApplicationMgrImpl.java:723)
	at com.ibm.ws.runtime.component.ApplicationMgrImpl.start(ApplicationMgrImpl.java:2044)
	at com.ibm.ws.runtime.component.CompositionUnitMgrImpl.start(CompositionUnitMgrImpl.java:437)
	at com.ibm.ws.runtime.component.CompositionUnitImpl.start(CompositionUnitImpl.java:122)
	at com.ibm.ws.runtime.component.CompositionUnitMgrImpl.start(CompositionUnitMgrImpl.java:380)
	at com.ibm.ws.runtime.component.CompositionUnitMgrImpl.access$300(CompositionUnitMgrImpl.java:108)
	at com.ibm.ws.runtime.component.CompositionUnitMgrImpl$CUInitializer.run(CompositionUnitMgrImpl.java:935)
	at com.ibm.wsspi.runtime.component.WsComponentImpl$_AsynchInitializer.run(WsComponentImpl.java:349)
	at com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1554)
Caused by: java.security.AccessControlException: Access denied (java.lang.RuntimePermission createClassLoader)
	at java.security.AccessController.checkPermission(AccessController.java:108)
	at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)
	at com.ibm.ws.security.core.SecurityManager.checkPermission(SecurityManager.java:212)
	at java.lang.SecurityManager.checkCreateClassLoader(SecurityManager.java:594)
	at java.lang.ClassLoader.<init>(ClassLoader.java:143)
	at java.lang.ClassLoader.<init>(ClassLoader.java:124)
    ..... provider code path......
	at java.lang.J9VMInternals.initializeImpl(Native Method)
	at java.lang.J9VMInternals.initialize(J9VMInternals.java:200)
	... 32 more
","01/Aug/09 14:29;allee8285;Changes are committed under svn r799155 and r799013. 

Due to incorrect comment prefix (i.e. OENJPA-1206), these changes are not being logged in this JIRA's ""committed version"" history.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Cannot retrieve Map<PersistenceCapable, PersistenceCapable> fields when DataCache is on",OPENJPA-1205,12431715,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,sdroscher,sdroscher,29/Jul/09 17:04,22/Apr/10 20:32,14/Mar/19 03:02,23/Mar/10 01:06,1.2.1,,,,,,,,,2.0.0-M3,,,,,datacache,,,,,,0,,"Consider the following mapping, which uses a Map of a PC class to another PC class:

@OneToMany(targetEntity = CatalogProductPriceImpl.class, cascade = { CascadeType.ALL })
@MapKey(name = ""catalog"")
public Map<Catalog, CatalogPrice> getCatalogPrices() {
  return catalogPrices;
}

With the DataCache on, when a product is retrieved for the first time, this map will be correct. However, the next time it is retrieved (i.e. from the cache), what is returned is a Map<LongId, CatalogPrice> not the expected Map<Catalog, CatalogPrice>.

The attached patch resolves this issue.",,,,,,,,,,,,,,,,,,,,,,29/Jul/09 18:08;sdroscher;EntityToEntityMapFix.patch;https://issues.apache.org/jira/secure/attachment/12414929/EntityToEntityMapFix.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-07-29 18:49:52.104,,,no_permission,,,,,,,,,,,38612,,,Tue Mar 23 01:06:27 UTC 2010,,,Patch Available,,,,0|i0z7sv:,203566,,,,,,,,"29/Jul/09 17:05;sdroscher;OPENJPA-589 fixes a similar issue with the value of the map, but the error can still occur with the key of the map.","29/Jul/09 18:49;drwoods;Can you attach a patch that adds or modifies an existing junit testcase to demonstrate the original failure?
","22/Mar/10 20:17;drwoods;Does the fix for OPENJPA-1232 in 2.0.0-M3 or later resolve this issue?
","22/Mar/10 22:21;sdroscher;The fix in OPENJPA-1232 is essentially the same change as that in my patch to this issue. So yes, it does appear to resolve this issue.",23/Mar/10 01:06;drwoods;Fixed by OPENJPA-1232 in r802211,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Argument type mismatch when an EmbeddedId contains an Emun type ,OPENJPA-1204,12431662,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,29/Jul/09 05:40,19/Aug/09 16:15,14/Mar/19 03:02,29/Jul/09 19:59,,,,,,,,,,2.0.0-M3,,,,,jdbc,,,,,,0,,"Caused by: java.lang.IllegalArgumentException: argument type mismatch
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.openjpa.enhance.Reflection.set(Reflection.java:761)
	at org.apache.openjpa.kernel.ObjectIdStateManager.setValue(ObjectIdStateManager.java:741)
	at org.apache.openjpa.kernel.ObjectIdStateManager.store(ObjectIdStateManager.java:508)
	at org.apache.openjpa.jdbc.meta.strats.EmbedValueHandler.toObjectValue1(EmbedValueHandler.java:254)
	at org.apache.openjpa.jdbc.meta.strats.EmbedValueHandler.toObjectValue(EmbedValueHandler.java:202)
	at org.apache.openjpa.jdbc.meta.strats.ObjectIdValueHandler.toObjectValue(ObjectIdValueHandler.java:77)
	at org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy.getPrimaryKeyValue(HandlerFieldStrategy.java:330)
	at org.apache.openjpa.jdbc.meta.ClassMapping.getObjectId(ClassMapping.java:188)
	at org.apache.openjpa.jdbc.meta.ClassMapping.getObjectId(ClassMapping.java:147)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:934)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:280)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2349)
	at org.apache.openjpa.jdbc.meta.strats.RelationToManyInverseKeyFieldStrategy.loadElement(RelationToManyInverseKeyFieldStrategy.java:87)
	at org.apache.openjpa.jdbc.meta.strats.RelationCollectionInverseKeyFieldStrategy.loadElement(RelationCollectionInverseKeyFieldStrategy.java:76)
	at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.load(StoreCollectionFieldStrategy.java:555)
	at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:919)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:641)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:3035)
	at org.apache.openjpa.kernel.StateManagerImpl.load(StateManagerImpl.java:451)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:971)
",,,,,,,,,,,,,,,,,,,,,,29/Jul/09 06:55;faywang;patch.txt;https://issues.apache.org/jira/secure/attachment/12414851/patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161483,,,2009-07-29 05:40:52.0,,,,,,,0|i0yy1b:,201984,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JPA2 - createEMF should return null for unhandled PUs,OPENJPA-1203,12431654,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,drwoods,drwoods,drwoods,29/Jul/09 01:43,09/Mar/10 18:31,14/Mar/19 03:02,05/Oct/09 21:07,2.0.0,,,,,,,,,2.0.0-M3,,,,,docs,,,,,,0,,"JPA2 spec section 9.2 states - ""If a provider does not qualify as the provider for the named persistence unit, it must return null when createEntityManagerFactory is invoked on it.""
But OpenJPA is throwing exceptions for all failure cases...
For now, we'll keep the 1.x behavior, but may need to revisit this when we start running the JPA2 TCK.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161482,,,Mon Oct 05 21:07:07 UTC 2009,,,,,,,0|i1ds3b:,288648,,,,,,,,29/Jul/09 01:44;drwoods;Also see discussion thread http://n2.nabble.com/JPA2---When-should-createEMF%28%29-return-an-Exception-vs.-NULL--tp3312130p3312130.html,05/Oct/09 18:29;drwoods;Doc this as an OpenJPA behavior...,"05/Oct/09 20:58;drwoods;View r820390 of the geronimo-jpa_2.0_spec code for the implemented createEMF() behavior for handling exceptions -
http://svn.apache.org/viewvc/geronimo/specs/trunk/geronimo-jpa_2.0_spec/src/main/java/javax/persistence/Persistence.java?view=markup&pathrev=820390

Basically, even if a provider returns an exception, we'll still give any other provider on the classpath a chance, as required by the JPA 2.0 spec.
If one exception is returned and no provider can return a EMF, then that exception is returned as the cause within a PersistenceException, so apps can use getCause() to determine the provider returned failure.
If more than one exception is returned and no provider can return a EMF, then the exceptions are added to the end of the PersistenceException message and no cause will be set.
Even if one or more providers return an exception, if a provider does return a EMF, then all exceptions will be discarded and the EMF will be returned to the caller.
If no exceptions occur and no EMF can be returned, then a PersistenceException will be thrown with a generic message and list of providers discovered.
",05/Oct/09 21:07;drwoods;mentioned in Migration section of docs using r822006,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""Mapped by"" field not set when contained in superclass ",OPENJPA-1201,12431617,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,david minor,david minor,28/Jul/09 18:17,09/Mar/10 18:31,14/Mar/19 03:02,14/Sep/09 14:52,1.2.0,1.2.1,,,,,,,,1.3.0,2.0.0-M3,,,,jdbc,,,,,,0,,"The mapped by field (inverse relation) is not set when the field is contained in a superclass. In my case the problem was with a collection of objects of the same type (i.e. a hierarchy), and using parallel eager fetch mode, but I think the problem may be more general.

I tracked the problem to the setMappedBy() method in JDBCStoreManager, which is calling getDeclaredFieldMappings(), but the result of this call doesn't include superclass field mappings. Changing it to getFieldMappings() fixed the problem.",,,,,,,,,,,,,,,,,,,,,,28/Jul/09 18:18;david minor;openjpa_superclass_collection.patch;https://issues.apache.org/jira/secure/attachment/12414776/openjpa_superclass_collection.patch,01/Sep/09 16:53;david minor;test-abstract-class-inverse-relation.patch;https://issues.apache.org/jira/secure/attachment/12418263/test-abstract-class-inverse-relation.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-09-14 14:30:38.831,,,no_permission,,,,,,,,,,,161480,,,Mon Sep 14 14:52:28 UTC 2009,,,Patch Available,,,,0|i0zbpz:,204201,,,,,,,,28/Jul/09 18:18;david minor;Patch against 1.2.1,01/Sep/09 16:53;david minor;Test case patch against 1.2.1 which demonstrates the issue.,14/Sep/09 14:30;drwoods;Committed to trunk as r814662.,14/Sep/09 14:51;drwoods;Committed to 1.3.x as r814673.,"14/Sep/09 14:52;drwoods;Mike/David, please reopen if you'd like to apply the patch to other branches.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect Entity is returned if ElementClassCriteria is not selected.,OPENJPA-1200,12431612,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,rpalache,rpalache,rpalache,28/Jul/09 17:45,21/Sep/16 14:21,14/Mar/19 03:02,21/Aug/09 20:37,2.0.0-M2,,,,,,,,,1.2.0,2.0.0-M3,,,,,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,21/Aug/09 13:22;rpalache;OPENJPA-1200_trunk.patch;https://issues.apache.org/jira/secure/attachment/12417270/OPENJPA-1200_trunk.patch,07/Dec/09 05:10;rpalache;openJPA-1200_1.1.x.patch;https://issues.apache.org/jira/secure/attachment/12427133/openJPA-1200_1.1.x.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-08-21 20:37:54.832,,,no_permission,,,,,,,,,,,161479,,,Mon May 24 02:56:40 UTC 2010,,,Patch Available,,,,0|i0z0z3:,202460,,,,,,,,28/Jul/09 18:15;rpalache;Attached patch contains testcase and a potential fix.,"28/Jul/09 18:23;rpalache;Ref: http://n2.nabble.com/ClasscastException-when-ClassCrietria-is-not-used.-td3290568.html#a3290568

I have an openJPA application with following entities:

""Item"" Entity with SINGLE_TABLE inheritance strategy.
 DiscriminatorColumn on this ITEM_TYPE.

""Book"" and ""Movie"" entities extend ""Item."" 

Book has Many to One relation with Artist.
Movie has Many to One relation with Artist.

""artist.getBooks()"" results in rows that contain both ""Book"" and""Movie""  hence I get the following classcast :
Exception in thread ""main"" java.lang.ClassCastException: org.apache.openjpa.enhance.model$Movie$pcsubclass 

I think artist.getBooks() returning Movie is a BUG and hence opened this JIRA.


","29/Jul/09 04:18;rpalache;With attached patch, TestFinderCache is failing.

I will look into it and will try to fix it.",30/Jul/09 17:49;rpalache;Test case only.,16/Aug/09 08:40;rpalache;Testcase with Fix.,"21/Aug/09 13:22;rpalache;Attached patch makes the fixed behavior as default ( as it is a bug).
If users need to have the old behavior then they can use 
compatibility property superclassDiscriminatorStrategyByDefault=false.",21/Aug/09 20:37;mikedd;Thanks for the patch Ravi.,12/Dec/09 00:54;dezzio;Applied Ravi's patch to 1.1.x branch at rev 889871.,"03/May/10 21:20;curtisr7;I know this is wayyyyy after the fact, but could you document the compatibility flag (SuperclassDiscriminatorStrategyByDefault)?

The problem that was reported by OPENJPA-1398 was fixed by this flag, but it was pretty hard to find since it isn't documented.","03/May/10 21:45;rpalache;Hi Rick,

I will document it.

The reason I did not document it before is because the behavior seen with flag superclassDiscriminatorStrategyByDefault=false (pre-1200) is a BUG.
So I thought I should not document something that is a BUG.

Regards,
Ravi.
",04/May/10 13:00;curtisr7;Thanks Ravi!,"04/May/10 14:48;ppoddar@apache.org;Not sure of this option or even the original cause as 'error'. The domain model presented where Book and Movie both can have many Artists. And hence an Artist can be related to both Movies and Books. Thus Artist.getBooks() to return only books is the appropriate scenario for ElementClassCriteria (in fact if my memory serves me right, that is the exact reason to demonstrate the advanced capabilities of OpenJPA that domain model had been originally designed). 

The original use case will behave correctly if @ElementClassCriteria is used -- it is that simple. Otherwise Artist.getItems() will return a list of Item containing both Book and Movies. 

I
","04/May/10 16:10;rpalache;Hi Pinaki,

The issue is not about Artist.getItems().
The issue is about when I do Artist.getBOOKS() then movies are also returned, which I guess is an error.

Book extend Item and Movie extend Item.
Artist has one to many relation with both Book and Movie.

In this scenario, when I do artist.getBooks() then, I think, the expected behavior is to return only books and not movies.

If you think it is not an error then I can switch the default value of superclassDiscriminatorStrategyByDefault to be false.
This will return both books and movies when I do artist.getBooks().

If a user do not want to get both books and movies when artist.getBooks() is called, then they can do one of the below :

1. use openJPA specific annotation ElementClassCriteria  to get only books.
2. use superclassDiscriminatorStrategyByDefault = true to get only books.

Please suggest.

Thanks,
Ravi.","04/May/10 22:16;ppoddar@apache.org;        Book b = new Book(""book"");
        Movie m = new Movie(""movie"");
        Artist a = new Artist(""Herman Hess"");
        b.setArtist(a);
        m.setArtist(a);


As the above code form the test shows, an Artist instance a is related to a Movie m and a Book b.

And both Book and Movie sharing the single table have the same column name ""ARTIST"" though the relationship field is named 'artist1' and 'artist' respectively.

Under such mapping, Artist indeed now related to both Movies and Books via the same column 'ARTIST' 

I see that as an 'quirky' usage which can be sorted out by @ElementClassCriteria to provide a semantics such that Artist.getBooks() or Artist.getMovies() still filter out the collection-valued relation by the class of its elements. 
","24/May/10 02:56;rpalache;I agree that ElementClassCriteria is the easy solution for this issue, but what is the purpose of having DiscriminatorColumn ?
Doesn't it mean Book entity is distinguished by discriminatory value BOOKS and movie by MOVIES, meaning when artist .getBooks() is called then the discriminatory value of books should only be considered ?

One more reason for working on this issue is because customer claims the use case works on other JPA provides, TopLink, without the need for proprietary annotations.

From your previous notes, you are suggesting to revert the changes in this JIRA and use ElementClassCriteria as a solution.
Also from OPENJPA-1398, it does not look like my changes cover all the scenarios properly.

So, I think the best thing to do here is to revert all the changes that went as part of this JIRA and ask customer to use ElementClassCriteria.
Please confirm if my understanding is correct.
",,,,,,,,,,,,,,,,,,,,,,
NativeQueries fail with MySQL ,OPENJPA-1197,12431515,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,27/Jul/09 15:38,24/Feb/10 14:16,14/Mar/19 03:02,27/Jul/09 17:08,1.0.3,1.2.1,,,,,,,,1.0.4,1.2.2,1.3.0,2.0.0-beta,,,,,,,,0,,"The TestCase for DataCache included / excluded types relies on a NativeQuery to drop database tables at the end of the test. This fails with some versions of the MySQL JDBC driver. 

The exception from the testcase looks like this  :
<openjpa-1.0.4-SNAPSHOT-rexported nonfatal general error> org.apache.openjpa.persistence.PersistenceException: Unable to retrieve metadata for procedure.
    at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3964)
    at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:97)
    at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:83)
    at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:59)
    at org.apache.openjpa.jdbc.kernel.SQLStoreQuery$SQLExecutor.executeUpdate(SQLStoreQuery.java:242)

   <snip>
Caused by: java.sql.SQLException: Unable to retrieve metadata for procedure.
    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:910)
    at com.mysql.jdbc.CallableStatement.extractProcedureName(CallableStatement.java:857)
    at com.mysql.jdbc.CallableStatement.determineParameterTypes(CallableStatement.java:692)
    at com.mysql.jdbc.CallableStatement.&lt;init&gt;(CallableStatement.java:513)
    at com.mysql.jdbc.Connection.parseCallableStatement(Connection.java:4422)
    at com.mysql.jdbc.Connection.prepareCall(Connection.java:4496)
    at com.mysql.jdbc.Connection.prepareCall(Connection.java:4470)
    at org.apache.commons.dbcp.DelegatingConnection.prepareCall(DelegatingConnection.java:212)

Upgrading to a more recent version of the MySQL driver resolves these issues and allows the testcase to pass. ",,,,,,,,,,,,,,,,OPENJPA-774,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-07-27 17:01:35.433,,,no_permission,,,,,,,,,,,161476,,,Mon Jul 27 17:08:04 UTC 2009,,,,,,,0|i1ds3r:,288650,,,,,,,,"27/Jul/09 17:01;milosz;This is probably the same issue as in OPENJPA-774 - we use prepareCall instead of prepareStatement.
","27/Jul/09 17:08;mikedd;Hi Milosz, 

That's another way to address the issue I suppose. Since the 5.1.6 driver allows us to use prepareCall without hitting the issue (at least on Linux), I'm content to use that instead of making a code change though. 

That would explain why I didn't see the problem with trunk / 1.3.x though. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Column names do not contain delimiters when obtained from DatabaseMetaData,OPENJPA-1189,12431056,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,mikedd,mikedd,21/Jul/09 17:55,22/Apr/10 20:32,14/Mar/19 03:02,24/Mar/10 18:19,2.0.0-beta,,,,,,,,,2.0.0-beta,,,,,jdbc,,,,,,0,,"The DatabaseMetaData returned by DB2 does not include delimiters for column names which include whitespace. This causes potential duplicate column names if we merge into an existing schema.

The problem can be illustrated by running the TestManualDelimitedJoinAnnotations test twice sequentially. The first time the test is executed the database will be clean (presumably) and everything will work. Subsequent executions read the existing column information from the database (non delimited) and end up creating a duplicate column.

Example stacktrace : 
 <openjpa-2.0.0-SNAPSHOT-r422266:794075M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: DB2 SQL Error: SQLCODE=-104, SQLSTATE=42601, SQLERRMC=);entityCs_c id OTHER;<references_spec>, DRIVER=3.50.152 {stmnt 10751758 CREATE TABLE ""delim id"".""c d"" (""entityCs_c id"" INTEGER, ENTITYDS_ID INTEGER, entityCs_c id OTHER)} [code=-104, state=42601]
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:553)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:453)
       <snip>

To resolve the problem we can detect a column / table / schema name which contains whitespace and add the appropriate delimiters (when the name is provided by the database). One place to make this change is in DBDictionary.newColumn() 
    protected Column newColumn(ResultSet colMeta)
        throws SQLException {
        Column c = new Column();
        c.setSchemaName(colMeta.getString(""TABLE_SCHEM""));
        c.setTableName(colMeta.getString(""TABLE_NAME""));
        c.setName(colMeta.getString(""COLUMN_NAME""));  // detect whether we need delimiters and add them

It's also worth noting that the testcase drops the offending table and then recreates it. There may be a larger issue where the metadata is cached improperly (could be DB2 specific).",DB2 (could exist on other databases),,,,,,,,,,,,,,,,,,,,,11/Aug/09 15:41;dianner;patch.txt;https://issues.apache.org/jira/secure/attachment/12416209/patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-07-22 16:28:34.916,,,no_permission,,,,,,,,,,,161468,,,Wed Mar 24 18:46:30 UTC 2010,,,,,,,0|i0z86f:,203627,,,,,,,,"22/Jul/09 16:28;dianner;>To resolve the problem we can detect a column / table / schema name which contains whitespace and add the appropriate delimiters (when the name is provided by the database).

It probably won't be this simple. There could be other characters (other than whitespace) that need delimiting. Also, there could be lowercase characters.","22/Jul/09 18:40;mikedd;Hi Dianne, 

I figured you'd know when we need delimiters better than I do (although I'm surprised that mixed case would be one of them). I imagine DBDictionary could do with a boolean needsDelimiters(String identifier) method, or String delimitIfNeeded(String identifier). A quick grep through DBDictionary didn't turn one up (I could have missed it though). ","11/Aug/09 15:41;dianner;Attaching patch for review and possibly commit.

This problem occurred when a column name retrieved from the DB metadata was passed as a parameter to the Table.getColumn(String name) to retrieve the Column object. The column name retrieved from the DB does not contain delimiters and this info apparently cannot be obtained. The Table object was created using input metadata from annotations and xml, and might contain delimiters for the Map keys. Therefore, the name might not be found. So, the fix is to delimit the input name if it is initially not found.

Changes were made in the Table getColumn() and containsColumn() methods to take DBDictionary as a parameter, from which the DB-specific delimiter is retrieved. However, some calling methods do not currently have access to the DBDictioinary and pass in null. In this scenario, the double-quote is used as the delimiter. While this is spec-complient, this may not work for some dbs, which is not good. So, I've opened jira OPENJPA-1236 to handle this in the future. I suspect some chaining of changes in method signatures to allow a DBDictionary parameter will fix this.",24/Mar/10 18:19;techhusky;This issue was resolved under OPENJPA-1115.  The OpenJPA naming utility detects when identifiers returned from dbmd require delimiters.,24/Mar/10 18:46;drwoods;show as being fixed in 2.0.0-beta,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Subquery overhaul,OPENJPA-1185,12430947,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,faywang,faywang,20/Jul/09 16:47,07/Jul/10 19:18,14/Mar/19 03:02,07/Feb/10 00:09,2.0.0-M3,,,,,,,,,1.3.0,2.0.0-beta,,,,jdbc,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,22/Jul/09 20:15;faywang;OPENJPA-1185-1.patch;https://issues.apache.org/jira/secure/attachment/12414242/OPENJPA-1185-1.patch,22/Jul/09 23:27;faywang;OPENJPA-1185-2.patch;https://issues.apache.org/jira/secure/attachment/12414282/OPENJPA-1185-2.patch,22/Jul/09 06:04;faywang;OPENJPA-1185.patch;https://issues.apache.org/jira/secure/attachment/12414186/OPENJPA-1185.patch,22/Jul/09 06:08;faywang;TestMultThread.java;https://issues.apache.org/jira/secure/attachment/12414188/TestMultThread.java,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161464,,,Wed Jul 22 23:27:54 UTC 2009,,,,,,,0|i0z6kf:,203366,,,,,,,,22/Jul/09 06:04;faywang;Thread-safe query support,22/Jul/09 06:08;faywang;Multi-thread test case ,22/Jul/09 20:15;faywang;an enhanced patch to fix thread-safe problem of subquery restructuring.,22/Jul/09 23:27;faywang;call ThreadLocal.remove() after query execution to mitigate the impact on memory usage.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inverse relations not set for MapKey field when using parallel eager select,OPENJPA-1184,12430939,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,david minor,david minor,20/Jul/09 15:55,09/Mar/10 18:31,14/Mar/19 03:02,11/Sep/09 20:08,1.2.1,,,,,,,,,1.3.0,2.0.0-M3,,,,jdbc,,,,,,0,,"When selecting multiple entities A which contain a @MapKey field for entity B, the inverse relation from B to A will only be set for the first entity A, when using parallel eager select. This is because all entity B objects are created when loading the 1st entity A object, with the inverse relation to be set later in setInverseRelation(), but setInverseRelation() is looking for Collection fields only, so the Map fields are ignored.",All environments using JDBC store.,,,,,,,,,,,,,,,,,,,,,01/Sep/09 00:53;david minor;mapkey-inverse-relation-test.patch;https://issues.apache.org/jira/secure/attachment/12418200/mapkey-inverse-relation-test.patch,20/Jul/09 15:57;david minor;openjpa.patch;https://issues.apache.org/jira/secure/attachment/12414015/openjpa.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-07-29 18:51:12.641,,,no_permission,,,,,,,,,,,161463,,,Fri Sep 11 20:08:59 UTC 2009,,,Patch Available,,,,0|i0zbq7:,204202,,,,,,,,20/Jul/09 15:57;david minor;Patch against 1.2.1.,"29/Jul/09 18:51;drwoods;David, do you have a junit testcase that demonstrates this failure?","31/Jul/09 19:12;david minor;I don't -- I've never written a test case for openjpa, so I'll see if I can find some time this next week to figure it out.",01/Sep/09 00:53;david minor;Test case against 1.2.1 which demonstrates the issue.,11/Sep/09 20:08;drwoods;Patch and tests committed to trunk and 13x.  Thanks to David Minor for the patches.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA performs differently with orm.xml and annotations,OPENJPA-1174,12430079,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,rpalache,rpalache,rpalache,10/Jul/09 17:02,21/Sep/16 14:21,14/Mar/19 03:02,25/Aug/09 13:05,2.0.0,,,,,,,,,1.2.0,2.0.0-M3,,,,jpa,,,,,,0,," When configurations are provided from orm.xml file, some behaviors are different from behaviors on annotation configuration. 
The behavior difference occurs when fetch=LAZY is specified on many-to-one mapping.

When there are two objects Country and Security and Security has many-to-one mapping field country, 
OpenJPA executes one more SQL query to get country field if orm.xml file is used.

 ----
 * annotation case

     // step 1) Load country in entity manager
     aUS_country = t.em.find(Country.class, aUS_sid);
     // SELECT t0.NAME FROM TEST16.COUNTRY t0 WHERE t0.COUNTRY_ID = ?

     // step 2) Load security in entity manager
     aI_security = t.em.find(Security.class, aI_sid);
     // SELECT t0.COUNTRY_ID, t0.SYMBOL FROM TEST19.SECURITY t0 WHERE t0.SECURITY_ID = ?

     // step 3) get country from security
     Country aUS_country2 = aI_security.getCountry();
     // no SQL was executed.
 .
 * orm.xml case
 .
     // step 1) Load country in entity manager
     aUS_country = t.em.find(Country.class, aUS_sid);
     // SELECT t0.NAME FROM TEST16.COUNTRY t0 WHERE t0.COUNTRY_ID = ?
 .
     // step 2) Load security in entity manager
     aI_security = t.em.find(Security.class, aI_sid);
     // SELECT t0.SYMBOL FROM TEST16.SECURITY t0 WHERE t0.SECURITY_ID = ?
 .
     // step 3) get country from security
     Country aUS_country2 = aI_security.getCountry();
     // SELECT t1.COUNTRY_ID, t1.NAME   FROM TEST16.SECURITY t0, TEST16.COUNTRY t1 WHERE t0.SECURITY_ID = ? AND t0.COUNTRY_ID = t1.COUNTRY_ID
 ----

 The important difference is in step 2. When using orm.xml, many-to-one field ""country"" was not loaded if fetch=LAZY.
 Instead, it's loaded on annotation configuration.
 .
 Because many-to-one ""country"" field is not loaded, step 3 executes additional SQL to load ""country"" field on orm.xml.
 Instead, on annotation case, step 3 did not execute any SQLs.",,0,0,,0%,0,0,,,,,,,,,,,,,,,22/Jul/09 10:11;rpalache;OPENJPA-1174-trunk.patch;https://issues.apache.org/jira/secure/attachment/12414201/OPENJPA-1174-trunk.patch,14/Jul/09 20:36;rpalache;OPENJPA-1174-trunk.patch;https://issues.apache.org/jira/secure/attachment/12413479/OPENJPA-1174-trunk.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-07-15 15:37:04.368,,,no_permission,,,,,,,,,,,38624,,,Tue Aug 25 13:00:35 UTC 2009,,,Patch Available,,,,0|i0z83b:,203613,,,,,,,,"14/Jul/09 20:36;rpalache;Attached patch file contains the testcase and fix.

Please comment after reviewing the changes.

Regards,
Ravi.","15/Jul/09 15:37;mikedd;Thanks for the patch Ravi. I noticed that you also updated how we handle embeddables when specified in a mapping file. They're now included in the default fetch group automatically. 

It matches the annotation handling and it's a great catch but we probably should add a testcase for it (unless I've missed where it's covered). 

The patch looks good though - running regression tests now. ","15/Jul/09 15:51;rpalache;Hi Mike,

Thanks for looking into it.

The current testcase attached just shows how it is handled in case of mapping file.
Are you looking for a testcase that shows the differences between annotation handling and mapping file?
Please confirm and I will start working on it.

Regards,
Ravi.



","15/Jul/09 18:17;mikedd;Hi Ravi,

Here's the portion of the patch that I'm talking about :

@@ -1393,6 +1398,7 @@

     protected void parseEmbedded(FieldMetaData fmd, Attributes attrs)
         throws SAXException {
         assertPC(fmd, ""Embedded"");
+        fmd.setInDefaultFetchGroup(true);
         fmd.setEmbedded(true);
         fmd.setSerialized(false); // override any Lob annotation

This is the only method in XMLPesistenceMetaDataParser that doesn't have a check like this one : 
                String val = attrs.getValue(""fetch"");
                if (val != null) {
                    fmd.setInDefaultFetchGroup(""EAGER"".equals(val));
                }

With this change we won't be checking the fetch value for Embedded fields. It matches the annotation parser, but we should add a testcase with an Embedded field to demonstrate the change in behavior. 

Actually it might be worth spending a few cycles on developing lower level unit test that validates that the annotations & xml are handled identically, but that's beyond the scope of this issue really. ","15/Jul/09 18:46;mikedd;Actually in thinking about this more I think the testcase needs to be reconsidered. What we're really interested in here is whether the metedata is generated identically when we use an xml mapping file or annotations. We're not particularly interested in whether we ignore FetchType=LAZY - so long as we do it identically either way the MetaData is obtained. 

The testcase relies on the LAZY hint being ignored (it's actually very interesting that it isn't ignored if no hint is specified). This behavior can't be relied on and wouldn't be expected in most cases. We could change this behavior at any point in the future and this testcase would no longer serve the intended purpose. 

A better functional test would be to have duplicates of the entities : one with annotations one with orm.xml and make sure the same SQL is issued for both of them. A better unit test could just look at the ClassMetaData / ClassMapping for the two entities and make sure they are equivalent.

In addition we'll want to add an Embedded field in the entities since there's a specific change to parseEmbedded that needs to be asserted. 

While the code changes look correct I'd prefer to validate it with a more reliable unit test. 
","22/Jul/09 10:11;rpalache;Hi Mike,

Attached patch contains new testcase.
This time it compared SQL generated from annotation processing with mapping file processing.

Please review it and let me know of any changes.

Regards,
Ravi.","31/Jul/09 21:55;mikedd;Hi Ravi, the new patch looks good. I'm running the regression bucket now (not expecting anything just a sanity check). The only change I had to make was to reorder tags in orm.xml (m2m must come before embedded). Not sure how anyone would notice that but the IBM SDK happens to check it.. ","31/Jul/09 22:05;mikedd;Thanks for the patch and all the work debugging Ravi. 

Committed in revision 799754",10/Aug/09 15:57;dezzio;Merged fix at trunk revision 799754 to 1.1.x branch at revision 802838,"25/Aug/09 13:00;faywang;The default fetch type for ManyToOne and OneToOne is eager. That is, if the fetch type is not specified in the orm.xml, the fetch mode should be eager.",,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE in UUIDGenerator.initializeForType1(),OPENJPA-1168,12429866,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,curtisr7,curtisr7,08/Jul/09 22:00,09/Mar/10 18:31,14/Mar/19 03:02,14/Jul/09 17:57,,,,,,,,,,1.3.0,2.0.0-M3,,,,lib,,,,,,0,,"When UUIDGenerator.createType1() is called by more than one thread at *nearly* the same time AND UUIDGenerator.createType1() wasn't called previously, a small timing window exists where a NPE will result.

Scenario:
Thread 1 calls UUIDGenerator.createType1() and RANDOM == null so initializeForType1() is called. While that thread is in initializeForType1(), it sets the static variable RANDOM so that value is no longer null. Now Thread 2 calls UUIDGenerator.createType1() and RANDOM is no longer null, so it proceeds to the call System.arraycopy(IP, 0, uuid, 10, IP.length);. At this point Thread 1 hasn't got to initializing IP yet, so Thread 2 gets hits a NPE.",,,,,,,,,,,,,,,,,,,,,,09/Jul/09 15:49;curtisr7;OPENJPA-1168.patch;https://issues.apache.org/jira/secure/attachment/12413032/OPENJPA-1168.patch,09/Jul/09 13:25;curtisr7;OPENJPA-1168.patch;https://issues.apache.org/jira/secure/attachment/12413018/OPENJPA-1168.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-07-09 01:29:16.673,,,no_permission,,,,,,,,,,,38625,,,Thu Jul 09 16:17:42 UTC 2009,,,Patch Available,,,,0|i0z83z:,203616,,,,,,,,"08/Jul/09 22:06;curtisr7;The patch includes a test case and the fix for this issue. 

Since this bug is a timing window, running this test case against an un-patched tree may work from time to time. Please let me know if you want me to post some more information in the test case about why I did what I did.

- Rick","09/Jul/09 01:29;mikedd;Hi Rick,

I'm unable to hit the timing window you mention on my system, but your explanation is sound. 

That said there's still a window where IP can be initialized (non null) but not copied. Another thread could hit this window when IP was empty and get a non-unique id. It's probably safer to set a different flag at the end of the method and key off that instead of IP or RANDOM.

Thanks for the patch though - I doubt this was easy to find.  ","09/Jul/09 13:25;curtisr7;Nice catch Mike. 

I updated the patch as recommended.",09/Jul/09 15:49;curtisr7;Fixed a problem in the test case that was introduced because of the previous patch.,"09/Jul/09 16:17;milosz;This reminds me of a test case which sometimes fails for me while running against MySQL and which I did not have time to look at. Maybe this is connected although the test case is single-threaded. The stack trace I am receiving is:

testDefaultValues(org.apache.openjpa.persistence.generationtype.TestGeneratedValues)  Time elapsed: 0.787 sec  <<< FAILURE!
junit.framework.AssertionFailedError
        at junit.framework.Assert.fail(Assert.java:47)
        at junit.framework.Assert.assertTrue(Assert.java:20)
        at junit.framework.Assert.assertFalse(Assert.java:34)
        at junit.framework.Assert.assertFalse(Assert.java:41)
        at org.apache.openjpa.persistence.generationtype.TestGeneratedValues.testDefaultValues(TestGeneratedValues.java:49)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at org.apache.openjpa.persistence.test.PersistenceTestCase.runBare(PersistenceTestCase.java:466)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:181)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:345)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009)

The TestGeneratedValues.java:49 contains:

        assertFalse(gv.getUuidstring().equals(gv2.getUuidstring()));

This means UUID generator sometimes generates duplicates.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Two unique constraints in a table try to share the same constraint name,OPENJPA-1165,12429844,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,milosz,ljnelson,ljnelson,08/Jul/09 19:03,22/Apr/10 20:32,14/Mar/19 03:02,21/Oct/09 19:39,1.2.1,1.3.0,,,,,,,,1.3.0,,,,,sql,,,,,,0,,"Put two @Column(unique = true) annotations on two different fields in an Entity.

Set up OpenJPA to synchronize mappings (i.e. generate DDL).

Observe that when the DDL is created it attempts to create two unique constraints, one for each column.  This is good.  However, also observe that both unique constraints are named ""UNQ_"".  This causes the H2 database (and probably others) to reject the DDL as invalid (correctly).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-10-21 19:39:22.218,,,no_permission,,,,,,,,,,,161446,,,Wed Oct 21 19:39:22 UTC 2009,,,,,,,0|i0z82v:,203611,,,,,,,,"21/Oct/09 19:39;milosz;I have ported the fix from trunk to 1.3.x branch.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Data consistency issues while modifying collections.,OPENJPA-1163,12429818,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,rpalache,rpalache,rpalache,08/Jul/09 15:31,21/Sep/16 14:21,14/Mar/19 03:02,03/Aug/09 21:07,,,,,,,,,,1.2.0,2.0.0-M3,,,,kernel,,,,,,0,,"There are data consistency issues when modifying more number of elements in a collection Vs less number of elements.

Following is a detailed explanation about the issue with example:
 
- Entity A has a collection of Entities AItems with cascade ALL.
- Test case :
  Clear all the data inside tables representing Entity A and AItems.  
  Create 3 entity managers em1,em2 and em3.
   
  em1.begin()
      create A on em1 with id ""1""
      add 10 elements of AItems (id's from 0-9) to the created A(id 1).
      persist A.
  em1.commit()
 
  em1.begin()
      merge A ( created in the previous step)
      Remove 3 elements of AItems from the merged A.
      Add 3 elements of AItems ( id's 10,11,12) to the merged A (id 1).
   
With out committing em1
   
  em2.begin()
      query database to fetch A and construct object result2 of entity A.
      Add 3 elements of AItems ( id's 13,14,15) to fetched A ( result2)      

   em2.commit ()
   em1.commit()
   
  em3.begin()
     query database to check the size of AItems that are related to A ( id 1)
  em3.commit()
   
  The result on em3's query for AItems related to A, returns 13 as expected.
  13 ( Initial 10 - em1's 3 + em1's 3 + em2's 3).
   
When the same test case is repeated with removing and adding 10 elements instead of 3 as before then I get wrong results.
   
    Add initial 10 AItems (id's 0-9) for A.
    commit()
   
    em1 will remove 10 AItems from the collection of A.
    em1 will add 10 AItems (id's 10-19) to collection of A.
   
    em2 will add 10 AItems (id's 20-29) to collection of A.
   
    Commit em2.
    Commit em1.
   
    Then instead of 20 elements ( Initial 10 - em1's 10 + em1's 10 + em2's 10), I see only 10 elements.
   
    The 10 elements that I see are from em1's added AItems ( id's 10-19).


I think the cause of the issue is that, when more number of elements (compared to initial element count of collection) in a collection are modified then collection tracking is disabled and openJPA tries to do the following:
 -- Delete every thing from the collection
 -- Insert data back to collection.
While Inserting the data back it does not consider adding the dirty records ( em2's 10 added elements ) because the collection tracking is disabled.",openJPA trunk. Derby DB.,0,0,,0%,0,0,,,,,,,,,OPENJPA-1223,,,,,,03/Aug/09 17:33;rpalache;OPENJPA-1163_trunk.patch;https://issues.apache.org/jira/secure/attachment/12415375/OPENJPA-1163_trunk.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-07-21 03:18:49.997,,,no_permission,,,,,,,,,,,38636,,,Thu Sep 17 19:15:33 UTC 2009,,,Patch Available,,,,0|i0z85j:,203623,,,,,,,,08/Jul/09 16:01;rpalache;Attached is a test case and fix for the issue.,"21/Jul/09 03:18;mikedd;Hi Ravi,

Thanks for the patch. I think this sort of change needs a corresponding configuration option in the Compatibility class (maybe called limitChangesTracked?). The javadoc for org.apache.openjpa.conf.Compatibility can contain the information on when we changed the default behavior and why we made the change. If that isn't enough to go on just let me know and I'll provide some more pointers. 

I think that changing the default is the correct way to go, but I can also see existing applications that are unknowingly coded to the old behavior so I'd like to give them an option to move forward. I'll take a closer look at the testcase tomorrow (might be evening) but at first glance the patch looks good. 

Thanks very much for finding and debugging this.","22/Jul/09 02:57;mikedd;Hi Ravi,

This patch demonstrates a race condition more than anything else. You have two transactions. Tran 1 gets a copy of the entity, removes everything from its collection, then adds ten more items. Tran 2 gets a copy of the entity and just adds ten items. To show this just print out the size of newA.getAItems() before committing tran 1.

In Tran 1 the entity has only 10 items , in tran 2 the entity has 20. The last one to commit wins. It's a unidirectional relationship - I'm guessing this is because it's a uni-directional relationship and A is the owner (even though the updates are in the AItem table) and therefore the state in A trumps the state in AItem. 

Interestingly enough if you updated any field in A you should see an OptimisticLockException which would explain the problem better. ","23/Jul/09 19:16;rpalache;Hi Mike,

In my example, data dealt with Trans1 and Trans2 is not interfering with each other.
Both Trans1 and Trans2 are working on different objects and different rows of table.
Hence I fail to understand what you meant by ""This patch demonstrates a race condition more than anything else.""

The whole idea of my testcase is to demonstrate that the results in database are different if I execute same code but the number of rows updates are different.

A Item has 10 rows.
Trans1 --> deletes 10 rows. (0 to 9)
                   Adds 10 rows.(10 to 19)
Trans2 --> Adds 10 rows.(20 to 29)
Commit Trans2.
Commit Trans1.

Rows in talbe AItems after above execution : ( 10 to 19) = 10 rows in total.

The same code when I manipulate only 3 rows.
A Item has 10 rows.
Trans1 --> deletes 3 rows. (0 to 6)
                   Adds 3 rows.(10 to 12)
Trans2 --> Adds 3 rows.(20 to 22)
Commit Trans2.
Commit Trans1.
Rows in talbe AItems after above execution : (0 to 6 , 10 to 12 , 20 to 22) = 13 rows in total

If only Trans1 has to win , then the results should be ( 0 to 6 ,10 to 12 = 10 in total) rather than 13.

So the results in AItems are different even though the same code is executed.

>> You mentioned ""The last one to commit wins.""
When the data in both the transactions are not interfering with each other then both the transactions has to win , isn't it ?

Please correct me if I am loosing the track.

Thanks,
Ravi.","23/Jul/09 20:43;mikedd;Hi Ravi,

I'm sorry, I misread the test results I'd made some changes and may have changed the testcase.

I believe that both times the expected result should be 10 AItems (pretend A is unversioned). The last commit contains an instance of A, which is related to 10 AItems. A has a OneToMany unidirectional relationship with AItem. Since AItem does not have a relationship with A, A is the owner of the relationship. So the last transaction to update A:id=1 wins (or at least so I thought).

It's very interesting that the behavior is different when you add more changes (exceed 10).

What bothers me about it is that you've updated a versioned entity (newA and result2) twice but didn't get an Optimistic Lock Exception. I'd think this is the correct behavior in this case (because A owns the relationship, it's really A that gets updated). That won't help for unversioned entities though - they'll still get the odd behavior you've found.","24/Jul/09 01:10;rpalache;Hi Mike,

Thanks a lot for spending your time on this.

>> It's very interesting that the behavior is different when you add more changes (exceed 10).

CollectionChangeTrackerImpl.add() and remove() methods should give more info about this.
If the number of added objects plus the number of removed objects are greater than collection size, ChangeTracker is forcefully disabled.
If ChangeTracker is disabled, OpenJPA update strategy is delete all and re-insert all objects.
So while insert-all it can not see the objects inserted as part of em2 ( in my sample).
Hence this bug.

>> What bothers me about it is that you've updated a versioned entity (newA and result2) twice but didn't get an Optimistic Lock Exception. 

Excellent concern.
I was thinking previously that AItem objects modified in tran 1 and tran 2 does not interfere with each other and hence should not result in optimistic lock excpetion.
Now I understand that both tran 1 and tran 2 are working on same row of A , which mean at the time of tran1 commit I should get optimistic lock exception.

I verified the reason why I am not getting optimistic lock exception and I changed the method level version annotation to field level.
Now I got optimistic lock errors when I set the version annotation on field rather than on method.
I think version annotation on methods has some issue.

With version annotation on method, when I check the db tables then I do not see the corresponding version column.
After adding version attribute to the field I can see version column on the table and getting optimistic lock exception.

So in my example, both A and AItems are treated as non versioned entities.

In the process of answering your concerns, I realized that I definitely have to revisit my testcase.
I will try to modify the test case such that it properly demonstrates the current issue.
I think the issue defined in this JIRA is valid but my test case needs to be revisited.
Do you agree with this ?

Thanks again,
Ravi.","25/Jul/09 00:30;rpalache;Hi,

I simplified the test case now.
It has only one entity ""A"".
A in unversioned and it has an id ( primary key), name, age and a map.

A's initialValues :
    A(id,age,name,map) =     A (1, 30, ""Initial"", 0-9 ( size of 10).

Trans1 :
    A.Age = 40;
    Remove 8 elements in Map.
    Add 8 elements to Map (10 - 17)
Trans2: 
    A.Name = ""Changed""
    Add 8 elements to Map (20 - 27)

Commit Trans2 .
Commit Trans1.

Results :

A's values :
    A(id,age,name,map) =     A (1, 40, ""Changed Name"", 8,9,10-17 ( size of 10).

The same when repeated with adding & removing 3 elements ( instead of 8)
then A's values :
    A(id,age,name,map) =     A (1, 40, ""Changed Name"", 3-9,10-12,20-22 ( size of 13).
    
The question is which behavior in the above is true ?

Should the whole Map be replaced by Trans 1 ( as it is last committed) (or)
Should the Map be a combination of changes made in Trans1 and Trans2 ?

If you see the other values of A; the changes made to age and name by Trans1 and 2 are both considered.
When it comes to map the results are different.

Regards,
Ravi.","03/Aug/09 03:00;rpalache;The attached patch contains fix along with the testcase.
This will take autoOff parameter from openjpa.compatibility option.
The default option is what ever existing currently with out the patch.

Regards,
Ravi.","03/Aug/09 17:33;rpalache;Forgot to attach the testcase.
The current patch contains both the test case and fix.

Regards,
Ravi.","03/Aug/09 21:06;mikedd;Hi Ravi,

Great testcases (sorry this was a long time coming). I wouldn't recommend using this approach for relationships but the PersistentCollection is an interesting wrinkle.

Thanks very much for your hard work on this issue. ","05/Aug/09 01:51;ppoddar@apache.org;Hi Ravi/Mike, 
As you have analyzed the issue, do you think
  1. is this earlier value of autoOff considered a defect? Or a behavior that we must retain with a Compatibility option?

If it is ony a defect that was not exposed till this issue then there may not be a strong case for a compatibility option.

If it not a defect and we need to retain both the old value and the new value, then instead of adding a separate compatibility option, consider 
autooff as one more configurable option of ProxyManager. ProxyManager already have few boolean configurable properties so this new
choice will fit neatly (also the patch footprint will reduce). 
If this issue is not a defect then the default value should remain as before. But documentation should explain when the configuration should be switched.
If this issue is a defect then the default value should flip. But documentation should explain how the configuration could be switched to backward compatible behavior
","05/Aug/09 16:47;rpalache;>> If this issue is a defect then the default value should flip.

The reason for not switching the default value is because I am not completely confident that the previous behavior is a defect. 
So without confirmation of whether it is a defect or not, I felt it is convenient for existing applications using the current default
 value to upgrade to latest versions without the need for any additional properties. Also there is a doc JIRA (OPENJPA-1223) opened for documenting this.

In my opinion the previous value is a defect.
May be I am wrong but I think it is a defect based on the following :

1)  The previous default behavior is as follows:
    When the number of modifications(add/remove) to a collection exceeds the initial size of collection then the logic is to
    remove everything from collection and re-insert the objects. In the process of re-inserting it will not consider data 
    that is modified as part of another transaction.
    
    So, the end result is that the data inserted into database is dependent on the number of modifications made on the collection.
    I think it is bug as the data inserted into the database should be consistent irrespective of the number of modifications 
    made to the collection.
    
2)  When the data modified in two concurrent transactions does not interfere with each other then both the transactions should win.
    For example, let's consider table A which has 5 rows ( primary key of int 1-5) and has row level locking. 
    Transaction 1 tries to modify rows 1 -3 and transaction 2 modifies 4-5 at the same time.
    In this case I think both the transactions has to win.
    The above is not possible with default value of autoOff, when the # of modifications to A exceeds 5.

If you think adding an option to ProxyManager is a better fit than compatibility configuration then I will modify my fix.
Can I please ask, if there is any additional advantage with it other than patch footprint.

Regards,
Ravi.","05/Aug/09 19:23;mikedd;>    So, the end result is that the data inserted into database is dependent on the number of modifications made on the collection.
>    I think it is bug as the data inserted into the database should be consistent irrespective of the number of modifications
>    made to the collection. 

I agree, the number of modifications should not have an affect. 

> 2) When the data modified in two concurrent transactions does not interfere with each other then both the transactions should win.
>    For example, let's consider table A which has 5 rows ( primary key of int 1-5) and has row level locking.
>    Transaction 1 tries to modify rows 1 -3 and transaction 2 modifies 4-5 at the same time.
>    In this case I think both the transactions has to win.

IMO this really depends on who owns the relationship or the collection. 

For example this model :
@Entity 
public class Manager {
    @OneToMany(mappedBy=""manager"")
    private Collection<Employee> employees;
}

@Entity
public class Employee { 
    @ManyToOne
    private Manager manager; 
}

Employee owns the relationship, and the employee table has a foreign key. Any Employees with a FK -> a particular manager are considered that manager's Employees. In this case we should see the behavior Ravi is advocating. 

The following example is slightly different : 
@Entity 
public class Manager {
    @OneToMany
    private Collection<Employee> employees;
}

@Entity
public class Employee { 
    // no reference to Manager.
}

In this case Manager is the owner of the relationship and the Manager object owns the relationship and the set of Employees. In this case I'm less certain how we should behave. My original take was that the last to commit wins - Manager owns the state of the relationship and bears the sole burden of maintaining it. 

I'm not sure that's the ideal solution, but I didn't feel confident enough in the answer to change the default. ","07/Aug/09 21:37;dezzio;From trunk, merged fix to 1.1.x branch at rev 802218",17/Sep/09 19:15;drwoods;add missing Fix version for trunk,,,,,,,,,,,,,,,,,,,,,,
Bad error message for find of an Entity with compound primary key if parameter of wrong class,OPENJPA-1159,12429521,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,clr,clr,clr,04/Jul/09 03:53,09/Mar/10 18:31,14/Mar/19 03:02,27/Aug/09 23:32,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,kernel,,,,,,0,,"Test set: com.mysql.clusterj.openjpatest.LongLongStringPKRelationshipTest
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 4.234 sec <<< FAILURE!
test(com.mysql.clusterj.openjpatest.LongLongStringPKRelationshipTest)  Time elapsed: 4.168 sec  <<< ERROR!
<openjpa-1.2.0-r422266:753657 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: 1
	at org.apache.openjpa.kernel.BrokerImpl.newObjectId(BrokerImpl.java:1154)
	at org.apache.openjpa.kernel.DelegatingBroker.newObjectId(DelegatingBroker.java:268)
	at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:451)
	at com.mysql.clusterj.openjpatest.LongLongStringPKRelationshipTest.test(LongLongStringPKRelationshipTest.java:65)
Caused by: java.lang.ArrayIndexOutOfBoundsException: 1
	at org.apache.openjpa.util.ApplicationIds$PrimaryKeyFieldManager.retrieve(ApplicationIds.java:602)
	at org.apache.openjpa.util.ApplicationIds$PrimaryKeyFieldManager.fetchLongField(ApplicationIds.java:578)
	at com.mysql.clusterj.jpatest.model.LongLongStringFKRelationship.pcCopyKeyFieldsToObjectId(LongLongStringFKRelationship.java)
	at org.apache.openjpa.enhance.PCRegistry.copyKeyFieldsToObjectId(PCRegistry.java:172)
	at org.apache.openjpa.util.ApplicationIds.fromPKValues(ApplicationIds.java:218)
	at org.apache.openjpa.kernel.BrokerImpl.newObjectId(BrokerImpl.java:1141)
	... 30 more

The failure is clearly a user error but the message is bad. The message should say that the type of the argument doesn't match the metadata for the class.

The failing line of code is:
            LongLongStringFKRelationship b = em.find(LongLongStringFKRelationship.class, i);

The correct code is:
            LongLongStringFKRelationship b = em.find(LongLongStringFKRelationship.class, new LongLongStringOid(i));
",,,,,,,,,,,,OPENJPA-365,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-08-27 23:32:22.626,,,no_permission,,,,,,,,,,,161441,,,Thu Aug 27 23:32:22 UTC 2009,,,,,,,0|i1ds6n:,288663,,,,,,,,"27/Aug/09 23:32;ppoddar@apache.org;This has been fixed in OPENJPA-365. 

Please reopen if the error message is still poor.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect handling of long values in AbstractResult,OPENJPA-1158,12429508,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,drwoods,clr,clr,03/Jul/09 20:17,09/Mar/10 18:31,14/Mar/19 03:02,14/Sep/09 20:07,2.0.0,,,,,,,,,1.3.0,2.0.0-M3,,,,jdbc,,,,,,0,,"This code is in org.apache.openjpa.jdbc.sql.AbstractResult.

   public long getLong(Object obj)
       throws SQLException {
       return getLongInternal(translate(obj, null), null);
   }

   public long getLong(Column col, Joins joins)
       throws SQLException {
       return getLongInternal(translate(col, joins), joins);
   }

   protected long getLongInternal(Object obj, Joins joins)
       throws SQLException {
       Number val = (Number) checkNull(getObjectInternal(obj,
           JavaTypes.INT, null, joins));
       return (val == null) ? 0 : val.intValue();
   }

It seems like it's an obvious bug; using intValue and JavaTypes.INT in getLongInternal should use longValue and JavaTypes.LONG.
",,,,,,,,,,,,,,,,,,,,,,03/Jul/09 20:19;clr;OPENJPA-1158.patch;https://issues.apache.org/jira/secure/attachment/12412520/OPENJPA-1158.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-09-14 20:03:42.556,,,no_permission,,,,,,,,,,,161440,,,Mon Sep 14 20:07:46 UTC 2009,,,Patch Available,,,,0|i1ds6v:,288664,,,,,,,,03/Jul/09 20:19;clr;This patch corrects the issue. Please review.,14/Sep/09 20:03;drwoods;Applied to trunk in r808701 by Pinaki.,14/Sep/09 20:07;drwoods;Committed to 1.3.x in r814825.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Path length issues on Windows ,OPENJPA-1156,12429404,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,02/Jul/09 16:53,08/Jan/10 00:13,14/Mar/19 03:02,21/Jul/09 02:41,1.2.2,1.3.0,2.0.0,,,,,,,1.2.2,1.3.0,2.0.0-M3,,,build / infrastructure,,,,,,0,,"The testcases for OPENJPA-1061 exceed the maximum path length on Windows. The problem was reported from a continuous integration server which actually complained about the svn files, but it could happen for ""normal"" builds as well. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161438,,,2009-07-02 16:53:33.0,,,,,,,0|i0yzp3:,202253,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BrokerImpl.detachAllInternal() does not detach newly loaded entities,OPENJPA-1155,12429397,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,dianner,dianner,dianner,02/Jul/09 15:41,09/Mar/10 18:31,14/Mar/19 03:02,03/Mar/10 18:10,2.0.0,,,,,,,,,2.0.0-M3,,,,,kernel,,,,,,0,,"During detach, it is possible for additional entities to be loaded if the openjpa.DetachState property has been set to ""all"" or ""fetch-groups"". These entities may not be included in the collection of entities that are identified in the BrokerImpl.detachAllInternal() method when it calls the DetachManager.detachAll(collection) method. Before 2.0, these newly loaded entities were always detached since the detach processing always cascaded. However, with the 2.0 spec requirements for cascade, the default behavior no longer cascades. Therefore, there may be some entities left in the persistence context after this processing occurs. detachAllInternal() is associated with the clear(), close(), and afterCompletion() operations and it is expected that the persistence context really be empty. To ensure this, the compatibility option of cascadeWithDetach will be set to true by detachAllInternal() before calling the DetachManager.detach() method.",,,,,,,,,,,,,,,,,,,,,,02/Jul/09 15:56;dianner;patch.txt;https://issues.apache.org/jira/secure/attachment/12412403/patch.txt,06/Jul/09 17:23;dianner;patch2.txt;https://issues.apache.org/jira/secure/attachment/12412632/patch2.txt,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-07-06 16:16:16.734,,,no_permission,,,,,,,,,,,38635,,,Wed Mar 03 18:10:19 UTC 2010,,,Patch Available,,,,0|i0z85b:,203622,,,,,,,,02/Jul/09 15:56;dianner;Attaching patch with the fix described in the previous comment.,"02/Jul/09 17:02;dianner;I forgot to mention when I attached the patch - The original problem that caused this was in a container with a client-server application. I wasn't able to re-create this problem in a JSE environment, so I'm not able to provide junit tests.","06/Jul/09 16:16;techhusky;Comment on patch.txt dated 2009-07-02 08:56 AM:

Resetting the compat flag should occur in a finally{} block.  Otherwise, the detach mgr. could throw an exception and it the value would not get reset.",06/Jul/09 17:23;dianner;Patch2 added with Jeremy's suggestion.,06/Jul/09 19:08;techhusky;Committed patch2.txt for Dianne under revision 791568.,"03/Mar/10 18:10;drwoods;please open a new jira if additional work is required, as this is being marked as completed for the 2.0.0-M3 release",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OptimisticLockException thrown on Query.getResultList() when Pessimistic Lock is applied,OPENJPA-1142,12428598,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,22/Jun/09 18:51,04/Mar/10 01:11,14/Mar/19 03:02,03/Mar/10 23:37,2.0.0-M3,,,,,,,,,2.0.0-beta,,,,,kernel,,,,,,0,,"The following sample code snippet may yield a OptimisticLockException.

    Query tc_query = itemManager.createNamedQuery(""TypeCategory.find_tc"").setParameter(""product_id"", new Integer(product_id));		
    tc_query.setLockMode(LockModeType.PESSIMISTIC_READ);
    Collection typeCat = tc_query.getResultList();

This is a incorrect behavior per JPA 2.0 spec:

public interface Query {
  /**
   * Execute a SELECT query and return the query results
   * as an untyped List.
   * @return a list of the results
   * @throws IllegalStateException if called for a Java Persistence query language UPDATE or DELETE statement
   * @throws QueryTimeoutException if the query execution exceeds the query timeout value set
   * @throws TransactionRequiredException if a lock mode has been set and there is no transaction
   * @throws PessimisticLockException if pessimistic locking fails and the transaction is rolled back
   * @throws LockTimeoutException if pessimistic locking fails and only the statement is rolled back
   */
  List getResultList();
",,,,,,,,,,,,,,,,,,,,,,23/Jun/09 02:22;allee8285;OPENJPA-1142.patch;https://issues.apache.org/jira/secure/attachment/12411483/OPENJPA-1142.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-03-03 17:52:38.864,,,no_permission,,,,,,,,,,,87574,,,Wed Mar 03 17:52:38 UTC 2010,,,Patch Available,,,,0|i0z8vz:,203742,,,,,,,,"03/Mar/10 17:52;drwoods;Code was checked in for this JIRA, so can it be marked as resolved?",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE  at org.apache.openjpa.jdbc.meta.MappingInfo.mergeJoinColumn(MappingInfo.java:1400),OPENJPA-1141,12428375,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,yann,yann,19/Jun/09 15:35,17/Jan/11 14:28,14/Mar/19 03:02,08/Jan/10 00:07,1.2.0,,,,,,,,,1.2.2,1.3.0,2.0.0-beta,,,jdbc,,,,,,1,,"We have the NPE shown below in a reproducible testcase (ZIP attached to JIRA ...).

We've reduced our complex intended target domain model (about 200+ Entities) to a simpler model with only 3 classes which illustrate the problem: You'll find attached a test project with a first entity which has a a OneToMany (with an ElementJoinColumns, but that shouldn't matter?) to a second entity has a ManyToOne to a third entity. The middle entity has a Composite ID Class including a ManyToOne as a key, which according to http://openjpa.apache.org/builds/1.2.0/apache-openjpa-1.2.0/docs/manual/ref_guide_pc_oid.html#ref_guide_pc_oid_entitypk is supported, so this seems a bug in OpenJPA's mapping algos, somehow?

<openjpa-1.2.1-r752877:753278 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: null
        at org.apache.openjpa.kernel.QueryImpl.compileForCompilation(QueryImpl.java:610)
        at org.apache.openjpa.kernel.QueryImpl.compileForExecutor(QueryImpl.java:667)
        at org.apache.openjpa.kernel.QueryImpl.getOperation(QueryImpl.java:1492)
        at org.apache.openjpa.kernel.DelegatingQuery.getOperation(DelegatingQuery.java:123)
        at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:243)
        at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:294)
        at testcase.TestMappingProblem.doTest(TestMappingProblem.java:42)
        at testcase.TestMappingProblem.testIt(TestMappingProblem.java:20)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:345)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009)
Caused by: java.lang.NullPointerException
        at org.apache.openjpa.jdbc.meta.MappingInfo.mergeJoinColumn(MappingInfo.java:1400)
        at org.apache.openjpa.jdbc.meta.MappingInfo.createJoins(MappingInfo.java:1206)
        at org.apache.openjpa.jdbc.meta.MappingInfo.createForeignKey(MappingInfo.java:968)
        at org.apache.openjpa.jdbc.meta.ValueMappingInfo.getTypeJoin(ValueMappingInfo.java:104)
        at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.map(RelationFieldStrategy.java:157)
        at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:121)
        at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:80)
        at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:454)
        at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:419)
        at org.apache.openjpa.jdbc.meta.ClassMapping.resolveNonRelationMappings(ClassMapping.java:869)
        at org.apache.openjpa.jdbc.meta.MappingRepository.prepareMapping(MappingRepository.java:339)
        at org.apache.openjpa.meta.MetaDataRepository.preMapping(MetaDataRepository.java:662)
        at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:549)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:308)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:363)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getClassMetaData(JPQLExpressionBuilder.java:159)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.resolveClassMetaData(JPQLExpressionBuilder.java:139)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:225)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:195)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateType(JPQLExpressionBuilder.java:188)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.access$600(JPQLExpressionBuilder.java:69)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.populate(JPQLExpressionBuilder.java:1756)
        at org.apache.openjpa.kernel.jpql.JPQLParser.populate(JPQLParser.java:56)
        at org.apache.openjpa.kernel.ExpressionStoreQuery.populateFromCompilation(ExpressionStoreQuery.java:153)
        at org.apache.openjpa.kernel.QueryImpl.newCompilation(QueryImpl.java:658)
        at org.apache.openjpa.kernel.QueryImpl.compilationFromCache(QueryImpl.java:639)
        at org.apache.openjpa.kernel.QueryImpl.compileForCompilation(QueryImpl.java:605)
        ... 33 more",,,,,,,,,,,,,,,,OPENJPA-1736,,,,,,26/Oct/09 15:05;fyrewyld;OpenJPA-1.2.x-OJ1141_10226009.patch;https://issues.apache.org/jira/secure/attachment/12423204/OpenJPA-1.2.x-OJ1141_10226009.patch,28/Oct/09 15:47;fyrewyld;OpenJPA-1.3.x_OJ1141.patch;https://issues.apache.org/jira/secure/attachment/12423461/OpenJPA-1.3.x_OJ1141.patch,16/Nov/09 21:36;dirichs;OpenJPA-Trunk_OJ1141-2.patch;https://issues.apache.org/jira/secure/attachment/12425147/OpenJPA-Trunk_OJ1141-2.patch,26/Oct/09 19:15;fyrewyld;OpenJPA-Trunk_OJ1141.patch;https://issues.apache.org/jira/secure/attachment/12423231/OpenJPA-Trunk_OJ1141.patch,19/Jun/09 15:35;yann;TestMappingProblem.zip;https://issues.apache.org/jira/secure/attachment/12411233/TestMappingProblem.zip,22/Jul/09 10:22;vorburger;ddl.sql;https://issues.apache.org/jira/secure/attachment/12414202/ddl.sql,17/Jan/11 14:28;ragesteel;openjpa-1141.zip;https://issues.apache.org/jira/secure/attachment/12468557/openjpa-1141.zip,,,,,,,,7.0,,,,,,,,,,,,,,,,,,,2009-07-07 17:15:32.113,,,no_permission,,,,,,,,,,,161425,,,Mon Jan 17 14:28:20 UTC 2011,,,,,,,0|i0zbpr:,204200,,,,,,,,"07/Jul/09 17:15;mikedd;The entities contain comments indicating that they were generated. Did you use the OpenJPA ReverseMappingTool, or something else (ie Dali)? 

If you used the OpenJPAReverseMappingTool then would it be possible to see the table ddl that resulted in these entities? It looks like some annotations need to be added to complete the mappings. ","09/Jul/09 14:52;dirichs;See http://n2.nabble.com/NPE-at-org.apache.openjpa.jdbc.meta.MappingInfo.mergeJoinColumn(MappingInfo.java%3A1400)-tt3120428.html#a3231887
for an explanation of the root cause of this error.

It also affects 2.0.0-M2.","21/Jul/09 07:55;dirichs;There seems to be no problem with the mapping of the supplied testcase as such. The reported exception is caused while OpenJPA resolves the primary key fields of NotepadEntity. Since one of the primary key fields of NotepadEntity is the id of another entity, namely TypeEntity, the primary key fields of NotepadEntity may only be completely resolved after TypeEntity has been resolved. However, the mapping data resolution algorithm of OpenJPA doesn't take into account this type of dependency between entities.

See org.apache.openjpa.jdbc.meta.ClassMapping, methods resolveNonRelationMappings() and resolveMapping(). Inside the latter, there already seems to be a workaround for this deficiency of OpenJPAs resolution strategy. Here is says in line 838 (I'm referencing to the 2.0.0-M2 source):
  // set resolve mode to force this field mapping to be 
  // resolved again. The need to resolve again occurs when 
  // a primary key is a relation field with the foreign key
  // annotation. In this situation, this primary key field
  // mapping is resolved during the call to 
  // resolveNonRelationMapping. Since it is a relation
  // field, the foreign key will be constructed. However, 
  // the primary key of the parent entity may not have been 
  // resolved yet, resulting in missing information in the fk

Unfortunately, there are situations such as in the reported test case that cause an exception before the code following the above comment runs. A more promising strategy would be to resolve the entities in the correct order taking into account the dependencies of their primary key fields. Then this workaround would not be needed at all and the reported exception would no longer happen.

Of course, the code responsible for determining the correct order of entity resolution would have to deal with cycles, which may occur as the result of incorrect mappings. However, I can't think of any situation where cyclic references of primary key fields between entities would make any sense, so this case can probably reported as an error and remain unhandled.

Oh, btw. I would be glad to help testing any fix for this.","22/Jul/09 10:28;vorburger;Michael Dick, in response to your questions (as also via IBM PMR 44438 500 624) : 

Attached a ddl.sql which represents the three physical tables that PortfolioEntity, NotepadEntity & TypeEntity need to map to. This is a simplified subset of a more complex existing (non changeable) real-world target DDL schema.  Note that the defect (NPE) occurs inside OpenJPA within jdbc.meta.MappingInfo BEFORE any SQL at all is actually executed - this DDL is FYI as requested, but the initially provided test case actually fails with NPE and demonstrates the problem WITHOUT any DB / DDL. See Martin Dirichs comments above.

Regarding the comment in the .java that says ""This file has been automatically generated, DO NOT MODIFY!"", please ignore that - strictly speaking all those *Entity classes (not just Notepad) were generated from some kind of in-house meta description, but NOT by the OpenJPAReverseMapping tool, but by a proprietary code gen. tool. That should be irrelevant for the purposes of this discussion though, please just assume for this discussion that it was hand-written, i.e. the generator could be adapted by us if there is a solution in adding any annotations as you suggest - but which?","22/Jul/09 12:14;mikedd;Hi Michael,

I haven't taken a look at this issue since I made the earlier remarks, I'll take another look this morning and get back to you. Martin's comments above are intriguing though - at first glance I thought it was an incomplete mapping issue, but now I'm not sure. 

Thanks for the explanation of how the entities get generated, too by the way. ","22/Jul/09 15:42;bjreed;One thing I tried was playing around with the entities and persisting them before creating/running the query.

Looks like persisting a TypeEntity (even one that's not used) seems to tweak the algorithm enough to get around the NullPointerException.

I changed the doTest method to do the following:

    public void testIt () throws Exception {
        EntityManager em = emf.createEntityManager();

        em.getTransaction().begin();
        TypeEntity te = new TypeEntity();
        em.persist(te);

        Query query = em.createQuery(""SELECT o from Portfolio o"");
        query.getResultList();
        em.getTransaction().commit();
        em.close();

    }",22/Jul/09 15:53;mikedd;Spoke with B.J. offline and he agreed to look at the issue. ,"17/Aug/09 12:51;bjreed;Can someone else take a look at this?  I had only agreed originally to look at the work around and have not had much of a chance to try to actually fix the problem.  By having it assigned to me, I'm afraid that someone more capable may be kept from looking into this.",22/Oct/09 23:23;fyrewyld;Update based on suggestions from code review.,"26/Oct/09 15:05;fyrewyld;Updated version of the patch, dated 10 26 2009.",26/Oct/09 19:15;fyrewyld;OpenJPA-1141 patch for trunk,28/Oct/09 15:47;fyrewyld;Patch for OpenJPA 1.3.x,"16/Nov/09 21:36;dirichs;I have tested patch OpenJPA-Trunk_OJ1141.patch with my application. Unfortunately, the patch doesn't seem to eliminate the problem. There seemed to be no difference at all.

Digging further into this issue, I could spot in the code why the patch did not solve the problem. The patch adds a line to the bottom of MetaDataRepository.processBuffer() to reorder entities for further processing. Method processBuffer() is a bit strange at first view:

private List<ClassMetaData> processBuffer(ClassMetaData meta, InheritanceOrderedMetaDataList buffer, int mode) {
    // if we're already processing a metadata, just buffer this one; when
    // the initial metadata finishes processing, we traverse the buffer
    // and process all the others that were introduced during reentrant calls
    if (!buffer.add(meta) || buffer.size() != 1)
        return null;

    // continually pop a metadata and process it until we run out; note
    // that each processing call might place more metas in the buffer as
    // one class tries to access metadata for another; also note that the
    // buffer orders itself from least to most derived
    ClassMetaData buffered;
    List<ClassMetaData> processed = new ArrayList<ClassMetaData>(5);
    while (!buffer.isEmpty()) {
        buffered = buffer.peek();
        buffered.resolve(mode);
        processed.add(buffered);
        buffer.remove(buffered);
    }

    // this line is added by the patch
    processed = resolveFKInPKDependenciesOrdering(processed);

    return processed;
}

Thus, the iteration within processBuffer() is only executed if the supplied list of entity meta data solely contains one item, which is also supplied as first parameter to the method. This puzzle is solved, of course, by taking into account that the line ""buffered.resolve(mode);"" may lead to recursive calls to processBuffer(), thereby growing the list of meta data while iterating over it in the outermost call.

Note that the patch only adds a line behind the while loop. However, exceptions similar to the one reported in this JIRA issue occur within the while loop, during the recursion. The patch may happen to eliminate the meta data resolution problem for the supplied test setup, it does not work for the general case.

The root problem lies in the usage of an InheritanceOrderedMetaDataList as buffer. This kind of list makes sure that new meta data entries put into the list are always inserted behind any meta data entries of super classes. This is fine, but it is not enough. If entities use other entities for their primary key fields, this is a dependency not taken into account by the InheritanceOrderedMetaDataList. Instead, entities not inheriting from each other are simply ordered alphabetically when inserted into the list.

This is the real flaw of using the InheritanceOrderedMetaDataList in this context. Since resolving the meta data of an entity is only guaranteed to work if both super classes and entites referred to in the primary key fields are already resolved beforehand, the usage of InheritanceOrderedMetaDataList is error prone.

There exists another approach to remove this kind of meta data resolution problems: Use a simple ArrayList instead of InheritanceOrderedMetaDataList. In the process of resolving the meta data for an entity, the current code already takes into account all possible dependencies between entities. In short, ClassMetaData.resolveMeta() works as follows:
  - resolve super class of current entity, if applicable
  - resolve primary key field entities of current entity, if applicable
Both of these actions lead to calls to MetaDataRepository.processBuffer() with the respective entity meta data before processBuffer() is finally called for the current entity. Thus, all entities the current entity is dependent on are put into the buffer before the current entity. A simple array list thus is sufficient to let all entities be processed in the correct order.

I've attached a corresponding patch called OpenJPA-Trunk_OJ1141-2.patch which implements these considerations. Although this patch removes the special logic within MetaDataRepository introduced by the original patch, the test cases of the original patch continue to work flawlessly as does the test suite attached to this JIRA issue. What is more, this fix is also able to cope with the mapping of my application, which happens to have many instances of foreign key references in primary keys as well as sub/superclass dependencies.
","17/Jan/11 14:28;ragesteel;I'm encountered simular NullPointerException at org.apache.openjpa.jdbc.meta.MappingInfo.mergeJoinColumn(MappingInfo.java:1415), when trying to use Entities as part of Primary Key in 1.2.2. There is no such problem in 2.0.0 and 2.0.1.
I've prepare minimal set of Entities that reproduces this error.
If I remove @JoinColumns from LineItem.order or remove Item.items — problem goes away. If I rename Product to Customer (with corresponding changes in other classes) — problem goes away too.

<openjpa-1.2.2-r422266:898935 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: null
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:196)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:192)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:145)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:56)
	at org.apache.openjpa.test.TestMapping.testMapping(TestMapping.java:11)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:59)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:115)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:102)
	at org.apache.maven.surefire.Surefire.run(Surefire.java:180)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:350)
	at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1021)
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.jdbc.meta.MappingInfo.mergeJoinColumn(MappingInfo.java:1415)
	at org.apache.openjpa.jdbc.meta.MappingInfo.createJoins(MappingInfo.java:1206)
	at org.apache.openjpa.jdbc.meta.MappingInfo.createForeignKey(MappingInfo.java:968)
	at org.apache.openjpa.jdbc.meta.ValueMappingInfo.getTypeJoin(ValueMappingInfo.java:104)
	at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.map(RelationFieldStrategy.java:157)
	at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:121)
	at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:80)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:454)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:419)
	at org.apache.openjpa.jdbc.meta.ClassMapping.resolveNonRelationMappings(ClassMapping.java:871)
	at org.apache.openjpa.jdbc.meta.MappingRepository.prepareMapping(MappingRepository.java:418)
	at org.apache.openjpa.meta.MetaDataRepository.preMapping(MetaDataRepository.java:757)
	at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:644)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:393)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataLocking(MetaDataRepository.java:366)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:360)
	at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:253)
	at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:224)
	at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:192)
	at org.apache.openjpa.enhance.ManagedClassSubclasser.prepareUnenhancedClasses(ManagedClassSubclasser.java:121)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.loadPersistentTypes(AbstractBrokerFactory.java:310)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.initializeBroker(AbstractBrokerFactory.java:228)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:190)
	... 32 more
",,,,,,,,,,,,,,,,,,,,,,,
checkstyle results in velocity errors in build output,OPENJPA-1139,12428151,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,mikedd,mikedd,mikedd,17/Jun/09 17:41,06/Aug/09 17:32,14/Mar/19 03:02,17/Jun/09 18:30,2.0.0,,,,,,,,,2.0.0-M3,,,,,build / infrastructure,,,,,,0,,"The checkstyle plugin pulls in an older version of the plexus velocity plugin which generates extraneous messages like these : 

[INFO] ************************************************************** 
[INFO] Starting Jakarta Velocity v1.4
[INFO] RuntimeInstance initializing.
[INFO] Default Properties File: org/apache/velocity/runtime/defaults/velocity.properties
[INFO] Default ResourceManager initializing. (class org.apache.velocity.runtime.resource.ResourceManagerImpl)
[INFO] Resource Loader Instantiated: org.codehaus.plexus.velocity.ContextClassLoaderResourceLoader
[INFO] ClasspathResourceLoader : initialization starting.
[INFO] ClasspathResourceLoader : initialization complete.
[INFO] ResourceCache : initialized. (class org.apache.velocity.runtime.resource.ResourceCacheImpl)
[INFO] Default ResourceManager initialization complete.
[INFO] Loaded System Directive: org.apache.velocity.runtime.directive.Literal
[INFO] Loaded System Directive: org.apache.velocity.runtime.directive.Macro
[INFO] Loaded System Directive: org.apache.velocity.runtime.directive.Parse
[INFO] Loaded System Directive: org.apache.velocity.runtime.directive.Include
[INFO] Loaded System Directive: org.apache.velocity.runtime.directive.Foreach
[INFO] Created: 20 parsers.
[INFO] Velocimacro : initialization starting.
[INFO] Velocimacro : adding VMs from VM library template : VM_global_library.vm
[ERROR] ResourceManager : unable to find resource 'VM_global_library.vm' in any resource loader.
[INFO] Velocimacro : error using  VM library template VM_global_library.vm : org.apache.velocity.exception.ResourceNotFoundException: Unable to find resource 'VM_global_library.vm'
[INFO] Velocimacro :  VM library template macro registration complete.
[INFO] Velocimacro : allowInline = true : VMs can be defined inline in templates
[INFO] Velocimacro : allowInlineToOverride = false : VMs defined inline may NOT replace previous VM definitions
[INFO] Velocimacro : allowInlineLocal = false : VMs defined inline will be  global in scope if allowed.
[INFO] Velocimacro : initialization complete.
[INFO] Velocity successfully started.

Moving up to a newer velocity dependency removes much of this output (I'm specifically targetting the [ERROR] message with this fix ). ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161423,,,2009-06-17 17:41:49.0,,,,,,,0|i1ds9b:,288675,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Overrides are not applied when embeddables are defined in XML,OPENJPA-1135,12427677,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,11/Jun/09 19:13,09/Mar/10 18:31,14/Mar/19 03:02,09/Sep/09 19:37,2.0.0,,,,,,,,,2.0.0-M3,,,,,jpa,,,,,12/Jun/09 00:00,0,,"After adding support to create metadata for XML-only defined embeddables only after the embeddable is parsed (OPENJPA-926), attribute overrides on those embeddables are no longer applied.  The overrides need to be applied after the metadata is added.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161419,,,2009-06-11 19:13:47.0,,,,,,,0|i0z8pr:,203714,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DBDictionary.getPlaceholderValueString returns 0 for boolean which fails in PostgreSQL database.,OPENJPA-1133,12427606,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,rpalache,rpalache,rpalache,11/Jun/09 02:02,21/Sep/16 14:21,14/Mar/19 03:02,16/Jun/09 16:18,2.0.0,,,,,,,,,1.2.0,2.0.0-M3,,,,query,,,,,,0,,"When DBDictionary.getPlaceholderValueString is called with Types.BIT, it returns ""0"". 
PostgreSQL actually requires that a boolean be set. It cannot handle a numeric argument.

Fix Description:
Overriden DBDictionary.getPlaceholderValueString() inside PostgresDictionary to process Types.BIT correctly. 
Now, the method returns 'false' value when Types.BIT is passed as Column.type.

Test case:
The above bug is exposed from Kodo product which internally uses openJPA.
When a query is made on a subclass using kodo api.
Kodo generates an SQL ( with help of openJPA) that has UNION in it.

It generates a SQL similar to the following:

 SELECT 0  FROM public.classA t0 UNION ALL SELECT t0.guidance FROM public.classB t0
 
It got 0 from the openJPA DBDictionary.getPlaceholderValueString as the guidance data type is boolean.

The above SQL will throw an exception in postgreSQL db saying: 
ERROR: UNION types integer and boolean cannot be matched.","openJPA trunk.
PostgreSQL 8.3",,,,,,,,,,,,,,,,,,,,,11/Jun/09 15:28;rpalache;OPENJPA-1133_trunk.patch;https://issues.apache.org/jira/secure/attachment/12410407/OPENJPA-1133_trunk.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-06-16 16:18:21.611,,,no_permission,,,,,,,,,,,38730,,,Fri Aug 07 21:34:30 UTC 2009,,,Patch Available,,,,0|i0z8p3:,203711,,,,,,,,11/Jun/09 15:28;rpalache;Attached patch contains test case and fix on trunk.,"16/Jun/09 12:47;rpalache;Hi,

Can someone please commit these changes.

Thanks,
Ravi.",16/Jun/09 16:18;mikedd;Thanks for the patch Ravi. ,"07/Aug/09 21:34;dezzio;From trunk, merged fix to 1.1.x branch at revs 802213 and 802214",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Dropping constraints fails on MySQL,OPENJPA-1132,12427582,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,milosz,milosz,milosz,10/Jun/09 17:57,09/Mar/10 18:31,14/Mar/19 03:02,13/Jun/09 15:06,1.3.0,2.0.0,,,,,,,,2.0.0-M3,,,,,sql,,,,,,0,,"MySQL rejects our DROP CONSTRAINT statements, it requires different syntax.
",MySQL 5.1,,,,,,,,,,,,,,,OPENJPA-1083,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-06-11 02:49:49.522,,,no_permission,,,,,,,,,,,161417,,,Sat Jun 13 15:06:58 UTC 2009,,,,,,,0|i0z8of:,203708,,,,,,,,"11/Jun/09 02:49;mikedd;Looks like ALTER TABLE xxx DROP FOREIGN KEY yyy should work [1]. I'm not sure if there's a more general name we can use  though. 

[1] http://dev.mysql.com/doc/refman/5.1/en/innodb-foreign-key-constraints.html","13/Jun/09 15:06;milosz;I have modified MySQLDictionary to use ""ALTER TABLE xxx DROP FOREIGN KEY yyy"". Also corrected the statement to drop a primary key to ""ALTER TABLE xxx DROP PRIMARY KEY"" although it seems to be unused at the moment.

Change applied to trunk and 1.3.x branch.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""openjpa.FetchPlan.ReadLockMode is not a supported query hint...."" WARNING message is logged when creating a named query.",OPENJPA-1129,12427388,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,curtisr7,curtisr7,08/Jun/09 18:41,09/Mar/10 18:31,14/Mar/19 03:02,20/Oct/09 04:27,2.0.0,,,,,,,,,2.0.0-M2,2.0.0-M3,,,,,,,,,,0,,"When I create a namedQuery, I see the following message logged.

110641  WARN   [Thread-2] openjpa.Runtime - ""openjpa.FetchPlan.ReadLockMode"" is not a supported query hint. May be you meant ""openjpa.FetchPlan.ReadLockLevel""? 

To recreate the problem, create an Entity with a named query and then try to create that named query via EntityManager.createNamedQuery(..). It doesn't seem to have any functional affect, but I don't think it should be logged.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161414,,,2009-06-08 18:41:49.0,,,,,,,0|i1dsa7:,288679,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Typos in user manual and log messages,OPENJPA-1127,12427276,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,milosz,milosz,milosz,06/Jun/09 08:54,09/Mar/10 18:31,14/Mar/19 03:02,06/Jun/09 09:28,1.2.1,2.0.0,,,,,,,,2.0.0-M3,,,,,diagnostics,docs,,,,,0,,"A few typographical errors exist in the user manual and localizer.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161412,,,Sat Jun 06 09:28:42 UTC 2009,,,,,,,0|i1dsaf:,288680,,,,,,,,06/Jun/09 09:28;milosz;Corrections applied to trunk and 1.3.x branch.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
A message is logged about dynamically loading the class enhancer even though I'm using the -javaagent,OPENJPA-1125,12427229,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,05/Jun/09 16:29,02/May/13 02:29,14/Mar/19 03:02,10/Jun/09 14:56,2.0.0,,,,,,,,,2.0.0-M3,,,,,kernel,,,,,,0,,"When using the -javaagent enhancer, I see a message about OpenJPA dynamically loading the class enhancer.

INFO   [main] openjpa.Runtime - OpenJPA dynamically loaded the class enhancer. Any classes that were not enhanced at build time will be enhanced when the are loaded by the JVM. ",,,,,,,,,,,,,,,,,,,,,OPENJPA-952,09/Jun/09 19:34;curtisr7;OPENJPA-1125.patch;https://issues.apache.org/jira/secure/attachment/12410246/OPENJPA-1125.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-06-10 14:56:02.48,,,no_permission,,,,,,,,,,,161410,,,Wed Jun 10 14:56:02 UTC 2009,,,Patch Available,,,,0|i0zamf:,204023,,,,,,,,"05/Jun/09 18:01;curtisr7;Changed the logic in PCEnhancerAgent so that loadDynamicAgent will return true ONLY when the enhancer is dynamically invoked. This will ensure that the ""OpenJPA dynamically loaded the class..."" message is logged appropriately.",09/Jun/09 19:34;curtisr7;Refactored as part of testing for OPENJPA-1119.,10/Jun/09 14:56;mikedd;Thanks for the patch Rick. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Enums cause a ClassNotFoundException in the MappingTool,OPENJPA-1121,12427202,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,fs5,fs5,05/Jun/09 11:17,09/Mar/10 18:31,14/Mar/19 03:02,08/Mar/10 18:31,1.2.1,,,,,,,,,1.3.0,2.0.0-M3,,,,jpa,tooling,,,,,4,,"see: http://n2.nabble.com/mapping-tool---enums--trunk-td2138657.html#a2138657

ant trace:
Buildfile: C:\Development\projects\oopex\projectroot\image\openjpa1-jpa\fields-enum\build.xml
clean:
   [delete] Deleting directory C:\Development\projects\oopex\projectroot\image\openjpa1-jpa\fields-enum\build
init:
build:
    [mkdir] Created dir: C:\Development\projects\oopex\projectroot\image\openjpa1-jpa\fields-enum\build\model
    [mkdir] Created dir: C:\Development\projects\oopex\projectroot\image\openjpa1-jpa\fields-enum\build\java
    [mkdir] Created dir: C:\Development\projects\oopex\projectroot\image\openjpa1-jpa\fields-enum\build\conf
    [javac] Compiling 3 source files to C:\Development\projects\oopex\projectroot\image\openjpa1-jpa\fields-enum\build\model
    [javac] Compiling 1 source file to C:\Development\projects\oopex\projectroot\image\openjpa1-jpa\fields-enum\build\java
     [copy] Copying 1 file to C:\Development\projects\oopex\projectroot\image\openjpa1-jpa\fields-enum\build\conf
schema:
    [mkdir] Created dir: C:\Development\projects\oopex\projectroot\image\openjpa1-jpa\fields-enum\build\sql
[openjpa:mappingtool] 10  default  TRACE  [main] openjpa.Runtime - Setting the following properties from ""file:/C:/Development/projects/oopex/projectroot/image/openjpa1-jpa/fields-enum/build/conf/META-INF/persistence.xml"" into configuration: {openjpa.ConnectionPassword=, openjpa.ConnectionDriverName=org.h2.Driver, javax.persistence.provider=org.apache.openjpa.persistence.PersistenceProviderImpl, openjpa.MetaDataFactory=jpa(Types=oopex.openjpa1.jpa.fields.model.Person), openjpa.jdbc.Schema=TEST, openjpa.Log=File=stdout, DefaultLevel=WARN, Runtime=TRACE, SQL=TRACE, DataCache=TRACE, Tool=INFO, openjpa.jdbc.DBDictionary=oracle(MaxEmbeddedBlobSize=-1), openjpa.ConnectionUserName=sa, openjpa.ConnectionURL=jdbc:h2:tcp://localhost:9092/sample, openjpa.Id=default}
[openjpa:mappingtool] 36  default  INFO   [main] openjpa.Tool - No targets were given.  Running on all classes listed in your configuration, or all persistent classes in the classpath if no classes are configured.  Use -help to display tool usage information.
[openjpa:mappingtool] 48  default  TRACE  [main] openjpa.Runtime - No cache marshaller found for id org.apache.openjpa.conf.MetaDataCacheMaintenance.
[openjpa:mappingtool] 259  default  INFO   [main] openjpa.Tool - Mapping tool running on type ""class oopex.openjpa1.jpa.fields.model.Person"" with action ""buildSchema"".
[openjpa:mappingtool] 259  default  TRACE  [main] openjpa.Runtime - No cache marshaller found for id org.apache.openjpa.conf.MetaDataCacheMaintenance.
[openjpa:mappingtool] java.lang.NoClassDefFoundError: Loopex/openjpa1/jpa/fields/enums/State;
[openjpa:mappingtool] 	at java.lang.Class.getDeclaredFields0(Native Method)
[openjpa:mappingtool] 	at java.lang.Class.privateGetDeclaredFields(Class.java:2291)
[openjpa:mappingtool] 	at java.lang.Class.getDeclaredFields(Class.java:1743)
[openjpa:mappingtool] 	at org.apache.openjpa.lib.util.J2DoPrivHelper$7.run(J2DoPrivHelper.java:270)
[openjpa:mappingtool] 	at java.security.AccessController.doPrivileged(Native Method)
[openjpa:mappingtool] 	at org.apache.openjpa.persistence.PersistenceMetaDataDefaults.getAccessType(PersistenceMetaDataDefaults.java:262)
[openjpa:mappingtool] 	at org.apache.openjpa.persistence.PersistenceMetaDataDefaults.getAccessType(PersistenceMetaDataDefaults.java:250)
[openjpa:mappingtool] 	at org.apache.openjpa.meta.AbstractMetaDataDefaults.populate(AbstractMetaDataDefaults.java:155)
[openjpa:mappingtool] 	at org.apache.openjpa.persistence.PersistenceMetaDataDefaults.populate(PersistenceMetaDataDefaults.java:227)
[openjpa:mappingtool] 	at org.apache.openjpa.meta.MetaDataRepository.addMetaData(MetaDataRepository.java:794)
[openjpa:mappingtool] 	at org.apache.openjpa.meta.MetaDataRepository.addMetaData(MetaDataRepository.java:780)
[openjpa:mappingtool] 	at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.getMetaData(AnnotationPersistenceMetaDataParser.java:657)
[openjpa:mappingtool] 	at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parseClassAnnotations(AnnotationPersistenceMetaDataParser.java:480)
[openjpa:mappingtool] 	at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parse(AnnotationPersistenceMetaDataParser.java:352)
[openjpa:mappingtool] 	at org.apache.openjpa.persistence.PersistenceMetaDataFactory.load(PersistenceMetaDataFactory.java:229)
[openjpa:mappingtool] 	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:474)
[openjpa:mappingtool] 	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:294)
[openjpa:mappingtool] 	at org.apache.openjpa.jdbc.meta.MappingRepository.getMapping(MappingRepository.java:285)
[openjpa:mappingtool] 	at org.apache.openjpa.jdbc.meta.MappingTool.getMapping(MappingTool.java:676)
[openjpa:mappingtool] 	at org.apache.openjpa.jdbc.meta.MappingTool.buildSchema(MappingTool.java:748)
[openjpa:mappingtool] 	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:646)
[openjpa:mappingtool] 	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:1072)
[openjpa:mappingtool] 	at org.apache.openjpa.jdbc.ant.MappingToolTask.executeOn(MappingToolTask.java:205)
[openjpa:mappingtool] 	at org.apache.openjpa.lib.ant.AbstractTask.execute(AbstractTask.java:172)
[openjpa:mappingtool] 	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)
[openjpa:mappingtool] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[openjpa:mappingtool] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
[openjpa:mappingtool] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
[openjpa:mappingtool] 	at java.lang.reflect.Method.invoke(Method.java:597)
[openjpa:mappingtool] 	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105)
[openjpa:mappingtool] 	at org.apache.tools.ant.Task.perform(Task.java:348)
[openjpa:mappingtool] 	at org.apache.tools.ant.Target.execute(Target.java:357)
[openjpa:mappingtool] 	at org.apache.tools.ant.Target.performTasks(Target.java:385)
[openjpa:mappingtool] 	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1329)
[openjpa:mappingtool] 	at org.apache.tools.ant.Project.executeTarget(Project.java:1298)
[openjpa:mappingtool] 	at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)
[openjpa:mappingtool] 	at org.eclipse.ant.internal.ui.antsupport.EclipseDefaultExecutor.executeTargets(EclipseDefaultExecutor.java:32)
[openjpa:mappingtool] 	at org.apache.tools.ant.Project.executeTargets(Project.java:1181)
[openjpa:mappingtool] 	at org.eclipse.ant.internal.ui.antsupport.InternalAntRunner.run(InternalAntRunner.java:423)
[openjpa:mappingtool] 	at org.eclipse.ant.internal.ui.antsupport.InternalAntRunner.main(InternalAntRunner.java:137)
[openjpa:mappingtool] Caused by: java.lang.ClassNotFoundException: oopex.openjpa1.jpa.fields.enums.State
[openjpa:mappingtool] 	at org.apache.tools.ant.AntClassLoader.findClassInComponents(AntClassLoader.java:1383)
[openjpa:mappingtool] 	at org.apache.tools.ant.AntClassLoader.findClass(AntClassLoader.java:1324)
[openjpa:mappingtool] 	at org.apache.tools.ant.AntClassLoader.loadClass(AntClassLoader.java:1072)
[openjpa:mappingtool] 	at java.lang.ClassLoader.loadClass(ClassLoader.java:252)
[openjpa:mappingtool] 	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:320)
[openjpa:mappingtool] 	at java.lang.Class.forName0(Native Method)
[openjpa:mappingtool] 	at java.lang.Class.forName(Class.java:247)
[openjpa:mappingtool] 	at org.apache.openjpa.lib.util.TemporaryClassLoader.loadClass(TemporaryClassLoader.java:77)
[openjpa:mappingtool] 	at org.apache.openjpa.lib.util.TemporaryClassLoader.loadClass(TemporaryClassLoader.java:44)
[openjpa:mappingtool] 	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:320)
[openjpa:mappingtool] 	... 40 more

BUILD FAILED
C:\Development\projects\oopex\projectroot\image\openjpa1-jpa\fields-enum\build.xml:91: java.lang.NoClassDefFoundError: Loopex/openjpa1/jpa/fields/enums/State;

Total time: 2 seconds
",,,,,,,,,,,,,,,,,,,,,,09/Sep/09 19:15;fs5;TemporaryClassLoader.patch;https://issues.apache.org/jira/secure/attachment/12419079/TemporaryClassLoader.patch,04/Aug/09 08:47;fs5;fields-enum-trunk.zip;https://issues.apache.org/jira/secure/attachment/12415472/fields-enum-trunk.zip,05/Jun/09 11:19;fs5;fields-enum.zip;https://issues.apache.org/jira/secure/attachment/12409971/fields-enum.zip,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2009-06-05 16:34:49.288,,,no_permission,,,,,,,,,,,161406,,,Sun Mar 07 15:54:50 UTC 2010,,,Patch Available,,,,0|i0z1rb:,202587,,,,,,,,05/Jun/09 11:19;fs5;reproducer,"05/Jun/09 16:34;ppoddar@apache.org;works on trunk.
Possible to switch to tunk and verify?","04/Aug/09 08:47;fs5;Also with trunk (r800568)

java.lang.NoClassDefFoundError: Loopex/openjpa2/jpa2/fields/enums/State;
    at java.lang.Class.getDeclaredFields0(Native Method)
    at java.lang.Class.privateGetDeclaredFields(Class.java:2291)
    at java.lang.Class.getDeclaredFields(Class.java:1743)
    at org.apache.openjpa.lib.util.J2DoPrivHelper$7.run(J2DoPrivHelper.java:292)
    at org.apache.openjpa.lib.util.J2DoPrivHelper$7.run(J2DoPrivHelper.java:290)
    at java.security.AccessController.doPrivileged(Native Method)
    at org.apache.openjpa.persistence.PersistenceMetaDataDefaults.determineImplicitAccessType(PersistenceMetaDataDefaults.java:339)
    at org.apache.openjpa.persistence.PersistenceMetaDataDefaults.determineAccessType(PersistenceMetaDataDefaults.java:308)
    at org.apache.openjpa.persistence.PersistenceMetaDataDefaults.populate(PersistenceMetaDataDefaults.java:250)
    at org.apache.openjpa.meta.MetaDataRepository.addMetaData(MetaDataRepository.java:809)
    at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.getMetaData(AnnotationPersistenceMetaDataParser.java:744)
    at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parseClassAnnotations(AnnotationPersistenceMetaDataParser.java:545)
    at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parse(AnnotationPersistenceMetaDataParser.java:416)
    at org.apache.openjpa.persistence.PersistenceMetaDataFactory.load(PersistenceMetaDataFactory.java:260)
    at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:489)
    at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:309)
    at org.apache.openjpa.jdbc.meta.MappingRepository.getMapping(MappingRepository.java:289)
    at org.apache.openjpa.jdbc.meta.MappingTool.getMapping(MappingTool.java:676)
    at org.apache.openjpa.jdbc.meta.MappingTool.buildSchema(MappingTool.java:748)
    at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:646)
    at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:1072)
    at org.apache.openjpa.jdbc.ant.MappingToolTask.executeOn(MappingToolTask.java:205)
    at org.apache.openjpa.lib.ant.AbstractTask.execute(AbstractTask.java:171)
    at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)
    at org.apache.tools.ant.Task.perform(Task.java:348)
    at org.apache.tools.ant.Target.execute(Target.java:357)
    at org.apache.tools.ant.Target.performTasks(Target.java:385)
    at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1337)
    at org.apache.tools.ant.Project.executeTarget(Project.java:1306)
    at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)
    at org.apache.tools.ant.Project.executeTargets(Project.java:1189)
    at org.apache.tools.ant.Main.runBuild(Main.java:758)
    at org.apache.tools.ant.Main.startAnt(Main.java:217)
    at org.apache.tools.ant.launch.Launcher.run(Launcher.java:257)
    at org.apache.tools.ant.launch.Launcher.main(Launcher.java:104)
Caused by: java.lang.ClassNotFoundException: oopex.openjpa2.jpa2.fields.enums.State
    at org.apache.tools.ant.AntClassLoader.findClassInComponents(AntClassLoader.java:1400)
    at org.apache.tools.ant.AntClassLoader.findClass(AntClassLoader.java:1341)
    at org.apache.tools.ant.AntClassLoader.loadClass(AntClassLoader.java:1088)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:252)
    at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:320)
    at java.lang.Class.forName0(Native Method)
    at java.lang.Class.forName(Class.java:247)
    at org.apache.openjpa.lib.util.TemporaryClassLoader.loadClass(TemporaryClassLoader.java:77)
    at org.apache.openjpa.lib.util.TemporaryClassLoader.loadClass(TemporaryClassLoader.java:44)
    at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:320)
    ... 40 more",09/Sep/09 19:15;fs5;Patch attached. This is a hack of the hack from bug OPENJPA-646.,"07/Mar/10 15:54;jankeesvanandel;Same issue here, I'm using 2.0.0-M3.

It's currently preventing me of using any annotations in my entities.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
idEquals() broken in BigDecimalId and BigIntegerId,OPENJPA-1120,12427192,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,drwoods,dvholten,dvholten,05/Jun/09 09:17,09/Mar/10 18:31,14/Mar/19 03:02,14/Sep/09 19:54,1.0.3,1.1.0,1.2.1,1.3.0,2.0.0,,,,,1.3.0,2.0.0-M3,,,,jpa,,,,,,0,,"in openjpa/util/BigDecimalId and open/util/BigIntegerId the idEquals-methods compare their own keys to the other object, not to others.key.
That would always result in false - which is false sometimes",,,,,,,,,,,,,,,,,,,,,,05/Jun/09 09:18;dvholten;BrokenEqualsId.patch;https://issues.apache.org/jira/secure/attachment/12409957/BrokenEqualsId.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-06-05 16:30:15.868,,,no_permission,,,,,,,,,,,38543,,,Sun Aug 09 17:56:23 UTC 2009,,,Patch Available,,,,0|i1dsbj:,288685,,,,,,,,"05/Jun/09 16:30;allee8285;Need to check if ""other"" is a BigDecimalId or a subclass of BigDecimalId, otherwise a ClassCastException will occur in the return statement.

       if(key == null || ! BigDecimalId.class.isAssignableFrom(other.getClass())) 
             return false;
 
        return key.equals(((BigDecimalId)other).key);

Albert Lee.","30/Jul/09 01:04;drwoods;Applied to trunk as Rev799132 and 1.3.x as Rev799142.
Mike, can you consider applying the changes to 1.2.x and maybe 1.0.x?",09/Aug/09 17:56;mikedd;I'd like to see a testcase before deciding to include this fix in 1.2.x. It seems fairly straightforward but it'd be good to have one to prevent future regressions in this area. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE in InstrumentationFactory,OPENJPA-1119,12427147,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,04/Jun/09 20:03,09/Mar/10 18:31,14/Mar/19 03:02,22/Jun/09 19:16,2.0.0,,,,,,,,,2.0.0-M3,,,,,kernel,,,,,,0,,"As reported in the dev forum [1] InstrumentationFactory.class.getProtectionDomain().getCodeSource() returns null, causing a NPE.

Caused by: java.lang.NullPointerException
        at org.apache.openjpa.enhance.InstrumentationFactory.getAgentJar(InstrumentationFactory.java:204)
        at org.apache.openjpa.enhance.InstrumentationFactory.access$200(InstrumentationFactory.java:47)
        at org.apache.openjpa.enhance.InstrumentationFactory$1.run(InstrumentationFactory.java:99)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.apache.openjpa.enhance.InstrumentationFactory.getInstrumentation(InstrumentationFactory.java:87)
        at org.apache.openjpa.enhance.PCEnhancerAgent.loadDynamicAgent(PCEnhancerAgent.java:95)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.loadAgent(PersistenceProviderImpl.java:243)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:91)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:119)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:55)
        at javax.persistence.Persistence.createFactory(Persistence.java:172)
        ... 51 more

[1] http://n2.nabble.com/Error-loading-agent-with-Openjpa2-td3024299.html",,0,0,,0%,0,0,,,,,,,,,,,,,,,19/Jun/09 17:25;drwoods;OPENJPA-1119-dwoods.patch;https://issues.apache.org/jira/secure/attachment/12411244/OPENJPA-1119-dwoods.patch,17/Jun/09 14:14;curtisr7;OPENJPA-1119.PATCH;https://issues.apache.org/jira/secure/attachment/12410936/OPENJPA-1119.PATCH,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-06-16 21:16:15.559,,,no_permission,,,,,,,,,,,38610,,,Fri Jun 19 17:50:11 UTC 2009,,,Patch Available,,,,0|i0zatr:,204056,,,,,,,,05/Jun/09 20:13;curtisr7;Made code change to detect when the ProtectionDomain returns NULL for a code source.,"10/Jun/09 17:21;curtisr7;Refactored code for a more 'complete' fix. This new patch fixes the NPE, but also does some additional manifest validation. 

If it is determined that the InstrumentationFactory was loaded from a jar file, that jar file is opened up and the manifest is examined. If the InstrumentationFactory is defined as the Agent-Class, we will go ahead and use that as an argument to the attach api. If the InstrumentationFactory isn't defined as the Agent-Class, we will go off and create a temporary file. 

Currently the openjpa-all.xxxx.jar and openjpa-kernal.xx.jar files do not have the InstrumentationFactory defined as the Agent-Class and I will address that issue in OPENJPA-1117. I can hypothesize that the InstrumentationFactory could be loaded from a jar that doesn't have the Agent-Class defined if a user were to repackage OpenJPA and not properly copy the manifest attributes over.

While testing this patch I uncovered 33 new test failures when running on Sun 1.6. After looking closer at the failures, most of the tests are named TestUnenhancedxxxxx. After looking at the commit comment for OPENJPA-293, it appears that it was known that these tests would fail when using redefinition. Now that it is possible to use redefinition, these tests are failing. Since it appears [1] that we are going to disable support for the redefinition(subclassing) I am going to exclude these failing tests from the build. Three other tests are also failing due to the dynamic enhancer, so I am excluding those tests also.

I also updated the openjpa-persistence-jdbc/pom.xml and added -XX:MaxPermSize=256m to the test.jvm.arguments to take care of the Sun PermGen OOM problems that I run into when running on Sun 1.6. 

[1]http://n2.nabble.com/-VOTE--Turn-off-enhancement-by-subclassing-as-the-default-td1616140.html#a2950000","16/Jun/09 21:16;mikedd;Hi Rick,

Before we commit the patch could we make the perm gen size configurable? 256m doesn't seem to be enough for 64 bit JVMs so it might make sense to user a variable in pom.xml; set the variable to a default value (if we can it'd be neat to set it differently for 64 vs 32 bit jvms automagically), but let the build override it with  -Dtest.permgen.size=512m. 

Sorry I didn't try it on 64 bit JVMs until now. ","17/Jun/09 14:14;curtisr7;Updated the patch so that the jvm arg -XX:MaxPermSize is configurable via -Dtest.permgen.size=xxxm. I also increased the default value to 512m rather than 256m.

-Rick",17/Jun/09 18:32;mikedd;Thanks Rick. I haven't found a value that works on my 64 bit config with Sun JDK6 (tried up to 1024m which seems extreme). When I find a value that works I'll commit the patch. ,"18/Jun/09 15:09;drwoods;Michael, which OS are you seeing OOM for?

I'm running with the 64bit Sun JDK 1.6 on MacOSX -
java version ""1.6.0_13""
Java(TM) SE Runtime Environment (build 1.6.0_13-b03-211)
Java HotSpot(TM) 64-Bit Server VM (build 11.3-b02-83, mixed mode)

with the following in o-p-j/pom.xml -
+        <test.jvm.maxpermsize>256m</test.jvm.maxpermsize>    
+        <test.jvm.maxheapsize>512m</test.jvm.maxheapsize> 

and MAVEN_OPTS=""-Xmx1024m -XX:MaxPermSize=256m""

","18/Jun/09 15:59;mikedd;It's not actually an OOM, it's a case of running out of perm gen space. I've only see it happen with Linux + Sun JDK6.. Maybe I need to upgrade my JDK (and only with the patch applied). 

$java -version
java version ""1.6.0_13""
Java(TM) SE Runtime Environment (build 1.6.0_13-b03)
Java HotSpot(TM) 64-Bit Server VM (build 11.3-b02, mixed mode)
","19/Jun/09 17:25;drwoods;Updated patch after OPENJPA-1117 commit that works for me w/ Sun 64bit JDK 6 on MacOSX (if you exclude the criteria tests.)  Will try running on 64bit Linux before committing.
",19/Jun/09 17:50;drwoods;Only seeing the OOM PermGen space on 64bit Sun JDK 6 on Linux (SLES 10 SP 2 on x86_64  in this case),,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missing AgentClass attribute in openjpa-all-xxx.jar manifest.mf,OPENJPA-1117,12427049,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,drwoods,curtisr7,curtisr7,03/Jun/09 18:45,09/Mar/10 18:31,14/Mar/19 03:02,19/Jun/09 17:45,2.0.0,,,,,,,,,2.0.0-M3,,,,,build / infrastructure,,,,,,0,,"OPENJPA-952 added the Agent-Class attribute to the manifest.mf file for the openjpa binary, but the change was missed for openjpa-all. The openjpa-all pom.xml needs to have org.apache.openjpa.enhance.InstrumentationFactory defined as an AgentClass.","C:\>java -version
java version ""1.6.0_11""
Java(TM) SE Runtime Environment (build 1.6.0_11-b03)
Java HotSpot(TM) Client VM (build 11.0-b16, mixed mode, sharing)",,,,,,,,,,,,,,,,,,,,,19/Jun/09 16:11;drwoods;OPENJPA-1117-13x.patch;https://issues.apache.org/jira/secure/attachment/12411239/OPENJPA-1117-13x.patch,19/Jun/09 16:11;drwoods;OPENJPA-1117-trunk.patch;https://issues.apache.org/jira/secure/attachment/12411238/OPENJPA-1117-trunk.patch,03/Jun/09 19:49;curtisr7;OPENJPA-1117.patch;https://issues.apache.org/jira/secure/attachment/12409809/OPENJPA-1117.patch,03/Jun/09 18:46;curtisr7;OPENJPA-1117.patch;https://issues.apache.org/jira/secure/attachment/12409805/OPENJPA-1117.patch,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2009-06-18 17:43:59.911,,,no_permission,,,,,,,,,,,161404,,,Fri Jun 19 17:45:06 UTC 2009,,,Patch Available,,,,0|i1dsbz:,288687,,,,,,,,"03/Jun/09 19:26;curtisr7;I just ran into another issue, please hold off on committing this patch.","03/Jun/09 19:49;curtisr7;Updated the patch to also add the Agent-Class attribute to the openjpa-kernel module.

This is necessary to get the dynamic enhancer to run with the unit tests when running the 'package' target. ","18/Jun/09 17:43;drwoods;Yep, will take a look at the patch , as I just ran into this on Win2008 w/ 64bit Sun JDK6 -

Tests run: 1885, Failures: 24, Errors: 123, Skipped: 0
Failed to find Agent-Class manifest attribute from C:\Users\drwoods\openjpa\trunk\openjpa-kernel\target\openjpa-kernel-2.0.0-SNAPSHOT.jar
Failed to find Agent-Class manifest attribute from C:\Users\drwoods\openjpa\trunk\openjpa-kernel\target\openjpa-kernel-2.0.0-SNAPSHOT.jar
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE","18/Jun/09 18:56;drwoods;and then I ran into the OOM - PermGen space problem, so pulling in parts of OPENJPA-1119 to set the JVM memory options.",19/Jun/09 16:11;drwoods;Patch committed to trunk.,19/Jun/09 16:11;drwoods;Patch for 1.3.x branch.,"19/Jun/09 17:45;drwoods;Rick, thanks for the patch.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Annotation Strategy not working,OPENJPA-1116,12427028,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ashishpaliwal,ashishpaliwal,03/Jun/09 13:38,09/Mar/10 18:31,14/Mar/19 03:02,23/Sep/09 19:25,1.3.0,2.0.0-M2,,,,,,,,1.3.0,2.0.0-M3,,,,jdbc,,,,,,0,,"I had 2 entities, Person and Address where person had id, age, name and address_id and person had id and city.
I tried to apply the Strategy on Address so that  upon execution of JPQL query ""Select p from Person p"" the SQL query fired should make Inner Join rather than the default Left Outer Join.
I created a Strategy class InnerJoinStrategy that makes sure this happens  by overriding the selectEagerJoin() method and gave @Strategy(value = ""somepackage.InnerJoinStrategy"" ) in Person class before getAddress() method.
But unexpectedly, it was still making the LeftOuterJoin rather than the desired InnerJoin. Upon debugging I found that my strategy was never being called. I debugged further and found that in AnnotationPersistenceMappingParser class in parseMemberMappingAnnotations() method, for the case STRAT( which belongs to the Strategy annotation) the strategy value was being set in ValueMappingInfo, while from RuntimeStrategyInstaller it was being fetched from FieldMappingInfo. I changed the code to set it in FieldMappingInfo and everything worked fine. 

","Windows XP,  openjpa-2.0.0 source code",,,,,,,,,,,,,,,,,,,,,03/Jun/09 13:49;ashishpaliwal;OPENJPA-1116-2.0.0(2).patch;https://issues.apache.org/jira/secure/attachment/12409767/OPENJPA-1116-2.0.0%282%29.patch,03/Jun/09 13:49;ashishpaliwal;OPENJPA-1116-2.0.0.patch;https://issues.apache.org/jira/secure/attachment/12409766/OPENJPA-1116-2.0.0.patch,03/Jun/09 13:49;ashishpaliwal;testStrategyAnnotation.jar;https://issues.apache.org/jira/secure/attachment/12409765/testStrategyAnnotation.jar,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2009-09-23 19:25:27.764,,,no_permission,,,,,,,,,,,38611,,,Wed Sep 23 19:25:27 UTC 2009,,,Patch Available,,,,0|i0zav3:,204062,,,,,,,,"03/Jun/09 13:49;ashishpaliwal;The test case along with my InnerJoinStrategy and persistent entities person and Address.
2 Patches:
First for the dummy test case which I created to check the @strategy annotation, 
Second for the suggested change in AnnotationPersistenceMappingParser class.","23/Sep/09 19:25;drwoods;Code fixed in trunk in r808703 by Pinaki.
Testcases added to trunk in r818212 and r818215.
Code and testcases merged into 1.3.0 in r818217.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"@Version-Annotation on Column with unsupported type (e.g. BigDecimal) is silently ignored, but should raise an error",OPENJPA-1100,12426109,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,bardioc,bardioc,22/May/09 13:12,09/Mar/10 18:31,14/Mar/19 03:02,28/Aug/09 01:40,1.2.1,1.3.0,2.0.0-M2,,,,,,,2.0.0-M3,,,,,,,,,,,0,,"In the following example, the @Version annotated field 'version' does have a wrong type (none of the supported ones).

@Entity
@Table(name = ""PARTNER"", schema = ""PART"")
public class Partner
{
    @Id
    @Column(name = ""PART_KEY"")
    private BigDecimal partKey;

    @OneToMany(mappedBy = ""partner"", fetch = FetchType.LAZY)
    private List<PartnerRolle> rollen;
}

@Entity
@Table(name = ""PARTNERROLLE"")
public class PartnerRolle
{
    @EmbeddedId
    private PartnerRolleKey key;

    @Version
    @Column(name = ""VERSION"")
    private BigDecimal version;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = ""PART_KEY"")
    private Partner partner;
}

This does NOT lead to an error but silently omits the column in any query statements. The prepared statement (prepstmt) simply omitts the column. If the @Version is removed or a supported type like 'long' is used, the behaviour is correct.

Best regards,

Heiko","Windows XP, Java SDK 1.6, Websphere 6.1 + openJPA 1.2.1",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161388,,,2009-05-22 13:12:16.0,,,,,,,0|i0z99b:,203802,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
<xmp> tag in Javadoc comments causes Javadoc corruption,OPENJPA-1099,12426042,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,dezzio,dezzio,dezzio,21/May/09 18:42,22/May/09 14:19,14/Mar/19 03:02,22/May/09 14:19,1.1.0,1.2.0,1.2.1,,,,,,,2.0.0-M2,,,,,,,,,,,1,,"Two files (J2DoPrivHelper.java, and SequencedActionsTest.java) have <xmp>...</xmp> in their Javadoc comments.  I don't know what the purpose of these tags may be in some environments.  IMO, they should be replaced by <pre>...</pre> tags which do not cause problems for the Javadoc.  The problem can be readily seen by opening the Javadoc of OpenJPA in a browser and clicking on index, then scroll down to the J2DoPrivHelper class entry.  I'll leave this bug open for a few days to allow a chance for comments, in case I'm missing something.",Windows maven (and nightly snapshots and releases),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-05-21 19:22:15.386,,,no_permission,,,,,,,,,,,161387,,,Fri May 22 14:19:46 UTC 2009,,,,,,,0|i0yz0f:,202142,,,,,,,,"21/May/09 19:22;mikedd;It's my understanding that <xmp> is deprecated and we should replace with <pre></pre> using &lt &gt where appropriate. 

I think it's supported by some browsers though (or at least was for a while after it was deprecated). Regardless we should fix it. ",22/May/09 14:19;dezzio;Fix in revision 777539. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Detachment processing of our proxied mutable types (Date, Timestamp, etc) needs to be consistent",OPENJPA-1097,12426020,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,kwsutter,kwsutter,21/May/09 13:45,05/Apr/10 15:45,14/Mar/19 03:02,22/Mar/10 19:04,1.2.2,1.3.0,2.0.0-M1,,,,,,,1.3.0,2.0.0-beta3,,,,jpa,,,,,,0,,"Per the discussion on our forums [1], there seems to some consistent issues with how we perform detachment processing of the mutable types such as Date, Timestamp, etc.  There seems to be a couple of issues (at least)...

o  Detachment processing is not consistent between the detach() method and the clear() method.
o  Tracking of changes on a detached entity, but still allow it to be serialized without requiring the openjpa jar file.

[1]  http://n2.nabble.com/Date-Problem-td2943310.html#a2943310",,,,,,,,,,,,,,,,OPENJPA-1571,OPENJPA-1597,,,,,16/Mar/10 21:39;drwoods;OPENJPA-1097-12x-tests.diff;https://issues.apache.org/jira/secure/attachment/12438974/OPENJPA-1097-12x-tests.diff,04/Mar/10 20:17;drwoods;OPENJPA-1097-tests.diff;https://issues.apache.org/jira/secure/attachment/12437923/OPENJPA-1097-tests.diff,06/Mar/10 03:24;drwoods;OPENJPA-1097-trunk.diff;https://issues.apache.org/jira/secure/attachment/12438076/OPENJPA-1097-trunk.diff,16/Mar/10 16:25;drwoods;OPENJPA-1097.1-trunk.patch;https://issues.apache.org/jira/secure/attachment/12438933/OPENJPA-1097.1-trunk.patch,17/Mar/10 21:15;drwoods;OPENJPA-1097.2-trunk.patch;https://issues.apache.org/jira/secure/attachment/12439081/OPENJPA-1097.2-trunk.patch,05/Mar/10 14:38;curtisr7;OPENJPA-1097.patch;https://issues.apache.org/jira/secure/attachment/12438014/OPENJPA-1097.patch,19/Mar/10 20:45;drwoods;Proxies.java;https://issues.apache.org/jira/secure/attachment/12439327/Proxies.java,,,,,,,,7.0,,,,,,,,,,,,,,,,,,,2010-03-04 20:17:19.366,,,no_permission,,,,,,,,,,,161385,,,Mon Mar 22 19:04:02 UTC 2010,,,,,,,0|i0z9tj:,203893,,,,,,,,"04/Mar/10 20:17;drwoods;some tests showing how detach() and clear() do not unproxy the entities - 

160  test  INFO   [main] Tests - e20.sqlDate = org.apache.openjpa.util.java$sql$Date$proxy
160  test  INFO   [main] Tests - e20.sqlTime = org.apache.openjpa.util.java$sql$Time$proxy
160  test  INFO   [main] Tests - e20.sqlTimestamp = org.apache.openjpa.util.java$sql$Timestamp$proxy

but detachCopy() does -

161  test  INFO   [main] Tests - after detach e20copy
161  test  INFO   [main] Tests - e20.sqlDate = java.sql.Date
161  test  INFO   [main] Tests - e20.sqlTime = java.sql.Time
161  test  INFO   [main] Tests - e20.sqlTimestamp = java.sql.Timestamp
","04/Mar/10 21:47;drwoods;968 contains some important details, like the change in method signature/behavior of detach() in 2.0 (as required in the JPA 2.0 Spec) vs what was shipping in OpenJPA 1.x (value-add and not Spec defined.)
We do have some questionable behavior when detachAll() or clear() are called, in that in DetachManager.java the _copy is forced to false when _full is being set.
Also, calling detach(Entity) and then detachCopy(Entity) does not return an unproxied Entity as expected (if detachCopy is called first it works), but the same in-place entity from the earlier detach() call, as it was located in the _detached Map.","05/Mar/10 14:38;curtisr7;Sorry I didn't have much time this morning to look through the entire UT, but I think this should fix the problem. ",05/Mar/10 21:41;drwoods;New tests and DetachManager updates from Rick Curtis back ported to 1.3.x.,05/Mar/10 21:54;drwoods;Minor patch updates for 13x.,05/Mar/10 22:13;drwoods;Updated patch that includes fixes for some failing proxy tests.,05/Mar/10 22:44;drwoods;Latest patch for trunk based on DetachManager changes from Rick Curtis.,06/Mar/10 03:24;drwoods;Updated trunk patch,06/Mar/10 04:10;drwoods;Initial patch for 1.2.x to fix clear() not unproxying JavaTypes.OBJECT fields.,06/Mar/10 12:38;drwoods;Patch for 1.2.x which includes the new junits.,"08/Mar/10 14:16;drwoods;1.3.x - the 1.0b TCK passed with the integrated patches
trunk - the 1.0b and 2.0 TCK passed with the integrated patches

Will leave it to Mike to determine if the 1.2.x patch should be applied to the 1.2.3 release.
","08/Mar/10 14:44;drwoods;Basically, the patch fixed the clear() behavior, in that JavaType.OBJECT fields were not being unproxied and added junits to verify the following behavior by using an Entity20 class that contains the following fields -
    @Temporal(TemporalType.DATE) java.sql.Date
    @Temporal(TemporalType.TIME) java.sql.Time
    @Temporal(TemporalType.TIMESTAMP) java.sql.Timestamp

For trunk (when using the 2.0 default compatibility settings and the new JPA 2.0 Spec required in-place detach and no return values, which differs from the OpenJPA 1.x value-added detach()/detachAll() methods):
1) find() - entity uses the proxied classes before and after serialization
2) after in-place detach() - entity does NOT use proxied classes before or after serialization
3) after in-place detachAll() - none of the entities use proxied classes before or after serialization
4) detachCopy() - returns an entity that does NOT use proxied classes before or after serialization
5) clear() - existing entity instances after EM.clear() do NOT use proxied classes before or after serialization

For 1.3.x (same for proposed 1.2.x changes):
1) find() - entity uses the proxied classes before and after serialization
2) detach() returns a copy of the original entity that does NOT use proxied classes before or after serialization, but the original entity instance still uses proxies and returns FALSE for isDetached()
3) detachAll() returns copies of the original entities that do NOT use proxied classes before or after serialization, but the original entity instances still use proxies and returns FALSE for isDetached()
4) there is no tests for detachCopy() as this was added in 2.0.0 because JPA 2.0 Spec required in-place detach() and no return value
5) clear() - existing entity instances after EM.clear() do NOT use proxied classes before or after serialization
",15/Mar/10 20:21;drwoods;See OPENJPA-1571,16/Mar/10 16:25;drwoods;Updated patch that reverts some earlier DetachManager changes that broke the TestProxyCollection junits and updates the Proxies class to always remove $proxy classes on serialization if the entity is detachable.,"16/Mar/10 21:39;drwoods;Tests showing how detach()/detachAll()/clear() are currently working in 1.2.x, where entities serialized after calling clear() still contain our OpenJPA $proxy class wrappers.
","17/Mar/10 21:15;drwoods;Variation on previous patch, which I'm not planning on committing, but for historical purposes:
1) when an entity is serialized after a find() but before a detach()/detachAll()/detachCopy()/clear(), then it will always contain the $proxy wrapper classes
2) after detach/detachAll/detachCopy/clear, the $proxy classes will be removed at serialization
","19/Mar/10 20:45;drwoods;Long saga of this code change....  Capturing a version of the fully commented/debug code here in case we have to revisit this....  Not to commit as-is, but for historical purposes.
","22/Mar/10 14:21;drwoods;Mike, the OPENJPA-1097-12x-code.patch is for 1.2.3, which backports the code changes from 1.3.x/trunk and updates the TestDetachNoProxy.testClear() to verify that there is no $proxy usage after EM.clear() and the entity is serialized.
","22/Mar/10 19:04;drwoods;Updated code and docs in 1.3.x and 2.0.0.
Attached patch for 1.2.3 if we ever want to include it there.",,,,,,,,,,,,,,,,,,
ReverseMappingTool fails for openjpa-examples/reversemapping sample,OPENJPA-1091,12425610,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,techhusky,drwoods,drwoods,15/May/09 17:32,22/Apr/10 20:30,14/Mar/19 03:02,15/Apr/10 19:43,1.2.1,2.0.0-M2,,,,,,,,1.2.3,1.3.0,2.0.0,,,samples,tooling,,,,,0,,"The openjpa-examples/reversemapping sample works on 1.3.x, but fails on trunk.

Output from 1.3.x -
2228  none  INFO   [main] openjpa.Tool - ReverseMappingTool : generating classes.
2228  none  INFO   [main] openjpa.MetaData - Customized name found for class ""reversemapping.Airlines"": will rename as ""reversemapping.Airline"".
2355  none  INFO   [main] openjpa.MetaData - Customized name found for class ""reversemapping.Cities"": will rename as ""reversemapping.City"".
2356  none  INFO   [main] openjpa.MetaData - Customized name found for class ""reversemapping.Countries"": will rename as ""reversemapping.Country"".
2357  none  INFO   [main] openjpa.MetaData - Customized name found for class ""reversemapping.Flightavailability"": will rename as ""reversemapping.Availability"".
2358  none  INFO   [main] openjpa.MetaData - Customized name found for class ""reversemapping.Flights"": will rename as ""reversemapping.Flight"".
2382  none  INFO   [main] openjpa.MetaData - Customized name found for field ""citys"" in type ""reversemapping.Country"": will rename as ""reversemapping.Country"".
2390  none  INFO   [main] openjpa.MetaData - Customized name found for field ""availabilitys"" in type ""reversemapping.Flight"": will rename as ""reversemapping.Flight"".
2392  none  INFO   [main] openjpa.MetaData - Customized name found for field ""airline"" in type ""reversemapping.Airline"": will rename as ""reversemapping.Airline"".
2392  none  INFO   [main] openjpa.MetaData - Customized name found for field ""airlineFull"" in type ""reversemapping.Airline"": will rename as ""reversemapping.Airline"".
2393  none  INFO   [main] openjpa.MetaData - Customized name found for field ""departTime"" in type ""reversemapping.Flight"": will rename as ""reversemapping.Flight"".
2393  none  INFO   [main] openjpa.MetaData - Customized name found for field ""arriveTime"" in type ""reversemapping.Flight"": will rename as ""reversemapping.Flight"".
2393  none  WARN   [main] openjpa.MetaData - Column ""FLIGHTS.MEAL"" is type CHAR(1), but OpenJPA cannot reverse map it into a Java char because OpenJPA is currently configured to store Java chars into numeric database columns.  To configure OpenJPA to store Java chars into CHAR(1) columns, set the following property:
openjpa.jdbc.DBDictionary: StoreCharsAsNumbers=false
2399  none  INFO   [main] openjpa.MetaData - Table ""APP.FLIGHTS_HISTORY"" could not be reverse mapped.  This means that the table does not have a primary key (primary keys are required to establish unique identifiers for all persistent objects) and does not match a known pattern for a table used for cross-reference or value collections.
2399  none  INFO   [main] openjpa.MetaData - Table ""APP.MAPS"" could not be reverse mapped.  This means that the table does not have a primary key (primary keys are required to establish unique identifiers for all persistent objects) and does not match a known pattern for a table used for cross-reference or value collections.
2404  none  INFO   [main] openjpa.Tool - Writing generated class source code.
2404  none  INFO   [main] openjpa.MetaData - Writing java code for generated type ""reversemapping.Airline"".
2408  none  INFO   [main] openjpa.MetaData - Writing java code for generated type ""reversemapping.Availability"".
2418  none  INFO   [main] openjpa.Enhance - Generating an application id for type ""class reversemapping.Availability"".
2421  none  INFO   [main] openjpa.MetaData - Writing java code for generated type ""reversemapping.City"".
2422  none  INFO   [main] openjpa.MetaData - Writing java code for generated type ""reversemapping.Country"".
2423  none  INFO   [main] openjpa.MetaData - Writing java code for generated type ""reversemapping.Flight"".
2423  none  INFO   [main] openjpa.Enhance - Generating an application id for type ""class reversemapping.Flight"".
2424  none  INFO   [main] openjpa.Tool - Writing generated metadata.
2440  none  INFO   [main] openjpa.MetaData - Writing to file ""orm.xml"".
2571  none  INFO   [main] openjpa.MetaData - Writing class ""reversemapping.Airline"".
2579  none  INFO   [main] openjpa.MetaData - Writing class ""reversemapping.Availability"".
2582  none  INFO   [main] openjpa.MetaData - Writing class ""reversemapping.City"".
2583  none  INFO   [main] openjpa.MetaData - Writing class ""reversemapping.Country"".
2585  none  INFO   [main] openjpa.MetaData - Writing class ""reversemapping.Flight"".


Failing output from trunk -
2272  none  INFO   [main] openjpa.Tool - ReverseMappingTool : generating classes.
2273  none  INFO   [main] openjpa.MetaData - Customized name found for class ""reversemapping.Airlines"": will rename as ""reversemapping.Airline"".
2497  none  INFO   [main] openjpa.MetaData - Customized name found for field ""airline"" in type ""reversemapping.Airline"": will rename as ""reversemapping.Airline"".
2513  none  INFO   [main] openjpa.MetaData - Customized name found for field ""airlineFull"" in type ""reversemapping.Airline"": will rename as ""reversemapping.Airline"".
2517  none  WARN   [main] openjpa.MetaData - Column ""AIRLINES.MEAL"" is type CHAR(1), but OpenJPA cannot reverse map it into a Java char because OpenJPA is currently configured to store Java chars into numeric database columns.  To configure OpenJPA to store Java chars into CHAR(1) columns, set the following property:
openjpa.jdbc.DBDictionary: StoreCharsAsNumbers=false
2522  none  INFO   [main] openjpa.MetaData - Table ""SYS.AIRLINES"" could not be reverse mapped.  This means that the table does not have a primary key (primary keys are required to establish unique identifiers for all persistent objects) and does not match a known pattern for a table used for cross-reference or value collections.
2522  none  INFO   [main] openjpa.MetaData - Table ""SYSIBM.AIRLINES"" could not be reverse mapped.  This means that the table does not have a primary key (primary keys are required to establish unique identifiers for all persistent objects) and does not match a known pattern for a table used for cross-reference or value collections.
2526  none  INFO   [main] openjpa.Tool - Writing generated class source code.
2526  none  INFO   [main] openjpa.MetaData - Writing java code for generated type ""reversemapping.Airline"".
2531  none  INFO   [main] openjpa.Tool - Writing generated metadata.
2550  none  INFO   [main] openjpa.MetaData - Writing to file ""orm.xml"".
2567  none  INFO   [main] openjpa.MetaData - Writing class ""reversemapping.Airline"".
/Users/drwoods/openjpa/trunk/openjpa-integration/examples/target/examples/apache-openjpa-2.0.0-SNAPSHOT/examples/reversemapping/Main.java:52: cannot find symbol
symbol  : class Availability
location: class reversemapping.Main
        List<Availability> schedule = (List<Availability>)
             ^
. . .",Sun 1.5.0_16 on MacOSX,,,,,,,,,,,,,,,,,,,OPENJPA-1605,,15/Jan/10 21:13;drwoods;OPENJPA-1091-12x.diff;https://issues.apache.org/jira/secure/attachment/12430439/OPENJPA-1091-12x.diff,12/Jan/10 23:59;mikedd;OPENJPA-1091.1.2.x.diff.txt;https://issues.apache.org/jira/secure/attachment/12430065/OPENJPA-1091.1.2.x.diff.txt,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-12-01 22:33:06.581,,,no_permission,,,,,,,,,,,161379,,,Thu Apr 15 21:24:51 UTC 2010,,,Patch Available,,,,0|i0ywkn:,201747,,,,,,,,"15/May/09 17:52;drwoods;Can recreate the above by:
1) building trunk -
    mvn clean install
2) running the integration examples build -
    cd openjpa-integration
    mvn integration-test -Pexamples-profile
","15/May/09 17:54;drwoods;Get even worse results on trunk if Java 1.6.0_07 is used (with Derby 10.2.2.0 or 10.4.2.0) -
[INFO] ------------------------------------------------------------------------
[INFO] Building OpenJPA Examples Integration Tests
[INFO]    task-segment: [integration-test]
[INFO] ------------------------------------------------------------------------
[INFO] [checkstyle:checkstyle {execution: default}]
[INFO] Source directory does not exist - skipping report.
[INFO] [site:attach-descriptor]
[INFO] [antrun:run {execution: run-examples}]
[INFO] Executing tasks
     [echo] Running OpenJPA Examples
    [mkdir] Created dir: /Users/drwoods/openjpa/trunk/openjpa-integration/examples/target/examples
    [unzip] Expanding: /Users/drwoods/openjpa/trunk/openjpa-project/target/site/downloads/apache-openjpa-2.0.0-SNAPSHOT-binary.zip into /Users/drwoods/openjpa/trunk/openjpa-integration/examples/target/examples

pre-compile:

compile:
    [javac] Compiling 2 source files

run:
     [java] Exception in thread ""main"" <openjpa-2.0.0-SNAPSHOT-r422266:775185M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: Java exception: 'loader (instance of  sun/misc/Launcher$ExtClassLoader): attempted  duplicate class definition for name: ""sun/security/pkcs11/SunPKCS11"": java.lang.LinkageError'.
     [java] 	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:553)
     [java] 	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:453)
     [java] 	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:159)
     [java] 	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:163)
     [java] 	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:119)
     [java] 	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:204)
     [java] 	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:160)
     [java] 	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:212)
     [java] 	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:165)
     [java] 	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:64)
     [java] 	at hellojpa.Main.main(Main.java:43)
     [java] Caused by: java.sql.SQLException: Java exception: 'loader (instance of  sun/misc/Launcher$ExtClassLoader): attempted  duplicate class definition for name: ""sun/security/pkcs11/SunPKCS11"": java.lang.LinkageError'.
     [java] 	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.Util.javaException(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.<init>(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.EmbedPreparedStatement20.<init>(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.EmbedPreparedStatement30.<init>(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.EmbedPreparedStatement40.<init>(Unknown Source)
     [java] 	at org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.EmbedConnection.prepareMetaDataStatement(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.prepareSPS(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQueryUsingSystemTables(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.doGetCols(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getColumns(Unknown Source)
     [java] 	at org.apache.openjpa.lib.jdbc.DelegatingDatabaseMetaData.getColumns(DelegatingDatabaseMetaData.java:145)
     [java] 	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingDatabaseMetaData.getColumns(LoggingConnectionDecorator.java:751)
     [java] 	at org.apache.openjpa.lib.jdbc.DelegatingDatabaseMetaData.getColumns(DelegatingDatabaseMetaData.java:145)
     [java] 	at org.apache.openjpa.jdbc.sql.DBDictionary.getColumns(DBDictionary.java:3818)
     [java] 	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateTables(SchemaGenerator.java:459)
     [java] 	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateSchema(SchemaGenerator.java:335)
     [java] 	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateSchemas(SchemaGenerator.java:284)
     [java] 	at org.apache.openjpa.jdbc.schema.SchemaTool.getDBSchemaGroup(SchemaTool.java:1143)
     [java] 	at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:344)
     [java] 	at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:321)
     [java] 	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:501)
     [java] 	... 10 more
     [java] Caused by: java.sql.SQLException: Java exception: 'loader (instance of  sun/misc/Launcher$ExtClassLoader): attempted  duplicate class definition for name: ""sun/security/pkcs11/SunPKCS11"": java.lang.LinkageError'.
     [java] 	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)
     [java] 	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)
     [java] 	... 40 more
     [java] Caused by: java.lang.LinkageError: loader (instance of  sun/misc/Launcher$ExtClassLoader): attempted  duplicate class definition for name: ""sun/security/pkcs11/SunPKCS11""
     [java] 	at java.lang.ClassLoader.defineClass1(Native Method)
     [java] 	at java.lang.ClassLoader.defineClass(ClassLoader.java:675)
     [java] 	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
     [java] 	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
     [java] 	at java.net.URLClassLoader.access$000(URLClassLoader.java:56)
     [java] 	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
     [java] 	at java.security.AccessController.doPrivileged(Native Method)
     [java] 	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
     [java] 	at java.lang.ClassLoader.loadClass(ClassLoader.java:316)
     [java] 	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
     [java] 	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:288)
     [java] 	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
     [java] 	at sun.security.jca.ProviderConfig$3.run(ProviderConfig.java:234)
     [java] 	at java.security.AccessController.doPrivileged(Native Method)
     [java] 	at sun.security.jca.ProviderConfig.doLoadProvider(ProviderConfig.java:225)
     [java] 	at sun.security.jca.ProviderConfig.getProvider(ProviderConfig.java:205)
     [java] 	at sun.security.jca.ProviderList.getProvider(ProviderList.java:215)
     [java] 	at sun.security.jca.ProviderList.getService(ProviderList.java:313)
     [java] 	at sun.security.jca.GetInstance.getInstance(GetInstance.java:140)
     [java] 	at java.security.Security.getImpl(Security.java:659)
     [java] 	at java.security.MessageDigest.getInstance(MessageDigest.java:129)
     [java] 	at java.io.ObjectStreamClass.computeDefaultSUID(ObjectStreamClass.java:1759)
     [java] 	at java.io.ObjectStreamClass.access$100(ObjectStreamClass.java:52)
     [java] 	at java.io.ObjectStreamClass$1.run(ObjectStreamClass.java:205)
     [java] 	at java.security.AccessController.doPrivileged(Native Method)
     [java] 	at java.io.ObjectStreamClass.getSerialVersionUID(ObjectStreamClass.java:202)
     [java] 	at java.io.ObjectStreamClass.writeNonProxy(ObjectStreamClass.java:667)
     [java] 	at java.io.ObjectOutputStream.writeClassDescriptor(ObjectOutputStream.java:640)
     [java] 	at java.io.ObjectOutputStream.writeNonProxyDesc(ObjectOutputStream.java:1245)
     [java] 	at java.io.ObjectOutputStream.writeClassDesc(ObjectOutputStream.java:1203)
     [java] 	at java.io.ObjectOutputStream.writeArray(ObjectOutputStream.java:1282)
     [java] 	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1146)
     [java] 	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:326)
     [java] 	at org.apache.derby.iapi.services.io.FormatIdOutputStream.writeObject(Unknown Source)
     [java] 	at org.apache.derby.iapi.services.io.FormatableHashtable.writeExternal(Unknown Source)
. . .","15/May/09 20:58;drwoods;Also, looks like the reversemapping example never worked on Windows (at least it doesn't for 1.3.x) due to an invalid path being passed in dburl.","01/Dec/09 22:33;dkarr;Concerning the last comment, I believe that's the problem that I've noticed.  I noticed the following in the log when I tried to run it on WinXP.

<openjpa-1.2.1-r752877:753278 fatal user error> org.apache.openjpa.util.UserException: A connection could not be obtained for driver class ""org.apache.derby.jdbc.EmbeddedDriver"" and URL ""jdbc:derby:c:\frameworks\apache-openjpa-1.2.1\examples\reversemapping/reversemapping-database;create=true"".  You may have specified an invalid URL.
...
Caused by: java.sql.SQLException: Failed to start database 'c:\frameworks\apache-openjpa-1.2.1\examples\reversemapping/reversemapping-database', see the next exception for details.",28/Dec/09 08:12;leileiz;I met the same issue as David M.  What's wrong with it?,"28/Dec/09 18:52;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
",12/Jan/10 23:59;mikedd;It looks like a simple path conversion problem. The attached patch should resolve the issue. I don't have a windows install handy to try it out though. ,13/Jan/10 03:23;drwoods;Thanks Mike.  I'll give it a try tomorrow.,"15/Jan/10 21:13;drwoods;Patch <OPENJPA-1091-12x.diff> that fixes the reversemapping example by splitting the SQL out into a separate exec, as the Derby driver was locked (at lest with ANT 1.7.1 and 1.8.0RC1.)
","15/Jan/10 21:38;drwoods;Patch fixed 1.3.x.
Patch corrected the SQL problem on trunk, but now exposes the failure to create all the Java classes from the DB schema (only creates Airline.java and not the other entities.)
",15/Apr/10 16:33;techhusky;OPENJPA-1605 is the cause of this failing example on 2.0.x and trunk.  Will be integrating a fix shortly.,15/Apr/10 19:43;techhusky;The commits for OPENJPA-1605 fix the reverse mapping example on branch 2.0.x and trunk.,15/Apr/10 21:24;drwoods;Don't need Fix Version of 2.1.0 since 2.0.0 hasn't been released yet....,,,,,,,,,,,,,,,,,,,,,,,,
Build updates for openjpa-examples and openjpa-integration/examples,OPENJPA-1088,12425591,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,drwoods,drwoods,drwoods,15/May/09 14:25,09/Mar/10 18:31,14/Mar/19 03:02,15/May/09 21:21,1.3.0,2.0.0-M2,,,,,,,,1.3.0,2.0.0-M2,,,,samples,,,,,,0,,"Three problems discovered with the examples:
1) the openjpa-examples build was trying to use both the openjpa.jar and openjpa-all.jar files in the binary distribution
2) the examples directory in the binary.zip didn't have a README for the examples
3) the openjpa-integration/examples/pom.xml was not looking in the right location for the binary.zip file to extract
",,,,,,,,,,,,,,,,,,,,,,15/May/09 15:39;drwoods;OPENJPA-1088-13x.patch;https://issues.apache.org/jira/secure/attachment/12408258/OPENJPA-1088-13x.patch,15/May/09 14:27;drwoods;OPENJPA-1088-trunk.patch;https://issues.apache.org/jira/secure/attachment/12408251/OPENJPA-1088-trunk.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,38607,,,Fri May 15 15:39:13 UTC 2009,,,Patch Available,,,,0|i1dse7:,288697,,,,,,,,"15/May/09 14:27;drwoods;Patch file for trunk.
There is still an issue with the reversemapping example not building, which was there before the openjpa-all changes in OPENJPA-1063.","15/May/09 15:39;drwoods;patch for branches/1.3.x, which includes original patch for trunk plus fixes in Rev775185",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OrderColumn does not maintain index upon inter-list element removal - Phase 1,OPENJPA-1074,12424940,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,techhusky,techhusky,techhusky,08/May/09 15:16,22/Apr/10 20:32,14/Mar/19 03:02,23/Mar/10 01:21,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,jdbc,,,,,15/May/09 00:00,0,,"The current order column reordering mechanism does not maintain a contiguous index value when an item is deleted from anywhere except the end of a collection.  Per the latest JPA 2.0 spec, a contiguous index value must be maintained.

The current reordering mechanism does a full delete and reinsert of the container/collection table values if a reorder is required for inserts.  For deletes, it just removes entries and leaves an empty index value.  The first phase of the fix will be to maintain contiguous ordering using the same mechanism as inserts (delete/re-insert).  The second phase will be to update the ChangeTracker to record the indexes of the updated list items and to use that information to provide a more intelligent update strategy in the handlers.",,,,,,,,,,,,,OPENJPA-1582,,,OPENJPA-1595,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-03-03 01:16:29.585,,,no_permission,,,,,,,,,,,161364,,,Tue Mar 23 01:21:02 UTC 2010,,,,,,,0|i0ywf3:,201722,,,,,,,,03/Mar/10 01:16;drwoods;marking non-spec compliant behavior as a critical issue for 2.0.0,"03/Mar/10 17:55;techhusky;I fixed the non-spec compliant behavior described in this JIRA (ie. phase 1 - Per the latest JPA 2.0 spec, a contiguous index value must be maintained.) but the second phase of the JIRA has not been addressed:

""The current reordering mechanism does a full delete and reinsert of the container/collection table values if a reorder is required for inserts. For deletes, it just removes entries and leaves an empty index value. The first phase of the fix will be to maintain contiguous ordering using the same mechanism as inserts (delete/re-insert). The second phase will be to update the ChangeTracker to record the indexes of the updated list items and to use that information to provide a more intelligent update strategy in the handlers.""

A more spec related side effect of OpenJPA's current order column update strategy is that the OrderColumn insertable and updatable attributes may not result in the behavior one may expect since the db operations used to maintain the list do not exactly map to the db operations indicated by these attributes.

I spent a few days looking into implementing phase 2, but it turned into a non trivial exercise.
","23/Mar/10 01:18;drwoods;Splitting the remaining work into a new JIRA, as code was committed using this one and needs to be resolved.",23/Mar/10 01:21;drwoods;Opened OPENJPA-1595 for remaining Phase 2 work.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Nested embeddable with a relationship to an Entity with a generated id doesn't persist the relationship,OPENJPA-1072,12424829,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,curtisr7,curtisr7,07/May/09 16:48,09/Mar/10 18:31,14/Mar/19 03:02,08/May/09 15:17,2.0.0-M2,,,,,,,,,2.0.0-M2,,,,,jpa,,,,,,0,,"When working with embeddables I found that if I define a unidirectional @ManyToOne relationship from an embeddable to an Entity which has a generated id, the relationship in the join table doesn't get persisted. I'll attach a zip with my code, but I'll also try to describe the scenario here.

Entities: 
Seller - Has an auto generated ID and a name
Book - Has an id(isbn) and an ElementCollection of Listings
Listing - An embeddable that has a ManyToOne relationship to Seller, a price and comments.

The scenario is as follows:
* Create all the sellers.
* Create a book.
* Add a listing to each book. Each listing takes a Seller Entity and a price.
* When I commit the book, the seller_id column in my Listing join table is always zero.

",,,,,,,,,,,,,,,,,,,,,,07/May/09 16:48;curtisr7;jpa.embeddables.zip;https://issues.apache.org/jira/secure/attachment/12407549/jpa.embeddables.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161362,,,Thu May 07 16:48:52 UTC 2009,,,,,,,0|i0zatb:,204054,,,,,,,,07/May/09 16:48;curtisr7;Attaching recreate.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Restore support for composite foreign keys on MySQL,OPENJPA-1070,12424800,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,dirichs,dirichs,07/May/09 10:28,09/Mar/10 18:31,14/Mar/19 03:02,09/May/09 17:05,1.2.1,2.0.0-M2,,,,,,,,2.0.0-M2,,,,,jdbc,,,,,,0,,"When creating the database schema for MySQL databases, OpenJPA refuses to define foreign key constraints for composite keys. Warning message is: openjpa.jdbc.Schema - The foreign key ""<foreignkey>"" was not added to table ""[...]"" The reason for this is that composite foreign key support is explicitly disabled in MySQLDictionary.

However, composite foreign keys seem to work flawlessly in recent MySQL versions (such as 5.0.51a). Probably this limitation in MySQLDictionary thus is historic and can be removed.

For the corresponding mailing list discussion, see here:
http://n2.nabble.com/Composite-foreign-keys-with-MySQL-tc2772257.html",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161360,,,2009-05-07 10:28:46.0,,,,,,,0|i1drmn:,288573,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SetQueryTimeout(x) where x != 0 causes SQLException with DB2 on Z/OS,OPENJPA-1067,12424719,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,06/May/09 15:58,27/May/09 21:06,14/Mar/19 03:02,27/May/09 21:06,1.0.3,1.2.1,1.3.0,2.0.0-M2,,,,,,1.0.4,1.2.2,1.3.0,2.0.0-M2,,,,,,,,0,,"A recent (AFAIK) update to the DB2 JDBC driver changed behavior when the setQueryTimeout method is called on a connection to Z/OS and the timeout was non 0. 

A non zero value is not supported, but previously the value was ignored. Now an SQLException is raised. 

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-05-06 16:15:46.787,,,no_permission,,,,,,,,,,,88157,,,Tue May 12 21:31:00 UTC 2009,,,,,,,0|i1drmv:,288574,,,,,,,,"06/May/09 16:15;drwoods;Interesting... do you want me to look at this, given I modified how setQueryTimeout() is called in trunk to support the new javax.persistence.query.timeout hint?
","06/May/09 18:48;mikedd;Hi Donald, I appreciate the offer. My proposed solution is to set supportsQueryTimeout = false for Z/OS in the DB2Dictionary. Preliminary testing works with 1.2.1. 

I don't think it pays to invent something new that handles the value of 0. If that's the only value it accepts presumably that's the default anyway. ","06/May/09 19:18;drwoods;OK, but should we disable query timeout support for all DB2 zOS users, or just catch and log any exceptions when calling setQueryTimeout(), which could be useful for other drivers too.  By disabling query timeout support, you also disable the current lock timeout support which relies on using setQueryTimeout().","06/May/09 22:59;mikedd;It's a bit of a tradeoff. We know this call will at best have no effect, and at worst throws an exception. Either way we've wasted a trip to the database. 

I think in a perfect world it'd be better to have the functions that rely on query timeouts check whether the DBDictionary supports them and provide feedback (exception or log) when they're called. That might be more trouble than it's worth though - I haven't looked at the affected code.  

Before I saw your comment I went ahead and disabled it. I don't think there's any harm in leaving that code in and leaving the JIRA open though.","06/May/09 23:33;mikedd;Actually on second hand I think there's a separate issue here : whether we should remove the supportsQueryTimeout field. 

Selectively disabling some methods like we are with supportsQueryTimeout is problematic and it's easy to get out of sync with JDBC vendors (like we did in this case). We could let the call go through and let the upstream callers handle the exception - rather than checking for supportsQueryTimeout before calling the method. 

That's not a change I'm comfortable making in 1.2.x or 1.0.x though. Negating the call and logging could be done though. 

There's a fair amount of precedent for checking before calling though (avoiding the trip to the database). Unless there are objections I'll open a sub-task / related issue to discuss whether we need the supportsQueryTimeout field. ","07/May/09 12:54;drwoods;We have existing code and tests that check for (supportsQueryTimeout == true) today (like the reworked setTimeouts and setQueryTimeout in DBDictionary in trunk)  so there would be some minor rework.  Adding a try/catch/log wrapper to any setQueryTiemout() calls along with always calling getQueryTimeout() before setting a value, would probably be the better route for 1.3/2.0.  I'd expect DB2 to fix this in the next driver release, given this is a regression/loss of function for existing users...
","07/May/09 13:45;mikedd;As far as I can tell it never worked for Z/OS - this has been a restriction as far back as I could check. 

I'm guessing their response would be that adding support would be a new feature request (could take some time), and would we rather have them throw the exception or just ignore it. Which is pretty much what we're talking about ;-)

I've started talking to the DB2 contacts I know, and I'll update the issue when I know more. ","12/May/09 21:31;mikedd;For released versions (1.0.x - 1.2.x) I'm leaning towards something like the attached patch (for 1.2.x). 

In trunk we may want to do something better (ie separate dictionaries for DB2ZOS to make this a little less kludgy, and as Donald said the code path is a little different so it might need some tweaking. 

The patch uses jMock in the testcase to simulate a connection to Z so if you just apply it in an IDE you may need to regen your list of dependencies (mvn eclipse:eclipse, or something similar). ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Prepared Query Cache does not work with DataCache ,OPENJPA-1065,12424648,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,05/May/09 22:53,22/Sep/09 19:16,14/Mar/19 03:02,27/Aug/09 16:58,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,,,,,,,0,,Prepared Query is not cached when DataCache is active.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161356,,,2009-05-05 22:53:57.0,,,,,,,0|i0yy9r:,202022,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Entities extending from a Mapped Superclass that defines the ID fields share the same ObjectID type parameter,OPENJPA-1061,12424625,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,fyrewyld,fyrewyld,05/May/09 18:26,09/Mar/10 18:31,14/Mar/19 03:02,30/Jun/09 03:12,1.2.0,1.2.1,,,,,,,,1.0.4,1.2.2,1.3.0,2.0.0-M3,,jpa,,,,,,0,,"When a mapped superclass (MSC) defines @Id fields, it appears that entities extending the MSC use the MSC's type in the generated ObjectID's type field.  This can result in unexpected primary key collissions between entities that are not intended to be related in an entity inheritance hierarchy.  Attached to the JIRA is a junit test case that demonstrates the problem. ",,,,,,,,,,,,,OPENJPA-1156,,,,,,,,,25/Jun/09 20:00;fyrewyld;OpenJPA-1061_1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12411854/OpenJPA-1061_1.2.x.patch,02/Jul/09 21:55;fyrewyld;OpenJPA-JIRA1061-packagerefactor-1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12412425/OpenJPA-JIRA1061-packagerefactor-1.2.x.patch,02/Jul/09 20:20;fyrewyld;OpenJPA-JIRA1061-packagerefactor-trunk.patch;https://issues.apache.org/jira/secure/attachment/12412418/OpenJPA-JIRA1061-packagerefactor-trunk.patch,08/Jul/09 21:49;fyrewyld;OpenJPA-JIRA1061_1166-packagerefactor-1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12412919/OpenJPA-JIRA1061_1166-packagerefactor-1.2.x.patch,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2009-05-06 00:13:37.615,,,no_permission,,,,,,,,,,,38570,,,Wed Jul 08 21:49:18 UTC 2009,,,Patch Available,,,,0|i0z9kn:,203853,,,,,,,,05/May/09 18:27;fyrewyld;Unit test that demonstrates the problem.,"05/May/09 18:28;fyrewyld;What seems to be happening is that during entity enhancement, the MSC type acquires an ObjectIDType.  When the enhancer reaches the entity types extending the MSC, the if-block:

if (_meta.getIdentityType() == ClassMetaData.ID_APPLICATION
            && (_meta.getPCSuperclass() == null || getCreateSubclass() ||
                _meta.getObjectIdType() !=
                    _meta.getPCSuperclassMetaData().getObjectIdType())) {

compares the entity type's ObjectIDType with its MSC, finds they are equivalent, so the entity enhancement does not add the app-id methods; the leaf entity types defer to the MSC's app-id methods.  So when a new entity is being inserted into the persistence context, its initial ObjectID has the MSC in its type field, instead of the leaf entity type.  If another entity extending from the same MSC has the same PK-value, OpenJPAId's implentation of equals() will think it is equivalent, failing the checkForDuplicateId() check.

I've included a potential fix for the above issue.  It adds an additional check, looking for PKFields that are defined by a MSC.  If it finds such PKFields, it walks up the inheritance tree, stopping at either the MSC defining the PKField, or at an entity type (to avoid breaking entity inheritance mechanisms).  Stopping at the MSC defining the PKField qualifies the entity type for app-id method inclusion during enhancement.  This way, the leaf entities use their own pcNewObjectIdInstance() methods (with the appropriate type coded into the method) instead of relying on the mapped superclass's version of the method.

However, there is a degree of uncertainty I have with the fix.  While it fixes the described problem, and it does not fail any of the existing JUnit tests, I rely on the ClassMetaData.isEmbeddedOnly() method to determine if a type is a MSC or a genuine entity.  From what I could tell, the ClassMetaData.setEmbeddedOnly() method is called only during annotation and ORL XML metadata processing (it is set explicitly false for MappedSuperClass types).  However, the methods ClassMetaData.isEmbeddedOnly() and ClassMetaData.resolveMeta() are capable of mutating the ClassMetaData._embedded field; so there needs to be verification that relying on the _embedded field is the correct method of identifying a MSC type for this processing.
","05/May/09 18:29;fyrewyld;Proposed fix, pending verification that _embedded is a suitable check for MSC.",06/May/09 00:13;ppoddar@apache.org;I have added a new method ClassMetaData.isAbstract() which affirms (in JPA context) for MappedSuperclass. This method may help to identify whether a type is MSC. ,"06/May/09 16:21;faywang;hi Jody, the patch looks fine to me. ClassMetaData.resolveMeta can potentially modify _embedded field on the condition that the class meta data being resolved is actually ""embedded"" inside some other entity/embeddable. In other words, it has ""owner"". In the MSC case, one can not at the same time inherit from MSC and also embed an MSC when this MSC declares an Id field. As to the method isEmbeddableOnly, the _embedded field will not be set again in this method if it is already set. As you pointed out, in the case of MSC, this field is already set during the annotation/xml parsing time.","06/May/09 17:01;fyrewyld;Thanks for the advise.   I migrated the ClassMetaData.isAbstract()/setAbstract() methods from trunk to the 1.2.x release, and modified my patch to use those methods instead of isEmbeddable(); I'm much more content with that approach as it removes any chance that the added logic to addPCMethods() will trigger on anything else other then a MappedSuperclass.

I also found it curious to hear that the unit tests pass with the trunk build -- perhaps there has been a change in processing given all the additional embeddable support provided by JPA 2.0.  It would still be good to bring the unit tests to trunk, extra testing never hurts. :)

I've attached a new patch which migrates and utilizes the ClassMetaData.[is|set]Abstract() methods to this JIRA.",22/May/09 18:03;fyrewyld;Updated patch.  The previous patch failed when the MappedSuperclass had the id fields set to private-access.,"05/Jun/09 18:34;fyrewyld;Updated product code changes to resolve mapped superclass object id creation issue, and supporting JUnit test cases.",22/Jun/09 20:56;fyrewyld;Combined fix and junit together.,25/Jun/09 20:00;fyrewyld;Formatting cleanup.,30/Jun/09 03:12;mikedd;Thanks for the patch Jody,02/Jul/09 20:20;fyrewyld;Shortened the package names and tuned the entity class names used by the test case for OPENJPA-1061.  This patch is intended for trunk.  A patch for 1.2.x is coming shortly.,02/Jul/09 21:55;fyrewyld;Refactored packaging for the tests for the 1.2.x branch.,08/Jul/09 21:49;fyrewyld;Another pass at refactoring the package and class names.,,,,,,,,,,,,,,,,,,,,,,,
Attempting to returning a list over RMI/IIOP results in serialization exception,OPENJPA-1060,12424543,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,04/May/09 19:18,09/Mar/10 18:31,14/Mar/19 03:02,05/May/09 13:50,2.0.0-M2,,,,,,,,,2.0.0-M2,,,,,jpa,,,,,,0,,"Returning a result list over RMI/IIOP invocation currently fails on trunk/2.0 with this exception:

java.rmi.ServerException: RemoteException occurred in server thread; nested exception is: java.rmi.MarshalException: CORBA BAD_PARAM 0x4f4d0006 Maybe; nested exception is: java.io.NotSerializableException: org.apache.openjpa.jdbc.kernel.InstanceResultObjectProvider is not serializable at com.ibm.CORBA.iiop.UtilDelegateImpl.wrapException(UtilDelegateImpl.java:748) at javax.rmi.CORBA.Util.wrapException(Util.java:296) at ...

The problem is the result of storing the ROP in the userObject field of a ResultList in the org.apache.openjpa.kernel.QueryImpl.toResult(..) method.  - res.setUserObject(rop).  The ROP is not serializable so the RMI/CORBA layer throws an exception.

",JEE,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161352,,,Tue May 05 13:50:57 UTC 2009,,,,,,,0|i0zat3:,204053,,,,,,,,05/May/09 13:50;techhusky;Resolved by making the opaque user object within the result list transient.  This prevents the object from being serialized along with the result list.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Large result sets do not work with MySQL,OPENJPA-1054,12424186,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,curtisr7,curtisr7,29/Apr/09 16:41,09/Mar/10 18:31,14/Mar/19 03:02,28/May/09 20:46,,,,,,,,,,1.3.0,2.0.0-M2,,,,jdbc,,,,,,0,,"Large result sets do not work as documented. I did some googling around [1] and found a number of posts talking about how setFetchSize on the JDBC driver isn't being honored, some dating back as far as 2002. The MySQL docs [2] state ""When using versions of the JDBC driver earlier than 3.2.1, and connected to server versions earlier than 5.0.3, the setFetchSize() method has no effect, other than to toggle result set streaming as described above."". The doc outlines some additional instructions on how to create a statement that is going to allow a streaming result set. 

I spoke with Fey and she provided me with a patch that will allow us to use LRS with some limitations. I'm in the process of updating the docs and adding tests for the patch that Fey provided.

[1] Google ""mysql jdbc setFetchSize""
[2]http://dev.mysql.com/doc/refman/5.0/en/connector-j-reference-implementation-notes.html",,,,,,,,,,,,,,,,,,,,,,29/Apr/09 18:32;curtisr7;OPENJPA-1054.patch;https://issues.apache.org/jira/secure/attachment/12406811/OPENJPA-1054.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161347,,,Wed Apr 29 18:32:27 UTC 2009,,,Patch Available,,,,0|i1drnz:,288579,,,,,,,,29/Apr/09 18:32;curtisr7;I updated the doc and created two UTs for testing the new code introduced with this patch.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Updating an entity by setting an embeddable to it does not work properly if the embeddable has a cascade delete relationship with another entity,OPENJPA-1053,12424125,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,29/Apr/09 04:56,09/Mar/10 18:31,14/Mar/19 03:02,01/May/09 20:22,2.0.0-M2,,,,,,,,,2.0.0-M2,,,,,kernel,,,,,,0,,"Updating an entity (EntityA) by setting a new embeddable to it when the embeddable has a relationship with another entity (EntityB) with cascade delete does not work:

(1) the old entityB referenced by the old embeddable in EntityA will be deleted.
(2) if the EntityB also has cascade delete relation with EntityA, the EntityA will also be deleted,",,,,,,,,,,,,,,,,,,,,,,29/Apr/09 05:07;faywang;OPENJPA-1053.patch;https://issues.apache.org/jira/secure/attachment/12406739/OPENJPA-1053.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-05-26 17:17:27.061,,,no_permission,,,,,,,,,,,161346,,,Tue May 26 17:17:27 UTC 2009,,,,,,,0|i0zasn:,204051,,,,,,,,29/Apr/09 05:07;faywang;Test cases will be provided later.,26/May/09 17:17;to_rowe;Successfully verified on RHEL 5.1 AMD64 w/ IBM SE6. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[patch] Mappingtool doesn't check name conflicts if MappingDefaultsImpl is called with multiple columns.,OPENJPA-1051,12424056,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,dezzio,rpalache,rpalache,28/Apr/09 16:13,21/Sep/16 14:21,14/Mar/19 03:02,13/May/09 22:57,1.0.0,2.0.0-M2,,,,,,,,1.2.0,2.0.0-M2,,,,jdbc,,,,,,0,," In  OpenJPA implementation, it looks that MappingDefaultsImpl.populateColumns can accept multiple columns 
 because it has Column[] signature.
 If column name is longer than DBDictionary restriction (it's very short in some databases. 
 For example, oracle max name length is 32), names are truncated. 
 
 Because name conflict is detected based on actual Table info,given Column[] data does not get checked. 
 So, if given Column[] have very long name and truncated name of these Column[] is conflicted, 
 it could not be detected.",OpenJPA Trunk.,,,,,,,,,,,,,,,,,,,,,13/Nov/09 17:50;rpalache;OPENJPA-1051_Simple_Trunk.patch;https://issues.apache.org/jira/secure/attachment/12424876/OPENJPA-1051_Simple_Trunk.patch,28/Apr/09 16:43;rpalache;OPENJPA-1051_Trunk.patch;https://issues.apache.org/jira/secure/attachment/12406660/OPENJPA-1051_Trunk.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-05-13 22:57:54.941,,,no_permission,,,,,,,,,,,161344,,,Fri Nov 13 17:50:10 UTC 2009,,,,,,,0|i0yy4v:,202000,,,,,,,,"28/Apr/09 16:43;rpalache;I added temporary name set to detect such name conflicts to Table  and NameSet classes. 
Then, MappingDefaultsImpl uses this mechanism. 
 name collision is detected in NameSet class and resolved truncated name is added on MappingDefaultsImpl.  After resolving all names, temporary name cache is removed on 
 MappingDefaultsImpl.

 The fix can be verified by new unittest class TestMappingDefaultsImpl.java.

 Testing Done:
 OpenJPA head",04/May/09 13:28;rpalache;Can someone please commit the patch.,13/May/09 22:57;dezzio;Applied Ravi's patch.  Revision 774580.,"07/Aug/09 21:31;dezzio;From trunk, merged fix to 1.1.x branch at rev 802208","16/Sep/09 17:04;ppoddar@apache.org;A more parsimonious solution (perhaps) would be to simply add the valid name to NameSet.addName(...),
after the name is validated by DBDictionary.makeNameValid() which also ensures uniqueness against the name set, 

The issue of naming is getting trickier with several aspects
  a) The logic/protocol of naming of database elements (Table/Column/Schema/Sequence) is somewhat well-spread at different parts
  b) few assumptions are implicit (like full name of a table is a concatenation of schema.table -- but MySQL, for example, will not like that) 
  c) other 'container' things often cache these elements by their names but these names may get shortened/modified because of database length restrictions/keyword clash 
-- all these make naming a complex issue. One can see when methods like MappingDefaults.correctName() appears -- as if we know we have done mistakes :)

  d) the proverbial straw on the camel's back is the new JPA 2.0 requirement of these names be optionally quoted/delimited with default/platform specific quote characters.
  
In light of all the above, having a NameSet._subNames and adding/resetting it everywhere may add to the complexities.

Comments/Thoughts?","12/Nov/09 20:29;rpalache;Hi Pinaki,

Thanks for your suggestions.
After reviewing your comments, I agree that the current solution is a bit complex and will try to work on the solution you suggested.

Regards,
Ravi.","13/Nov/09 17:50;rpalache;Attached is the simplified fix suggested by Pinaki.
Thanks for the suggestion.

Ravi.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Query against a MappedSuperclass is not supported,OPENJPA-1049,12423531,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,22/Apr/09 23:57,09/Mar/10 18:31,14/Mar/19 03:02,28/Aug/09 01:44,1.2.1,1.3.0,2.0.0-M2,,,,,,,2.0.0-M3,,,,,query,,,,,,0,,"See [1] for details

While it is debatable whether query against MappedSuperClass to be supported or not (JPA spec says no), but OpenJPA document claims otherwise.

1. Decide on the feature
2. Given that OpenJPA document claims support, most likely the feature was implemented. Investigate whether it a regression across release or a pure documentation bug.

[1] http://n2.nabble.com/Can%27t-query-against-a-MappedSuperclass-tc2665700.html",,,,,,,,,,,,OPENJPA-1043,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161342,,,Fri Aug 28 01:44:09 UTC 2009,,,,,,,0|i0zarb:,204045,,,,,,,,28/Aug/09 01:44;ppoddar@apache.org;Corrected by enhancer change.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unique Constraint on MappedSupperClass causes NullPointerException,OPENJPA-1046,12423526,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,22/Apr/09 23:39,09/Mar/10 18:31,14/Mar/19 03:02,12/Nov/09 08:16,,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,1,,"Defining UniqueConstraint on MappedSuperClass fails with NPE [1]

@MappedSuperclass
@Table(uniqueConstraints={@UniqueConstraint(columnNames={""ATTR_NAME"", ""OWNER""})})
public abstract class Attribute<T> { 

While it is debatable a @Table annotation is appropriate for @MappedSuperClass, the situation must be detected and warned more gracefully than a NPE.

Also investigate whether UniqueConstraint on a MappedSuperClass should be supported.


[1] http://n2.nabble.com/UniqueConstraint-in-a-MappedSuperclass-not-working-tc2633410.html",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161340,,,Thu Nov 12 08:16:53 UTC 2009,,,,,,,0|i0zao7:,204031,,,,,,,,12/Nov/09 08:16;ppoddar@apache.org;Commits are wrongly tagged as OPENJPA-1047,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JPQL queries do not support queries on a MappedSuperclass,OPENJPA-1043,12423380,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,techhusky,techhusky,21/Apr/09 15:39,09/Mar/10 18:31,14/Mar/19 03:02,28/Aug/09 01:45,1.2.1,1.3.0,2.0.0-M2,,,,,,,2.0.0-M3,,,,,jpa,,,,,,0,,"This issue was reported by Jim Weaver via a nabble user forum post[1].  The JPA specification clearly states that queries upon a mapped superclass are not permitted, but the OpenJPA documentation has a note saying that they are supported[2].

Given:
@MappedSuperclass class A { }
@Entity class B extends A { }
@Entity class C extends A { }

I found that:

a) The em.find(A.class, id) operation does indeed allow the use of mapped superclass. OpenJPA issues a select upon tables B and C looking for a matching ID.
b) A JPQL query does not:  SELECT a FROM A a  fails with exception: (as reported by Jim)

I receive error message ""An error occurred while parsing the query filter
""SELECT a FROM A a"".  Error message:   The name ""A"" is not a recognized
entity or identifier.  Perhaps you meant B, which is a close match.  Known
entity names: [B, C]""

I attempted the same test with the OpenJPA base 1.0 provider and it failed with the same error so it doesn't look like this was ever supported via. JPQL.

If the decision is made not to provide this support in the near future, the documentation should be updated to qualify that mapped superclass is only allow on a find.

[1] http://n2.nabble.com/Can%27t-query-against-a-MappedSuperclass-tp2665700p2665700.html
[2] http://openjpa.apache.org/builds/latest/docs/manual/manual.html#jpa_overview_meta_embeddablesuper",,,,,,,,,,,,,,,,,,,,,,24/Apr/09 21:09;rpalache;openJPATestcase.zip;https://issues.apache.org/jira/secure/attachment/12406398/openJPATestcase.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-04-24 21:09:46.405,,,no_permission,,,,,,,,,,,161337,,,Fri Aug 28 01:45:28 UTC 2009,,,,,,,0|i0zarz:,204048,,,,,,,,24/Apr/09 21:09;rpalache;OpenJPA testcase where I can query against mappedsuperclass.,"24/Apr/09 21:11;rpalache;Hi,

In case it is helpful, when I give the complete packagename of the mappedsuperclass in the query then I am not seeing this issue.

E.g:
Query newQuery = pm.createQuery(""select x from test.kodo.memofield.AbstractInstance x""); 
List l = newQuery.getResultList();

Attached "" openJPATestcase.zip""  is the test case that will not break and the query is against mappessuperclass (with complete packagename).


To run the test case:

1) ant
2) ant test.

The version that I tested it against:

java org.apache.openjpa.conf.OpenJPAVersion

OpenJPA 2.0.0-SNAPSHOT
version id: openjpa-2.0.0-SNAPSHOT-r422266:753596
Apache svn revision: 422266:753596

Regards,
Ravi.",28/Aug/09 01:45;ppoddar@apache.org;See OPENJPA-1049,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OrderBy on nested embeddables is not working,OPENJPA-1041,12422962,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,15/Apr/09 23:22,09/Mar/10 18:31,14/Mar/19 03:02,01/May/09 20:20,2.0.0-M2,,,,,,,,,2.0.0-M2,,,,,jdbc,,,,,,0,,"Exception in thread ""main"" <openjpa-0.0.0-rnull fatal user error> org.apache.openjpa.util.MetaDataException: Cannot order ""spec_10_1_35_Ex3.Person_10_1_35_3.residences"" on ""zipcode.zip"", because that is not a persistent field in the related type.
	at org.apache.openjpa.meta.MetaDataRepository.newOrder(MetaDataRepository.java:880)
	at org.apache.openjpa.meta.FieldMetaData.getOrders(FieldMetaData.java:1153)
	at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.selectEager(StoreCollectionFieldStrategy.java:215)
	at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.selectEagerJoin(StoreCollectionFieldStrategy.java:180)
	at org.apache.openjpa.jdbc.meta.FieldMapping.selectEagerJoin(FieldMapping.java:829)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.select(JDBCStoreManager.java:1074)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:621)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:2975)
	at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:3053)
	at org.apache.openjpa.kernel.StateManagerImpl.fetchObjectField(StateManagerImpl.java:2295)
	at org.apache.openjpa.kernel.StateManagerImpl.fetchField(StateManagerImpl.java:817)
	at org.apache.openjpa.kernel.StateManagerImpl.fetch(StateManagerImpl.java:779)
	at org.apache.openjpa.enhance.RedefinitionHelper$1.invoke(RedefinitionHelper.java:230)
	at $Proxy11.size(Unknown Source)
	at spec_10_1_35_Ex3.Test_10_1_35_Ex3.findObj(Test_10_1_35_Ex3.java:131)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161335,,,2009-04-15 23:22:05.0,,,,,,,0|i0z99z:,203805,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Dynamic query predicates must not treat AND OR operators as associative,OPENJPA-1039,12422851,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,15/Apr/09 08:33,09/Mar/10 18:31,14/Mar/19 03:02,08/May/09 00:09,,,,,,,,,,2.0.0-M1,,,,,query,,,,,,0,,"		Predicate p1 = e.get(""salary"").greaterThan(100);
		Predicate p2 = e.get(""rating"").equal(5);
		Predicate p3 = e.get(""name"").like(""John"");

		Predicate w1 = p1.and(p2.or(p3));
		Predicate w2 = (p1.and(p2)).or(p3);

w1 and w2 are not the same.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161333,,,2009-04-15 08:33:30.0,,,,,,,0|i0yyn3:,202082,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Update docs that refer to OpenJPAEntityManager.getExtent(..),OPENJPA-1031,12422506,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,drwoods,curtisr7,curtisr7,09/Apr/09 19:18,09/Mar/10 18:31,14/Mar/19 03:02,07/May/09 13:43,,,,,,,,,,2.0.0-M2,,,,,docs,,,,,,0,,"User docs refer to OpenJPAEntityManager.getExtent(..), but it looks like the method was renamed to OpenJPAEntityManager.createExtent(..).",,,,,,,,,,,,,,,,,,,,,,09/Apr/09 19:26;curtisr7;OPENJPA-1031.patch;https://issues.apache.org/jira/secure/attachment/12405096/OPENJPA-1031.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-05-07 13:43:38.237,,,no_permission,,,,,,,,,,,161325,,,Thu May 07 13:43:38 UTC 2009,,,Patch Available,,,,0|i1drq7:,288589,,,,,,,,"07/May/09 13:43;drwoods;Applied to trunk as Rev772649.  Rick, thanks for the patch.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SQLServerDictionary causes NumberFormatException if MS SQL Server JDBC driver is used,OPENJPA-1029,12422393,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,drwoods,drwoods,08/Apr/09 18:47,09/Mar/10 18:31,14/Mar/19 03:02,30/Apr/09 16:32,2.0.0-M2,,,,,,,,,1.0.4,1.2.2,1.3.0,2.0.0-M2,,third-party,,,,,,0,,"If the Microsoft SQL Server JDBC Driver v1.2 or 2.0 is used instead of the jTDS driver, then the SQLServerDictionary will throw an exception while trying to parse the driverName ""Microsoft SQL Server JDBC Driver"" to determine the server version.  For the MS SQL JDBC driver, it should be using meta.getDatabaseMajorVersion() to determine the server version.  Also, the MS SQL JDBC driver was not being recognized correctly, so driverVendor was being set to VENDOR_OTHER instead of VENDOR_MICROSOFT.

java.lang.NumberFormatException: For input string: ""JDBC""
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:48)
	at java.lang.Integer.parseInt(Integer.java:447)
	at java.lang.Integer.parseInt(Integer.java:497)
	at org.apache.openjpa.jdbc.sql.SQLServerDictionary.connectedConfiguration(SQLServerDictionary.java:92)
	at org.apache.openjpa.jdbc.sql.DBDictionaryFactory.newDBDictionary(DBDictionaryFactory.java:190)
	at org.apache.openjpa.jdbc.sql.DBDictionaryFactory.newDBDictionary(DBDictionaryFactory.java:100)
	at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getDBDictionaryInstance(JDBCConfigurationImpl.java:584)
	at org.apache.openjpa.persistence.query.TestQueryTimeout.setUp(TestQueryTimeout.java:89)
	at junit.framework.TestCase.runBare(TestCase.java:125)
	at org.apache.openjpa.persistence.test.PersistenceTestCase.runBare(PersistenceTestCase.java:455)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:182)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
	at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:334)
	at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:980)
",,,,,,,,,,,,,,,,,,,,,,16/Apr/09 16:55;drwoods;OPENJPA-1029-10x.patch;https://issues.apache.org/jira/secure/attachment/12405669/OPENJPA-1029-10x.patch,16/Apr/09 16:55;drwoods;OPENJPA-1029-12x.patch;https://issues.apache.org/jira/secure/attachment/12405668/OPENJPA-1029-12x.patch,16/Apr/09 16:55;drwoods;OPENJPA-1029-13x.patch;https://issues.apache.org/jira/secure/attachment/12405667/OPENJPA-1029-13x.patch,16/Apr/09 17:15;drwoods;OPENJPA-1029.patch;https://issues.apache.org/jira/secure/attachment/12405670/OPENJPA-1029.patch,10/Apr/09 17:32;drwoods;OPENJPA-1029.patch;https://issues.apache.org/jira/secure/attachment/12405169/OPENJPA-1029.patch,08/Apr/09 21:07;drwoods;OPENJPA-1029.patch;https://issues.apache.org/jira/secure/attachment/12405004/OPENJPA-1029.patch,,,,,,,,,6.0,,,,,,,,,,,,,,,,,,,2009-04-09 10:04:44.368,,,no_permission,,,,,,,,,,,161323,,,Thu Apr 30 16:32:42 UTC 2009,,,,,,,0|i0zbpb:,204198,,,,,,,,"08/Apr/09 21:07;drwoods;Patch that allows usage of the MS SQL Server JDBC drivers [1] and adds a test profile for v2.0 of the driver.
[1] http://msdn.microsoft.com/en-us/data/aa937724.aspx
","08/Apr/09 21:08;drwoods;Jeremy, can you take a look at this patch for me?  It will have to be applied before OPENJPA-964-part1.patch for proper MS SQL Server support.","09/Apr/09 10:04;milosz;Donald, have you made sure we will not blow up when using the older Microsoft driver in these lines:

+            if (VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor)) {
+                if (meta.getDatabaseMajorVersion() >= 9) {

meta.getDatabaseMajorVersion() comes with JDBC 3.
","09/Apr/09 10:52;drwoods;What ""older"" driver are you referring to?
On the Microsoft website at the link provided earlier, there are only 3 drivers to download -
v1.1 - SQL Server 2000/2005 JDBC Driver 1.1 is JDBC 3.0 compliant and runs on the Java Runtime Environment (JRE) version 1.4 and later versions
v1.2 - provides access to SQL Server 2000 and SQL Server 2005 from any Java application ... Type 4 JDBC driver ... is JDBC 3.0 compliant and runs on the Java Development Kit (JDK) version 1.4 and higher.
v2.0 - provides access to SQL Server 2000, SQL Server 2005, and SQL Server 2008 from any Java application ... Type 4 JDBC driver ...  is JDBC 4.0 compliant and runs on the Java Development Kit (JDK) version 5.0 or later.

For OpenJPA, I would only suggest tolerating the 1.2 driver and supporting/recommending the 2.0 driver.  In my testing both worked fine, but we only get a SQL status code back from the 2.0 driver for query timeouts.
","09/Apr/09 13:30;milosz;I was referring to v1.2 but from your research we can see we are safe even with v1.1.

+1 for tolerating v1.2 and recommending v2.0. Allowing only v2.0 seems too restrictive to me as, from what I can see, this is very fresh stuff. A note on this could be added to Supported Databases section in the manual.
","09/Apr/09 18:28;drwoods;Thanks for the review.  I'll attach an updated patch that includes the Doc updates, along with setting a ne VENDOR_JTDS for the old driver, so we can differentiate the two.
",10/Apr/09 17:32;drwoods;Updated patch which does not log cursor or pooling warnings if using the v2.0 driver.,"10/Apr/09 17:33;drwoods;The doc updates were included in OPENJPA-1033, as I had other db/driver updates in-progress....
","16/Apr/09 13:41;drwoods;Patches to allow usage of the MS SQL Server JDBC Driver v1.2 or 2.0 with OpenJPA 1.0.x, 1.2.x and 1.3.x.
Also adds a test-mssql profile to the openjpa-persistence-jdbc/pom.xml for easier testing.
",16/Apr/09 16:55;drwoods;Updated patches that protect against a null driverName being returned from DatabaseMetaData and cleans up some of the conditional statements.,16/Apr/09 17:15;drwoods;Updated patch for trunk that protects against a possible null driverName being returned from DatabaseMetaData and cleans up some of the conditional statements.,17/Apr/09 03:39;techhusky;Committed OPENJPA-1029.patch dated 2009-04-16 10:15 AM to trunk for Donald under revision 765841.,"17/Apr/09 12:51;drwoods;Mike, please consider the patches for the maintenance branches. Thanks.",30/Apr/09 16:32;drwoods;resolving as fixed in trunk,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException during findBy when embeddable is involved,OPENJPA-1028,12422304,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,07/Apr/09 21:49,09/Mar/10 18:31,14/Mar/19 03:02,10/Apr/09 23:20,2.0.0-M2,,,,,,,,,2.0.0-M2,,,,,,,,,,,0,,"Caused by: java.lang.ClassCastException: myFvt.EmbedA incompatible with myFvt.EntityA
	at myFvt.EntityB.pcReplaceField(EntityB.java)
	at org.apache.openjpa.kernel.StateManagerImpl.replaceField(StateManagerImpl.java:3083)
	at org.apache.openjpa.kernel.StateManagerImpl.storeObjectField(StateManagerImpl.java:2512)
	at org.apache.openjpa.kernel.StateManagerImpl.storeObject(StateManagerImpl.java:2502)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.setMappedBy(JDBCStoreManager.java:453)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:384)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:289)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:995)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:953)

This ClassCastException occurred in the following test scenario:

(1) 
@Entity
public class EntityA implements Serializable {
    @Id
    Integer id;

   @Embedded
    EmbedA embedA;

...
}

(2) 
@Embeddable
public class EmbedA {
   
    @OneToOne(mappedBy=""a"", fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    EntityB entityB;
    
...
}

(3)
@Entity
public class EntityB {
    
    @Id
    protected int id;

    @OneToOne
    private EntityA a;
...
}

(4) test case:
        EntityManager em = emf.createEntityManager();
        EntityA a = em.find(EntityA.class, 1);

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-04-08 10:54:51.239,,,no_permission,,,,,,,,,,,161322,,,Mon Apr 13 17:56:09 UTC 2009,,,,,,,0|i0z98v:,203800,,,,,,,,"08/Apr/09 10:54;ppoddar@apache.org;Is this mapping consistent?

EmbedA says
@OneToOne(mappedBy=""a"", fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    EntityB entityB; 

But EntityB declares its field 'a' as EntityA not as EmbedA
@OneToOne
    private EntityA a; ",13/Apr/09 17:56;to_rowe;Successfully verified on RHEL 5.1 AMD64 w/ IBM SE6.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractResultList.subList throws UnsupportedOperationException,OPENJPA-1025,12422203,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,bjreed,jkronegg,jkronegg,07/Apr/09 07:13,09/Mar/10 18:31,14/Mar/19 03:02,30/Apr/09 15:45,1.2.1,1.3.0,2.0.0-M2,,,,,,,1.0.4,1.2.2,1.3.0,2.0.0-beta,,lib,,,,,,0,,"AbstractResultList implements the basics for readonly result lists. When calling the subList(int,int) method, the following exception is raised:

    java.lang.UnsupportedOperationException
    at org.apache.openjpa.lib.rop.AbstractResultList.subList(AbstractResultList.java:84)
    at org.apache.openjpa.kernel.DelegatingResultList.subList(DelegatingResultList.java:308)
    ...

Since the subList() method contract is to create a new List from the ResultList, this operation does not modify the original list: it only provides a *view* on the original list (see http://java.sun.com/docs/books/tutorial/collections/interfaces/list.html ). 

This problem is also found by other users: http://n2.nabble.com/DelegatingResultList.subList-not-implemented--td210389.html
They found the (bad) workaround to build a new List (bad because this is not the same as calling subList()):

    List mySubList = new ArrayList(openjpaList).subList(from, to);

The AbstractResultList class should be modified by one of this solution (sorted by decreasing preference order):
1) the AbstractResultList class should extends java.util.AbstractList and the subList() method should be removed (because implemented by AbstractList)
2) the subList() method should be implemented to return a view on the original list. See java.util.AbstractList for an implementation (http://www.koders.com/java/fidCFCB47A1819AB345234CC04B6A1EA7554C2C17C0.aspx?s=iso+3166 )
3) the subList() method should throw the exception with the message ""this method is not yet implemented. Workaround: new ArrayList(openjpaList).subList(from, to)""
","http://svn.apache.org/viewvc/openjpa/trunk/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractResultList.java?revision=757278&view=markup,
Seam 2.0, OpenJPA 1.2.1",14400,14400,,0%,14400,14400,,,,,,,,,,,,,,,21/Apr/09 15:28;bjreed;OPENJPA-1025-withTest.patch;https://issues.apache.org/jira/secure/attachment/12406035/OPENJPA-1025-withTest.patch,20/Apr/09 17:35;bjreed;OPENJPA-1025.patch;https://issues.apache.org/jira/secure/attachment/12405947/OPENJPA-1025.patch,21/Apr/09 13:41;bjreed;OPENJPA-1025b.patch;https://issues.apache.org/jira/secure/attachment/12406031/OPENJPA-1025b.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2009-04-20 17:35:33.476,,,no_permission,,,,,,,,,,,161319,,,Fri May 01 07:28:29 UTC 2009,,,,,,,0|i0zbov:,204196,,,,,,,,"20/Apr/09 17:35;bjreed;Attaching patch OPENJPA-1025.patch.  Update AbstractResultList to not implement subList, which forces subclasses to implement subList.  Update 3 classes that extend AbstractResultList to implement subList and return the proper List.","21/Apr/09 06:02;jkronegg;I'm not sure about the patch content for AbstractNonSequentialResultList ( https://issues.apache.org/jira/secure/attachment/12405947/OPENJPA-1025.patch ). In this class, the workaround ""new ArrayList()"" is used.
The List.subList(int,int) contract is to provide a view on the original list, not a shallow copy (see ""Range-View Operation"" section in http://java.sun.com/docs/books/tutorial/collections/interfaces/list.html ). Thus, operations on the subList are in fact done on the original List.

Let's try with the following code:

    myAbstractNonSequentialResultList.subList(first, last).add(myElement);

If the AbstractNonSequentialResultList class implements the List.subList contract correctly, this should raise an exception because the underlying AbstractResultList is read only (this is the expected result). But with the patch, the above code works correctly and the programmer may think that the underlying List has been modified, while it has still the same number of elements.

So IMHO, the patch is correct, except for class AbstractNonSequentialResultList which should use a true view of the original List and not a shallow copy. For this class, I see 3 solutions:
1) the subList method return a true *view* of the original List and not a shallow copy: this would be the best solution (See java.util.AbstractList for an implementation)
2) the subList method throws a ""not implemented exception"": this would be a quickfix (I'm not sure it would solve the issue)
3) the subList method return a shallow copy of the original List (i.e. new ArrayList()): this solution is not desirable because it does not respect the List.subList contract as described above.
 ","21/Apr/09 13:41;bjreed;Thanks for the quick review Julien.

Attaching OPENJPA-1025b.patch.  For the AbstractNonSequentialResultList case, I think we're going to have to just throw a ""not implemented exception"".  The concrete classes for this use Object[] underneath in stead of a List.  I don't know of a way to create a List ""view"" on to an Object[] and I agree that an exception would be better than returning a modifiable List.  Also, logically, I really wasn't sure that getting a sub list on an object that is ""non sequential"" was really a good idea - doesn't seem like the data would be consistently returned.",21/Apr/09 15:28;bjreed;OPENJPA-1025-withTest.patch includes the code changes from 1025b.patch and an update to the ResultListTest to verify if subList is a supported method or not for each kind of AbstractResultList.,"22/Apr/09 11:52;jkronegg;I applied https://issues.apache.org/jira/secure/attachment/12406031/OPENJPA-1025b.patch : the UnsupportedOperationException is not raised anymore when using subList in my application (Seam CRUD application's EntityList.xhtml).
Thanks B.J., you can apply the patch as a solution.",30/Apr/09 14:45;mikedd;I'm not sure removing the method from AbstractList is the best solution for released versions since we could break downstream consumers. Merely overriding the subList method in the appropriate subclasses seems like a better solution in this case. ,"01/May/09 07:28;jkronegg;I agree. The subList method can be kept in AbstractResultList (BTW it's not AbstractList) and the subclasses overriden subList method will be called.
This is a more ""backward compatible"" fix.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
eager fetching of PersistentCollection of a primitive type fails,OPENJPA-1020,12421989,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mcconne,tedman@sfu.ca,tedman@sfu.ca,03/Apr/09 17:18,09/Mar/10 18:31,14/Mar/19 03:02,09/Mar/10 14:36,1.2.1,2.0.0-M2,,,,,,,,2.0.0-beta,,,,,jdbc,,,,,,3,,"When a PersistentCollection of primitives like String.class are persisted, if the collection is marked as eager fetching. An exception is thrown upon loading the collection :

Attached is a patch file to the 2.0.0 trunk's junit test which illustrates the collection working with lazy and failing with eager. This also happens in 1.2.1



Exception below:
--------------------

junit.framework.AssertionFailedError: java.lang.String cannot be cast to org.apache.openjpa.enhance.PersistenceCapable
	at junit.framework.Assert.fail(Assert.java:47)
	at org.apache.openjpa.persistence.annotations.TestPersistentCollection.testPersistentCollectionStringsEager(TestPersistentCollection.java:169)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.PersistenceTestCase.runBare(PersistenceTestCase.java:455)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:182)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
	at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:334)
	at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:980)
","Linux deltoid-r61 2.6.27.12-170.2.5.fc10.i686 #1 SMP Wed Jan 21 02:09:37 EST 2009 i686 i686 i386 GNU/Linux
java version ""1.6.0_12""
Java(TM) SE Runtime Environment (build 1.6.0_12-b04)
Java HotSpot(TM) Server VM (build 11.2-b01, mixed mode)
",,,,,,,,,,,,,,,,,,,,,03/Apr/09 20:10;tedman@sfu.ca;openjpa_jdbc_patch.zip;https://issues.apache.org/jira/secure/attachment/12404581/openjpa_jdbc_patch.zip,03/Apr/09 17:19;tedman@sfu.ca;openjpa_junit_patch.zip;https://issues.apache.org/jira/secure/attachment/12404567/openjpa_junit_patch.zip,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-04-17 08:21:59.682,,,no_permission,,,,,,,,,,,161314,,,Mon Mar 01 23:23:35 UTC 2010,,,,,,,0|i0zbnz:,204192,,,,,,,,03/Apr/09 17:19;tedman@sfu.ca;a patch to the junit tests illustrating the problem,"03/Apr/09 20:10;tedman@sfu.ca;a fix for the problem, it was my best guess and I'm not that familiar with the code so please read it over to make sure it makes sense.
","03/Apr/09 20:14;tedman@sfu.ca;It appears that in the JDBC Store Manager it assumes that the item in the collections is an entity or a persist capable object. In the case of PersistentCollections, I don't think that's true as you can store Strings,Enums etc... so I added a check in the loop to make sure it's a persist capable object before trying to cast and assign a reverse mapping.

It's entirely possible that the setInverseRelation() should never have been called at all for that collection... but I'm not sure. The patch I submitted just checked each element in the collection at the time of setting the inverse.","17/Apr/09 08:21;dleangen;This patch seems to work ok for me, too.",01/Mar/10 21:38;faywang;The fix and the test case have been checked into trunk level code. It is not ported to openjpa 1.2 yet.,01/Mar/10 23:23;kwsutter;Marking the fix versions since this was integrated back on 01/04/2010.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Disabling QueryCaching at runtime does not work,OPENJPA-1006,12421572,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,dezzio,rpalache,rpalache,30/Mar/09 17:25,21/Sep/16 14:21,14/Mar/19 03:02,17/Apr/09 00:30,1.2.1,2.0.0-M2,,,,,,,,1.2.0,2.0.0-M2,,,,datacache,,,,,,0,,"An application has a configuration that allows query caching, but is making runtime calls to inform a fetch plan to disable query caching.

The bug is that this dynamic no-caching request is being ignored by the query cache executor, which then caches the query regardless.

Tried to disable query cache using 
OpenJPAEntityManager.getFetchPlan().setQueryResultCache(false);

and also 

query.getFetchPlan().setQueryResultCacheEnabled(false);

","N/A.
should be replicable on all environments.
The one I tried is on windows with oracle 10g  as database.",,,,,,,,,,,,,,,,,,,,,10/Apr/09 18:27;rpalache;OPENJPA-1006.patch;https://issues.apache.org/jira/secure/attachment/12405179/OPENJPA-1006.patch,10/Apr/09 18:27;rpalache;TestQueryResultSize.java;https://issues.apache.org/jira/secure/attachment/12405180/TestQueryResultSize.java,30/Mar/09 17:29;rpalache;openJPATestcase.zip;https://issues.apache.org/jira/secure/attachment/12404164/openJPATestcase.zip,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2009-04-17 00:11:43.666,,,no_permission,,,,,,,,,,,161302,,,Fri Aug 07 21:27:54 UTC 2009,,,,,,,0|i0z97z:,203796,,,,,,,,"30/Mar/09 17:29;rpalache;Attached is the test case.

To replicate the problem:

1) Modify build.xml to reflect your environment. ( e.g: patch where the libraries for openJPA exist )
2) ""ant""
3) ""ant test""

","10/Apr/09 18:27;rpalache;Attached is the .patch  and test case ( new ).

I ran mvn test -Dtest=TestQueryResultSize.
I got assertion error.
Fixed the code attached in .patch file.
ran mvn test -Dtest=TestQueryResultSize.
The last test run is successfull.

Ran mvn -o clean package  and I see the following :
[INFO] OpenJPA ............................................... SUCCESS [4.032s]
[INFO] OpenJPA Utilities ..................................... SUCCESS [14.313s]
[INFO] OpenJPA Kernel ........................................ SUCCESS [15.562s]
[INFO] OpenJPA JDBC .......................................... SUCCESS [11.375s]
[INFO] OpenJPA JPA ........................................... SUCCESS [6.344s]
[INFO] OpenJPA JPA JDBC ...................................... SUCCESS [1:04:15.672s]
[INFO] OpenJPA XML Store ..................................... SUCCESS [1.562s]
[INFO] OpenJPA Slice ......................................... SUCCESS [2:06.719s]
[INFO] OpenJPA Aggregate Jar ................................. SUCCESS [9.531s]
[INFO] OpenJPA Distribution .................................. SUCCESS [20.719s]
[INFO] OpenJPA Persistence Examples .......................... SUCCESS [1.359s]
[INFO] OpenJPA Integration Tests ............................. SUCCESS [0.297s]
[INFO] OpenJPA Examples Integration Tests .................... SUCCESS [0.297s]
[INFO] OpenJPA JPA TCK Integration Tests ..................... SUCCESS [0.703s]","10/Apr/09 18:29;rpalache;Note to committer:

Please commit my changes and let me know of any issues.

Regards,
Ravi.","17/Apr/09 00:11;dezzio;Fix in trunk, rev 765801, and MISIDENTIFIED as fix for OpenJPA-1002.  (The misidentification has been corrected.)","07/Aug/09 21:27;dezzio;From trunk, merged fix to 1.1.x branch at 802203",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Derived Identity fails when parent id is auto-generated,OPENJPA-1004,12421561,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,faywang,faywang,30/Mar/09 16:06,13/Jan/11 14:40,14/Mar/19 03:02,02/Apr/09 20:07,1.2.2,2.0.0-M2,,,,,,,,2.0.0-M2,,,,,,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,31/Mar/09 04:49;faywang;OPENJPA-1004-1.patch;https://issues.apache.org/jira/secure/attachment/12404204/OPENJPA-1004-1.patch,01/Apr/09 05:02;faywang;OPENJPA-1004-2.patch;https://issues.apache.org/jira/secure/attachment/12404300/OPENJPA-1004-2.patch,30/Mar/09 23:36;faywang;OPENJPA-1004.patch;https://issues.apache.org/jira/secure/attachment/12404191/OPENJPA-1004.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2009-03-31 19:21:38.828,,,no_permission,,,,,,,,,,,161300,,,Thu Jan 13 14:40:32 UTC 2011,,,,,,,0|i0zbnb:,204189,,,,,,,,"30/Mar/09 23:34;faywang;The PCEnhancer generates pcCopyKeyFieldsToObjectId as following:

  public void pcCopyKeyFieldsToObjectId(Object paramObject)
  {
    Object localObject;
    ChildId localChildId = (ChildId)((ObjectId)paramObject).getId();
    localChildId.id = this.id;
    Parent localParent = this.parent;
    if (localParent != null)
      localObject = ((PersistenceCapable)localParent).pcFetchObjectId();
    localChildId.parent = ((localObject != null) ? ((LongId)localObject).getId() : 0L);
  }

Since the parent has generated key, its objectId is null during pre-flush stage, the parent.pcFetchObjectId will throw the exception: 

<openjpa-1.2.1-r752877:753278 fatal user error> org.apache.openjpa.persistence.InvalidStateException: Detected reentrant flush.  Make sure your flush-time instance callback methods or event listeners do not invoke any operations that require the in-progress flush to complete.
    at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1904)
    at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1679)
    at org.apache.openjpa.kernel.StateManagerImpl.assignObjectId(StateManagerImpl.java:524)
    at org.apache.openjpa.kernel.StateManagerImpl.assignObjectId(StateManagerImpl.java:506)
    at org.apache.openjpa.kernel.StateManagerImpl.fetchObjectId(StateManagerImpl.java:1434)
    at net.company.persistence.Parent.pcFetchObjectId(Parent.java)
    at net.company.persistence.Child.pcCopyKeyFieldsToObjectId(Child.java)

The proposed fix is to have PCEnhancer generate the following code when parent has generated key:

  public void pcCopyKeyFieldsToObjectId(Object paramObject)
  {
    ChildId localChildId = (ChildId)((ObjectId)paramObject).getId();
    localChildId.id = this.id;
    localChildId.parent = 0L;
  }

The test case then passed.",31/Mar/09 04:49;faywang;Testcase is attached.,"31/Mar/09 19:21;ppoddar@apache.org;Excellent fix Fay for a complex problem.

If you want a stress test of this stuff -- There are some added complexity of generated identity on Oracle platform. There is a documented test in org.apapche.openjpa......oracle.TestAutoCrement. ","01/Apr/09 05:02;faywang;The earlier fix has problem. Although persist works, after persist, the objectId is not set properly, causing subsequent update to fail. The new patch will fix persist/update/delete problem.","12/Jan/11 14:18;khaksnes;Are there any workarounds/fixes available for Geronimo 1.2.x?
I am bitten severely by this bug or a close relative using Geronimo 2.2.1 which are using 1.2.2","13/Jan/11 14:40;mikedd;I haven't looked at how feasible it would be to migrate this fix to 1.2.x, and might not get a chance to really look at it until after the 2.1.0 release. 

If you're familiar with maven & svn could you try building the change on 1.2.x? I'm not sure how to install a custom version of OpenJPA into geronimo, but there should be a way. 

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Select range doesn't work on Oracle JDBC driver,OPENJPA-1002,12421534,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,amy,amy,30/Mar/09 08:25,21/Sep/16 14:21,14/Mar/19 03:02,16/Sep/09 14:31,1.1.0,1.2.1,1.3.0,2.0.0-M2,,,,,,1.2.0,2.0.0-M3,,,,jdbc,,,,,,1,,"Select range doesn't work on Oracle with Oracle jdbc driver 10.2.0.1.0.
The test case is like below:
        OpenJPAEntityManager pm =(OpenJPAEntityManager)currentEntityManager();
        FetchPlan fetch = (FetchPlan) pm.getFetchPlan();
        fetch.addField(EagerOuterJoinPC.class, ""stringList"");
        fetch.setFetchBatchSize(3);
        OpenJPAQuery q = pm.createQuery(JPQLParser.LANG_JPQL,
                ""select x from EagerOuterJoinPC x order by x.name asc"");
        q.setFirstResult(5).setMaxResults(15);
        
        List results = (List) q.getResultList();
        assertEquals(5, results.size());

The assertion passed on Derby. But failed on Oracle:
junit.framework.AssertionFailedError: expected:<5> but was:<10>
        at junit.framework.Assert.fail(Assert.java:47)
        at junit.framework.Assert.failNotEquals(Assert.java:282)
        at junit.framework.Assert.assertEquals(Assert.java:64)
        at junit.framework.Assert.assertEquals(Assert.java:201)
        at junit.framework.Assert.assertEquals(Assert.java:207)
        at org.apache.openjpa.persistence.jdbc.meta.TestEagerOuterToManyJoins.testQueryRange(TestEagerOuterToManyJoins.java:679)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:127)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:334)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:980)
","OS: windows XP professional
java version 1.5.0_14
Oracle jdbc driver 10.2.0.1.0",,,,,,,,,,,,,,,,,,,,,30/Mar/09 08:45;amy;1002.patch;https://issues.apache.org/jira/secure/attachment/12404115/1002.patch,14/Apr/09 14:52;rpalache;1002_Headtrunk.patch;https://issues.apache.org/jira/secure/attachment/12405421/1002_Headtrunk.patch,14/Apr/09 14:52;rpalache;TestEagerOuterToManyJoins1.java;https://issues.apache.org/jira/secure/attachment/12405422/TestEagerOuterToManyJoins1.java,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2009-04-14 14:52:27.796,,,no_permission,,,,,,,,,,,38608,,,Wed Jul 29 20:25:44 UTC 2009,,,Patch Available,,,,0|i0zanr:,204029,,,,,,,,"30/Mar/09 08:45;amy;The attached patch includes fix and test case.

To reproduce the error, applying the patch (excluding DBDictionary and OracleDictionary), run TestEagerOuterToManyJoins with Oracle jdbc driver, like:
        mvn test -Dtest= TestEagerOuterToManyJoins -Ptest-custom \
          -Dopenjpa.custom.driverjar=$(pwd)/drivers/jdbc-oracle-10_2_0_1_0.jar \
          -Dopenjpa.custom.driverclass=oracle.jdbc.driver.OracleDriver \
          -Dopenjpa.custom.url=jdbc:oracle:thin:@HOST:PORT:DBNAME \
          -Dopenjpa.custom.username=USERNAME \
          -Dopenjpa.custom.password=PASSWORD

","14/Apr/09 14:52;rpalache;
1002_Headtrunk.patch is ported patch on top of openjpa trunk.

Adding a new testcase TestEagerOuterToManyJoins1.

Steps that confirmed the fix is working:

a. mvn clean test -Dtest=TestEagerOuterToManyJoins1 -DfailIfNoTests=false will result in success.
b. mvn test -Dtest=TestEagerOuterToManyJoins1 -Ptest-custom -Dopenjpa.custom.driverjar=C:\bea\WLS100\wlserver_10.0\server\lib\ojdbc14.jar -Dopenjpa.custom.driverclass=oracle.jdbc.driver.OracleDriver -Dopenjpa.custom.url=jdbc:oracle:thin:@host:port:dbname -Dopenjpa.custom.username=user -Dopenjpa.custom.password=psswd -DfailIfNoTests=false

will result in assertion issues.

c. apply the attached patch.
d. Run step B again and this time it will be a success.

","17/Apr/09 00:32;dezzio;Revision 765801 is misidentified in the commit message as applying to this bug.  In fact, it actually applies to OpenJPA-1006.","21/Apr/09 04:30;rpalache;Can someone please commit my changes on the head revision.

Thanks,
Ravi.",21/Apr/09 13:55;drwoods;adding [PATCH] and assigning to a release,28/Apr/09 19:22;dezzio;Patch applied to trunk (currently 2.0.0 Snapshot). Revision 769505.,07/May/09 13:44;drwoods;Still needs to be applied to 1.3.x.,10/Jul/09 20:14;dezzio;Merged change at trunk revision 769505 to branch 1.1.x at revision 793096,"29/Jul/09 20:25;drwoods;Please consider for 1.0.x and 1.2.x.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.IndexOutOfBoundsException when executing attached test case,OPENJPA-1001,12421510,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,rakr,rakr,29/Mar/09 20:03,09/Mar/10 18:31,14/Mar/19 03:02,11/Feb/10 23:14,1.2.1,,,,,,,,,1.2.3,1.3.0,2.0.0-beta2,,,jdbc,,,,,,0,,"I am hitting the following exception when executing the given test case:

Caused by: java.lang.IndexOutOfBoundsException: Index: 1, Size: 1
	at java.util.ArrayList.RangeCheck(ArrayList.java:546)
	at java.util.ArrayList.get(ArrayList.java:321)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.setParameters(SQLBuffer.java:615)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:515)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:471)
	at org.apache.openjpa.jdbc.sql.SelectImpl.prepareStatement(SelectImpl.java:463)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:379)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:325)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.getInitializeStateResult(JDBCStoreManager.java:503)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:322)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:278)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:894)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:852)
	... 53 more
<openjpa-1.2.1-rexported nonfatal general error> org.apache.openjpa.persistence.PersistenceException: Index: 1, Size: 1
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:875)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:774)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.find(JDBCStoreManager.java:951)
	at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.load(RelationFieldStrategy.java:609)
	at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:819)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:688)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:2921)
	at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:2999)
	at org.apache.openjpa.kernel.StateManagerImpl.fetchObjectField(StateManagerImpl.java:2242)
	at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.delete(RelationFieldStrategy.java:256)
	at org.apache.openjpa.jdbc.meta.FieldMapping.delete(FieldMapping.java:589)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.delete(AbstractUpdateManager.java:238)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.delete(AbstractUpdateManager.java:252)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.populateRowManager(AbstractUpdateManager.java:143)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:85)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:717)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2010)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1908)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1679)
	at org.apache.openjpa.kernel.QueryImpl.isInMemory(QueryImpl.java:956)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:796)
	at org.apache.openjpa.kernel.QueryImpl.deleteAll(QueryImpl.java:872)
	at org.apache.openjpa.kernel.QueryImpl.deleteAll(QueryImpl.java:868)
	at org.apache.openjpa.kernel.DelegatingQuery.deleteAll(DelegatingQuery.java:541)
	at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:331)
	at org.apache.openjpa.persistence.test.PersistenceTestCase.clear(PersistenceTestCase.java:232)
	at org.apache.openjpa.persistence.test.PersistenceTestCase.clear(PersistenceTestCase.java:205)
	at org.apache.openjpa.persistence.test.SingleEMFTestCase.tearDown(SingleEMFTestCase.java:71)
	at junit.framework.TestCase.runBare(TestCase.java:130)

...",Can reproduce on Max OS X and Linux,,,,,,,,,,,,,,,,,,,,,29/Mar/09 20:05;rakr;IncompleteRelationshipChildEntity.java;https://issues.apache.org/jira/secure/attachment/12404095/IncompleteRelationshipChildEntity.java,29/Mar/09 20:05;rakr;IncompleteRelationshipParentEntity.java;https://issues.apache.org/jira/secure/attachment/12404096/IncompleteRelationshipParentEntity.java,29/Mar/09 20:05;rakr;IncompleteRelationshipSubclass.java;https://issues.apache.org/jira/secure/attachment/12404097/IncompleteRelationshipSubclass.java,07/Dec/09 15:18;bjreed;OPENJPA-1001.patch;https://issues.apache.org/jira/secure/attachment/12427185/OPENJPA-1001.patch,29/Mar/09 20:05;rakr;TestIncompleteRelationship.java;https://issues.apache.org/jira/secure/attachment/12404094/TestIncompleteRelationship.java,,,,,,,,,,5.0,,,,,,,,,,,,,,,,,,,2009-04-03 13:52:10.033,,,no_permission,,,,,,,,,,,161298,,,Mon Dec 07 15:18:36 UTC 2009,,,,,,,0|i0zbnr:,204191,,,,,,,,"01/Apr/09 18:39;rakr;I've done some more digging around, and the issue *appears* to be:

SelectImpl.wherePrimaryKey(ClassMapping mapping, Column[] toCols, 
    	Column[] fromCols, Object oid, JDBCStore store, PathJoins pj,
    	SQLBuffer buf, List parmList)

This method is adding the primary key values to the parameter list.  It is adding a NULL value to the parameter list, and is also adding ""IS NULL"" to the SQLBuffer.

Then, when SQLBuffer calls setParameters(PreparedStatement ps, List cacheParams), it is finding that NULL value in the cacheParams list, and is throwing the IndexOutOfBoundsException when attempting to find the column name for the null value.","03/Apr/09 13:52;mikedd;Simply guarding for null when we add to the list appears to resolve the problem and it didn't break any other tests. The results look identical to what I get when running on trunk which has Pinaki's version of SQL caching. 

It seems to me that there's a better way to fix the problem, but I haven't been able to dig in and find it. ","03/Apr/09 20:31;ppoddar@apache.org;> The results look identical to what I get when running on trunk which has Pinaki's version of SQL caching. 
Does that imply the test passed with 'Pinaki's version of SQL caching'?

The test passed on trunk for me.

*If* this test is failing with previous SQLCaching (not pinaki's version of  SQL caching which is better be referred as Prepared Query caching -- because that more accurately reflects what it is) that brings up again the long-standing issue with QuerySQLCache. 

Though Prepared Query Cache has no resemblance to  QuerySQLCache in terms of its design and its solution approach -- I still agreed to retain the same moniker to configure it because I saw it as a replacement for a potentially risky (and costly) mistake that has entered our released service stream. 

I am aware of the concerns/risks of backporting a rather large change such as Prepared Query Cache  in a released service stream. But If Prepared Query Cache were not written by me, I would have voiced my opinion more strongly to backport it as a replacement for existing QuerySQLCache. The risk of regression with PQC changes are minimal both because of its design as well as it has been operation/tested in one way or other in different scenarios. 

Effectively, In my view (which can be accused of bias in this case), the cost of retaining existing QuerySQLCache in the service stream outweighs the risks of injecting PQC in the stream -- 
","03/Apr/09 20:41;mikedd;Sorry I wasn't clear with my earlier remarks. The testcase passed for me with trunk, and also passed with a simple guard for null. I just haven't had a chance to dig deeper (don't want to just band aid a fix in). 

Pinaki, taking a closer look at Prepared Query Caching is on my ever growing list to things to do, but I don't want to sidetrack this issue any more than I already have :-)","07/Dec/09 15:18;bjreed;This issue has been fixed in trunk with OPENJPA-703 revision 739123.  Unfortunately, that commit was very large (> 60 files).

I've been able to reduce the patch down to 5 files....seems that any more changes from this point break other JUnit test cases

Mike, when committing this patch to 1.2.x, also commit the TestIncompleteRelationship test case and I suggest committing the test case to trunk as well.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missing sql-warning in the localizer.properties,OPENJPA-999,12419407,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,faywang,faywang,25/Mar/09 17:36,09/Mar/10 18:31,14/Mar/19 03:02,25/Mar/09 17:55,2.0.0-M2,,,,,,,,,2.0.0-M2,,,,,,,,,,,0,,"Missing sql warning in localizer.properties resulting in lost message when there is sql warning.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161296,,,2009-03-25 17:36:22.0,,,,,,,0|i0yxk7:,201907,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PCEnhancer can't execute if a non-OpenJPA PU is found,OPENJPA-993,12417380,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,20/Mar/09 13:23,09/Mar/10 18:31,14/Mar/19 03:02,21/Dec/09 17:14,1.2.0,1.2.1,,,,,,,,1.3.0,2.0.0-beta,,,,kernel,,,,,,0,,"The PCEnhancer blows up if you have a non-OpenJPA persistence provider defined and available on the classpath. This makes comparisons between providers more than a little unfriendly. 

Example stack : 

204  OpenJPAPU  INFO   [main] openjpa.Tool - No targets were given.  Running on all classes in your persistent classes list, or all metadata files in classpath directories if you have not listed your persistent classes.  Use -help to display tool usage information.
Exception in thread ""main"" java.util.MissingResourceException: org.apache.openjpa.persistence.PersistenceProductDerivation:java.util.MissingResourceException: Persistence provider ""org.eclipse.persistence.jpa.PersistenceProvider"" specified in persistence unit ""EclipseLinkPU"" in ""META-INF/persistence.xml"" is not a recognized provider.
	at org.apache.openjpa.lib.conf.ProductDerivations.reportErrors(ProductDerivations.java:365)
	at org.apache.openjpa.lib.conf.ProductDerivations.load(ProductDerivations.java:270)
	at org.apache.openjpa.lib.conf.Configurations.populateConfiguration(Configurations.java:344)
	at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:4439)
	at org.apache.openjpa.enhance.PCEnhancer$1.run(PCEnhancer.java:4410)
	at org.apache.openjpa.lib.conf.Configurations.launchRunnable(Configurations.java:708)
	at org.apache.openjpa.lib.conf.Configurations.runAgainstAllAnchors(Configurations.java:698)
	at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:4405)
	at org.apache.openjpa.enhance.PCEnhancer.main(PCEnhancer.java:4396)
Caused by: java.util.MissingResourceException: Persistence provider ""org.eclipse.persistence.jpa.PersistenceProvider"" specified in persistence unit ""EclipseLinkPU"" in ""META-INF/persistence.xml"" is not a recognized provider.
	at org.apache.openjpa.persistence.PersistenceProductDerivation.load(PersistenceProductDerivation.java:339)
	at org.apache.openjpa.persistence.PersistenceProductDerivation.load(PersistenceProductDerivation.java:185)
	at org.apache.openjpa.lib.conf.ProductDerivations.load(ProductDerivations.java:261)
	... 7 more",,,,,,,,,,,,,,,,,,,,,,15/Dec/09 16:16;curtisr7;OPENJPA-993.patch;https://issues.apache.org/jira/secure/attachment/12428051/OPENJPA-993.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-12-15 16:16:07.83,,,no_permission,,,,,,,,,,,161290,,,Mon Dec 28 18:36:34 UTC 2009,,,,,,,0|i1drtr:,288605,,,,,,,,15/Dec/09 16:16;curtisr7;Attaching a patch to look at later when I have more time.,21/Dec/09 17:14;curtisr7;Committed changes to 1.3 and trunk.,"28/Dec/09 18:36;xiaoqinfeng2000;I am on vacation from 12/20/2009 Â to 12/26/2009.

If you have any question on deployment and JEE bugs, please contact Saurabh Arora or my manager Maruthi Nuthikattu.

For emergency, contact me at 925-209-5517.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Failed to throw EntityExistException on duplicated persist in DB2,OPENJPA-992,12417325,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,19/Mar/09 21:50,12/Oct/09 20:02,14/Mar/19 03:02,22/Mar/09 02:04,1.2.2,1.3.0,2.0.0-M2,,,,,,,2.0.0-M2,,,,,jdbc,,,,,,0,,"TestException.testThrowsEntityExistsException() failed when run against DB2 due to incorrect exception being thrown from OpenJPA. The test is expecting EntityExistsException but instead a RolledbackException with nested PersistenceException is thrown.

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161289,,,2009-03-19 21:50:04.0,,,,,,,0|i1drtz:,288606,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Replicated is only recognized for root instance but not the instanes reachable from the root during persist() operation.,OPENJPA-981,12416999,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,16/Mar/09 20:24,09/Mar/10 18:31,14/Mar/19 03:02,18/Mar/09 14:04,,,,,,,,,,2.0.0-M2,,,,,slice,,,,,,0,,The root instance is replicated across multiple slices. But the closure of the root is assigned to the first slice only even when the instances of closure are @Replicated themselves. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161278,,,2009-03-16 20:24:46.0,,,,,,,0|i0z9y7:,203914,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Allow DB2 JCC driver to work with Informix database,OPENJPA-973,12416593,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,10/Mar/09 23:31,19/Aug/09 16:19,14/Mar/19 03:02,17/Aug/09 18:33,,,,,,,,,,1.3.0,2.0.0-M3,,,,jdbc,,,,,,0,,"Openjpa parses the DatabaseMetaData retrieved from the jdbc connection to determine the database type. For informix, if db2jcc driver is used, the product name in the DatabaseMetaData does not start with ""informix"", but with ""ids""",,,,,,,,,,,,,,,,,,,,,,18/Mar/09 21:25;faywang;OPENJPA-973.patch;https://issues.apache.org/jira/secure/attachment/12402510/OPENJPA-973.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-05-07 13:27:42.164,,,no_permission,,,,,,,,,,,161270,,,Mon Aug 17 18:45:35 UTC 2009,,,,,,,0|i0z5tz:,203247,,,,,,,,"18/Mar/09 21:25;faywang;Allow com.ibm.db2.jcc.DB2Driver to work with
Informix. Since this driver can work with both DB2
and Informix, we need to check url protocol first to determine
the correct DBDictionary.","07/May/09 13:27;drwoods;Patch applied to trunk on March 23 by Fay and I verified that the DB2 driver could be used with IDS when testing the query timeout featue, so marking as resolved.","07/May/09 16:02;faywang;There is an open issue with db2 jcc driver when connecting to Informix.

A similar call to getColumns work with both jcc and native jdbc driver:

        ResultSet rs = dbMeta.getColumns(""demodb"", null, ""jpataskbean"", null); ==> jcc return columns

	However, the getImportedKeys does not work with jcc driver:

	     rs = dbMeta.getImportedKeys(""demodb"", null, ""jpataskbean""); ==> jcc returns empty result set
 
There can be two possibilities here.

The database metadata methods in the driver are implemented by calling a stored procedure on the server. So the problem could be in the in the stored procedure.

Or since the  IDS server supports two different protocols (i.e. sqli and drda). It is possible that getImportedKeys is working in sqli protocol which is used with Informix legacy jdbc driver and not working with drda protocol which is used by JCC driver.

Either way this does seems to be a JCC driver problem.

","07/May/09 16:36;drwoods;OK, reopening since there is still an issue.
BTW - I used the DRDA protocol for query timeout testing on IDS, but didn't run all the unit tests.","17/Jul/09 20:43;mikedd;Merged to 1.3.x, I believe the remaining problems  are with the JCC driver and this issue can be closed. ","17/Aug/09 18:45;faywang;The informix problem of
rs = dbMeta.getImportedKeys(""demodb"", null, ""jpataskbean""); ==> jcc returns empty result set 

is fixed in 11.50.xC5 fix pack release.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"SchemaToolTask does not have ""dropTables"" argument",OPENJPA-970,12416552,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,hallmit,hallmit,10/Mar/09 16:32,09/Mar/10 18:31,14/Mar/19 03:02,17/Mar/09 21:10,1.2.0,,,,,,,,,1.3.0,2.0.0-M2,,,,third-party,,,,,,0,,"The task SchemaToolTask does not implements
""dropTables"" argument. According to the documentation [1] this task can
take ""dropTables"" arguments
but when I run as shown below I get this error: The <schematool> type
doesn't support the ""droptables"" attribute.

    <schematool dropTables=""false"" action=""refresh"">
            <fileset dir=""${build.sql.dir}"">
                <include name=""schema.xml"" />
            </fileset>
            <config
propertiesFile=""${prototype.src.model.base}/META-INF/persistence.xml"" />
        </schematool>

In fact, I looked in source code and this task has no set method for
""dropTables""argument.

I use :
revision.number=422266:683325
openjpa.version=1.2.0

[1]
http://openjpa.apache.org/builds/1.2.0/apache-openjpa-1.2.0/docs/manual/ref_guide_schema_schematool.html
 
Thanks, ",,,,,,,,,,,,,,,,,,,,,,12/Mar/09 17:41;drwoods;OPENJPA-970.patch;https://issues.apache.org/jira/secure/attachment/12402068/OPENJPA-970.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-03-12 17:41:27.204,,,no_permission,,,,,,,,,,,161267,,,Thu Mar 12 17:41:27 UTC 2009,,,,,,,0|i0z5dr:,203174,,,,,,,,"12/Mar/09 17:41;drwoods;Patch for reported problem, based on the suggested change by Leonardo on the users list.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Open up FinderCacheImpl for non-JDBC or JDBC-like  implementation of preparing statement/query execution,OPENJPA-965,12416339,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,06/Mar/09 23:04,09/Mar/10 18:31,14/Mar/19 03:02,10/Mar/09 04:31,2.0.0-M2,,,,,,,,,2.0.0-M2,,,,,,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161262,,,2009-03-06 23:04:25.0,,,,,,,0|i0za1b:,203928,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MethodQL parameter passing broken,OPENJPA-955,12416213,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,logemann,logemann,05/Mar/09 16:38,09/Mar/10 18:31,14/Mar/19 03:02,06/Mar/09 23:55,1.2.0,,,,,,,,,2.0.0-M1,2.0.0-M2,,,,kernel,,,,,,0,,"        OpenJPAEntityManager oem = OpenJPAPersistence.cast(em);
        OpenJPAQuery query = oem.createQuery(""openjpa.MethodQL"", ""de.logentis.openjpa.LogentisMethodQL.blabla"");
        query.setResultClass(DP_PLZ_DA.class);
        query.setParameter(1, ""Fred"").setParameter(2, ""Lucas"");

This results of an empty parameter Map in the LogentisMethodQL.blabla() method. 

Even worse, when doing parameter passing as stated in the docs Chapter 9 / 5:

query.setParameter(""first"", ""Fred"").setParameter(""last"", ""Lucas"");

There is an exception thrown.

In fact MethodQL is completely broken when it comes to parameters at this point.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-03-06 13:51:32.414,,,no_permission,,,,,,,,,,,161252,,,Fri Mar 06 14:56:04 UTC 2009,,,,,,,0|i0za0f:,203924,,,,,,,,"05/Mar/09 16:42;logemann;The problem is somewhere in MethodStoreQuery.bindParameterTypes():

   private LinkedMap bindParameterTypes() {
        ctx.lock();
        try {
            if (_params != null)
                return _params;
            String params = ctx.getParameterDeclaration();
            if (params == null)
                return EMPTY_PARAMS;

            List decs = Filters.parseDeclaration(params, ',', ""parameters"");
            if (_params == null)
                _params = new LinkedMap((int) (decs.size() / 2 * 1.33 + 1));
            String name;
            Class cls;
            for (int i = 0; i < decs.size(); i += 2) {
                name = (String) decs.get(i);
                cls = ctx.classForName(name, null);
                if (cls == null)
                    throw new UserException(_loc.get(""bad-param-type"", name));
                _params.put(decs.get(i + 1), cls);
            }
            return _params;
        } finally {
            ctx.unlock();
        }
    }

_params is null and even ctx.getParameterDeclaration(); doesnt return anything useful. When passing the parameter into QueryImpl (the API one - not the delegate) it wont be passed in the lower layers (the delegate). This is at least what i ve learned from debugging so far.","06/Mar/09 13:51;drwoods;Code checked into trunk as Rev750798 by Pinaki.
Mike, can we also get this merged into 1.3.x?","06/Mar/09 14:56;logemann;Nice to have it also in 1.3.x

Perhaps we should create a JIRA which makes the ""declareParameters"" obsolete. As discussed in the dev-list, we could determine the parameter types on the setParameter() calls on the public Query class. This would prevent users from calling (internal) delegates.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Javadoc jar file does not contain legal files,OPENJPA-951,12416018,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,03/Mar/09 17:01,31/Mar/09 12:09,14/Mar/19 03:02,31/Mar/09 12:09,1.0.4,1.2.1,1.3.0,2.0.0-M2,,,,,,1.0.4,1.2.1,1.3.0,2.0.0-M2,,build / infrastructure,,,,,,0,,"Donald's fix to use the ianal plugin revealed a problem in the javadoc plugin. The javadoc plugin does not include elements from the 
<resources> tags in pom.xml. The normal jar plugin and source plugin do include these resources.

As a result we have no legal files in the javadoc jar and we're failing the ianal check. Quick browsing of the javadoc plugin mailing lists suggest a few workarounds for this problem which I'll test during the 1.2.1 release. After the release I'll migrate the changes to the other affected branches. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-03-03 17:25:55.152,,,no_permission,,,,,,,,,,,161249,,,Tue Mar 03 20:59:00 UTC 2009,,,,,,,0|i1drxj:,288622,,,,,,,,03/Mar/09 17:25;djencks;In my experience using the maven-remote-resources-plugin gets the legal files in both source and javadoc jars as well as the main artifact.  I think all the plugins have to be configured in a profile for this to work (e.g. mvn source:jar doesn't run the m-r-r-p but mvn -Prelease does),"03/Mar/09 20:59;mikedd;Hi David, I haven't tried the remote-resources-plugin yet.

Since the proper license files are already there in the ""main"" jar file I just unzipped it from there into the javadoc location. Seemed to work for me, if it is a bit kludgy. 

If you can point me to an example with the maven-remote-resources-plugin I'm happy to take look. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Overly verbose TestCases,OPENJPA-947,12415888,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,01/Mar/09 22:35,30/Jul/09 14:04,14/Mar/19 03:02,01/Apr/09 15:18,1.0.3,1.1.0,1.2.0,,,,,,,1.3.0,2.0.0-M2,,,,,,,,,,0,,"Too many of our test cases enable trace by default, or use system.out.printlns. The extra information dumped to the console makes it hard to spot useful information like real failures. 

A great deal of this output can be disabled by setting the openjpa.loglevel property when running a maven build, but not all testcases respect it.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161245,,,2009-03-01 22:35:34.0,,,,,,,0|i1dry7:,288625,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FetchAttribute.recursionDepth = -1 does not load properly self referenced entities in a complex relation,OPENJPA-944,12415697,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,yzhivkov,yzhivkov,26/Feb/09 18:58,09/Mar/10 18:31,14/Mar/19 03:02,18/Jan/10 21:36,1.0.0,1.0.1,1.0.2,1.0.3,1.1.0,1.2.0,,,,2.0.0-beta,,,,,jdbc,kernel,,,,,0,,"A problem with loading recursively referenced entities was found when there is a complex relation of the following kind:
Leaf <-> BranchConnection <-> Branch(1) <- Branch(2) <- ...
where Branch has a self reference to itself.

Using a FetchPlan with a fetch group that has a fetch attribute with recursionDepth=-1 does not produce the expected result and only the first of the Branch nodes is loaded. 
Loading a Leaf with 5 branches in a row and traversing through them fails right on level 3 (starting from 5 downwards) which leads to the thought that OpenJPA loads only the first element (along with its direct parent).
","JDK: Sun 1.5
Database: Derby 10.2.2.0
OS: Windows XP ",,,,,,,,,,,,,,,,,,,,,21/Apr/09 00:07;yzhivkov;fix_recursive_entity_loading-OPENJPA-944-openjpa1.0.1.patch;https://issues.apache.org/jira/secure/attachment/12405970/fix_recursive_entity_loading-OPENJPA-944-openjpa1.0.1.patch,21/Apr/09 00:07;yzhivkov;fix_recursive_entity_loading-OPENJPA-944-openjpa1.2.1.patch;https://issues.apache.org/jira/secure/attachment/12405971/fix_recursive_entity_loading-OPENJPA-944-openjpa1.2.1.patch,26/Feb/09 18:59;yzhivkov;openjpa_complex_relation_recursion_test.zip;https://issues.apache.org/jira/secure/attachment/12401060/openjpa_complex_relation_recursion_test.zip,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161242,,,Tue Apr 21 00:07:26 UTC 2009,,,Patch Available,,,,0|i0yw67:,201682,,,,,,,,"26/Feb/09 18:59;yzhivkov;Attached a test case that shows the error. I tried the test case with 1.0.0, 1.0.1, 1.0.3, 1.1.0 and 1.2.0 and even with the latest trunk code but neither of them work.

For running the test case unzip the zip file and execute from a shell:
  mvn install

The provided test case extends SingleEMFTestCase and can directly be copied into openjpa-persistence-jdbc/src/test for being executed within there as well.
",26/Feb/09 19:20;yzhivkov;Could be related to OPENJPA-911. The only difference is that the attached to this bug test case works for release 1.0.0 whilst my test case does not work for any released version of OpenJPA.,"21/Apr/09 00:07;yzhivkov;Attached patch files for fixing that issue for OpenJPA versions 1.0.1 and 1.2.1. The same changes could be used for the other versions as well.

I think the problem is that the recursion depth is not calculated properly. When the FetchConfiguration is created for every field-to-field relation only the type of the FieldMetaData is taken into consideration. This causes a confusion of what the real recursion depth is. 
For example if the field BranchConnection.branch refers to Branch and Branch.parent has a reference to Branch then there is the following field metadata:

|| Field || From Type || Recursion Depth ||
| branch | Branch | 1 |
| parent | Branch | -1 |

When the mappings are built and OpenJPA gets to BranchConnection.branch - > Branch.parent and tries to add the new field Branch.parent it will try to find an already existing limit and will compare the From Type of the new field to the From Type of the existing mappings (parents of the new mapping).
As the second mapping in the table has not been created yet it will grab the first one which is not what we expect and will set recursion depth 1. This prevents from getting the real recursion depth and only the first parent of the Branch connected to BranchConnection will be loaded.

For fixing this behavior a new check for the field name was added. This makes sure that when the recursion depth is being determined only the mappings that are of the same kind (fromField and fromType) will be taken into consideration.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using table-generator in XML descriptor results in ClassCastException,OPENJPA-940,12415537,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,fancy,uhermse,uhermse,25/Feb/09 07:58,17/Feb/11 14:11,14/Mar/19 03:02,17/Feb/11 04:12,1.2.0,2.0.0-M2,,,,,,,,2.1.1,,,,,,,,,,,0,,"Defining a table generator in the XML descriptor leads to a class cast exception. The reason is a probably unintentional fall through of a switch/case block in class XMLPersistenceMetaDataSerializer line 502:

...
            switch (type) {
                case TYPE_META:
                    serializeClass((ClassMetaData) obj, fieldAccess
                        && propertyAccess);
                    break;
                case TYPE_SEQ:
                    if (isMappingMode())
                        serializeSequence((SequenceMetaData) obj);
                        // HERE SHOULD BE A break;
                case TYPE_QUERY:
                    serializeQuery((QueryMetaData) obj);
                    break;
...

As a result I get the following stack:

219  testPU  INFO   [main] openjpa.Runtime - Starting OpenJPA 1.2.0
688  testPU  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.DerbyDictionary"".
3329  testPU  WARN   [main] openjpa.MetaData - Found duplicate generator ""tableGen"" in ""class com.daimler.tss.lab.jpa.pojo.Slave"".  Ignoring.
3830  testPU  INFO   [main] openjpa.MetaData - Writing to file ""C:\Uli\Workspaces\TSS_ganymede_2\OpenJPA Test\build\classes\META-INF\test-orm.xml"".
3986  testPU  INFO   [main] openjpa.MetaData - Writing sequence ""tableGen"".
Exception in thread ""main"" <openjpa-1.2.0-r422266:683325 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: org.apache.openjpa.jdbc.meta.SequenceMapping cannot be cast to org.apache.openjpa.meta.QueryMetaData
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:196)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:192)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:145)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:56)
	at com.daimler.tss.lab.jpa.test.RelationshipManagementTest.createMaster(RelationshipManagementTest.java:47)
	at com.daimler.tss.lab.jpa.test.RelationshipManagementTest.main(RelationshipManagementTest.java:39)
Caused by: java.lang.ClassCastException: org.apache.openjpa.jdbc.meta.SequenceMapping cannot be cast to org.apache.openjpa.meta.QueryMetaData
	at org.apache.openjpa.persistence.XMLPersistenceMetaDataSerializer.serialize(XMLPersistenceMetaDataSerializer.java:504)
	at org.apache.openjpa.lib.meta.XMLMetaDataSerializer.serialize(XMLMetaDataSerializer.java:257)
	at org.apache.openjpa.lib.meta.XMLMetaDataSerializer.serialize(XMLMetaDataSerializer.java:121)
	at org.apache.openjpa.lib.meta.XMLMetaDataSerializer.serialize(XMLMetaDataSerializer.java:90)
	at org.apache.openjpa.meta.AbstractCFMetaDataFactory.serialize(AbstractCFMetaDataFactory.java:479)
	at org.apache.openjpa.meta.AbstractCFMetaDataFactory.store(AbstractCFMetaDataFactory.java:234)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:538)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:453)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:159)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:119)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:189)
	... 6 more

May I suggest to run findBugs on your source code. That would have found this section for sure. Does anyone test the XML descriptor stuff?
","Windows XP
Java SE 6 Update 11",1200,1200,,0%,1200,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161238,,,2009-02-25 07:58:07.0,,,,,,,0|i0ywfz:,201726,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Removing entities with Embedded field issue multiple delete statements,OPENJPA-935,12415279,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,mmtt45,mmtt45,21/Feb/09 11:59,21/Sep/16 14:21,14/Mar/19 03:02,15/Mar/10 21:29,1.2.0,,,,,,,,,1.2.0,2.0.0-M2,,,,jpa,,,,,,0,,"> I have a following beans:
>
> @Embeddable
> class A {
> int field1
> }
>
> @Entity
> class B {
> @Id
> long id;
>
> int field2
>
> @Embedded
> A field3
> }
>
> When I trying to delete all instances of B entity from data storage by
> ""delete from B"" I got:
>
> 1. Query (""select"" statement) for all B instances
> 2. For each instance from 1. delete statement
>
> Why this is not delete by simple ""delete from B"" sql statement?",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-08-10 15:54:17.826,,,no_permission,,,,,,,,,,,161233,,,Mon Aug 10 15:54:17 UTC 2009,,,,,,,0|i0z7un:,203574,,,,,,,,10/Aug/09 15:54;dezzio;Merged change at trunk revision 746640 to branch 1.1.x at 802837,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Oversight in TestSequenceGenerator,OPENJPA-934,12415276,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,techhusky,milosz,milosz,21/Feb/09 09:38,09/Mar/10 18:31,14/Mar/19 03:02,11/Jun/09 18:58,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,sql,,,,,,0,,"There is a small oversight in TestSequenceGenerator which results in the test being run on a database without sequences and not being run on a database with sequences.

The snippet:

        try {
            enabled =
                ((JDBCConfiguration) emf.getConfiguration())
                    .getDBDictionaryInstance().nextSequenceQuery == null;
        } catch (Throwable t) {
            enabled = false;
        }

should read:

        try {
            enabled =
                ((JDBCConfiguration) emf.getConfiguration())
                    .getDBDictionaryInstance().nextSequenceQuery != null;
        } catch (Throwable t) {
            enabled = false;
        }
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-02-23 15:30:01.092,,,no_permission,,,,,,,,,,,161232,,,Mon Feb 23 15:30:01 UTC 2009,,,,,,,0|i1drzr:,288632,,,,,,,,"23/Feb/09 15:30;techhusky;Thanks, Milosz.  My bad.  Pinaki also pointed out this bug a short while ago.  I'll make the correction.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Database version detection in MySQLDictionary is not reliable,OPENJPA-933,12415270,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,milosz,milosz,milosz,21/Feb/09 08:24,09/Mar/10 18:31,14/Mar/19 03:02,18/Apr/09 12:59,1.2.0,1.3.0,2.0.0-M2,,,,,,,1.3.0,2.0.0-M2,,,,jdbc,sql,,,,,0,,"The database version detection code assumes the version string always looks like ""4.1.3-nt"" whereas currently a MySQL on Linux reports itself as ""5.1.30"". This causes an exception catch and a fallback to default values (in particular supportsXMLColumn stays false). Also, the code could take advantage of JDBC 3 methods that return version numbers.

I will provide a patch.
","MySQL 5.1.30, Linux",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161231,,,Sat Apr 18 12:59:58 UTC 2009,,,,,,,0|i1drzz:,288633,,,,,,,,"18/Apr/09 12:59;milosz;A patch applied to trunk and 1.3.x branch.

Changes:
- Corrected version parsing for non-JDBC 3 drivers
- Version numbers are got from JDBC 3 methods if available
- Removed driver version parsing, now uses metaData.getDriverMajorVersion() which is a pre-JDBC 3 method
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Runtime enhancer doesn't work propery if there is a trailing persistence.xml file on the classpath.,OPENJPA-932,12415255,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,curtisr7,curtisr7,20/Feb/09 19:50,09/Mar/10 18:31,14/Mar/19 03:02,16/Jun/09 17:46,1.2.0,2.0.0-M1,2.0.0-M2,,,,,,,1.3.0,2.0.0-M3,,,,kernel,,,,,,0,,"I have an application where I am using runtime class enhancement via the javaagent and I set openjpa.RuntimeUnenhancedClasses=unsupported. My application works fine when running on 1.1.0 but when I moved to 1.2.0 (and 2.0.0) I started getting errors because my classes aren't being enhanced. 

After debugging I determined that I had a jar on the end of my classpath that had a META-INF/persistence.xml file in it. The extra persistence.xml file has no PUs defined, and should have been ignored. When I removed that jar from my classpath things starting working again. It also works if I put my META-INF/persistence.xml file on the end of my classpath.",,,,,,,,,,,,,,,,,,,,,,24/Apr/09 18:52;curtisr7;OPENJPA-932.patch;https://issues.apache.org/jira/secure/attachment/12406383/OPENJPA-932.patch,12/Mar/09 20:25;curtisr7;OPENJPA-932.patch;https://issues.apache.org/jira/secure/attachment/12402084/OPENJPA-932.patch,11/May/09 20:03;curtisr7;OPENJPA932.test.patch;https://issues.apache.org/jira/secure/attachment/12407807/OPENJPA932.test.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2009-03-06 17:01:01.76,,,no_permission,,,,,,,,,,,161230,,,Wed May 13 15:28:11 UTC 2009,,,,,,,0|i0zanb:,204027,,,,,,,,"02/Mar/09 23:10;curtisr7;The bug is that we parse all URLs matching the provided resource name, but only return the PU names from the last URL that was parsed. We should be saving the results after each time we parse a URL and returning ALL results.

In addition to the bug fix I added some error detection. If there are persistence unit name collisions for the provided resource name, a WARNING message will be logged.  See below for a snippet from a test run.

...
     [java] 297  WARN   [main] openjpa.Persistence - The persistence unit ""jpa.connection-pool"" was found in the following resources ""[file:/C:/jpa/workspace-samples/projects/j
pa.connection.pool/bin/META-INF/persistence.xml, jar:file:/C:/jpa/workspace-samples/projects/lib/test-bad.jar!/META-INF/persistence.xml]"". Please correct the problem as it may
have unexpected results.
...",05/Mar/09 17:10;curtisr7;Updated the patch to get a logger in a different manner. This patch is for trunk.,06/Mar/09 16:24;curtisr7;Changed the way I obtained a logger once again. ,"06/Mar/09 17:01;mikedd;Hi Rick,

The current patch will *always* log to StdErr. I think we'd be better off saving the fact that there was a name collision and logging it after we've parsed the configuration.

I'm also not sure we need a new logging level for this issue. Wouldn't one of the other levels, ie Runtime have sufficed? ","06/Mar/09 17:26;techhusky;Comments on patch dated 2009-03-06 08:24 AM:

- I don't think a new trace group should be added specifically for this warning.  (OpenJPA trace groups are well documented in the manual, so if a new group would need to be doc'd if consensus is that a new group should be added.).  While this exception shows up during enhancement, it is in product derivation code so openjpa.Runtime may be better?

- I'm still struggling a bit with constructing a new config to get a logger, but OpenJPA doesn't really have anything configured at this point and I can't think of a cleaner way to get this important warning out there without other potentially messy changes.  The null check is good, IMHO.  The comment regarding its necessity can be removed.

- The error message isn't completely clear as to what the problem is or how to fix it.  I think wording which includes the notion that ""persistence unit names should be unique"" may help.  (I'd say must, but as this problem points out, we don't enforce it)","10/Mar/09 14:49;curtisr7;The new patch has the following updates:
* Removed the Persistence trace group.
* The previous PU name collision detection and logging was removed as it would only detect collisions when using the PCEnhancerAgent.
* PU name collisions are now detected and saved away, but not logged until an EMF is created for that PU.  The capability to make a PU name collision a fatal error exists, but I decided that course action is a bit extreme. I think new message is verbose enough that a user should be able to figure out what's going on if they're having problems.

One question - Do I need a separate Jira for the PU name collision detection/logging since it is pretty much separate from the bug that this Jira was opened for?

-Rick","11/Mar/09 14:42;curtisr7;For the unit test I needed to have multiple META-INF/persistence.xml files on my classpath and the test validates that all PUs are found that exist in those xml files. I wasn't quite sure what the 'proper' way was to do this, but what I posted works... Please correct me if there is a better way.

Note: The attached jar file needs to be expanded into openjpa-parent\openjpa-persistence\src\test.

-Rick",11/Mar/09 15:41;curtisr7;Modified slightly to build the bad-persistence.jar rather than check it into svn.,"12/Mar/09 16:13;techhusky;Comments on patches dated 2009-03-10 07:49 AM and 2009-03-11 08:41 AM.

1) PUNameCollision and related methods in ProductDerivations should be moved to PersistenceProductDerivation to keep openjpa-lib free of persistence artifacts.

2) Creating a jar is much preferred to checking one in, but I'm not sold on that yet either since (unless I'm mistaken) it is always in the classpath when running tests.  Anyone have other ideas for testing this scenario?",12/Mar/09 20:25;curtisr7;* Refactored the code in response to comment one from above.,"17/Apr/09 19:17;techhusky;Rick - I applied this patch and have a few comments/issues.

- I'm OK with loading an additional jar to the test classpath in the openjpa-persistence sub-project since there are very few tests that run in that package.  The code is only testing a warning path and shouldn't affect the behavior of those tests.

- I could not force the production of the new warning message using the provided code (which I think is the intent of bad-persistence.xml) since the persistence.xml's all use unique pu names.  Also, there was no test code to drive the code where the warning is logged.  Is one of the names used in bad-persistence supposed to be a duplicate?  Based on the code changes, the warning does not get logged unless one tries to create an emf with pu name that is a duplicate.  I created a simple test program to force the condition and it worked fine, but I think a test needs to be provided in order to produce and validate the warning condition, if possible.",24/Apr/09 18:52;curtisr7;Looks like I forgot add my test case to SVN when I built the previous patch. ,29/Apr/09 19:59;techhusky;Committed patch(es) for Rick to trunk under revision 769901.,11/May/09 20:03;curtisr7;The attached file removes changes I introduced in the pom.xml to test this patch. All of the *magic* is now contained within the test.,"13/May/09 15:28;techhusky;OPENJPA932.test.patch committed for Rick under revision 774393.  Nice work, Rick.  The code you've added to dynamically create and load a persistence jar on the fly would be a great addition to a general test utility.",,,,,,,,,,,,,,,,,,,,,,
Fix definition of javax.persistence.query.timeout property,OPENJPA-927,12415069,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,dianner,dianner,dianner,18/Feb/09 16:18,02/May/13 02:29,14/Mar/19 03:02,06/Mar/09 18:20,2.0.0-M2,,,,,,,,,2.0.0-M2,,,,,kernel,,,,,,0,,"This was originally reported by Pinaki in OPENJPA-849. It is being moved to this new JIRA. Here's Pinaki's original comment:

 
        queryTimeout.setLoadKey(""javax.persistence.query.timeout"");
        queryTimeout.setDefault(""-1"");
        queryTimeout.set(-1);
        queryTimeout.setDynamic(true);

does not seem kosher for the following reason:

1. loadKey is the key with which a property is loaded from configuration artifacts. At this point of execution, no property has been *actually* loaded, they are merely being declared to exist. Hence we should not be setting load key.
2. configuration declares a Value. But does not assign its value. So setting its value to -1 does not look alright. Setting default value is OK.

These issues gain significance in the light of the fact the configuration's hashcode is the key to a factory in JNDI. And computation of hashcode depends on the actual value of the Values.
As an extreme example, assume two Configuration C1 and C2 nearly identical but differs *only* in their query.timeout value. The requirement is hash code for C1 and C2 must not be equal. And that is what Configuration.hashCode() ensures. But, because we are setting query timeout to -1 (that is not what the user's p.xml sets) and it is marked as dynamic, in both cases Configuration hashcode will treat query.timeout value to be -1 and will end up computing same hashcode for C1 and C2.
",,,,,,,,,,,,,,,,,,,,,,23/Feb/09 18:26;drwoods;OPENJPA-927-trunk.patch;https://issues.apache.org/jira/secure/attachment/12400783/OPENJPA-927-trunk.patch,20/Feb/09 23:02;dianner;patch.txt;https://issues.apache.org/jira/secure/attachment/12400635/patch.txt,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-02-23 18:26:43.751,,,no_permission,,,,,,,,,,,161225,,,Thu Jul 30 14:09:08 UTC 2009,,,,,,,0|i1ds0n:,288636,,,,,,,,"18/Feb/09 16:21;dianner;Thanks for checking this out Pinaki.

>1. loadKey is the key with which a property is loaded from configuration artifacts. At this point of execution, no property has been >*actually* loaded, they are merely being declared to exist. Hence we should not be setting load key.

I now understand this and will change it. But, we have to solve a problem if we don't do this. The getProperties() methods return all defined properties, even if they have not been explicitly set. This calls the Configuration .toProperties() method which calls the setValue() method. By default, if we don't do anything, the value javax.persistence.query.timeout will be prefixed with ""openjpa."", which is not good. We can get around this doing a setEquivalentKey() instead. But, now I'm wondering what we'll get with the getSupportedProperties() with this change. I'll have to investigat that. But, if that's ok, is this a reasonable alternative? Or, should I figure out something else?

The other option is to define a new openjpa property, such as openjpa.QueryTimeout. I was trying to avoid that option. I'm not sure we want to define a new openjpa property for every new spec property.

>2. configuration declares a Value. But does not assign its value. So setting its value to -1 does not look alright. Setting default >value is OK.

ok - But, I modeled this after the openjpa.LockTimeout definition. So, does this one need to be corrected too?
","20/Feb/09 23:02;dianner;Here's a patch that does the following:

1 - Changes the setLoadKey() for javax.persistence.query.timeout to setEquivalentKey()
2 - Removes the set(-1) for the query timeout and lock timeout properties
3 - Removes from the EM getProperties Map the Connection2Password property",23/Feb/09 18:26;drwoods;Thanks Dianne.  Here is a version of the unmodified patch for non-Eclipse users.,"23/Feb/09 18:29;drwoods;Note:  my patch is a lot larger, as it removes the Windows ^M chars off every line of EntityManagerImpl.java, since I have my svn config properties setup as suggested by the ASF....","02/Mar/09 19:34;drwoods;Dianne, your patch is working for me.  Can you commit it?",04/Mar/09 19:36;techhusky;Committed Dianne's patch (with modifications) under revisions 750112 750113 750115 750117.,"06/Mar/09 18:17;drwoods;Dianne, can this be marked as resolved now?","30/Jul/09 14:09;alan_raison;The test org.apache.openjpa.persistence.simple.TestPropertiesMethods contains a derby connection string.  This is problematic if Derby is not being used to test.

I think removing the setting of the openjpa.ConnectionURL property will fix this - but I'm not sure if this nullifies the test!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bidirectional OneToOne relation incorrectly set in loadEagerJoin,OPENJPA-925,12415018,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,fancy,fancy,18/Feb/09 06:43,09/Mar/10 18:31,14/Mar/19 03:02,19/Feb/09 18:14,1.2.0,1.2.1,1.3.0,2.0.0-M1,2.0.0-M2,,,,,1.2.1,1.3.0,2.0.0-M2,,,,,,,,,0,,"A test scenario uncovers a bug in eager loading bidirectional OneToOne relation.

  OneOneParent  has a bidirectional OneToOne relation with OneOneChild as annotated as following:

@Entity
public class OneOneParent {
...
    @OneToOne(mappedBy=""parent"")
    private OneOneChild child;
}

@Entity
public class OneOneChild {
...
    @OneToOne
    private OneOneParent parent;
}

Testcase:

String query = ""select c FROM OneOneChild c"";
        Query q = em.createQuery(query);
        List list = q.getResultList();

        for (int i = 0; i < list.size(); i++) {
            OneOneChild c = (OneOneChild) list.get(i);
            assertEquals(c, c.getParent().getChild());
        }

We expect c equals c.getParent().getChild(), but instead got assertion failure.

It seems to be a bug introduced in performance improvement work (the related issues: OPENJPA-292 & OPENJPA-744).",,,,,,,,,,,,OPENJPA-919,,,,,,,,,,18/Feb/09 21:12;drwoods;OPENJPA-925-branches12x.patch;https://issues.apache.org/jira/secure/attachment/12400448/OPENJPA-925-branches12x.patch,18/Feb/09 16:12;drwoods;OPENJPA-925-branches12x.patch;https://issues.apache.org/jira/secure/attachment/12400425/OPENJPA-925-branches12x.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-02-18 15:17:44.213,,,no_permission,,,,,,,,,,,161223,,,Thu Feb 19 18:14:13 UTC 2009,,,,,,,0|i0zalj:,204019,,,,,,,,"18/Feb/09 15:17;drwoods;Catalina, this looks like like it resolved my testcase for OPENJPA-919, so can we get this back ported to the 1.2.x branch?
I'll create a patch and attach it, as I need to apply this to my local 1.2.x code and rerun the failing EJB TCK testcases for Geronimo to verify that this did fix our problems.
","18/Feb/09 16:12;drwoods;Changes back ported from trunk to branches/1.2.x.  This resolved the junit testcase attached in OPENJPA-919, but still need to run the EJB TCK on Geronimo before I can say its completely resolved.","18/Feb/09 19:39;drwoods;Catalina, please apply this fix to the 1.2.x branch, as it fixed the EJB TCK failures we were seeing in Geronimo 2.1.4 with OpenEJB 3.0.1.  Thanks.
",18/Feb/09 21:12;drwoods;Updated patch for branches/1.2.x which includes the latest updates made to trunk in r745597.,"19/Feb/09 02:28;fancy;fix checked in under trunk revision r745408, and 1.3.x at r745409.",19/Feb/09 02:34;drwoods;This also needs to be applied against the 1.2.x branch to resolve a EJB TCK issue found by Geronimo.,"19/Feb/09 18:14;drwoods;Also applied to branches/1.2.x by Mike, so marking as resolved.  thanks.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
setByteArrayInputStream being used in stead of setBytes,OPENJPA-922,12414883,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,bjreed,bjreed,16/Feb/09 16:38,21/Sep/16 14:35,14/Mar/19 03:02,01/Sep/15 22:01,1.2.0,2.0.0-M2,,,,,,,,2.0.0-M3,,,,,,,,,,,0,,"I have an Entity and one of its fields is defined as CHAR(16) FOR BIT DATA NOT NULL.

When trying to persist the entity, I get the following error:

   Error: SQLCODE=-301, SQLSTATE=07006, SQLERRMC=1, DRIVER=3.50.152  
   {prepstmnt 1386959531 INSERT INTO NULLID.TESTTBL (tkiid) VALUES (?)  
   [params=(InputStream) java.io.ByteArrayInputStream@75947594]}

It seems that the wrong kind of set is being used to set the parameter on the prepared statement.",DB2 on Windows,,,,,,,,,,,,,,,,,,,,,03/Mar/09 15:14;bjreed;OPENJPA-922-C.patch;https://issues.apache.org/jira/secure/attachment/12401318/OPENJPA-922-C.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-03-03 10:01:55.828,,,no_permission,,,,,,,,,,,161220,,,Mon Jun 22 21:37:07 UTC 2015,,,Patch Available,,,,0|i0z2qf:,202745,,,,,,,,"16/Feb/09 16:41;bjreed;For DB2, the DBDictionary useSetBytesForBlobs field is set to false.  Within setBytes, if this flag is true, setBinaryStream() is called regardless of what kind of column we really have (BYTES or BLOB_OBJECT).  Patch includes change to the if statement to also check the column type before using the setBinaryStream and a simple test case.

Please apply to both 1.2.x and trunk","24/Feb/09 20:29;bjreed;Was premature with the patch.  The ""fix"" breaks BLOBs so it's no good.  Basically, both unserialized BLOBS and byte arrays go through the ByteArrayValueHandler in stead of the BlobValueHandler (determined in MappingHandler.defaultHandler()) so the jdbc layer doesn't know there is a difference between the 2 and can't make the correct call to set the data....the use of ByteArrayValueHandler for both also happened on Derby so we need a way to differentiate between the two different kinds of byte[] (BLOBs and char for bit data) so that we know which method to use to set the data in the DB.","02/Mar/09 22:08;bjreed;I have attached OPENJPA-922-B.patch as a second attempt to fix this problem (also includes the test case).  Basically, the DB2Dictionary needs to override the DBDictionary setBytes and getBytes methods.  For setBytes, it can check the Column definition to use the proper set, for getBytes, the Column is nowhere to be found so it just tries the original getBlob, but if that fails, then it tries to getBytes as a last resort.  I'm sure there's a better way for the get, but I haven't stumbled across it yet.","03/Mar/09 10:01;milosz;Since the test case is likely to fail on databases other then DB2 (specific columnDefinition), it is a good idea to run it only when DB2 is connected. A few ideas:
1. Use the annotation described in OPENJPA-942.
2. Test whether DBDictionary is an instance of DB2Dictionary. Some other tests already use that approach.

","03/Mar/09 15:14;bjreed;Thanks Milosz.  I was so worried about the fix not breaking other DBs that I forgot about the test breaking other DBs.  Have attached the OPENJPA-922-C.patch to fix this.  When the annotation in OPENJPA-942 is working, it would probably be better to use that.","22/Jun/15 21:37;jira-bot;Commit 1686945 from [~jpaheath] in branch 'openjpa/branches/1.2.x'
[ https://svn.apache.org/r1686945 ]

OPENJPA-922: Support for DB2 BIT DATA - back ported 2.0.x changes to 1.2.x",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
stored procedures throw InvalidStateException when using getSingleResult() or getResultList(),OPENJPA-917,12414494,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,bjreed,bjreed,bjreed,10/Feb/09 14:59,09/Mar/10 18:31,14/Mar/19 03:02,12/Feb/09 19:08,1.2.0,,,,,,,,,1.0.4,1.2.1,1.3.0,2.0.0-M2,,query,,,,,,0,,"Currently, org.apache.openjpa.persistence.QueryImpl throws an InvalidStateException when any stored procedure is called.  The code needs to be updated to allow native queries to continue without the exception.",,,,,,,,,,,,,,,,,,,,,,10/Feb/09 15:04;bjreed;OPENJPA-917.patch;https://issues.apache.org/jira/secure/attachment/12399924/OPENJPA-917.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-02-12 19:08:22.727,,,no_permission,,,,,,,,,,,161216,,,Thu Feb 12 19:08:22 UTC 2009,,,,,,,0|i0yxcf:,201872,,,,,,,,"10/Feb/09 15:04;bjreed;This patch updates QueryImpl.java to bypass the InvalidStateException when a native query is used.  Also included is a JUnit test case that creates / loads / uses / drops a Derby stored procedure.  This patch was created on the openjpa 1.2.x branch and should also be applied and verified on trunk.

This fix does not fix the case where returning objects from stored procedures is not working properly - a new JIRA will be opened for this improvement",12/Feb/09 19:08;mikedd;Thanks for the patch B.J!,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DistributedTemplate is incorrectly setting some attributes on the statements,OPENJPA-916,12414419,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,drwoods,drwoods,09/Feb/09 19:46,09/Mar/10 18:31,14/Mar/19 03:02,01/Mar/09 21:07,1.1.0,1.2.0,1.3.0,2.0.0-M2,,,,,,2.0.0-M2,,,,,slice,,,,,,0,,"DistributedTemplate.java in openjpa-slice is not setting the setQueryTimeout() and setMaxRows() properties on its List of statements, but instead is setting the value on setMaxFieldSize() instead.",,,,,,,,,,,,,,,,,,,,,,09/Feb/09 19:52;drwoods;OPENJPA-916-branches11x.patch;https://issues.apache.org/jira/secure/attachment/12399850/OPENJPA-916-branches11x.patch,09/Feb/09 19:52;drwoods;OPENJPA-916-branches12x.patch;https://issues.apache.org/jira/secure/attachment/12399849/OPENJPA-916-branches12x.patch,09/Feb/09 19:52;drwoods;OPENJPA-916-branches13x.patch;https://issues.apache.org/jira/secure/attachment/12399848/OPENJPA-916-branches13x.patch,09/Feb/09 19:52;drwoods;OPENJPA-916-trunk.patch;https://issues.apache.org/jira/secure/attachment/12399847/OPENJPA-916-trunk.patch,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2009-02-09 21:16:41.495,,,no_permission,,,,,,,,,,,161215,,,Sun Mar 01 21:07:18 UTC 2009,,,,,,,0|i1dr87:,288508,,,,,,,,09/Feb/09 19:52;drwoods;Patch to properly call the setQueryTimeout() and setMaxRows() on the List of Statements.,09/Feb/09 19:53;drwoods;Unassigning so a committer can review and hopefully commit.,"09/Feb/09 21:16;ppoddar@apache.org;Thanks Dan for finding this error.
I will apply the patch to trunk.","23/Feb/09 16:48;drwoods;Mike, please consider applying to the 1.2.x branch.","01/Mar/09 21:07;mikedd;Some of the users of the 1.2.x and 1.0.x are conservative about changes, especially without a testcase. For now we'll resolve this issue in the released branches only. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
A deadlock issue happens when DirtyListener is used,OPENJPA-913,12414352,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,hiroki.tateno,hiroki.tateno,09/Feb/09 06:51,21/Sep/16 14:21,14/Mar/19 03:02,16/Mar/09 09:37,1.2.0,,,,,,,,,1.2.0,2.0.0-M2,,,,kernel,,,,,,0,,"A deadlock issue happens when OpenJPA entity manager is
concurrently called and DirtyListener is used and 
DirtyListener.beforeDirty calls an entity manager related 
operation. To call OpenJPA entity manager concurrently, 
we need to define openjpa.MulthThreaded option as true.

Following is test scenario.

1. Thread A calls entityMangaer.refresh() repeatedly.
   In refresh() method, entityManager acquires BrokerImpl
   lock. And then, entityManager acquires LifecycleEventManager
   lock to call lifecycle callback.
2. Thread B calls persistedObject.getAItems() (getting
   collection items).
3. In enhanced getItems() method, entityManager tries
   to mark it as ""dirty"". Before marking, callback listener
   DirtyListener.beforeDirty is called. In this point,
   LifecycleEventManager lock is acquired without acquiring
   BrokerImpl lock.
4. In the testcase, beforeDirty calls persistedObject.getAItems().
   And then, entity manager tries to acquire BrokerImpl lock.
   But, sometimes BrokerImpl lock is already acquired by Thread B.
   So, a deadlock issue happens. deadlock stack is as follows.

====
     [java] ""Thread-1"" prio=1 tid=0x09e98b28 nid=0x7fcc waiting on condition [0xb15f3000..0xb15f4130]
     [java]     at sun.misc.Unsafe.park(Native Method)
     [java]     at java.util.concurrent.locks.LockSupport.park(LockSupport.java:118)
     [java]     at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:716)
     [java]     at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:746)
     [java]     at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1076)
     [java]     at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:184)
     [java]     at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:256)
     [java]     at org.apache.openjpa.kernel.BrokerImpl.lock(BrokerImpl.java:4168)
     [java]     at org.apache.openjpa.kernel.BrokerImpl.beginOperation(BrokerImpl.java:1770)
     [java]     at org.apache.openjpa.kernel.BrokerImpl.isActive(BrokerImpl.java:1742)
     [java]     at org.apache.openjpa.kernel.StateManagerImpl.beforeRead(StateManagerImpl.java:964)
     [java]     at org.apache.openjpa.kernel.StateManagerImpl.accessingField(StateManagerImpl.java:1501)
     [java]     at model.A.getAItems(A.java)
     [java]     at model.ADirtyListener.beforeDirty(ADirtyListener.java:24)
     [java]     at org.apache.openjpa.event.LifecycleEventManager.fireEvent(LifecycleEventManager.java:423)
     [java]     at org.apache.openjpa.event.LifecycleEventManager.fireEvent(LifecycleEventManager.java:289)
     [java]     - locked <0x51b4e4b0> (a org.apache.openjpa.event.LifecycleEventManager)
     [java]     at org.apache.openjpa.kernel.BrokerImpl.fireLifecycleEvent(BrokerImpl.java:693)
     [java]     at org.apache.openjpa.kernel.StateManagerImpl.fireLifecycleEvent(StateManagerImpl.java:364)
     [java]     at org.apache.openjpa.kernel.StateManagerImpl.dirty(StateManagerImpl.java:1596)
     [java]     at org.apache.openjpa.kernel.StateManagerImpl.dirty(StateManagerImpl.java:1539)
     [java]     at org.apache.openjpa.util.Proxies.dirty(Proxies.java:66)
     [java]     at org.apache.openjpa.util.ProxyCollections.beforeAdd(ProxyCollections.java:57)
     [java]     at org.apache.openjpa.util.java$util$HashSet$proxy.add(Unknown Source)
     [java]     at business.Test$2.run(Test.java:80)
     [java]     at java.lang.Thread.run(Thread.java:595)

     [java] ""Thread-0"" prio=1 tid=0x09e9d010 nid=0x7fcb waiting for monitor entry [0xb1674000..0xb1674db0]
     [java]     at org.apache.openjpa.event.LifecycleEventManager.fireEvent(LifecycleEventManager.java:272)
     [java]     - waiting to lock <0x51b4e4b0> (a org.apache.openjpa.event.LifecycleEventManager)
     [java]     at org.apache.openjpa.kernel.BrokerImpl.fireLifecycleEvent(BrokerImpl.java:693)
     [java]     at org.apache.openjpa.kernel.StateManagerImpl.fireLifecycleEvent(StateManagerImpl.java:364)
     [java]     at org.apache.openjpa.kernel.StateManagerImpl.clearFields(StateManagerImpl.java:2647)
     [java]     at org.apache.openjpa.kernel.StateManagerImpl.beforeRefresh(StateManagerImpl.java:1239)
     [java]     at org.apache.openjpa.kernel.BrokerImpl.refreshInternal(BrokerImpl.java:2835)
     [java]     at org.apache.openjpa.kernel.BrokerImpl.refresh(BrokerImpl.java:2781)
     [java]     at org.apache.openjpa.kernel.DelegatingBroker.refresh(DelegatingBroker.java:1078)
     [java]     at org.apache.openjpa.persistence.EntityManagerImpl.refresh(EntityManagerImpl.java:694)
     [java]     at business.Test$1.run(Test.java:64)
     [java]     at java.lang.Thread.run(Thread.java:595)
====

Intially the problem is reproduced on OpenJPA 1.x. But,
I verified the problem could be reproduced with latest 
OpenJPA head.
",Linux x86,,,,,,,,,,,,,,,,,,,,,09/Feb/09 06:57;hiroki.tateno;proposed-fix.patch;https://issues.apache.org/jira/secure/attachment/12399796/proposed-fix.patch,09/Feb/09 06:53;hiroki.tateno;testcase.zip;https://issues.apache.org/jira/secure/attachment/12399795/testcase.zip,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161212,,,Mon Mar 16 09:37:21 UTC 2009,,,,,,,0|i0z5cf:,203168,,,,,,,,"09/Feb/09 06:53;hiroki.tateno;I uploaded a simple testcase testcase.zip.

====
step by step test procedure)
1. update database configuration in persistence.xml
2. run ""ant test""
====
","09/Feb/09 06:57;hiroki.tateno;Also, I attached possible fix of the issue.
The root cause of the issue is sometimes BrokerImpl.fireLifecycleEvent
is called without BrokerImpl lock. So, I added lock()/unlock() to 
BrokerImpl.fireLifecycleEvent. It may be overkill fix. If it's overkill,
it's better that adding broker.lock()/broker.unlock() to around
calling fireLifecycleEvent() in StateManagerImpl.dirty().
","16/Mar/09 09:37;hiroki.tateno;Abe's change resolved the issue.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Potential NPE in setInverseRelation,OPENJPA-912,12414319,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,fancy,fancy,08/Feb/09 01:33,23/Feb/09 16:50,14/Mar/19 03:02,23/Feb/09 16:50,1.2.0,1.2.1,1.3.0,2.0.0-M1,2.0.0-M2,,,,,1.2.1,1.3.0,2.0.0-M2,,,jdbc,,,,,,0,,,,,,,,,,,,,,,,,,OPENJPA-925,,,,,,19/Feb/09 19:56;drwoods;OPENJPA-912-branches12x.patch;https://issues.apache.org/jira/secure/attachment/12400546/OPENJPA-912-branches12x.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-02-19 18:15:08.613,,,no_permission,,,,,,,,,,,161211,,,Mon Feb 23 16:50:46 UTC 2009,,,,,,,0|i0z78f:,203474,,,,,,,,"08/Feb/09 01:47;fancy;fix checked in trunk r741994, 
 1.3.x r741995",19/Feb/09 18:15;drwoods;adding missing Fix Version values,"19/Feb/09 18:15;drwoods;This also needs to be applied to branches/1.2.x, as it is related to OPENJPA-925.","19/Feb/09 18:29;fancy;For tacking purpose, documenting the NPE  in JDBCStoreManager.setInverseRelation().

TestCase : TestChainEntities.testChainEntities

&lt;openjpa-2.0.0-SNAPSHOT-r422266:740991 nonfatal general error&gt; org.apache.openjpa.persistence.PersistenceException: null
at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:968)
at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:862)
at org.apache.openjpa.kernel.DelegatingBroker.find(DelegatingBroker.java:201)
at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:459)
at org.apache.openjpa.persistence.relations.TestChainEntities.getA(TestChainEntities.java:94)
at org.apache.openjpa.persistence.relations.TestChainEntities.chainUpdate(TestChainEntities.java:55)
at org.apache.openjpa.persistence.relations.TestChainEntities.testChainEntities(TestChainEntities.java:50)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:585)
at junit.framework.TestCase.runTest(TestCase.java:154)
at junit.framework.TestCase.runBare(TestCase.java:127)
at org.apache.openjpa.persistence.test.PersistenceTestCase.runBare(PersistenceTestCase.java:443)
at junit.framework.TestResult$1.protect(TestResult.java:106)
at junit.framework.TestResult.runProtected(TestResult.java:124)
at junit.framework.TestResult.run(TestResult.java:109)
at junit.framework.TestCase.run(TestCase.java:118)
at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:173)
at junit.framework.TestSuite.runTest(TestSuite.java:208)
at junit.framework.TestSuite.run(TestSuite.java:203)
at sun.reflect.GeneratedMethodAccessor45.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:585)
at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:585)
at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:334)
at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:980)
Caused by: java.lang.NullPointerException
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.setInverseRelation(JDBCStoreManager.java:395)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:366)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:264)
at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:987)
at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:945)
... 33 more
","19/Feb/09 19:56;drwoods;NPE patch ported from Trunk to 1.2.x, as suggested by Catalina in connection to the OPENJPA-925 patch.
","19/Feb/09 19:56;drwoods;Michael, please review and consider applying to branches/1.2.x.  Thanks.","19/Feb/09 20:39;mikedd;I've never seen this failure in 1.2.x, TestChainEntities is working as is at the moment. Is there another change that might be in trunk & 1.3.x which exposed this behavior? 

I see where the NPE is possible, but I'd expect that to be deterministic behavior. If it's intermittent I'd like to know more about what causes it in Catalina's environment that I can't reproduce locally. ",23/Feb/09 16:50;drwoods;Applied to 1.2.x.  Thanks Mike.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
hints don't work for NamedNativeQuery,OPENJPA-898,12414027,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,maojianfeng,maojianfeng,04/Feb/09 19:16,09/Mar/10 18:31,14/Mar/19 03:02,01/Mar/09 21:06,1.2.0,,,,,,,,,1.3.0,2.0.0-M2,,,,,,,,,,0,,"Hints defined for a named native query such as the one below don't get loaded, however, if changed it to @NamedQuery, the hints get loaded.
 
          @NamedNativeQuery(name=""GetMemberInfo"",
		query=""CALL MEMBERSUB"",
		hints= {
			@QueryHint(name=""openjpa.hint.u2sub.numberofpara"", value=""2""),
			@QueryHint(name=""openjpa.hint.u2sub.output.para"", value =""2"")
			}
		)",,,,,,,,,,,,,,,,,,,,,,23/Feb/09 18:09;drwoods;OPENJPA-898-branches10x.patch;https://issues.apache.org/jira/secure/attachment/12400781/OPENJPA-898-branches10x.patch,23/Feb/09 18:06;drwoods;OPENJPA-898-branches12x.patch;https://issues.apache.org/jira/secure/attachment/12400777/OPENJPA-898-branches12x.patch,23/Feb/09 18:08;drwoods;OPENJPA-898-branches13x.patch;https://issues.apache.org/jira/secure/attachment/12400780/OPENJPA-898-branches13x.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2009-02-11 08:13:57.314,,,no_permission,,,,,,,,,,,161198,,,Sun Mar 01 21:06:55 UTC 2009,,,,,,,0|i0yxef:,201881,,,,,,,,11/Feb/09 08:13;ppoddar@apache.org;Can you run the test with latest change and confirm if the hints are avaialble with NamedNativeQuery,11/Feb/09 17:35;drwoods;adding target Fix Versions,"23/Feb/09 16:47;drwoods;Mike, please consider for the 1.2.x branch.",23/Feb/09 18:06;drwoods;Two line addition to trunk back ported to 1.2.x for easier patching.,23/Feb/09 18:08;drwoods;patch for 1.3.x,23/Feb/09 18:09;drwoods;patch for 1.0.x,"01/Mar/09 21:06;mikedd;Some of the users of the 1.2.x and 1.0.x are conservative about changes, especially without a testcase. For now we'll resolve this issue in the released branches only. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Several source files include Windows EoL chars,OPENJPA-896,12414006,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,mikedd,drwoods,drwoods,04/Feb/09 16:39,09/Mar/10 18:31,14/Mar/19 03:02,22/Mar/09 23:57,1.0.3,1.1.0,1.2.0,,,,,,,1.0.4,1.2.2,1.3.0,2.0.0-M2,,docs,,,,,,0,,"Several of the doc files include the Windows Ctrl+M chars at the end of lines when checked out to non-Windows platforms (like MacOSX and Linux), due to the committer not using the ASF suggested svn config values - http://www.apache.org/dev/svn-eol-style.txt


From http://www.apache.org/dev/version-control.html -
Configuring the Subversion client

Committers will need to properly configure their svn client. One particular issue is OS-specific line-endings for text files. When you add a new text file, especially when applying patches from Bugzilla, first ensure that the line-endings are appropriate for your system, then do ...

svn add test.txt
svn propset svn:eol-style native test.txt

Your svn client can be configured to do that automatically for some common file types. Add the contents of the file http://www.apache.org/dev/svn-eol-style.txt to your ~/.subversion/config file. [Note: for Windows this is normally found at C:\Documents and Settings\{username}\Application Data\Subversion\config]

Some files may need additional properties to be set, for example svn:executable=* should be applied to those script files (e.g. .bat, .cgi, .cmd, .sh) that are intended to be executed. Since not all such files are necessarily intended to be executed, the executable property should not be made an automatic default.

However, you should still pay attention to the messages from your svn client when you do 'svn commit'.
",,,,,,,,,,,,,,,,,,,,,,04/Feb/09 22:40;drwoods;OPENJPA-896-trunk-withprops.patch;https://issues.apache.org/jira/secure/attachment/12399489/OPENJPA-896-trunk-withprops.patch,04/Feb/09 19:00;drwoods;OPENJPA-896-trunk.patch;https://issues.apache.org/jira/secure/attachment/12399471/OPENJPA-896-trunk.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-02-27 15:14:07.834,,,no_permission,,,,,,,,,,,161196,,,Sun Mar 22 23:57:02 UTC 2009,,,,,,,0|i1dran:,288519,,,,,,,,"04/Feb/09 19:00;drwoods;Patch file which removes the Windows Ctrl+M EOL chars.
For Windows users, you can use a program like SlickEdit to resave the files in Unix format (and fix your svn config.)
For Unix/Linux users, use the ""dos2unix *.xml"" command.
For Mac users, you need to provide a dos2unix script that uses the tr command -
{noformat}
#! /bin/sh
for x
do
echo ""Converting $x""
tr -d '\015' < ""$x"" > ""$x.tmp""
mv ""$x.tmp"" ""$x""
done
{noformat}",04/Feb/09 22:40;drwoods;Updated patch <OPENJPA-896-trunk-withprops.patch> that fixes the EOL chars and includes adding the svn:eol-style=native on the xml and xsl files.,"04/Feb/09 22:42;drwoods;You can manually add the svn props after applying the first patch <OPENJPA-896-trunk.patch> by:
{noformat}
cd openjpa-project/src/doc/manual
svn propset svn:eol-style native *.xml
svn propset svn:eol-style native *.xsl
{noformat}
","27/Feb/09 15:14;mikedd;Per Don's email to the dev mailing list several java files also contain windows eol characters. Unless someone disagrees I think we should use a single JIRA issue to resolve both problems. 

I'm not sure why I don't see the problem when running svn diff on linux, but I see how this can be a pain for those who do.

Proposed solution execute these commands on all .xml, .java files in the source tree
  svn propset  svn:eol-style native 
  dos2unix

Per conversation on the dev mailing list this is acceptable provided we do it in a single big commit (ie no functional changes).

If this approach is not sufficient or anyone disagrees that we should do this please comment here. ","27/Feb/09 21:10;techhusky;+1 use a single JIRA.

+1 we do it in a single big commit (ie no functional changes)

If the change is made, can you (Donald) inform folks on how to setup their environment so that we don't end up back in the same state in the future?  Commits to existing files are not typically an issue, but new files using Windows eol's may get committed without proper setup.  I've probably committed a few, myself.  :-)","22/Mar/09 23:57;mikedd;Sounded like enough committers thought this was safe so I went ahead and ran a script to convert eol characters

The script  does : 
svn propset svn:eol-style native ${file}
dostounix ${file}

For every .java or .xml file in the source tree. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Typos and inconsistent method signature styles in the user manual,OPENJPA-890,12413816,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,drwoods,drwoods,drwoods,02/Feb/09 21:31,09/Mar/10 18:31,14/Mar/19 03:02,29/Jul/09 20:36,1.0.3,1.1.0,1.2.0,2.0.0-M1,2.0.0-M2,,,,,2.0.0-M3,,,,,docs,,,,,,0,,"While reviewing the User's Guide, I noticed: 1) some words were missing from sentences, 2) there was inconsistent usage of spacing when documenting method signatures, 3) some of the example code fragments had typos, ...
",,,,,,,,,,,,,,,,OPENJPA-896,,,,,,04/Feb/09 18:27;drwoods;OPENJPA-890-trunk-typos.patch;https://issues.apache.org/jira/secure/attachment/12399469/OPENJPA-890-trunk-typos.patch,04/Feb/09 18:55;drwoods;OPENJPA-890-trunk-whitespace.patch;https://issues.apache.org/jira/secure/attachment/12399470/OPENJPA-890-trunk-whitespace.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,38477,,,Wed Jul 29 20:36:32 UTC 2009,,,Patch Available,,,,0|i1drbj:,288523,,,,,,,,04/Feb/09 18:27;drwoods;Minor rewording and example code typo fixes for trunk.,04/Feb/09 18:55;drwoods;Optional patch to cleanup the whitespace around method signatures and called methods to match the standard Java and Eclipse formatter profiles in Eclipse Ganymede.,"04/Feb/09 19:08;drwoods;Unassigning, so a committer can grab it.",29/Jul/09 20:36;drwoods;Applied to trunk as Rev799063 and 799064.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Assertion oversight in TestLibService,OPENJPA-887,12413724,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,milosz,milosz,milosz,01/Feb/09 15:01,09/Mar/10 18:31,14/Mar/19 03:02,28/Mar/09 14:58,1.3.0,2.0.0-M1,2.0.0-M2,,,,,,,1.3.0,2.0.0-M2,,,,,,,,,,0,,"There is a small but quite nasty oversight in TestLibService class:

assertNotNull(""could not find the reference from "" + bName + ""'s volunteer status back to "" + bName, volunteer.getBorrower() == borrower);

I suspect the intention was to have assertTrue(...).  The above compiles because of autoboxing creating a Boolean but the assertion is always true, even if volunteer.getBorrower() != borrower.
",,,,,,,,,,,,,,,,,,,,,,01/Feb/09 15:03;milosz;OPENJPA-887.patch;https://issues.apache.org/jira/secure/attachment/12399237/OPENJPA-887.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-03-31 20:37:39.08,,,no_permission,,,,,,,,,,,161188,,,Wed Apr 01 15:08:16 UTC 2009,,,,,,,0|i1drc7:,288526,,,,,,,,01/Feb/09 15:03;milosz;The patch is attached.,"28/Mar/09 14:58;milosz;The patch applied to trunk and 1.3.x branch.

I am sorry the trunk commit went without message - I made a kind of ""do-it-first-time"" mistake. The trunk revision is 759470.
","31/Mar/09 20:37;mikedd;No worries Milosz. I've gone ahead and corrected the svn log settings for both releases. 

FWIW you can do this by running the following commands : 

$ svn ps -r 759470 --revprop svn:log ""OPENJPA-887"" https://svn.apache.org/repos/asf/openjpa/trunk

$ svn ps -r 759473 --revprop svn:log ""OPENJPA-887"" https://svn.apache.org/repos/asf/openjpa/branches/1.3.x/

The SVN FAQ has complete documentation at http://subversion.tigris.org/faq.html#change-log-msg.

Obviously you're not the first to do this ;-)
","01/Apr/09 15:08;milosz;Thanks, Mike. I was aware of this ""revert property"" feature but was not sure whether I should use this.

Actually, only trunk commit was without a message, the 1.3.x commit had a message but it does not matter now.


",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Certain query failing after svn:739123,OPENJPA-886,12413662,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,,fern,fern,30/Jan/09 22:18,09/Mar/10 18:31,14/Mar/19 03:02,23/Feb/09 15:00,2.0.0-M2,,,,,,,,,2.0.0-M1,2.0.0-M2,,,,kernel,,,,,,0,,"We were using the nightly snapshot builds, then this morning our app stopped working.  A certain query ( it looks quite normal to me ), fails, and we have no clue what's going on.

The stack trace is below.  It complains that a parameter type is not allowed, even though it has been working until that check-in.  And the type is a normal Entity, related through a ManyToOne relationship from the other class.. The class code excerpts are below as well..



2009-01-30 11:43:31,349 [btpool0-1] DEBUG openjpa.Query - Executing query: [SELECT t0.JDOID, t0.CREATETIME, t0.BRACKET_JDOID, t0.GROUP0, t0.USER_JDOID FROM BRACKETEER t0 WHERE (t0.GROUP0 = ? AND t0.USER_JDOID = ?)] with parameters: {1=com.protrade.bracket.data.entities.User@b1406b[
  fbId=578696943
  appAdded=false
  recruiter=<null>
  numMinibrackets=0
  numBrackets=0
  createTime=1233343722122
  idLong=9000
  jdoId=<null>
  jdoversion=0
], 0=<<BracketGroupId:BracketGroup:32>>} 
2009-01-30 11:28:42,483 [btpool0-2] ERROR com.protrade.bracket.fbsite.filters.AppSubscriptionHandler - The specified parameter of type ""class com.protrade.bracket.data.entities.User"" is not a valid query parameter.
<openjpa-2.0.0-SNAPSHOT-r422266:739178 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: The specified parameter of type ""class com.protrade.bracket.data.entities.User"" is not a valid query parameter.
    at org.apache.openjpa.jdbc.sql.DBDictionary.setUnknown(DBDictionary.java:1354)
    at org.apache.openjpa.jdbc.kernel.SQLStoreQuery$SQLExecutor.executeQuery(SQLStoreQuery.java:314)
    at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:997)
    at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:846)
    at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:777)
    at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:525)
    at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:274)
    at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:284)
    at com.protrade.common.persistence.JPAUtil.execute(JPAUtil.java:195)
    at com.protrade.common.persistence.JPAUtil.execute(JPAUtil.java:170)
    at com.protrade.common.persistence.JPAUtil.executeList(JPAUtil.java:155)
    at com.protrade.common.persistence.JPADQuery.list(JPADQuery.java:24)
    at com.protrade.common.persistence.BaseRootDAOBase.runListQueryWithListNCS(BaseRootDAOBase.java:272)
    at com.protrade.common.persistence.BaseRootDAOBase.findByFieldsNCS(BaseRootDAOBase.java:199)
    at com.protrade.common.persistence.BaseRootDAOBase.existsByFieldsNCS(BaseRootDAOBase.java:236)
    at com.protrade.common.persistence.BaseDAOBase.existsByFieldsNCS(BaseDAOBase.java:144)
    at com.protrade.bracket.data.BracketDao.isBracketeer(BracketDao.java:152) 



@Entity
public class Bracketeer extends HBaseIdCreateTime implements IBracketeer {
...
    @Persistent
    @Externalizer( ""getIdLong"" )
    private BracketGroupId group;


    @ManyToOne
    @JoinColumn( name = ""USER_JDOID"" )
    private User user;
...
}

@Entity
public class User extends HBaseIdCreateTime implements UnifiedSocialUser {
...
} 


",,,,,,,,,,,,,,,,OPENJPA-703,,,,,,01/Feb/09 23:02;fancy;TestSetParameter.java;https://issues.apache.org/jira/secure/attachment/12399253/TestSetParameter.java,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-02-01 23:02:24.881,,,no_permission,,,,,,,,,,,161187,,,Sun Feb 01 23:02:24 UTC 2009,,,,,,,0|i0yvrj:,201616,,,,,,,,"30/Jan/09 22:21;fern;Catalina Wei commented that the stacktrace looked to be using a SQL query instead of a JPQL query ( which is what our code is expecting to use ).  So I can only guess that the large checkin at svn:739123, might have a typo, that is executing the wrong code path.

I am sorry, but I don't have the JPQL query at the moment.. though I have logging turned up to TRACE, openjpa didn't seem to print it out..

but it's really straight forward.. something like (psedo code) ""select * from ...Braketeer as this where this.group = :p0 and this.user = :p1""
","01/Feb/09 23:02;fancy;Pinaki,
The attached file contains a simple query string that could help you debugging the problem:

        String query = ""UPDATE CompUser e set e.name= ?1, e.age = ?2 WHERE e.userid = ?3"";
  
        int count = em.createQuery(query).
            setParameter(1, ""Shannon"").
            setParameter(2, 29).
            setParameter(3, userid2).
            executeUpdate();

You could add  a version column to CompUser entity for non-user parameter.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Logging oversight in DB2Dictionary,OPENJPA-884,12413623,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,mikedd,milosz,milosz,30/Jan/09 14:38,09/Mar/10 18:31,14/Mar/19 03:02,01/Mar/09 20:10,1.2.0,1.2.1,1.3.0,2.0.0-M1,2.0.0-M2,,,,,1.3.0,2.0.0-M2,,,,logging,,,,,,0,,"There is a small oversight in DB2Dictionary - there is a check whether TRACE level is enabled and then an exception is logged on ERROR level.
",,,,,,,,,,,,,,,,,,,,,,30/Jan/09 14:40;milosz;OPENJPA-884.patch;https://issues.apache.org/jira/secure/attachment/12399131/OPENJPA-884.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-02-04 13:38:45.874,,,no_permission,,,,,,,,,,,161185,,,Thu Feb 05 16:45:07 UTC 2009,,,,,,,0|i1drcf:,288527,,,,,,,,30/Jan/09 14:40;milosz;The patch fixes the logging issue and also corrects a few typos in comments and access to static constants.,"04/Feb/09 13:38;mikedd;I think the intent was actually to use trace level logging. We're reporting an error, but one that we can recover from. The method doesn't re-throw the exception and the original intent appears to be just to recover silently. Still it's not obvious what the intent is and it needs to be fixed. 

Good catch Milosz","05/Feb/09 14:38;milosz;Yes, using the trace level should also be acceptable.

On the other hand, I had another look at this and could not see any reasonable exception being thrown. So now I am in favor of removing this try/catch completely, at least in the trunk.

Unfortunately this piece of code is too old too have its history in the SVN.
","05/Feb/09 15:30;mikedd;I noticed the same thing about history in SVN. This code was added when OpenJPA was in the incubator. If the incubator's svn repository is still available we could probably find it there. 

I think I agree with you regarding removing the try / catch. Seems to me if we can't detect the version of DB2 we'd want to fail early rather than having an empty forUpdateClause. 

Catalina, do you have a recommendation? You've done a lot of work with DB2 and might remember when this code was added. ","05/Feb/09 16:45;fancy;Milosz & Mike, 
That  try/catch block seems unnecessary. I am OK with removing that try/catch.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Documentation is out of date for some MySQLDictionary properties,OPENJPA-883,12413618,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,milosz,milosz,milosz,30/Jan/09 13:43,09/Mar/10 18:31,14/Mar/19 03:02,02/Apr/09 19:10,1.2.0,1.2.1,1.3.0,2.0.0-M1,2.0.0-M2,,,,,1.3.0,2.0.0-M2,,,,docs,,,,,,0,,"After the changes made in OPENJPA-564, the javadoc and manual have not been updated. The ""useClobs"" property has incorrect javadoc and its section in the manual. The section in the manual for the ""driverDeserializesBlobs"" property is also a bit misleading.",,,,,,,,,,,,,,,,OPENJPA-564,,,,,,30/Jan/09 13:47;milosz;OPENJPA-883.patch;https://issues.apache.org/jira/secure/attachment/12399127/OPENJPA-883.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161184,,,Thu Apr 09 19:41:54 UTC 2009,,,,,,,0|i1drcn:,288528,,,,,,,,30/Jan/09 13:47;milosz;The patch brings javadoc and the manual up to date.,"02/Apr/09 19:10;milosz;The patch applied to trunk and 1.3.x branch.
","09/Apr/09 19:41;milosz;Also changed the out-dated paragraph about MySQL and sub-selects in the manual.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@MappedSuperClass Cause Null Pointer Exception in Class With IdClass,OPENJPA-873,12413299,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,26/Jan/09 19:05,09/Mar/10 18:31,14/Mar/19 03:02,04/Feb/09 17:30,1.2.0,,,,,,,,,1.0.4,1.2.2,1.3.0,2.0.0-M2,,,,,,,,0,,"This JIRA is open on behalf of pioneer_ip@yahoo.com.

@MappedSuperclass
public abstract class CashBaseEntity extends BaseEntity{
@Column(name=""TRCCRUI"")
          private String createUser;
         
          @Column(name=""TRCCRTS"")
          private Date createTime;
         
          @Column(name=""TRCLUUID"")
          private String updateUser;
         
          @Column(name=""TRCLUTS"")
          private Date updateTime;
         
          @Version
          @Column(name=""TRCVER"")
          private int version;
//getter setter ....removed ..for short post

    }


@Entity
@Table (  name = ""cc2SITUATION"")
@IdClass(SituationDA.SituationId.class)
public class SituationDA extends CashBaseEntity{
   
    @Id
    @Column(name=""C2008SRL"")
    private String CashBoxPeriodSerial;
   
    @Id
    @Column(name=""C2012TYPE"")
    private short Type;

    public static class SituationId implements Serializable{
        private static final long serialVersionUID = 1L;
        public String CashBoxPeriodSerial;
        public short Type;
       
        public SituationId(){
           
        }
       
        public boolean equals(Object other){
            if (other instanceof SituationId) {
                final SituationId otherId = (SituationId)other;
                return ( otherId.CashBoxPeriodSerial.equals(this.CashBoxPeriodSerial) &&
otherId.Type == this.Type );
                }
                return false;   
        }
       
        public int hashCode() {
            return super.hashCode();
        }
    }
//getter setter removed for short post..
}

@Entity
@Table (name = ""CF2VLUITEM"")
public class ValuableItemDA extends CashBaseEntity{
    @Id
    @Column(name=""C2001COD"")
    private short Code;

//getter setter removed for short post..

}


Exception in thread ""main"" java.lang.NullPointerException
    at org.apache.openjpa.meta.ClassMetaData.validateAppIdClass(ClassMetaData.java:1883)
    at org.apache.openjpa.meta.ClassMetaData.validateIdentity(ClassMetaData.java:1840)
    at org.apache.openjpa.meta.ClassMetaData.validateMeta(ClassMetaData.java:1757)
    at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1630)
    at org.apache.openjpa.meta.MetaDataRepository.processBuffer(MetaDataRepository.java:717)
    at org.apache.openjpa.meta.MetaDataRepository.resolveMeta(MetaDataRepository.java:616)
    at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:541)
    at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:308)
    at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:249)
    at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:4502)
    at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:4449)
    at org.apache.openjpa.enhance.PCEnhancer$1.run(PCEnhancer.java:4419)
    at org.apache.openjpa.lib.conf.Configurations.launchRunnable(Configurations.java:726)
    at org.apache.openjpa.lib.conf.Configurations.runAgainstAllAnchors(Configurations.java:716)
    at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:4414)
    at org.apache.openjpa.enhance.PCEnhancer.main(PCEnhancer.java:4405)

",,,,,,,,,,,,,,,,,,,,,,08/Jun/09 18:12;fyrewyld;OPENJPA-873_1.0.x.patch;https://issues.apache.org/jira/secure/attachment/12410150/OPENJPA-873_1.0.x.patch,22/Jun/09 17:27;fyrewyld;OPENJPA-873_1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12411429/OPENJPA-873_1.2.x.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-01-27 16:23:43.19,,,no_permission,,,,,,,,,,,161174,,,Mon Jun 22 18:05:12 UTC 2009,,,,,,,0|i0z2nb:,202731,,,,,,,,26/Jan/09 20:26;faywang;fix is commited r737814 (openjpa-1.3.x) and r737816 (openjpa trunk).,27/Jan/09 16:23;mikedd;Reopening. Testcase needed. ,"04/Feb/09 17:29;faywang;Test cases are checked into trunk r-740802, and openjpa1.3.x r-740804.",08/Jun/09 18:12;fyrewyld;Patch for OpenJPA 1.0.x,22/Jun/09 17:27;fyrewyld;Patch for OpenJPA 1.2.x.,22/Jun/09 18:05;mikedd;Applied patches for 1.0.x and 1.2.x. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compound custom id in bidirectional many-to-one,OPENJPA-872,12413221,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,techhusky,dblevins,dblevins,26/Jan/09 07:12,09/Mar/10 18:31,14/Mar/19 03:02,26/Jan/09 16:25,1.2.0,,,,,,,,,1.2.1,1.3.0,2.0.0-M2,,,,,,,,,0,,"It seems that the order of parameters filled into the SQLBuffer are getting mixed.  Seeing this with a bidirectional many-to-one where the owning side uses a compound primary key resulting in a compound foreign key.  When the owning side's collection is loaded the sql is correctly generated with the foreign keys in the where clause but the values are not passed in the correct order.  There is clearly great care taken in regards to order when the sql string SQLBuffer is getting filled in, but there seems to be a second pass where the parameter values are collected and the order in this case *appears* to be alphabetical.  I.e. the two values in the compound key are ""id"" and ""brandname"", if ""brandname"" is renamed to ""zbrandname"" the test will consistently pass.

Caused by: <openjpa-1.2.0-r422266:683325 nonfatal store error> org.apache.openjpa.util.StoreException: Wrong data type: java.lang.NumberFormatException: For input string: ""Red""
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4238)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4203)
	at org.apache.openjpa.jdbc.sql.HSQLDictionary.newStoreException(HSQLDictionary.java:292)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:88)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:64)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:632)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:2920)
	at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:2998)
	at org.apache.openjpa.kernel.StateManagerImpl.fetchObjectField(StateManagerImpl.java:2241)
	at org.apache.openjpa.kernel.StateManagerImpl.fetchField(StateManagerImpl.java:777)
	at org.apache.openjpa.kernel.StateManagerImpl.fetch(StateManagerImpl.java:739)
	at org.apache.openjpa.enhance.RedefinitionHelper$1.invoke(RedefinitionHelper.java:230)
	at $Proxy20.size(Unknown Source)
	at org.superbiz.customid.TestBean.tx2(TestBean.java:55)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.openejb.core.interceptor.ReflectionInvocationContext$Invocation.invoke(ReflectionInvocationContext.java:158)
	at org.apache.openejb.core.interceptor.ReflectionInvocationContext.proceed(ReflectionInvocationContext.java:141)
	at org.apache.openejb.core.interceptor.InterceptorStack.invoke(InterceptorStack.java:122)
	at org.apache.openejb.core.stateless.StatelessContainer._invoke(StatelessContainer.java:211)
	at org.apache.openejb.core.stateless.StatelessContainer.invoke(StatelessContainer.java:169)
	at org.apache.openejb.core.ivm.EjbObjectProxyHandler.businessMethod(EjbObjectProxyHandler.java:217)
	at org.apache.openejb.core.ivm.EjbObjectProxyHandler._invoke(EjbObjectProxyHandler.java:77)
	at org.apache.openejb.core.ivm.BaseEjbProxyHandler.invoke(BaseEjbProxyHandler.java:286)
	... 25 more
Caused by: java.sql.SQLException: Wrong data type: java.lang.NumberFormatException: For input string: ""Red""
	at org.hsqldb.jdbc.Util.throwError(Unknown Source)
	at org.hsqldb.jdbc.jdbcPreparedStatement.setParameter(Unknown Source)
	at org.hsqldb.jdbc.jdbcPreparedStatement.setString(Unknown Source)
	at org.apache.commons.dbcp.DelegatingPreparedStatement.setString(DelegatingPreparedStatement.java:132)
	at org.apache.commons.dbcp.DelegatingPreparedStatement.setString(DelegatingPreparedStatement.java:132)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.setString(DelegatingPreparedStatement.java:309)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.setString(LoggingConnectionDecorator.java:990)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.setString(DelegatingPreparedStatement.java:309)
	at org.apache.openjpa.jdbc.sql.DBDictionary.setString(DBDictionary.java:1097)
	at org.apache.openjpa.jdbc.sql.DBDictionary.setUnknown(DBDictionary.java:1298)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.setParameters(SQLBuffer.java:630)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:529)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:485)
	at org.apache.openjpa.jdbc.sql.SelectImpl.prepareStatement(SelectImpl.java:463)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:379)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:339)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:420)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:230)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:220)
	at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.load(StoreCollectionFieldStrategy.java:599)
	at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:819)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:626)
	... 47 more

Here's a snapshot of the SelectImp instance just after it is built:

	• this = {org.apache.openjpa.jdbc.sql.SelectImpl@8556}""SELECT t0.ID, t0.QUANTITY FROM LINEITEM t0 WHERE t0.FK_FOR_ID = ? AND t0.FK_FOR_BRANDNAME = ?""
	• mapping = {org.apache.openjpa.jdbc.meta.ClassMapping@8381}""org.superbiz.customid.Invoice""
	• toCols = {org.apache.openjpa.jdbc.schema.Column[2]@8382}
	• [0] = {org.apache.openjpa.jdbc.schema.DynamicSchemaFactory$DynamicColumn@8409}""BRANDNAME""
	• [1] = {org.apache.openjpa.jdbc.schema.DynamicSchemaFactory$DynamicColumn@8425}""ID""
	• fromCols = {org.apache.openjpa.jdbc.schema.Column[2]@8382}
	• [0] = {org.apache.openjpa.jdbc.schema.DynamicSchemaFactory$DynamicColumn@8409}""BRANDNAME""
	• [1] = {org.apache.openjpa.jdbc.schema.DynamicSchemaFactory$DynamicColumn@8425}""ID""
	• oid = {org.apache.openjpa.util.ObjectId@8383}""org.superbiz.customid.Invoice-org.superbiz.customid.InvoiceKey@c412bd2""
	• store = {org.apache.openjpa.jdbc.kernel.JDBCStoreManager@8373}
	• pj = null
	• buf = null
	• parmList = {java.util.ArrayList@8720} size = 0
	• collectParmValueOnly = true
	• pks = {java.lang.Object[2]@8790}
	• [0] = {java.lang.String@8413}""Red""
	• [1] = {java.lang.Integer@8429}""1""
	• toCols.length = 2 

Note the primary key values are in the incorrect order for the way the sql statement was built.  Later when setParameters is called:

	• this = {org.apache.openjpa.jdbc.sql.SQLBuffer@7747}
	• ps = {org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement@7752}""prepstmnt 7374346 SELECT t0.ID, t0.QUANTITY FROM LINEITEM t0 WHERE t0.FK_FOR_ID = ? AND t0.FK_FOR_BRANDNAME = ?""
	• cacheParams = {java.util.ArrayList@7753} size = 2
	• [0] = {java.lang.String@7648}""Red""
	• [1] = {java.lang.Integer@7652}""1""
	• _params = {java.util.ArrayList@7754} size = 2
	• [0] = {java.lang.Integer@7652}""1""
	• [1] = {java.lang.String@7648}""Red"" 

The interesting thing is that the value of _params is correct and matches the sql.  For some reason there ",,,,,,,,,,,,,,,,,,,,,,26/Jan/09 07:16;dblevins;jpa-customid.tar.gz;https://issues.apache.org/jira/secure/attachment/12398716/jpa-customid.tar.gz,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-01-26 16:25:55.383,,,no_permission,,,,,,,,,,,161173,,,Tue Feb 03 23:11:37 UTC 2009,,,,,,,0|i0yvmv:,201595,,,,,,,,26/Jan/09 07:16;dblevins;Attached is a test case for representing the issue.  It leverages openejb for simplicity in the setup department.  Should be no problem to rework it to standalone jpa.,"26/Jan/09 16:25;techhusky;David,

Thanks for the excellent test case and failure documentation.  As Kevin suspected, this problem is/was related to QuerySQLCache.  This problem was fixed in OPENJPA-838, revision 728758 of 1.2.x  (1.2.1-SNAPSHOT).  Either changing your pom to include the 1.2.1-SNAPSHOT or adding this property:

          <property name=""openjpa.jdbc.QuerySQLCache"" value=""false""/>

to your persistence.xml will correct the problem.","03/Feb/09 23:11;ppoddar@apache.org;1. With new Prepared Query Cache, this example works both for find() as well as query.

2. Prepared Query Cache is available since  SVN revision 740208.

3. OPENJPA-703 is tracking the development of this new Prepared Query Cache. 

4. This cache is active by default. 
    It can be switched off as above
           <property name=""openjpa.jdbc.QuerySQLCache"" value=""false""/> 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unexpected Behaviour of DBDictionary.indexOf() method,OPENJPA-867,12413100,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,milosz,alan_raison,alan_raison,23/Jan/09 15:37,02/Feb/12 16:25,14/Mar/19 03:02,29/Aug/11 20:13,1.2.0,2.0.0-M2,,,,,,,,2.2.0,,,,,sql,,,,,,0,,"There is potentially unexpected behaviour of the indexOf method of the DBDictionary class (org.apache.openjpa.jdbc.sql.DBDictionary) when a start index is specified but the search string is not found.

When a start index is specified (say ""N""), the search target string has the first N characters removed, the search performed (by INSTR in the default case), this is reduced by 1 to make it 0-indexed and then crucially the start index in added to the result.

In Oracle, if the search term is not found, INSTR returns 0.  If a start index is supplied, this is then added and 1 is taken away, so the ""result of indexOf"" will be ""start index - 1"" if the search string is not found.  It may not be obvious whether, once a query is run, a number represents a successful match or not.

I would expect the case where the string is not found to return 0 or -1, depending on the index base.  I think it is misleading for this to return a positive integer if the string is not found.

Since you cannot tell whether the string will be matched at the time the query is constructed, it may be difficult to find a fix for this.",openjpa-jdbc 1.2.0 and trunk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-08-20 17:02:03.079,,,no_permission,,,,,,,,,,,63298,,,Thu Feb 02 16:25:01 UTC 2012,,,,,,,0|i1drdz:,288534,,,,,,,,"20/Aug/11 17:02;milosz;It turns out that the following databases do have a 3-argument version of LOCATE-like functions making the trick with SUBSTRING obsolete:
- Oracle (INSTR),
- MySQL (LOCATE),
- H2 (LOCATE),
- SQLServer (CHARINDEX).

Sybase supports LOCATE only in some of database flavours. Since it is not clear for me which flavours support it (seems IQ does and ASE does not) and I don't have access to a Sybase instance, I am going to leave the current behaviour on Sybase as is. If anyone knows which Sybase databases support the 3-argument LOCATE and how to tell them, please speak up.",29/Aug/11 20:13;milosz;Resolving for the databases with 3-argument LOCATE functions. Others (e.g. PostgreSQL) have to still live with the SUBSTRING trick.,02/Feb/12 16:25;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DBDictionary.maxTableNameLength is not checked when using SynchronizeMappings,OPENJPA-866,12413092,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mcconne,alan_raison,mikedd,23/Jan/09 14:53,14/Jul/10 15:57,14/Mar/19 03:02,12/Mar/09 21:32,1.2.0,1.3.0,2.0.0-M2,,,,,,,1.3.0,2.0.0-M2,,,,,,,,,,0,,"Per Alan Raison's post to the dev mailing list there appears to be a problem with trimming table names when SynchronizeMappings is used. 

Here's the email that started the conversation : 
I have been writing a DBDictionary for the Ingres database and have been running the test cases.  Ingres supports 32 character table names, and this has been set in the dictionary.  However some tests have hit an error whereby the table name is too long for the database.

I notice in the DBDictionary class there is a method called ""getValidTableName"" but this clearly isn't being used since it is trying to use a table name which is too long.  Other databases (such as Oracle) also have quite a short maximum length for table names, so this problem must be able to overcome, but I can't see anything in other Dictionary classes.

Is there anything special I should be doing to run the tests?  I am currently running through mvn test.

My draft DBDictionary class is attached along with a sample surefire report (with my username and password removed!)

The full thread can be seen here : http://n2.nabble.com/OpenJPA-1.2.0-Test-Cases---Table-Name-too-Long-td2197132.html
",,,,,,,,,,,,,,,,OPENJPA-1725,,,,,,12/Mar/09 18:20;mcconne;OPENJPA-866_4.patch;https://issues.apache.org/jira/secure/attachment/12402071/OPENJPA-866_4.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-03-02 04:05:10.6,,,no_permission,,,,,,,,,,,161168,,,Tue May 26 14:52:34 UTC 2009,,,,,,,0|i0yx0v:,201820,,,,,,,,"02/Mar/09 04:05;mcconne;Adding a patch to check that the table name is valid before adding it to the schema. This fixes the problem for Oracle, which has only a 30-character maximum table length name, but should work for Ingres as well. I'll install and test with Ingres tomorrow just to be sure.","02/Mar/09 11:20;alan_raison;You'll need the Ingres DBDictionary, which can be found at http://code.ingres.com/apps/openjpa/.

I'm not sure that's 100% up to date, however, so I'll run on my own machine and let you know.

Thanks

Alan","02/Mar/09 16:12;alan_raison;I've just tried to run the test ""org.apache.openjpa.enhance.TestDataCachingAndUnenhancedPropertyAccess"" with the patched sources, but I still get:

Table name ""UnenhancedIdentityIdPropertyAccess"" is 34-character long. The database allows maximum 32-character for a table name.

How did you test the patch?  Let me know and I will try to replicate that.",05/Mar/09 02:54;mcconne;Attaching another patch to check the length of the table and column names when dynamically creating the database schema. It also includes a JUnit testcase to demonstrate the failure on multiple databases.,"05/Mar/09 03:05;mcconne;Hi Alan, I've been testing this failure on the following databases: MySQL, PostgreSQL, DB2, Derby, and Oracle. Unfortunately, I've haven't been able to get the Ingres database working with OpenJPA using your dictionary. This second patch improves the maven build very significantly with the Oracle database, which has only a 30-character table and column limit. BTW, did you know that you have the maxColumnNameLength defined twice in your IngreDictionary class ??","05/Mar/09 11:59;alan_raison;Tim

I've tried your patch and although it improves things somewhat, in that there are no more ""table name too long"" errors, I still get a number of schema-related errors.  For example, with the aforementioned TestDataCachingAndUnenhancedPropertyAccess test, I get errors along the lines of:

Table 'unenhancedidentityidpropertyacc1' does not exist or is not owned by you. {DELETE FROM UNENHANCEDIDENTITYIDPROPERTYACC1}

I am, however getting some previously failing tests to pass; org.apache.openjpa.enhance.TestUnenhancedCompoundPK.testCompoundPKFieldAccessOpenJPADefined passes whereas the other three in that class do not.

BTW apologies for claiming that your first patch did nothing; the problem was with maven/eclipse.
","05/Mar/09 17:30;mcconne;Hi Alan, thanks for the feedback. I'll look at your remaining problem(s) later today/tonight to see if I can figure out what's going on.....","05/Mar/09 17:38;alan_raison;It appears that the table has beenn created with the name ""UNENHANCEDIDENTITYIDPROPERTYACCE"" but OpenJPA is trying to access it as ""UNENHANCEDIDENTITYIDPROPERTYACC1"" (one letter shorter with a digit added)",05/Mar/09 18:58;mikedd;Regarding the entity for the testcase could we change the field names to be something shorter (ie under the 80 column limit) and use the @Column annotation if they need to be longer (which can be split across multiple lines). ,"05/Mar/09 19:35;mcconne;Sure Michael, I'll take care of that in the next patch once I get Alan's remaining problem(s) fixed......",07/Mar/09 03:40;mcconne;Here is the final (hopefully) patch to fix this problem. It basically checks the dictionary before adding tables to dynamic schemas and columns to those tables. If either exceeds the maximum length specified in the dictionary the table/column names are made valid using the same dictionary. There are still problems related to reserved words for table/column names but I'll address that problem with another patch for that JIRA. ,"09/Mar/09 11:00;alan_raison;Tim - thanks for that, it works a treat.","11/Mar/09 14:03;allee8285;I tried apply the patch against the trunk but mvn clean install consistently failied in:

Results :

Tests in error:
  testCacheMarshallerEndToEnd(org.apache.openjpa.conf.TestCacheMarshallerEndToEnd)

Tests run: 1374, Failures: 0, Errors: 1, Skipped: 0

I ran the with and without the patch twice and still failed the same say.

Can you take a look and see what may be causing the problem ?

Thanks,
Albert Lee.","12/Mar/09 06:10;mcconne;Hi Albert, This was my fault. I will attach another patch tomorrow and will be more thorough in testing my patches. Thanks much....","12/Mar/09 18:20;mcconne;Another patch which to fixex the serialization problem. The DynamicTable inner class is now non-static like the DynamicColumn inner class in DynamicSchemaFactory. All JUnit testcases in the build (i.e., Derby database) work fine now....",26/May/09 14:52;drwoods;also included in 1.3.x as Rev778727,,,,,,,,,,,,,,,,,,,,,
Subquery problems with SYNTAX_DATABASE (Oracle),OPENJPA-864,12412951,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,21/Jan/09 23:30,23/Jan/09 14:49,14/Mar/19 03:02,23/Jan/09 14:49,1.0.3,1.2.0,,,,,,,,1.0.4,1.2.1,1.3.0,2.0.0-M2,,,,,,,,0,,"The following query does not generate the correct SQL with Oracle : 
""SELECT e,d from Employee e, Dependent d ""
                + ""WHERE e.empId = :empid ""
                + ""AND d.id.empid = (SELECT MAX (e2.empId) FROM Employee e2) ""
                + ""AND d.id.effDate > :minDate ""
                + ""AND d.id.effDate < :maxDate "";

The problem will exist with any DBDictionary that uses JoinSyntaxes.SYNTAX_DATABASE (no joins will be created for Dependent). 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161166,,,2009-01-21 23:30:21.0,,,,,,,0|i0yxav:,201865,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unexpected mere-cascade behavior when cascade.all/merge specified on both sides of relationships !!!,OPENJPA-863,12412762,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,turagasandy,turagasandy,19/Jan/09 18:07,09/Mar/10 18:31,14/Mar/19 03:02,23/Jan/09 18:27,1.2.0,2.0.0-M2,,,,,,,,1.3.0,2.0.0-M2,,,,jpa,,,,,,0,,"When cascade.all/merge is specified on both sides of relationships, and if the parent is attached and the children are newly created entities that are being merged, the merge is not cascading to the parent's relationships if the parent is attached.
",,,,,,,,,,,,,,,,,,,,,,19/Jan/09 18:09;turagasandy;OPENJPA-863.patch;https://issues.apache.org/jira/secure/attachment/12398249/OPENJPA-863.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-01-23 18:27:04.05,,,no_permission,,,,,,,,,,,161165,,,Fri Jan 23 18:27:04 UTC 2009,,,,,,,0|i0z587:,203149,,,,,,,,"19/Jan/09 18:09;turagasandy;This patch the resolves the cascading merge problem.

Thanks
Sandhya","23/Jan/09 18:27;fancy;Fix available in following revisions:
trunk svn r737132
1.3.x svn r737131",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong id-parameter used for prepared statement when fetching a collection,OPENJPA-862,12412683,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,arne,arne,17/Jan/09 22:52,01/May/09 10:18,14/Mar/19 03:02,01/May/09 10:18,1.2.0,,,,,,,,,1.2.1,,,,,datacache,,,,,,0,,"When fetching a collection that is a property of an entity that was fetched through a collection, too, under some (reproducable) circumstances the collection is empty instead of filled with the correct entities.",,,,,,,,,,,,,,,,,,,,,,17/Jan/09 22:55;arne;OPENJPA-862.zip;https://issues.apache.org/jira/secure/attachment/12398154/OPENJPA-862.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-01-18 03:34:34.639,,,no_permission,,,,,,,,,,,161164,,,Fri May 01 10:18:04 UTC 2009,,,,,,,0|i0z2mn:,202728,,,,,,,,"17/Jan/09 22:55;arne;The attached test reproduces the problem. I'm sorry it contains so many entities, but I was not able to reproduce the problem with a smaller set of entities.","17/Jan/09 22:59;arne;When analyzing the executed sql of the test-case, I recognized that OpenJPA uses the wrong Pet-ID during selection of the visits for the second pet. It uses the ID of the first pet instead.

From this observation I guess this is a caching problem. As a new entity-manager is used for every query (doing this within one entity-manager seems to work fine) the caching problem must be somewhere in the entity-manager-factory.","18/Jan/09 03:34;faywang;Hi Arne, I could not reproduce your problem. What is the level of openjpa 1,2.x you are using? ","01/May/09 10:18;arne;Hi Fay,
Sorry for the late reply. I was using 1.2.0. With 1.2.1 the problem is gone.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unhelpful log messages are shown during deployment,OPENJPA-860,12412498,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,jkh,jkh,15/Jan/09 15:48,23/Jan/09 21:41,14/Mar/19 03:02,23/Jan/09 21:41,1.2.0,,,,,,,,,1.3.0,,,,,,,,,,,0,,"Enabling log level TRACE results in rather unhelpful messages during deployment:

7  myPU  TRACE  [Thread-41] openjpa.MetaData - Scan of ""META-INF/orm.xml"" found persistent types [Ljava.lang.String;@856daa.

The attached patch fixes this to display the correct:

7  myPU  TRACE  [Thread-41] openjpa.MetaData - Scan of ""META-INF/orm.xml"" found persistent types [com.heilgeist.testcase.geronimo.jarfile.MyEntity1].
",,,,,,,,,,,,,,,,,,,,,,15/Jan/09 15:49;jkh;openjpa-tracemsg.patch;https://issues.apache.org/jira/secure/attachment/12397975/openjpa-tracemsg.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-01-15 20:27:52.879,,,no_permission,,,,,,,,,,,161163,,,Fri Jan 16 07:14:21 UTC 2009,,,,,,,0|i1dref:,288536,,,,,,,,15/Jan/09 20:27;mikedd;Thanks for the patch Janko. I put the changes into 1.3.x and 2.0.0. ,"16/Jan/09 07:14;jkh;Hi Mike,

thanks for applying the patch, but you missed the changed argument in the last call to log.trace:

{code:java}
log.trace(_loc.get(""scan-found-names"", clss, rsrc));
{code}
should be
{code:java}
log.trace(_loc.get(""scan-found-names"", newNames, rsrc));
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA requires all persistent fields to be specified on an XML defined entity,OPENJPA-859,12412382,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,techhusky,techhusky,14/Jan/09 15:17,09/Mar/10 18:31,14/Mar/19 03:02,10/Dec/09 19:33,2.0.0-M2,,,,,,,,,2.0.0-beta,,,,,jpa,,,,,,0,,"This problem was reported by Frank Schwarz on the user forum[1].  It appeared to be related to the use of the new element-collection element in XML, but is actually are result of not having all persistent fields defined in XML.  If all fields are defined - or the entity is simply annotated with @Entity no exception is thrown.

Based on the JPA spec:

2.1.1 - If the entity has field-based access, the persistence provider runtime accesses instance variables
directly. All non-transient instance variables that are not annotated with the Transient
annotation are persistent. When field-based access is used, the object/relational mapping annotations
for the entity class annotate the instance variables.

In addition, the <entity> xsd documentation states:  [entity] Defines the settings and mappings for an entity. Is allowed to be
sparsely populated and used in conjunction with the annotations.

[1] http://n2.nabble.com/orm.xml---element-collection---trunk-tp2142331p2142331.html",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-09-25 17:55:15.523,,,no_permission,,,,,,,,,,,161162,,,Thu Dec 10 19:33:15 UTC 2009,,,,,,,0|i0z59r:,203156,,,,,,,,"25/Sep/09 17:55;curtisr7;1.3.x -- Committed revision 818927,818932.
trunk -- Committed revision 818928.",10/Dec/09 19:33;curtisr7;Changes committed to trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Informix cursor not open problem if synchronizeMapping set true,OPENJPA-853,12411987,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,09/Jan/09 00:08,09/Mar/10 18:31,14/Mar/19 03:02,10/Jan/09 00:51,1.2.0,,,,,,,,,1.2.1,1.3.0,2.0.0-M2,,,jdbc,,,,,,0,,"Informix JDBC driver default resultSet Holdability is 2 (CLOSE_CURSORS_OVER_COMMIT), which causes SQLException :Cursor not open.
<openjpa-1.2.1-SNAPSHOT-r422266:723087 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: Cursor not open.
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4232)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4197)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:88)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:64)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.handleCheckedException(SelectResultObjectProvider.java:155)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:40)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1228)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:990)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:805)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:775)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:771)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:517)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:254)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:293)
	at com.ibm.ws.query.utils.SetupQueryTestCase.setUpEmpDept(SetupQueryTestCase.java:1359)
	at com.ibm.ws.query.utils.SetupQueryTestCase.setUp(SetupQueryTestCase.java:436)
	at com.ibm.ws.query.tests.ano.JUBulkUpdateTest.setUp(JUBulkUpdateTest.java:42)
Caused by: java.sql.SQLException: Cursor not open.
	at com.informix.util.IfxErrMsg.getSQLException(IfxErrMsg.java:348)
	at com.informix.jdbc.IfxSqli.addException(IfxSqli.java:3000)
	at com.informix.jdbc.IfxSqli.receiveError(IfxSqli.java:3310)
	at com.informix.jdbc.IfxSqli.dispatchMsg(IfxSqli.java:2263)
	at com.informix.jdbc.IfxSqli.receiveMessage(IfxSqli.java:2183)
	at com.informix.jdbc.IfxSqli.executeFetch(IfxSqli.java:1835)
	at com.informix.jdbc.IfxSqli.getaRow(IfxSqli.java:4015)
	at com.informix.jdbc.IfxResultSet.next(IfxResultSet.java:533)
	at org.apache.commons.dbcp.DelegatingResultSet.next(DelegatingResultSet.java:168)
	at org.apache.openjpa.lib.jdbc.DelegatingResultSet.next(DelegatingResultSet.java:106)
	at org.apache.openjpa.jdbc.sql.ResultSetResult.nextInternal(ResultSetResult.java:222)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.nextInternal(SelectImpl.java:2451)
	at org.apache.openjpa.jdbc.sql.AbstractResult.next(AbstractResult.java:173)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.next(SelectResultObjectProvider.java:99)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:35)
	... 21 more",,,,,,,,,,,,,,,,OPENJPA-775,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-01-09 09:01:09.143,,,no_permission,,,,,,,,,,,161156,,,Sat Jan 10 00:51:15 UTC 2009,,,,,,,0|i0z2lz:,202725,,,,,,,,"09/Jan/09 09:01;milosz;A similar problem with Firebird has been reported in OPENJPA-775.
","10/Jan/09 00:51;fancy;fix checked in under OpenJPA svn:
    trunk -  r733204,
   1.3.x -   r733205   
   1.2.x  -  r733206",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Retrieving database generated keys gets never enabled,OPENJPA-847,12411523,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,milosz,milosz,milosz,31/Dec/08 10:18,09/Mar/10 18:31,14/Mar/19 03:02,31/May/09 09:57,2.0.0-M2,,,,,,,,,1.3.0,2.0.0-M2,,,,jdbc,,,,,,0,,Support for getting generated keys (OPENJPA-736) needs a bit of more work - DBDictionary.supportsGetGeneratedKeys is always false.,,,,,,,,,,OPENJPA-736,,,,,,,,,,,,25/Jan/09 12:01;milosz;OPENJPA-847.patch;https://issues.apache.org/jira/secure/attachment/12398681/OPENJPA-847.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161150,,,Sun May 31 09:57:15 UTC 2009,,,,,,,0|i1drfb:,288540,,,,,,,,"31/Dec/08 10:26;milosz;DBDictionary says:

                metaData = conn.getMetaData();
                try {
                    // JDBC3-only method, so it might throw a 
                    // AbstractMethodError
                    isJDBC3 = metaData.getJDBCMajorVersion() >= 3;
                    supportsGetGeneratedKeys = metaData.supportsGetGeneratedKeys();
                } catch (Throwable t) {
                    // ignore if not JDBC3
                }

However, DelegatingDatabaseMetaData.supportsGetGeneratedKeys always throws an exception:

    public boolean supportsGetGeneratedKeys() throws SQLException {
        throw new UnsupportedOperationException();
    }

Now , as OpenJPA requires Java 5 (JDBC 3), we probably can delegate all DelegatingDatabaseMetaData methods to the delegate or even get rid of DelegatingDatabaseMetaData completely.
","25/Jan/09 12:01;milosz;The patch delegates all JDBC 3 methods to the delegate instead of throwing exceptions.
",30/May/09 13:24;milosz;Change applied to trunk.,31/May/09 09:57;milosz;Change applied also to 1.3.x branch.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Ordering across slice fails when ordering terms are not included in projection items,OPENJPA-845,12411263,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,23/Dec/08 19:25,09/Mar/10 18:31,14/Mar/19 03:02,26/Feb/09 17:13,,,,,,,,,,2.0.0-M1,,,,,slice,,,,,,1,,"Query 1: select p from Person p ORDER BY p.name
Query 2: select p, p.name from Person p ORDER BY p.name

Query 1 fails, Query 2 succeeds. The in-memory ordering required for Query 1 in terms needed to extract the ordering value p.name from a Person p. That logic is broken for PCPath (i.e. p.name). Inheritance hierarchy of PCPath was changed (with certain reservation as it went against the norm) to extend kernel.exps.CandidatePath so that in-memory value evaluation logic can be reused. However, the logic for CandidatePath does not work for PCPath because the internal representation of the path vary (Traversal vs. Action) and are unrelated. The result is a class cast exception (thanks to Fernando who tracked the error down).       
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161149,,,2008-12-23 19:25:03.0,,,,,,,0|i0zahr:,204002,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The OpenJPA web site must post the privacy policy,OPENJPA-844,12411253,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,clr,clr,23/Dec/08 16:47,08/Mar/10 15:22,14/Mar/19 03:02,08/Mar/10 15:22,,,,,,,,,,,,,,,site,,,,,,0,,"During the last few board meetings, the usage of Google Analytics to
track the usage of our web sites was discussed. While this is not a
problem per se, Google requires in its Terms and Conditions that all
sites using it must post a privacy policy (to be exact, paragraph 7 of
the Analytics Terms and Conditions at
http://www.google.com/analytics/tos.html states that ""You must post a
privacy policy and that policy must provide notice of your use of a
cookie that collects anonymous traffic data."")

The legal-discuss group, together with the Jackrabbit PMC and a number
of individuals has pursued this issue and drafted up a privacy policy
for Jackrabbit, which is available at
http://jackrabbit.apache.org/privacy-policy.html

The board would like to thank you for this and appreciates the effort
and diligence that went into it.

If your PMC is collecting information through Google Analytics (ATM
there are at least 18 PMCs using it; you know who you are), we expect
you to set up a privacy policy along the lines of the Jackrabbit PMC and
add a note to your next board report after you have done so. 

Thank you for your cooperation.

	For the Apache board
		Henning

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-03-08 15:22:22.377,,,no_permission,,,,,,,,,,,161148,,,Mon Mar 08 15:22:22 UTC 2010,,,,,,,0|i0z5bb:,203163,,,,,,,,"08/Mar/10 15:22;drwoods;This was done awhile back, as I added a privacy policy page -
   http://openjpa.apache.org/privacy-policy.html
and a link under the Overview menu which is present on the home page and any page that is sourced from the wiki.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unnecessary version update on inverse-side of a 1-m relationship,OPENJPA-843,12411187,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,dinkar,dinkar,dinkar,22/Dec/08 19:16,09/Mar/10 18:31,14/Mar/19 03:02,12/Jan/09 22:43,2.0.0-M2,,,,,,,,,1.2.1,1.3.0,2.0.0-M2,,,jdbc,,,,,,0,,"A Customer has 1-m relationship to Inventory:

@Entity
Customer {
    ....
    @OneToMany(mappedBy=""customer"")
    private Collection<Inventory> inventories = new ArrayList<Inventory>();
    ....
}

@Entity
Inventory {
    ...
    @ManyToOne
    private Customer customer;
    ...
}

When an Inventory instance is modified, its version is bumped as expected.  However, when an Inventory is added or deleted from the Inventory list in Customer, the Customer instance version is unnecessarily bumped up. According to section 3.4.2 of the 1.0 spec,

""The version attribute is updated by the persistence provider runtime when the object is 
written to the database. All non-relationship ﬁelds and properties and all relationships 
owned by the entity are included in version checks.""

When additions or deletions are made to the Inventory list of Customer, the version of the Customer instance should remain unchanged. As the inverse-side, Customer does not own the Inventory that is added/deleted. ",,,,,,,,,,,,,,,,,,,,,,22/Dec/08 19:30;dinkar;OPENJPA-843-test.patch;https://issues.apache.org/jira/secure/attachment/12396622/OPENJPA-843-test.patch,22/Dec/08 19:24;dinkar;OPENJPA-843.patch;https://issues.apache.org/jira/secure/attachment/12396620/OPENJPA-843.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-01-12 22:43:12.759,,,no_permission,,,,,,,,,,,161147,,,Mon Jan 12 22:43:12 UTC 2009,,,,,,,0|i1drfj:,288541,,,,,,,,"22/Dec/08 19:24;dinkar;In the patch, the call to updateIndicators() is made only under these conditions:

- any non-relational field of the entity is modified
- any relationships owned by the entity are modified.

The flag (updateIndicators) to decide whether versions/discriminators should be modified is passed in recursively to update(), to take care of the case where the version field is in a superclass whose fields have not been modified, but the subclass' fields have been modified. ","12/Jan/09 22:43;fancy;Patch has been commited at following svn revisions:
trunk : r733932
1.3.x:  r733945
1.2.x:  r733944",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
fix parameter setting problem when QuerySQLCache is on,OPENJPA-838,12411068,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,19/Dec/08 18:51,09/Mar/10 18:31,14/Mar/19 03:02,29/Jan/09 16:44,1.2.0,,,,,,,,,1.2.1,1.3.0,2.0.0-M2,,,jdbc,,,,,,0,,"java.lang.IndexOutOfBoundsException
    at java.util.ArrayList.get(Unknown Source)
    at org.apache.openjpa.jdbc.sql.SQLBuffer.setParameters(SQLBuffer.java:629)
    at
org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:529)
    at
org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:485)
    at
org.apache.openjpa.jdbc.sql.SelectImpl.prepareStatement(SelectImpl.java:463)
    at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:379)
    at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:339)
    at
org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:420)
    at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:230)
    at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:220)
    at
org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.load(StoreCollectionFieldStrategy.java:629)
    at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:822)
    at
org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:682)
    at
org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
    at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
    at
org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:2924)
    at
org.apache.openjpa.kernel.StateManagerImpl.load(StateManagerImpl.java:379)
    at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:864)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-01-26 19:15:15.828,,,no_permission,,,,,,,,,,,161142,,,Thu Jan 29 16:44:40 UTC 2009,,,,,,,0|i0zai7:,204004,,,,,,,,"19/Dec/08 19:02;faywang;The problem of parameter setting when cache is on is a result of how OpenJPA processes parameters.  There is no distinction between literal vs. user-specified parameters and there is no clear-cut way to separate parameter setting logic from the logic to reconstruct SQLBuffer within SelectImpl, making re-using SQLBuffer within SelectImpl impossible, ","22/Dec/08 20:09;faywang;change is committed to openjpa 1.2.x r728758, 1.3.x r728753, trunk r728750",26/Jan/09 19:15;mikedd;We need a testcase for this issue to prevent future regressions. I'm reopening the issue and assigning to Fay. ,27/Jan/09 16:36;faywang;Test cases are checked in openjpa 1.2.x (r-738137) and openjpa 1.3.x (r-738136). The test case will be checked into the trunk once Jeremy give a green light.,29/Jan/09 16:44;faywang;Test case is checked into trunk r-738918.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
after em.clear the datacache is inconsistent,OPENJPA-836,12411045,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,fancy,open_johan,open_johan,19/Dec/08 12:03,09/Mar/10 18:31,14/Mar/19 03:02,14/Jan/09 23:25,1.2.0,1.3.0,,,,,,,,1.3.0,2.0.0-M2,,,,datacache,,,,,,0,,"I have the cache enabled. kodo.DataCache=true
I update an Entity's  description field (no fk);
After the em.merge or em.persist I do an em.clear.

In a new transaction (new webpage request) I do a select query asking for the previous entity. 

I get back the Entity but only it's id has been set. everything else is null. 
From then on all the attempts to execute the same query get the same result.

This does not happen if kodo.DataCache=false.
This does not happen if kodo.DataCache=true but the em.clear is not used.

All the above operations are done using the JPA api.
However, If I aquire manually the StoreCache I see that the Entity still exists in.
If do a manual storeCache.evict on the specific Entity or evictAll, the problem is resolved. 

Note:  The original weblogic 10.3 openjpa jar which is version 1.1 has been replaced with version 1.2.0. (and also tested with snapshot of 1.3.0)

//CODE:
//The only table that I use in the example is test_table.

putData(){
   TestTable test = em.find(TestTable.class, 1);
    test.setDescription(""This is a NEW description"");
    em.merge(test);
    em.flush();
    em.clear();
}

getData(){
      TestTable test = em.find(TestTable.class, 1);
      log.debug(""Description is is: ""+test.getDescription());
}


request1: getData(); --> prints: ""this is an old description""
request2: putData();
request3: getData();--> prints null; ","Weblogic 10.3 on WinXP EJB 3.0 (CMT)
<property name=""kodo.DataCache"" value=""true""/>
      <property name=""kodo.RemoteCommitProvider"" value=""sjvm""/>",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-01-14 23:25:45.557,,,no_permission,,,,,,,,,,,161140,,,Wed Jan 21 10:37:14 UTC 2009,,,,,,,0|i0yw73:,201686,,,,,,,,"23/Dec/08 16:52;open_johan;//The only table that I use in the example is test_table.

putData(){
   TestTable test = em.find(TestTable.class, 1);
    test.setId(1);
    test.setDescription(""This is a NEW description"");
    em.merge(test);
    em.flush();
    em.clear();
}

getData(){
      TestTable test = em.find(TestTable.class, 1);
      log.debug(""Description is is: ""+test.getDescription());
}

request1: getData(); --> prints: ""this is an old description""
request2: putData(); 
request3: getData();--> prints null;",14/Jan/09 23:25;fancy;Fix checked in trunk:  r734551 & 1.3.x  : r734550,21/Jan/09 10:37;open_johan;Fix Verified on latest 1.3 snapshot! ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Loading nested toMany EAGER relation resuled in PersistenceException,OPENJPA-835,12411017,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,18/Dec/08 23:07,19/Dec/08 02:24,14/Mar/19 03:02,19/Dec/08 02:24,1.2.0,1.2.1,1.3.0,2.0.0-M2,,,,,,1.2.1,1.3.0,2.0.0-M2,,,jdbc,,,,,,0,,"<openjpa-1.2.1-SNAPSHOT-r422266:723087 fatal general error> org.apache.openjpa.persistence.PersistenceException: com.ibm.ws.query.entities.ano.ProductAno.inventory
	at org.apache.openjpa.kernel.StateManagerImpl.setExtraFieldData(StateManagerImpl.java:721)
	at org.apache.openjpa.kernel.StateManagerImpl.setIntermediate(StateManagerImpl.java:698)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:367)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:278)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.initialize(WsJpaJDBCStoreManager.java:144)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:894)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:852)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:774)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:976)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.load(WsJpaJDBCStoreManager.java:107)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:278)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2394)
	at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.loadEagerJoin(RelationFieldStrategy.java:538)
	at org.apache.openjpa.jdbc.meta.FieldMapping.loadEagerJoin(FieldMapping.java:807)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1042)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1002)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:376)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:278)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.initialize(WsJpaJDBCStoreManager.java:144)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:894)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:852)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:774)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:976)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.load(WsJpaJDBCStoreManager.java:107)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:278)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2394)
	at org.apache.openjpa.jdbc.meta.strats.RelationToManyInverseKeyFieldStrategy.loadElement(RelationToManyInverseKeyFieldStrategy.java:87)
	at org.apache.openjpa.jdbc.meta.strats.RelationCollectionInverseKeyFieldStrategy.loadElement(RelationCollectionInverseKeyFieldStrategy.java:76)
	at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.processEagerParallelResult(StoreCollectionFieldStrategy.java:318)
	at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.loadEagerParallel(StoreCollectionFieldStrategy.java:252)
	at org.apache.openjpa.jdbc.meta.FieldMapping.loadEagerParallel(FieldMapping.java:801)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1045)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1002)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:376)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:278)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.initialize(WsJpaJDBCStoreManager.java:144)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:894)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:852)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:774)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:976)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.load(WsJpaJDBCStoreManager.java:107)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:278)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2394)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:272)
	at org.apache.openjpa.jdbc.kernel.InstanceResultObjectProvider.getResultObject(InstanceResultObjectProvider.java:59)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:36)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1228)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:990)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:805)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:775)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:771)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:517)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:254)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:293)
	at com.ibm.ws.query.utils.SetupQueryTestCase.setUpPartComposite(SetupQueryTestCase.java:1066)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161139,,,Fri Dec 19 02:24:33 UTC 2008,,,,,,,0|i0z75j:,203461,,,,,,,,"19/Dec/08 02:24;fancy;Fix checked in openjpa svn:
 1.2.x revision r727894
 1.3.x revision r727896
 trunk revision r727895",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
State field mapped to XML column has incorrect value when loaded from database,OPENJPA-834,12411004,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,milosz,milosz,18/Dec/08 21:10,09/Mar/10 18:31,14/Mar/19 03:02,26/Jan/09 19:57,1.3.0,2.0.0-M2,,,,,,,,1.3.0,2.0.0-M2,,,,kernel,,,,,,0,,"The org.apache.openjpa.persistence.xmlmapping.xmlbindings.myaddress.Address is a class with JAXB annotations. It has a property street of type List<String>. When an entity containing Address in its state field is loaded from database, the street property is empty.

My initial investigation led me to a conclusion that the issue is caused by a proxy returned from ProxyManagerImpl.newCustomProxy(Object) which does not behave correctly.
",Database with XML column support,,,,,,,,,,,,,,,OPENJPA-861,OPENJPA-833,,,,,20/Dec/08 10:26;milosz;OPENJPA-834.patch;https://issues.apache.org/jira/secure/attachment/12396539/OPENJPA-834.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-01-15 21:54:17.364,,,no_permission,,,,,,,,,,,161138,,,Mon Jan 26 19:57:49 UTC 2009,,,,,,,0|i0z2jr:,202715,,,,,,,,18/Dec/08 21:11;milosz;OPENJPA-833 contains a test case for this.,"19/Dec/08 10:58;milosz;Heh, the issue is simpler - the Address class needs a setter for the street property. Otherwise ProxyBean.newInstance(Object) will not copy that property.

I will send a patch soon.
","20/Dec/08 10:26;milosz;The patch adds a setter for the street property. If applying the patch, please remove the @AllowFailure from the test case.
","15/Jan/09 18:46;milosz;The XJC generator can be forced to generate setters for collections by using a plug-in [1]. The manual could be updated with that information.

[1] https://jaxb2-commons.dev.java.net/collection-setter-injector/","15/Jan/09 21:54;fancy;Milosz,
Thanks for the patch.
Do you mind documenting the XJC plug-ins that generate the setters for collections in our Manual -  the  xmlmapping section ?

The issue remains open until proper documentation is in place.

Thank you for the work.","16/Jan/09 10:29;milosz;Catalina,
I will provide a patch for the manual.
","24/Jan/09 13:16;milosz;I have incorporated the changes for the manual into the patch for OPENJPA-861.
","26/Jan/09 19:57;fancy;Updates to the manual has been provided by Milosz Tylenda and committed under following revisions:
trunk: -  r737799
1.3.x -    r737801",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Externalizer fails with ClassCastException with runtime enhancement,OPENJPA-828,12410754,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ppoddar@apache.org,ppoddar@apache.org,16/Dec/08 01:26,02/May/13 02:29,14/Mar/19 03:02,10/Apr/13 20:52,,,,,,,,,,1.2.3,2.0.0-M1,2.0.0-M2,,,,,,,,,0,,"Several issues [1] are reported with @Externalizer field failing with ClassCastException. The issue appears only for runtime enhanced classes and not for build time enhancement.

[1] http://n2.nabble.com/%40Externalizer-does-not-work-on-persist--tt209702.html#a209702",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-04-06 08:56:37.959,,,no_permission,,,,,,,,,,,161132,,,Mon Apr 06 09:26:28 UTC 2009,,,,,,,0|i0z2iv:,202711,,,,,,,,"06/Apr/09 08:56;jkronegg;Got this issue using Boolean->CHAR Y/N mapping for runtime enhanced classes under OpenJPA 1.2.1:

    @Column(name=""flag"", nullable=true, length=1)
    @ExternalValues({""true=Y"", ""false=N""})
    @org.apache.openjpa.persistence.Type(char.class)
    public Boolean getFlag() {
      ..
    }

Applying changes described in the following edits solved the problem:
http://svn.apache.org/viewvc/openjpa/trunk/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java?view=diff&r1=726926&r2=726927&pathrev=726927

This issue should also be solved in 1.2 and 1.3 branches...",06/Apr/09 09:26;jkronegg;See also this forum thread: http://n2.nabble.com/Convert-boolean-to-String-type-using-ExternalValues-td1659239.html,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
slices: hangs with multithreaded true,OPENJPA-825,12410528,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,fern,fern,11/Dec/08 23:40,09/Mar/10 17:53,14/Mar/19 03:02,12/Sep/09 04:47,2.0.0-M2,,,,,,,,,2.0.0-M1,,,,,slice,,,,,,0,,"When I turned on openjpa.Multithreaded as a possible fix for another bug, I see that the system hangs.  Attached are going to be a log file, and jstack, showing how it system hung on the very first query. ( it did execute a few find() operations, but those are not executed via ParallelExecutor ).",,,,,,,,,,,,,,,,OPENJPA-820,OPENJPA-826,,,,,16/Dec/08 23:10;fern;hang-multithread-2.jstack;https://issues.apache.org/jira/secure/attachment/12396253/hang-multithread-2.jstack,11/Dec/08 23:41;fern;hang-multithread.jstack;https://issues.apache.org/jira/secure/attachment/12395890/hang-multithread.jstack,11/Dec/08 23:41;fern;hang-multithread.txt;https://issues.apache.org/jira/secure/attachment/12395891/hang-multithread.txt,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2008-12-14 04:53:04.255,,,no_permission,,,,,,,,,,,161129,,,Thu Feb 26 16:31:16 UTC 2009,,,,,,,0|i0yw5r:,201680,,,,,,,,"11/Dec/08 23:41;fern;jstack, showing where the query hangs..",11/Dec/08 23:41;fern;the log file to show how the system hung on a query...,"14/Dec/08 04:53;ppoddar@apache.org;Multithreaded mode of OpenJPA kernel and parallel database operation in Slice
===============================================================

Background
   a) OpenJPA allows multiple threads to execute a single instance of EntityManager. By default, OpenJPA assumes that a single thread is invoking operations on a particular instance of EntityManager. 
   openjpa.Multithreaded configuration property can be set to true to signal multithreaded acceess. Under multithreaded mode, OpenJPA kernel classes acquire an instance-level Reentrant lock before almost any of its methods and 
   releases the lock on the method's finally block.

   b) Slice executes most of the frequent database operations (query, flush) on individual slice in separate threads.


   These two threading models conflict and give rise to a classic deadlock scenario as follows:

   1. Assume EntityManager instance em, a Query instance Q created by E, openjpa.Multithreaded=true, a user thread UT and three slices S1,S2,S3

   2. T calls em.x() or Q.y()

   3. em/Q acquires a reentrant lock L on thread UT and invokes lower-layer method which eventually invokes Slice operations

   4. Slice spawns three threads ST1, ST2, ST3 and on each of these threads invoke identical operation S.z()

   5. If S.z() on ST1 invokes any operation of em/Q then ST1 can not acquire L as it is acquired by em/Q in step 3 and yet to be released. The architecture of Slice makes it typical that S.z() invokes one or more method on em or Q. 

   6. em.x()/Q.y() can not release L till  S.z() finishes   

   7. S.z() can not finish because ST1 waits for L to be released by UT



Observations
==========
  a) openjpa.Multithreaded is a non-default option and single threaded operation on em is more prevalent. Note that single threaded access does not imply that em can only be invoked only on UT. It is perfectly permissible to 
start a transaction of em on some thread UT, commit the transaction and then start another transaction on same em on a different thread UT2 under default mode of openjpa.Multithreaded=false.

  b) Execution of common database operations on each slice S1, S2,... in parallel has definite performance benefit and should be the default choice. And this is at par with the default choice of openjpa.Multithreaded=false


Possible solutions
===============
  1. Under openjpa.Multithreaded=true, execute database operation on all slices on the same user thread UT. Otherwise, execute database operation on each slice on separate thread
  2. Modify OpenJPA kernel's threading model to make it more fine-grained, read/write sensitive
  3. Detect deadlock and throw exception as ST1 waits on L
  
My preferred solution is (1). ","15/Dec/08 17:26;fern;I have to add that because Slices does execute the Query using multiple threads ( ST1, ST2, ST3 mentioned above ).  It is explicitly accessing the EM in a multi-threaded manner, thus breaking the whole assumptions that you can only access the EM with one thread.

THUS:

Slices REQUIRES openjpa.Multithreaded=true !!!!!!!!!!!!

Conceptually, if you will be executing the EM with multiple threads, you have to use openjpa.Multithreaded=true.  And if you don't you will see corruption and weird behavior, which another issue (OPENJPA-820) shows exactly that Slices with openjpa.Multithread=false can have erratic behavior, with invalid results for queries.  Thus if you run Slices with openjpa.Multithreaded=false, then any query you run could be returning invalid values!

I just wanted to go on record stating that this bug (OPENJPA-825) is an either/or proposition, or only an issue if you run with openjpa.Multithreaded=true, because currently Slices requires openjpa.Multithreaded=true.  Thus though the easy solution is #1, that is the most un-performant of any of them, so it's a great short-term solution.  And #3 is useless because deadlocks ARE GUARANTEED to occur (OPENJPA-820), because most of the code uses a global lock, there is no way around deadlocks.  #2 is the only long-term solution...
","16/Dec/08 23:10;fern;another jstack of openjpa slices hanging: within the StateManager...

1) I have applied the patch from OPENJPA-826, that removes the first hang spot in QueryImpl.isUnique
    (this was the hang shown in the first stack trace I attached)

2) I have disabled the current work around to this bug applied by Pinaki
    (the work around currently turns off ParallelExecutor when Multithreaded=true)
    (I have disabled the work around to test a parallel execution, to find and fix hangs)
","26/Feb/09 16:31;ppoddar@apache.org;Two primary objectives or hard constraints
1. Slice must execute database operations in parallel. Otherwise the basic purpose of working with distributed data in an efficient manner is defeated.
2. OpenJPA's threading model should not be altered. Threading model is hard to retrofit and OpenJPA's current threading model is battle-tested. Any fundamental alteration is a risk not worth taking.

One approach to meet the above criteria and address this difficult reported issue is to incorporate a variation on threading model for Slice module. Let each slice run on a specialized SliceThread which acts like a child of a parent 'user' thread. The parent thread is the thread that invoked the Broker/EntityManager operation. When the control reaches to Slice for executing database operation, let Slice spawn specialized SliceThread. Let a SliceThread use its parent's lock. But do this only for Broker and not for Query (which has its own reentrant lock). ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
org.apache.openjpa.lib.util.ParseException when try to get property descriptor for property: CacheMarshallers,OPENJPA-824,12410435,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,amy,amy,11/Dec/08 04:09,09/Mar/10 18:31,14/Mar/19 03:02,16/Dec/08 04:44,,,,,,,,,,2.0.0-M1,,,,,kernel,,,,,,0,,"When running org/apache/openjpa/persistence/conf/TestKodoConfiguration, there will be an exception:
testBeanAccessors(org.apache.openjpa.persistence.conf.TestKodoConfiguration)  Time elapsed: 0.172 sec  <<< ERROR!
org.apache.openjpa.lib.util.ParseException: Errors occurred while creating property descriptors for the following properties: [CacheMarshallers].
        at org.apache.openjpa.lib.conf.ConfigurationImpl.getPropertyDescriptors(ConfigurationImpl.java:449)
        at org.apache.openjpa.persistence.conf.TestKodoConfiguration.testBeanAccessors(TestKodoConfiguration.java:128)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:127)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:334)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:980)",All supported environments ,,,,,,,,,,,,,,,OPENJPA-830,,,,,,11/Dec/08 04:17;amy;OPENJPA-824.patch;https://issues.apache.org/jira/secure/attachment/12395795/OPENJPA-824.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161128,,,Tue Dec 16 04:44:05 UTC 2008,,,,,,,0|i0z66v:,203305,,,,,,,,"11/Dec/08 04:12;amy;Currently TestKodoConfiguration is excluded. 
To fix the ParseException, there will be 2 parts:
1. add information for property CacheMarshallers in corresponding localizer.properties.
2. change test code in TestKodoConfiguration to skip some check for kodo-specific property.

Then TestKodoConfiguration can be removed from the excluded list.

I'll attach the patch for review",11/Dec/08 04:17;amy;patch for review,"16/Dec/08 04:44;amy;The fix has been checked in (Thanks a lot to David Ezzio) with change 726860, 68, and 76.
The name of the test case is changed from TestKodoConfiguration to TestOpenJPAConfiguration.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
slices: DistributedStoreQuery$UpdateExecutor calls executeDelete by mistake,OPENJPA-821,12410326,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,fern,fern,10/Dec/08 01:15,09/Mar/10 18:31,14/Mar/19 03:02,10/Dec/08 12:36,2.0.0-M1,,,,,,,,,2.0.0-M1,,,,,slice,,,,,,0,,"At the bottom of DistributedStoreQuery, the UpdateExecutor class, is calling the executeDelete, instead of the executeUpdate.  Small oversight, easy to fix.. :) :)


Index: openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java
===================================================================
--- openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java        (revision 724945)
+++ openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java        (working copy)
@@ -269,7 +269,7 @@
                Executor executor;
                Object[] params;
                public Number call() throws Exception {
-                       return executor.executeDelete(query, params);
+                       return executor.executeUpdate(query, params);
                }
        }
 }
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161126,,,2008-12-10 01:15:05.0,,,,,,,0|i0ywjz:,201744,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"slices: a simple query is failing (unique, but totally sending wrong parameters to SQL)",OPENJPA-820,12410312,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,fern,fern,09/Dec/08 23:02,22/Apr/10 20:32,14/Mar/19 03:02,15/Mar/10 21:30,2.0.0-M2,,,,,,,,,,,,,,slice,,,,,,0,,"Thank you for fixing that PCPath issue!  Now I can move on to find the next bug to fix. :)  And I didn't have to wait long:

I am trying to run the simple query below, against 2 slices.

select this from com.protrade.fandom.data.entities.TeamFanJersey this  where this.teamFan = :p0


These are the two queries run on the low level databases:

SELECT t0.JDOID, t0.JERSEYLEVEL, t0.TEAMFAN_JDOID FROM TEAMFANJERSEY t0 WHERE (t0.TEAMFAN_JDOID IS NULL)

SELECT t0.JDOID, t0.JERSEYLEVEL, t0.TEAMFAN_JDOID FROM TEAMFANJERSEY t0 WHERE (t0.TEAMFAN_JDOID = 8574250)


As you can see, the query run against Slice1 thinks the parameter is Null, while the query run against Slice2, knows the proper value of the parameter.  This SQL is the lowlevel sql sent through the Mysql Driver (mysql driver logging).

I guess it's another bug in the DistributedPreparedStatement not properly setting parameters to all sub statements.. just a guess.
",,,,,,,,,,,,,,,,,,,,,,10/Dec/08 23:24;fern;bad-log.txt;https://issues.apache.org/jira/secure/attachment/12395771/bad-log.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161125,,,Mon Dec 15 17:32:05 UTC 2008,,,,,,,0|i0yw5b:,201678,,,,,,,,"09/Dec/08 23:18;fern;Alright, so it's not DistributedPreparedStatement, since this goes through the DistributedStoreQuery.  So I have no clue to give you.  Some how one of the slice queries loses the parameter....","10/Dec/08 22:52;fern;Pinaki Poddar wrote:
>> select this from com.protrade.fandom.data.entities.TeamFanJersey this 
> where this.teamFan = :p0
> 1. What is the value of the query parameter 'p0'? If p0 is persisted in one
> slice only, then in other slices the query should compare with IS NULL. 
> 
> 
> I had added a test case of the above form in
> ...openjpa.slice.TestQuery#testQueryParameterEntity. And that test verifies
> proper parameter binding and returns the correct result.
> 
> May be something more is happening in your use case. Post the relevant
> portion of the failing use case.
> ","10/Dec/08 22:53;fern;Question:

p0 is a persisted object, thus persisted in one slice. BUT I don't get your assertion that ""then in other slices the query should compare with IS NULL.""  There is no reason to force this assertion in the code.  Anyhow, where in the code would this behavior be applied?  I might not be too smart or the code might be more complicated than I thought, but I have not seen anything that would do that.","10/Dec/08 23:03;fern;I'll try posting the ""relevant portion of the failing use case"", but I just did.  There is a simple query, and it's failing, I already told you the query above, and pointed out the generated SQL that openjpa is executing against the slices..  and I have no clue how that would come about..

but here are more details.

I have two slices.  One is the full database that I have been using for non-slice work.  The second is a fully empty database with just the same schema, that I use for slices testing.  So TeamFan and TeamFanJersey objects all exist in the same database.

In my code I am trying to do something like:

attainTeamFanJersey( TeamFan fan );

which then calls the query listed below, to see if there is a TeamFanJersey for that TeamFan.  If null, then it creates one.

select this from com.protrade.fandom.data.entities.TeamFanJersey this where this.teamFan = :p0 

What I expect is that it will always return a value since I KNOW that a TeamFan and TeamFanJersey both exist in Slice1.

For some reason OpenJPA returns null randomly, thus for some reason OpenJPA can't find a valid TeamFanJersey, even though I know it exists.  When I was looking at the logs, that's when I saw the weird case that it seemed to be checking for NULL instead of the propery TeamFan id for one of the two slices.. weird.


When this happens, then my code assume that there is no TeamFanJersey, then it creates one.  But now there are 2 TeamFanJersey objects related to that TeamFan.


Now the kicker.  When the code creates a second TeamFanJersey, it properly creates that object.  And at times it creates that on Slice2.  But then when I execute the query again, at a later time ( same request, or another request ).

select this from com.protrade.fandom.data.entities.TeamFanJersey this where this.teamFan = :p0

It then finds BOTH TeamFanJersey objects.. which my code complains since it's expecting only 1 TeamFanJersey, not 2.. (getSingleResult).



So, here we are:

The query works most of the time, but seems to fail randomly.
The failure seems to be related to the low level SQL that it generates and runs against each Slice, in that it doesn't generate the same SQL.. weird.
","10/Dec/08 23:09;fern;the annoying part, is that it seems intermittent :(

I can't reproduce it at the moment :(
","10/Dec/08 23:24;fern;huge log file, where it failed..

if you search for TEAMFANJERSEY, you will see the SQL that was executed against the Slices..

Slice1 has all the data, Slice2 is empty.

","10/Dec/08 23:27;fern;There, I got a run where it fails. 

If you look at the log file and search for TEAMFANJERSEY, you will see the first SQL query:

SELECT t0.JDOID, t0.JERSEYLEVEL, t0.TEAMFAN_JDOID FROM TEAMFANJERSEY t0 WHERE (t0.TEAMFAN_JDOID IS NULL)

then the second:

SELECT t0.JDOID, t0.JERSEYLEVEL, t0.TEAMFAN_JDOID FROM TEAMFANJERSEY t0 WHERE (t0.TEAMFAN_JDOID = 8574250)

I can only assume that the first query was run against Slice1 (where TeamFanJersey is actually located), and the second against Slice2 (which is empty).  Thus the query returns null.. which causes my code to create a TeamFanJersey (which happens to go into Slice2), which causes all future executions of the query above to return 2 TeamFanJersey objects.. a failure, so you'll see a tonne of exceptions through the rest of the log:

...NonUniqueResultException: The query on candidate type ""class com.protrade.fandom.data.entities.TeamFanJersey"" with filter ""select this from com.protrade.fandom.data.entities.TeamFanJersey this  where this.teamFan = :p0"" was configured to have a unique result, but more than one instance matched the query.




Let me know what else I can do to help us figure this out! :) :)","15/Dec/08 17:32;fern;So it looks that this is caused by the ParallelExecutor executing the sub queries using multiple threads, without using proper locking: openjpa.Multithreaded=true.  So it looks like the root cause of this bug is OPENJPA-825.

But I would keep this bug open until that is fixed..",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE when no metadata is defined for a persistent class,OPENJPA-819,12410224,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,dianner,dianner,dianner,08/Dec/08 21:58,09/Mar/10 18:31,14/Mar/19 03:02,18/Dec/08 20:41,2.0.0-M2,,,,,,,,,2.0.0-M2,,,,,kernel,,,,,,0,,"The persistent class was specified in the persistence.xml under <class>, but persistence metadata was not specified for the class, either through annotation or the orm.xml. A NPE was thrown. We need a better message.

This issue was reported in the user forum by post http://n2.nabble.com/NullPointerException-when-calling-createEntityManager-on--EntityManagerFactory-td1621881.html",,,,,,,,,,,,,,,,,,,,,,16/Dec/08 22:02;dianner;OPENJPA-819.patch;https://issues.apache.org/jira/secure/attachment/12396244/OPENJPA-819.patch,16/Dec/08 15:47;dianner;OPENJPA-819.patch;https://issues.apache.org/jira/secure/attachment/12396201/OPENJPA-819.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-12-18 20:41:09.903,,,no_permission,,,,,,,,,,,161124,,,Thu Dec 18 20:41:09 UTC 2008,,,,,,,0|i1drhr:,288551,,,,,,,,16/Dec/08 15:47;dianner;Attaching patch for this problem. Please review and commit if ok.,"16/Dec/08 17:16;dianner;Pinaki responded with the following in the mailing list. I'm documenting here. Thanks Pinaki. See my embedded responses:

1. Many error messages in OpenJPA not only tells what the error is, it also
tries to help what can be common cause of the error. From that standpoint,
the message
  no-meta: No registered metadata for type ""{0}"".
could be changed to something like
  no-meta: No registered metadata for class ""{0}"". This can happen if this
class has not been annotated as persistent entity or specified in the
persistence unit.

<der>I agree. I just used an existing message. But, I'll update it as part of this fix.</der>

2. The test case can benefit from deriving from SingleEMFTest case and its
setUp(Object...args). There are many examples available in
openjpa-persistence-jdbc test package on its usage.

<der>Actually, I know about this class and I initially tried it. But, it went down a different path. It issued a similar message, but it did not go through the code that I changed. So, I had to resort to the current scheme.</der>

3. If SingleEMFTestCase is used, persistence.xml is not needed.

<der>See my comment under 2.</der>

4. The comments just above where the new exception is raised should be
modified, as after this change it sounds contradictory.

<der>Will do</der>",16/Dec/08 22:02;dianner;Updated patch incorporating Pinaki's comments. Please review.,18/Dec/08 20:41;techhusky;Committed for Dianne Richards to trunk under revision 727813.  Resolving issue.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TCK module should use Geronimo JPA 2.0 EA jar,OPENJPA-818,12410112,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,05/Dec/08 21:22,05/Dec/08 21:25,14/Mar/19 03:02,05/Dec/08 21:25,2.0.0-M2,,,,,,,,,2.0.0-M2,,,,,,,,,,08/Dec/08 00:00,0,,"The pom.xml file for the TCK module doesn't use the updated JPA 2.0 EA spec from Geronimo so the TCK fails when we require one of the new classes (ie QueryBuilder).

Switching the pom to use Geronimo's implementation resolves the missing classes issue, but we fail the method signature test - this likely won't be updated until a new TCK is released. 

I'm not an expert but I believe the signature test (and only the signature test) may be skipped by specifying -Djpatck.pkg.dir=com/sun/ts/tests/ejb30/ 
as a command line argument when running the TCK through maven. Until we get an updated TCK or someone with direct access to the TCK finds a better way to exclude the sig test I suggest anyone interested in running the TCK use the argument above. 

",,1800,1800,,0%,1800,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161123,,,Fri Dec 05 21:25:04 UTC 2008,,,,,,,0|i0z667:,203302,,,,,,,,"05/Dec/08 21:25;mikedd;I've changed the configuration to use Geronimo's API, but I haven't automatically excluded the failing test. Individual users will have to do that manually.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Exception is thrown when retrieving an entity which contains an embeddable and the embeddable contains a toMany relation ,OPENJPA-815,12410006,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,faywang,faywang,04/Dec/08 20:19,09/Mar/10 18:31,14/Mar/19 03:02,04/Dec/08 23:52,,,,,,,,,,1.3.0,2.0.0-M2,,,,,,,,,,0,,"Exception is thrown when retrieving an entity which contains an embeddable and the embeddable contains a toMany relation. This happens when QuerySQLCache is on.  

Caused by: java.lang.ArrayIndexOutOfBoundsException: Array index out of range: -1
	at org.apache.openjpa.util.ApplicationIds.toPKValues(ApplicationIds.java:83)
	at org.apache.openjpa.jdbc.sql.SelectImpl.wherePrimaryKey(SelectImpl.java:1444)
	at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.load(StoreCollectionFieldStrategy.java:608)
	at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:822)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:682)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)

",,,,,,,,,,,,,,,,,,,,,,04/Dec/08 22:35;faywang;openjpa-815.patch;https://issues.apache.org/jira/secure/attachment/12395339/openjpa-815.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161120,,,Thu Dec 04 23:51:54 UTC 2008,,,,,,,0|i0zafj:,203992,,,,,,,,"04/Dec/08 23:51;faywang;patch is committed to openjpa 1.3.0 r-73477, and trunk r-723480.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
slices: aggregate queries fail if any slice has empty results,OPENJPA-812,12409867,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,fern,fern,04/Dec/08 02:27,09/Mar/10 18:31,14/Mar/19 03:02,09/Dec/08 19:25,2.0.0-M1,,,,,,,,,2.0.0-M1,,,,,slice,,,,,,0,,"NPE when doing aggregate queries.  I can only guess that it's because the results from a slice is null.  Easy fix.  I will attach a very small patch.


2008-12-03 18:14:13,348 [pool-2-thread-2] ERROR com.protrade.fanwars.base.services.FanwarsAppEventHandlerWorker - doRefreshTeamFanBasePoints: Trouble loading TeamFan: <<TeamFanId:TeamFan:8574250>>
<openjpa-2.0.0-SNAPSHOT-r422266:723088M nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Failed to execute query ""select count( this ), max( this.createTime ) from com.protrade.fandom.data.entities.CheerStatus this  where this.teamFan = :p0 AND this.createTime > :p1 AND this.createTime <= :p2 AND this.points > 0"". Check the query syntax for correctness. See nested exception for details. 
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:857)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:779)
        at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:525)
        at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:257)
        at org.apache.openjpa.persistence.QueryImpl.getSingleResult(QueryImpl.java:452)
        at com.protrade.common.persistence.JPAUtil.execute(JPAUtil.java:181)
        at com.protrade.common.persistence.JPAUtil.executeUnique(JPAUtil.java:162)
        at com.protrade.common.persistence.JPADQuery.uniqueResult(JPADQuery.java:32)
        at com.protrade.common.persistence.BaseRootDAOBase.runUniqueQueryNCS(BaseRootDAOBase.java:290)
        at com.protrade.common.persistence.BaseDAOBase.runUniqueQueryNCS(BaseDAOBase.java:132)
        at com.protrade.fandom.data.FandomCoreDAO.getCheerStatusCountLastDate(FandomCoreDAO.java:582)
        at com.protrade.fandom.data.FandomCoreDAO.getTeamFanBasePointsCount(FandomCoreDAO.java:547)
        at com.protrade.fanwars.base.services.FanwarsAppEventHandlerWorker.doRefreshTeamFanBasePoints(FanwarsAppEventHandlerWorker.java:795)
        at com.protrade.fanwars.base.services.FanwarsAppEventHandler$11.run2(FanwarsAppEventHandler.java:270)
        at com.protrade.fanwars.base.services.FanwarsAppEventHandler$FanwarsWorkerRunnable.run(FanwarsAppEventHandler.java:441)
        at com.protrade.common.spring.OpenEMFilter$BindThreadRunnable.run(OpenEMFilter.java:129)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:417)
        at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:269)
        at java.util.concurrent.FutureTask.run(FutureTask.java:123)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:65)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:168)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
        at java.lang.Thread.run(Thread.java:595)
Caused by: java.lang.NullPointerException
        at org.apache.openjpa.slice.jdbc.UniqueResultObjectProvider.max(UniqueResultObjectProvider.java:126)
        at org.apache.openjpa.slice.jdbc.UniqueResultObjectProvider.next(UniqueResultObjectProvider.java:98)
        at org.apache.openjpa.kernel.QueryImpl.singleResult(QueryImpl.java:1292)
        at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1226)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:995)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:848)
        ... 23 more
",,,,,,,,,,,,,,,,,,,,,,04/Dec/08 02:33;fern;urop.diff;https://issues.apache.org/jira/secure/attachment/12395251/urop.diff,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161117,,,Thu Dec 04 02:33:38 UTC 2008,,,,,,,0|i0yw9r:,201698,,,,,,,,04/Dec/08 02:33;fern;small patch to deal with NPE in UniqueResultObjectProvider,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"With Oracle, OpenJPA allows setting non-nullable field to null",OPENJPA-811,12409788,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,dinkar,dinkar,03/Dec/08 18:44,17/Mar/09 16:21,14/Mar/19 03:02,17/Mar/09 16:21,1.2.0,2.0.0-M2,,,,,,,,1.2.1,1.3.0,2.0.0-M2,,,,,,,,,0,,"An entity has a field defined as follows:

@Column(nullable=false)
private Object  nonNullableObject;

Using Oracle, it is possible to set the value of this column to null. OpenJPA will not complain, but will instead store whatever is returned by oracle.sql.BLOB.empty_lob().

An exception should be thrown instead, because the field has been defined as non-nullable.",,,,,,,,,,,,,,,,,,,,,,03/Dec/08 18:46;dinkar;OPENJPA-811.patch;https://issues.apache.org/jira/secure/attachment/12395200/OPENJPA-811.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-03-08 17:59:52.973,,,no_permission,,,,,,,,,,,161116,,,Sun Mar 08 17:59:52 UTC 2009,,,,,,,0|i0z6fr:,203345,,,,,,,,03/Dec/08 18:46;dinkar;Submitting patch provided by Pinaki.,08/Mar/09 17:59;mikedd;Assigning to me to merge fix to 1.3.x. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
slices: basic query is failing on sort..  not sure why,OPENJPA-801,12409567,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,fern,fern,01/Dec/08 18:18,09/Mar/10 18:31,14/Mar/19 03:02,10/Dec/08 12:33,2.0.0-M1,,,,,,,,,2.0.0-M1,,,,,slice,,,,,,0,,"I get this exception when running with slices, but no exception when running without slices.  Not sure why.  Any ideas? Clues?

It looks to be expecting a ""Val"" object, but gets a ""PCPath"" object.



<openjpa-2.0.0-SNAPSHOT-r422266:722060M nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Failed to execute query ""select this from com.protrade.fandom.data.entities.CheerStatus this  where this.teamId = :p0 order by this.createTime desc"". Check the query syntax for correctness. See nested exception for details. 
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:857)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:779)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:525)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:257)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:429)
	at com.protrade.common.persistence.JPAUtil.execute(JPAUtil.java:192)
	at com.protrade.common.persistence.JPAUtil.execute(JPAUtil.java:166)
	at com.protrade.common.persistence.JPAUtil.executeList(JPAUtil.java:151)
	at com.protrade.common.persistence.JPADQuery.list(JPADQuery.java:24)
	at com.protrade.common.persistence.BaseRootDAOBase.runListQueryNCS(BaseRootDAOBase.java:266)
	at com.protrade.common.persistence.BaseDAOBase.runListQueryNCS(BaseDAOBase.java:116)
	at com.protrade.fandom.data.CheersDAO.getLatestCheerStatusByTeam(CheersDAO.java:61)
	at com.protrade.fanwars.base.components.cheer.CheerInbox.setupRender(CheerInbox.java:90)
	at com.protrade.fanwars.base.components.cheer.CheerInbox.setupRender(CheerInbox.java)
	at org.apache.tapestry5.internal.structure.ComponentPageElementImpl$13$1.run(ComponentPageElementImpl.java:490)
	at org.apache.tapestry5.internal.structure.ComponentPageElementImpl.invoke(ComponentPageElementImpl.java:912)
	at org.apache.tapestry5.internal.structure.ComponentPageElementImpl.access$200(ComponentPageElementImpl.java:50)
	at org.apache.tapestry5.internal.structure.ComponentPageElementImpl$13.render(ComponentPageElementImpl.java:494)
	at org.apache.tapestry5.internal.services.RenderQueueImpl.run(RenderQueueImpl.java:72)
	at org.apache.tapestry5.internal.services.PageRenderQueueImpl.render(PageRenderQueueImpl.java:121)
	at $PageRenderQueue_11df3c111bb.render($PageRenderQueue_11df3c111bb.java)
	at $PageRenderQueue_11df3c111b1.render($PageRenderQueue_11df3c111b1.java)
	at org.apache.tapestry5.services.TapestryModule$19.renderMarkup(TapestryModule.java:1208)
	at com.protrade.tapestry5.base.services.GoogleAdManagerServices$GoogleAdManagerMarkupRenderFilter.renderMarkup(GoogleAdManagerServices.java:84)
	at $MarkupRenderer_11df3c111bd.renderMarkup($MarkupRenderer_11df3c111bd.java)
	at com.protrade.tapestry5.base.services.BaseTapestryModule$4.renderMarkup(BaseTapestryModule.java:186)
	at $MarkupRenderer_11df3c111bd.renderMarkup($MarkupRenderer_11df3c111bd.java)
	at com.protrade.tapestry5.base.services.BaseTapestryModule$3.renderMarkup(BaseTapestryModule.java:176)
	at $MarkupRenderer_11df3c111bd.renderMarkup($MarkupRenderer_11df3c111bd.java)
	at com.protrade.facebook.base.services.UnifiedSocialFacebookBaseModule$1.renderMarkup(UnifiedSocialFacebookBaseModule.java:65)
	at $MarkupRenderer_11df3c111bd.renderMarkup($MarkupRenderer_11df3c111bd.java)
	at org.apache.tapestry5.services.TapestryModule$26.renderMarkup(TapestryModule.java:1529)
	at $MarkupRenderer_11df3c111bd.renderMarkup($MarkupRenderer_11df3c111bd.java)
	at com.protrade.tapestry5.base.services.BaseTapestryModule$2.renderMarkup(BaseTapestryModule.java:168)
	at $MarkupRenderer_11df3c111bd.renderMarkup($MarkupRenderer_11df3c111bd.java)
	at org.apache.tapestry5.services.TapestryModule$28.renderMarkup(TapestryModule.java:1566)
	at $MarkupRenderer_11df3c111bd.renderMarkup($MarkupRenderer_11df3c111bd.java)
	at org.apache.tapestry5.services.TapestryModule$27.renderMarkup(TapestryModule.java:1547)
	at $MarkupRenderer_11df3c111bd.renderMarkup($MarkupRenderer_11df3c111bd.java)
	at com.protrade.pageproxy.services.PageProxyModule$1.renderMarkup(PageProxyModule.java:74)
	at $MarkupRenderer_11df3c111bd.renderMarkup($MarkupRenderer_11df3c111bd.java)
	at com.protrade.tapestry5.base.services.BaseTapestryModule$1.renderMarkup(BaseTapestryModule.java:160)
	at $MarkupRenderer_11df3c111bd.renderMarkup($MarkupRenderer_11df3c111bd.java)
	at org.apache.tapestry5.services.TapestryModule$25.renderMarkup(TapestryModule.java:1509)
	at $MarkupRenderer_11df3c111bd.renderMarkup($MarkupRenderer_11df3c111bd.java)
	at $MarkupRenderer_11df3c111b9.renderMarkup($MarkupRenderer_11df3c111b9.java)
	at org.apache.tapestry5.internal.services.PageMarkupRendererImpl.renderPageMarkup(PageMarkupRendererImpl.java:64)
	at $PageMarkupRenderer_11df3c111b7.renderPageMarkup($PageMarkupRenderer_11df3c111b7.java)
	at org.apache.tapestry5.internal.services.PageResponseRendererImpl.renderPageResponse(PageResponseRendererImpl.java:57)
	at $PageResponseRenderer_11df3c1106c.renderPageResponse($PageResponseRenderer_11df3c1106c.java)
	at org.apache.tapestry5.internal.services.PageRenderRequestHandlerImpl.handle(PageRenderRequestHandlerImpl.java:59)
	at com.protrade.facebook.base.services.FacebookAuthFilterImpl.handle(FacebookAuthFilterImpl.java:51)
	at $PageRenderRequestHandler_11df3c1106d.handle($PageRenderRequestHandler_11df3c1106d.java)
	at org.apache.tapestry5.services.TapestryModule$33.handle(TapestryModule.java:1747)
	at $PageRenderRequestHandler_11df3c1106d.handle($PageRenderRequestHandler_11df3c1106d.java)
	at com.protrade.facebook.base.services.FbForceModeFilter.handle(FbForceModeFilter.java:75)
	at $PageRenderRequestHandler_11df3c1106d.handle($PageRenderRequestHandler_11df3c1106d.java)
	at com.protrade.tapestry5.base.services.RequestLogFilter.handle(RequestLogFilter.java:23)
	at $PageRenderRequestHandler_11df3c1106d.handle($PageRenderRequestHandler_11df3c1106d.java)
	at com.protrade.opensocial.base.services.OsForceTypeFilter.handle(OsForceTypeFilter.java:75)
	at $PageRenderRequestHandler_11df3c1106d.handle($PageRenderRequestHandler_11df3c1106d.java)
	at $PageRenderRequestHandler_11df3c1105e.handle($PageRenderRequestHandler_11df3c1105e.java)
	at org.apache.tapestry5.internal.services.PageRenderDispatcher.process(PageRenderDispatcher.java:92)
	at org.apache.tapestry5.internal.services.PageRenderDispatcher.dispatch(PageRenderDispatcher.java:71)
	at $Dispatcher_11df3c11065.dispatch($Dispatcher_11df3c11065.java)
	at $Dispatcher_11df3c11057.dispatch($Dispatcher_11df3c11057.java)
	at org.apache.tapestry5.services.TapestryModule$17.service(TapestryModule.java:1034)
	at org.apache.tapestry5.internal.services.LocalizationFilter.service(LocalizationFilter.java:42)
	at $RequestHandler_11df3c11058.service($RequestHandler_11df3c11058.java)
	at org.apache.tapestry5.internal.services.RequestErrorFilter.service(RequestErrorFilter.java:26)
	at $RequestHandler_11df3c11058.service($RequestHandler_11df3c11058.java)
	at org.apache.tapestry5.services.TapestryModule$3.service(TapestryModule.java:626)
	at $RequestHandler_11df3c11058.service($RequestHandler_11df3c11058.java)
	at org.apache.tapestry5.services.TapestryModule$2.service(TapestryModule.java:616)
	at $RequestHandler_11df3c11058.service($RequestHandler_11df3c11058.java)
	at org.apache.tapestry5.internal.services.StaticFilesFilter.service(StaticFilesFilter.java:85)
	at $RequestHandler_11df3c11058.service($RequestHandler_11df3c11058.java)
	at com.protrade.pageproxy.services.PageProxyServices$PageProxyRequestFilter.service(PageProxyServices.java:265)
	at $RequestHandler_11df3c11058.service($RequestHandler_11df3c11058.java)
	at org.apache.tapestry5.internal.services.CheckForUpdatesFilter$2.invoke(CheckForUpdatesFilter.java:93)
	at org.apache.tapestry5.internal.services.CheckForUpdatesFilter$2.invoke(CheckForUpdatesFilter.java:84)
	at org.apache.tapestry5.ioc.internal.util.ConcurrentBarrier.withRead(ConcurrentBarrier.java:83)
	at org.apache.tapestry5.internal.services.CheckForUpdatesFilter.service(CheckForUpdatesFilter.java:106)
	at $RequestHandler_11df3c11058.service($RequestHandler_11df3c11058.java)
	at $RequestHandler_11df3c1104f.service($RequestHandler_11df3c1104f.java)
	at org.apache.tapestry5.services.TapestryModule$16.service(TapestryModule.java:1012)
	at org.apache.tapestry5.upload.internal.services.MultipartServletRequestFilter.service(MultipartServletRequestFilter.java:44)
	at $HttpServletRequestHandler_11df3c11050.service($HttpServletRequestHandler_11df3c11050.java)
	at org.apache.tapestry5.internal.services.IgnoredPathsFilter.service(IgnoredPathsFilter.java:62)
	at $HttpServletRequestFilter_11df3c1104e.service($HttpServletRequestFilter_11df3c1104e.java)
	at $HttpServletRequestHandler_11df3c11050.service($HttpServletRequestHandler_11df3c11050.java)
	at com.protrade.pageproxy.services.PageProxyServices$PageProxyHttpServletRequestFilter.service(PageProxyServices.java:202)
	at $HttpServletRequestHandler_11df3c11050.service($HttpServletRequestHandler_11df3c11050.java)
	at $HttpServletRequestHandler_11df3c1104c.service($HttpServletRequestHandler_11df3c1104c.java)
	at org.apache.tapestry5.TapestryFilter.doFilter(TapestryFilter.java:179)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1115)
	at com.protrade.unifiedsocial.filters.NoUserSplashPageFilter.doFilter(NoUserSplashPageFilter.java:54)
	at com.protrade.common.web.ProtradeFilter.doFilter(ProtradeFilter.java:50)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1115)
	at com.protrade.unifiedsocial.filters.USSPFilter.doFilter(USSPFilter.java:34)
	at com.protrade.common.web.ProtradeFilter.doFilter(ProtradeFilter.java:50)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1115)
	at com.protrade.common.web.PCachedSessionStoreFilter.doFilter(PCachedSessionStoreFilter.java:39)
	at com.protrade.common.web.ProtradeFilter.doFilter(ProtradeFilter.java:50)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1115)
	at com.protrade.pageproxy.filter.PageProxyAssetFilter.doFilter(PageProxyAssetFilter.java:53)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1115)
	at com.protrade.fanwars.base.filters.FandomContextFilter.doFilter(FandomContextFilter.java:56)
	at com.protrade.common.web.ProtradeFilter.doFilter(ProtradeFilter.java:50)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1115)
	at com.protrade.common.spring.OpenDSFilter$1.run(OpenDSFilter.java:43)
	at com.protrade.common.spring.OpenEMFilter$BindThreadRunnable.run(OpenEMFilter.java:129)
	at com.protrade.common.spring.OpenEMFilter$BindThreadRunnable.run(OpenEMFilter.java:129)
	at com.protrade.common.spring.OpenDSFilter.doFilter(OpenDSFilter.java:54)
	at com.protrade.common.web.ProtradeFilter.doFilter(ProtradeFilter.java:50)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1115)
	at com.protrade.common.web.P3PFilter.doFilter(P3PFilter.java:15)
	at com.protrade.common.web.ProtradeFilter.doFilter(ProtradeFilter.java:50)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1115)
	at com.protrade.common.web.CharsetFilter.doFilter(CharsetFilter.java:34)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1115)
	at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:361)
	at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)
	at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:181)
	at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:766)
	at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:417)
	at org.mortbay.jetty.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:230)
	at org.mortbay.jetty.handler.HandlerCollection.handle(HandlerCollection.java:114)
	at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)
	at org.mortbay.jetty.Server.handle(Server.java:324)
	at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:534)
	at org.mortbay.jetty.HttpConnection$RequestHandler.content(HttpConnection.java:879)
	at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:741)
	at org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:213)
	at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:403)
	at org.mortbay.io.nio.SelectChannelEndPoint.run(SelectChannelEndPoint.java:409)
	at org.mortbay.thread.QueuedThreadPool$PoolThread.run(QueuedThreadPool.java:522)
Caused by: java.lang.ClassCastException: org.apache.openjpa.jdbc.kernel.exps.PCPath
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.getOrderingValue(ExpressionStoreQuery.java:734)
	at org.apache.openjpa.kernel.OrderingMergedResultObjectProvider.getOrderingValue(OrderingMergedResultObjectProvider.java:62)
	at org.apache.openjpa.lib.rop.MergedResultObjectProvider.next(MergedResultObjectProvider.java:172)
	at org.apache.openjpa.lib.rop.RangeResultObjectProvider.next(RangeResultObjectProvider.java:102)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:35)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1233)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:995)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:848)
	... 136 more
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-12-09 20:16:22.516,,,no_permission,,,,,,,,,,,161107,,,Tue Dec 09 20:16:22 UTC 2008,,,,,,,0|i0ywgn:,201729,,,,,,,,"02/Dec/08 21:10;fern;Let me do a cleaner write up:

It's complaining about the ordering value for some reason.  The code that fails is copied below.  It is trying to acquire the ""ordering value"" used in the query.  It looks like it's expecting a ""Val"" object that it calls ""evaluate"" on to get the actual ordering value.  But in Slices, it gets a ""PCPath"" object.  Not sure how this is happening, but I guess that this method should just be fixed to work with either ""Val"" or ""Path"" objects.  I would propose a patch, but I don't know how to evaluate a Path to get the value it points to..

ExpressionStoreQuery$DataStoreExecutor.getOrderingValue :
......
            // use the parsed ordering expression to extract the ordering value
            Val val = (Val) _inMemOrdering[orderIndex];
            return val.evaluate(resultObject, resultObject,
                q.getContext().getStoreContext(), params);
        }
....","02/Dec/08 21:44;fern;This is confusing me.

I'm reviewing the code, and it looks like _inMemOrdering is a copy of QueryExpressions.ordering.  Then I searched the whole code base for who modified QueryExpressions.ordering and I only found one place: JPQLQueryExpressionBuilder.evalOrderingClauses (code below).  But that's weird because it looks like this method will ALWAYS fill the ""odering"" field with PCPath objects.  But reviewing the rest of the code, it looks like everyone expects a ""Val"" object.  So I'm not sure who coverts and replaces these ""PCPath"" objects with ""Val"" objects.

Please, any clues??","04/Dec/08 03:04;fern;So I reviewed the code again, and for some reason I must have been blind before, but it looks like PCPath does indeed implement the ""Val"" interface.  So you should be able to cast  ""PCPath"" to a ""Val"".

So sadly, this might be some sort of class loading issue.. and I'm not sure how this could come about.  The openjpa libraries are included only by my WEB-INF/lib, so there should only be one classloader involved right?  I am running with Jetty, but that should not be an issue.

Is OpenJPA doing something funky with class loaders and Plugins??","04/Dec/08 23:48;fern;I am still at a loss, any help would be appreciated; here are more queries that are failing.. all for the same root exception

select this from com.protrade.fandom.data.entities.fanwire.ArticleLink this  where this.team = :p0 AND this.active = :p1 AND this.createTime > :p2 order by this.numBumps desc, this.createTime desc

select this from com.protrade.fandom.data.entities.fanwire.ArticleLinkComment this  where this.articleLink = :p0 AND this.active = :p1 order by this.createTime asc



.....
.....
Caused by: java.lang.ClassCastException: org.apache.openjpa.jdbc.kernel.exps.PCPath
at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.getOrderingValue(ExpressionStoreQuery.java:734)
at org.apache.openjpa.kernel.OrderingMergedResultObjectProvider.getOrderingValue(OrderingMergedResultObjectProvider.java:62)
at org.apache.openjpa.lib.rop.MergedResultObjectProvider.next(MergedResultObjectProvider.java:172)
at org.apache.openjpa.lib.rop.RangeResultObjectProvider.next(RangeResultObjectProvider.java:102)
at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:35)
at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1233)
at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:995)
at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:848)
... 136 more 
.....
.....","09/Dec/08 20:16;ppoddar@apache.org;I have committed a change 724856 -- which makes PCPath a CandidatePath. 
This is a departure from the common practice of other JDBC expressions *not* inheriting from equivalent kernel expressions. 
I am assuming that there must be a strong reason behind this decision of not extending  kernel expressions. 
However, as the test corpus did not complain of the change and extraction of ordering value from an instance is non-trivial code in CandiddatePath, I have committed the change, but with some reservation. 

Will rollback on any objection to this change.

More importantly, will someone illuminate why JDBC expressions do not inherit kernel expressions?    ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"slices: can not handle multiple projections in one query ( select count(*), max(fieldA) .......)",OPENJPA-799,12409520,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,fern,fern,01/Dec/08 00:06,09/Mar/10 18:31,14/Mar/19 03:02,20/Dec/08 06:57,2.0.0-M1,,,,,,,,,2.0.0-M1,,,,,slice,,,,,,0,,"I got this exception while running my program, and eventually I figured out that the existing UniqueResultObjectProvider that was doing the aggregation would loop through the result sets, but would do it one per column.. (twice in my case), but it would not reset the resultsets after each loop...

I will look at just writing it from scratch (calling it AggregatingResultObjectProvider, to be closer to what it actually does ).  I'll submit a patch soon.


<openjpa-2.0.0-SNAPSHOT-r422266:721073M nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Failed to execute query ""select count( this ), max( this.createTime ) from com.protrade.fandom.data.entities.CheerStatus this  where this.teamFan = :p0 AND this.createTime > :p1 AND this.createTime <= :p2 AND this.points > 0"". Check the query syntax for correctness. See nested exception for details. 
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:857)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:779)
        at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:525)
        at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:257)
        at org.apache.openjpa.persistence.QueryImpl.getSingleResult(QueryImpl.java:452)
        at com.protrade.common.persistence.JPAUtil.execute(JPAUtil.java:181)
        at com.protrade.common.persistence.JPAUtil.executeUnique(JPAUtil.java:162)
        at com.protrade.common.persistence.JPADQuery.uniqueResult(JPADQuery.java:32)
        at com.protrade.common.persistence.BaseRootDAOBase.runUniqueQueryNCS(BaseRootDAOBase.java:290)
        at com.protrade.common.persistence.BaseDAOBase.runUniqueQueryNCS(BaseDAOBase.java:132)
        at com.protrade.fandom.data.FandomCoreDAO.getCheerStatusCountLastDate(FandomCoreDAO.java:567)
        at com.protrade.fandom.data.FandomCoreDAO.getTeamFanBasePointsCount(FandomCoreDAO.java:532)
        at com.protrade.fanwars.base.services.FanwarsAppEventHandlerWorker.doRefreshTeamFanBasePoints(FanwarsAppEventHandlerWorker.java:794)
        at com.protrade.fanwars.base.services.FanwarsAppEventHandler$11.run2(FanwarsAppEventHandler.java:270)
        at com.protrade.fanwars.base.services.FanwarsAppEventHandler$FanwarsWorkerRunnable.run(FanwarsAppEventHandler.java:441)
        at com.protrade.common.spring.OpenEMFilter$BindThreadRunnable.run(OpenEMFilter.java:129)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:417)
        at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:269)
        at java.util.concurrent.FutureTask.run(FutureTask.java:123)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:65)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:168)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
        at java.lang.Thread.run(Thread.java:595)
Caused by: java.sql.SQLException: After end of result set
        at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1055)
        at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:956)
        at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:926)
        at com.mysql.jdbc.ResultSetImpl.checkRowPos(ResultSetImpl.java:815)
        at com.mysql.jdbc.ResultSetImpl.getObject(ResultSetImpl.java:4725)
        at org.apache.openjpa.lib.jdbc.DelegatingResultSet.getObject(DelegatingResultSet.java:266)
        at org.apache.openjpa.jdbc.sql.DBDictionary.getObject(DBDictionary.java:756)
        at org.apache.openjpa.jdbc.sql.ResultSetResult.getObjectInternal(ResultSetResult.java:445)
        at org.apache.openjpa.jdbc.sql.AbstractResult.getObject(AbstractResult.java:689)
        at org.apache.openjpa.jdbc.kernel.exps.UnaryOp.load(UnaryOp.java:116)
        at org.apache.openjpa.jdbc.kernel.ProjectionResultObjectProvider.getResultObject(ProjectionResultObjectProvider.java:78)
        at org.apache.openjpa.slice.jdbc.UniqueResultObjectProvider.next(UniqueResultObjectProvider.java:92)
        at org.apache.openjpa.kernel.QueryImpl.singleResult(QueryImpl.java:1292)
        at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1226)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:995)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:848)
        ... 23 more
",,,,,,,,,,,,,,,,,,,,,,01/Dec/08 00:38;fern;slices_aggregates.diff;https://issues.apache.org/jira/secure/attachment/12394983/slices_aggregates.diff,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161105,,,Mon Dec 01 00:38:37 UTC 2008,,,,,,,0|i0ywbj:,201706,,,,,,,,"01/Dec/08 00:38;fern;this is the patch to fix the broken UniqueResultObjectProvider.

created AggregatingResultObjectProvider, and changed DistributedStoreQuery to use this new class.

(also lots of formatting changes)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
slices does can not work with sequences properly (no adding objects?),OPENJPA-798,12409470,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,fern,fern,29/Nov/08 03:38,09/Mar/10 18:31,14/Mar/19 03:02,26/Feb/09 17:19,2.0.0-M2,,,,,,,,,2.0.0-M2,,,,,slice,,,,,,0,,"I can't believe that this was a bug that was existent.. but essentially once I got slices fixed up (see many preceding bugs), it all seems to work fine, except for I can't persist new objects.  Essentially the DistributedResultSet is very very buggy, and not implemented properly, so TableJDBCSeq can't do it's job properly ( since it's using the DistributedConnection/PreparedStatement/RestulSet ).

I just wanted to file the bug to get the word out.. but I basically have to re-write the whole class, So I guess I'll be submitting a patch tomorrow.

The first bug is that it will drop out the first row from every ResultSet (one per db).  It does this because as ResultSets are added, it calls ""first"", but then most people (and TableJDBCSeq), assume that it's ""beforeFirst"", so they call ""next"" expecting it to move to ""first"".  So in TableJDBCSeq, it goes beyond the first row, returning null.. and TableJDBCSeq thinks that the query actually returned an empty RestultSet and tries to act accordingly...

and as you review DistributedResultSet, you see lots and lots of bad logic, missing code, etc.  It's a pretty hacked together implementation of a ""Distributed ResultSet"".... need a proper version..",,,,,,,,,,,,,,,,,,,,,,30/Nov/08 23:04;fern;slices-resultset.diff;https://issues.apache.org/jira/secure/attachment/12394978/slices-resultset.diff,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161104,,,Sun Nov 30 23:04:38 UTC 2008,,,,,,,0|i0ywjj:,201742,,,,,,,,"30/Nov/08 23:04;fern;big patch to fix up badly broken DistributedResultSet.

Because it was a big re-write I created a DistributedResultSet2 and DelegatingResultSet2.  Then changed DistributedTemplate and DistributedPreparedStatement to use the new DistributedResultSet2.

It works now, I can now persist objects.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
slices does not work with QueryCompilationCache,OPENJPA-797,12409467,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,fern,fern,29/Nov/08 01:38,22/Apr/10 20:32,14/Mar/19 03:02,15/Mar/10 21:30,2.0.0-M2,,,,,,,,,,,,,,slice,,,,,,0,,"When you turn on QueryCompilationCache, slices does not work.  This is because the cached compiled Query keeps pointers to the previous Brokers that the queries were originally built against..  then later trying to execute the query against those already closed brokers..",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161103,,,Sat Nov 29 01:39:55 UTC 2008,,,,,,,0|i0yw4f:,201674,,,,,,,,"29/Nov/08 01:39;fern;documentation should be updated to mention this minor issue.

I have already spent so much time wading through that code to find this bug, I have not spent time trying to see if I can fix the DistributedStoreQuery, to support being cached.. so let's just way it's not supported at the moment..",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"enhancer throws an exception when parsing column name ""first.name"" because it thinks 'first' is a table name",OPENJPA-795,12409401,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,fancy,maojianfeng,maojianfeng,27/Nov/08 16:41,09/Mar/10 18:31,14/Mar/19 03:02,09/Dec/08 18:56,1.2.0,,,,,,,,,1.3.0,2.0.0-M2,,,,jdbc,,,,,,0,,"IBM U2JPA is a JPA implementation based on OpenJPA for IBM  U2 Databases.  IBM U2 Databases allow the use of '.' in the column names, such as ""FIRST.NAME', ""LAST.NAME"", ""PURCHASE.DATE"".  This causes the enhancer to exception out when parsing these column names, as shown below.  We have tried, in our implementation,  to change the catalogSeparator to different values than '.' to prevent the enhancer from breaking the above names into 'tablename'.'columnname'. But nothing worked.  Later i found the following code in openjpa\jdbc\meta\mappinginfo.java, clearly the separator is hardcoded as '.'.  I set the priority of this issue to 'critical' because this problem has severely impacted the adoption of U2JPA by our customers. 

          mergeColumn(.........) 
          {
                 int dotIdx = colName.lastIndexOf('.');
                 if (dotIdx == 0)
                            colName = colName.substring(1);
                 else if (dotIdx != -1) {
                           findTable(context, colName.substring(0, dotIdx), table,
                                null, null);
                           colName = colName.substring(dotIdx + 1);
                 }
                .............
        } 


class U2Dictionary extends DBDictionary {
	private ArrayList<U2DictRecord> u2fields = new ArrayList<U2DictRecord>();

	U2Dictionary() {
		platform = ""IBM U2"";
		catalogSeparator = "":"";
	}
..........

@Entity
@Table(name=""CUSTOMER"")
public class Customer implements Serializable {

	@Id
	@Column(name=""@ID"")
	private String _id;

	@Column(name=""FIRST.NAME"")
	private String name;

	public Customer(){};


	public String get_id() {
		return _id;
	}

	public void set_id(String _id) {
		this._id = _id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

}

Exception in thread ""main"" <openjpa-1.2.0-r422266:683325 fatal user error> org.apache.openjpa.persistence.ArgumentException: When mapping ""u2u.u2jpa.demo1.Customer.name"" to table ""CUSTOMER"", found a column mapped to illegal table ""FIRST"".
	at org.apache.openjpa.jdbc.meta.MappingInfo.findTable(MappingInfo.java:743)
	at org.apache.openjpa.jdbc.meta.MappingInfo.mergeColumn(MappingInfo.java:583)
	at org.apache.openjpa.jdbc.meta.MappingInfo.createColumns(MappingInfo.java:518)
	at org.apache.openjpa.jdbc.meta.ValueMappingInfo.getColumns(ValueMappingInfo.java:143)
	at org.apache.openjpa.jdbc.meta.strats.StringFieldStrategy.map(StringFieldStrategy.java:79)
	at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:121)
	at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:80)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:454)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:419)
	at org.apache.openjpa.jdbc.meta.ClassMapping.resolveNonRelationMappings(ClassMapping.java:855)
	at org.apache.openjpa.jdbc.meta.MappingRepository.prepareMapping(MappingRepository.java:339)
	at org.apache.openjpa.meta.MetaDataRepository.preMapping(MetaDataRepository.java:662)
	at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:549)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:308)
	at org.apache.openjpa.kernel.BrokerImpl.newObjectId(BrokerImpl.java:1114)
	at org.apache.openjpa.kernel.DelegatingBroker.newObjectId(DelegatingBroker.java:268)
	at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:451)
	at u2u.u2jpa.demo1.Demo1Main.main(Demo1Main.java:24)

","Windows XP, Eclipse 3.4 SR1, OpenJPA-1.2.0,  IBM U2JPA-1.0.0, IBM U2 databases",,,,,,,,,,,,,,,,,,,,,09/Dec/08 14:15;fancy;OPENJPA-795.patch;https://issues.apache.org/jira/secure/attachment/12395649/OPENJPA-795.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-12-06 01:14:25.565,,,no_permission,,,,,,,,,,,161101,,,Tue Dec 09 18:56:29 UTC 2008,,,,,,,0|i0ywif:,201737,,,,,,,,"06/Dec/08 01:14;fancy;Hi Jianfeng,
If shcmea name is 'TEST',  table name is 'EMPLOYEE',  column name is 'FIRST.LAST',
is the fully qualified column name in U2 is following or not  (using ':' as the catalog separator in between schema and table names; and table and column names:

    TEST:EMPLOYEE:FIRST.LAST

please verify before I can provide you with a patch.

Catalina ","09/Dec/08 14:15;fancy;Jianfeng,
could you verify if attached patch fix the problem ?
This patch can be applied against 1.2.x or 1.3.x branches.

Catalina","09/Dec/08 18:56;fancy;patch committed under  r724815 ( 1.3.x branch )  , r724817 (trunk).
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
issues with closing/opening entity manager (slices) (can't seem to be able to create multiple entityManagers ),OPENJPA-794,12409358,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,fern,fern,27/Nov/08 00:16,09/Mar/10 18:08,14/Mar/19 03:02,20/Dec/08 07:01,2.0.0-M1,,,,,,,,,2.0.0-M1,,,,,slice,,,,,,0,,"So, for each of my web requests I open an entitymanager at the begining, and close it at the end, something like this:

EntityManager pm = pmf.createEntityManager();
try {
 chain.filter(...);
}
finally {
 pm.close();
}


And this works perfectly without slices.  But when I turn on slices, this fails.  The first request works fine, but the second requests complains that the EntityManager has already been closed.  So it seems to be caching the EntityManager from the previous request...  can someone please help me figure out how to fix this??

I'll attach the log.",,,,,,,,,,,,,,,,,,,,,,27/Nov/08 00:21;fern;log.txt;https://issues.apache.org/jira/secure/attachment/12394793/log.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161100,,,Mon Dec 01 00:49:44 UTC 2008,,,,,,,0|i0ywhr:,201734,,,,,,,,"27/Nov/08 00:21;fern;A log of the failing run.  The first web request works fine ( you can see copious amounts of logs as it gets objects, etc etc ).  The second request fails from the go and every db access after, complaining that the EntityManager has already been closed, even though this was a fresh request.

that request ends around: 2008-11-26 16:18:17,570

the second request starts right after at: 2008-11-26 16:18:34,334
","27/Nov/08 00:23;fern;And I am using this code to do the binding/unbinding of the entity manager.  It is a very small chance that this interacts with the slices code, but I'm putting it up just in case.  It should be very close to what Spring does in it's OpenView filter code...



	public static void bindThread( EntityManagerFactory pmf ) {
		// logger.debug( ""bindThread( "" + pmf + "" )"" );
		if ( TransactionSynchronizationManager.hasResource( pmf ) ) {
			logger.error( ""FOUND Entity MANAGER IN THREAD"" );
			unbindThread( pmf );
		}
		EntityManager pm = pmf.createEntityManager();
		TransactionSynchronizationManager.bindResource( pmf, new EntityManagerHolder( pm ) );
	}

	public static void unbindThread( EntityManagerFactory pmf ) {
		// logger.debug( ""unbindThread( "" + pmf + "" )"" );
		if ( TransactionSynchronizationManager.hasResource( pmf ) ) {
			EntityManagerHolder holder = (EntityManagerHolder) TransactionSynchronizationManager.unbindResource( pmf );
			EntityManager pm = holder.getEntityManager();
			pm.close();
		}
	}
","01/Dec/08 00:49;fern;the root cause of this bug is that slices does not work with QueryCompilationCache..

Issue OPENJPA-797, is asking for this restriction to be posted in the Documentation.

This bug can either be closed (accepting the restriction), or be kept open to see if we can change the code to lift this restriction..

I would say close this one for now (duplicate of 797).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
An entity persist may fail when @MappedSupercalss is specified. ,OPENJPA-792,12409296,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,turagasandy,turagasandy,26/Nov/08 19:15,17/Sep/12 20:31,14/Mar/19 03:02,09/Dec/08 19:53,2.0.0-M2,,,,,,,,,1.3.0,2.0.0-M2,,,,jpa,,,,,,0,,"When @MappedSuperClass annotation is specified and if we try to persist the same key of the subclasses which are entities of the Mappedsuperclass , Persist fails which is not the expected behavior.

import java.util.Date;


import javax.persistence.Id;
import javax.persistence.Column;

@javax.persistence.MappedSuperclass
public class Party {
    
 
    protected Long PartyId;
    protected String Status;
    protected String ArchiveStatus;
    protected Date CreateDate;
    
    @Id
    public Long getPartyId() {
        return this.PartyId;
    }
    
    public void setPartyId(Long id){
        this.PartyId = id;
    }
    
    public void setArchiveStatus(String s){
        this.ArchiveStatus = s;
        
    }
    
    public void setStatus(String s) {
        this.Status = s;
    }
    
    @Column
    public String getStatus() {
        return this.Status;
    }
    
    @Column
    public String getArchiveStatus() {
        return this.ArchiveStatus;
    }
    
    public void setCreateDate(Date d) {
        this.CreateDate = d;
    }
    
    @Column
    public Date getCreateDate() {
        return this.CreateDate;
    }
}


import java.util.List;


import javax.persistence.DiscriminatorValue;
import javax.persistence.Entity;
import javax.persistence.Inheritance;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.InheritanceType;

import org.apache.openjpa.persistence.jdbc.DiscriminatorStrategy;


@Entity
@Table(name = ""Site"")
 public class Site  extends Party implements java.io.Serializable {

       private static final long serialVersionUID = 1L;
     
       private String SiteName;
       private String SiteDescription;
     /*  private List<Store> stores;
      
       @OneToMany(mappedBy=""site"",  cascade=CascadeType.ALL, fetch=FetchType.LAZY, 
         targetEntity=Store.class)
       public List<Store> getStores() {
             return stores;
       }
     
      public void setStores(List<Store> storeList){
          this.stores = storeList;
      }*/
     public void setSiteName(String s) {
         this.SiteName = s;
     }
     
     public String getSiteName(){
         return this.SiteName;
     }
     
     public void setSiteDescription(String s) {
         this.SiteDescription = s;
     }
     
     public String getSiteDescription() {
         return this.SiteDescription;
     }
 }


import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

@Entity
@Table(name = ""Store"")
 public class Store extends Party implements java.io.Serializable {

       private static final long serialVersionUID = 1L;
       private String StoreName;
       private String StoreDescription;
       
       private Site site;
       private Long SiteId;
      
       @ManyToOne( fetch = FetchType.LAZY,  cascade = CascadeType.ALL, 
               targetEntity=Site.class)
       @JoinColumn(name = ""Store.SiteId"",
       referencedColumnName=""site.PartyId"", nullable = false, insertable = true,
       updatable = true)
       
       public Site getSite() {
             return site;
       }
       
       public void setSite(Site s) {
           this.site = s;
           
       }
       
       public void setStoreName(String s) {
           this.StoreName = s;
       }
       
       public String getStoreName() {
           return this.StoreName;
       }
       
       public void setStoreDescription(String s){
           this.StoreDescription = s;
       }
       
       public String getStoreDescription(){
           return this.StoreDescription;
       } 
       
       
       public void setSiteId(Long id) {
           this.SiteId = id;
       }
       
       public Long getSiteId() {
           return this.SiteId;
       }
       
 }

TestCase follows:

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

import lazy_fetch.bean.Site;
import lazy_fetch.bean.Store;

public class TestLazyFetch {
    
    public static EntityManagerFactory emf = null;
    public static Long pkey = new Long (1502);
    
    public static void main(String[] args) {
        
        emf = Persistence.createEntityManagerFactory(""LazyFetch"");
       
        createSite();
        System.out.println(""Done creating Site"");
        createStore();
        System.out.println(""Done creating Store"");
       // getStoreWithSite();
        
    }
    
    public static void getStoreWithSite() {
        EntityManager em = emf.createEntityManager();
        Store store = em.find(Store.class, pkey);
        System.out.println(""store ="" + store);
       // Site site = store.getSite();
      //  System.out.println(""site ="" + site);
   }
   
    public static void createSite() {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();
        
        Site s = new Site();
        s.setPartyId(pkey);
        s.setSiteName(""San Jose"");
        s.setSiteDescription(""San Jose site"");
        s.setStatus(""2"");
        s.setArchiveStatus(""2"");
        s.setCreateDate(new Date());
        
        em.persist(s);
        em.getTransaction().commit();
        em.close();
    }
    
    public static void createStore() {
        
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();
         
         Site site = em.find(Site.class, pkey);
         
          Store store = new Store();
          store.setPartyId(pkey);
          store.setStoreDescription(""storeDescription"");
          store.setStoreName(""storeName"");
          store.setStatus(""1"");
          store.setArchiveStatus(""1"");
          store.setCreateDate(new Date());
          store.setSiteId(site.getPartyId());
          store.setSite(site);
          
       //  List<Store> stores = new ArrayList<Store>();
        //  stores.add(store);
       //   site.setStores(stores);

          em.persist(store);
          em.getTransaction().commit();
    }
    

}

47  LazyFetch  INFO   [main] openjpa.Runtime - Starting OpenJPA 2.0.0-SNAPSHOT
125  LazyFetch  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.DB2Dictionary"".
Exception in thread ""main"" <openjpa-2.0.0-SNAPSHOT-runknown nonfatal store error> org.apache.openjpa.persistence.EntityExistsException: An object of type ""lazy_fetch.bean.Store"" with oid ""lazy_fetch.bean.Party-1502"" already exists in this context; another cannot be persisted.
FailedObject: lazy_fetch.bean.Store@9c609c6
	at org.apache.openjpa.kernel.BrokerImpl.checkForDuplicateId(BrokerImpl.java:4756)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2445)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2281)
	at org.apache.openjpa.kernel.DelegatingBroker.persist(DelegatingBroker.java:1021)
	at org.apache.openjpa.persistence.EntityManagerImpl.persist(EntityManagerImpl.java:645)
	at lazy_fetch.tests.TestLazyFetch.createStore(TestLazyFetch.java:77)
	at lazy_fetch.tests.TestLazyFetch.main(TestLazyFetch.java:25)


",,,,,,,,,,,,,,,,,,,,,,04/Dec/08 18:56;turagasandy;openjpa-792.patch;https://issues.apache.org/jira/secure/attachment/12395309/openjpa-792.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-12-08 21:29:31.505,,,no_permission,,,,,,,,,,,161098,,,Mon Sep 17 20:31:04 UTC 2012,,,,,,,0|i0z2i7:,202708,,,,,,,,"26/Nov/08 19:57;turagasandy;Hi all,

         I am working on this issue and I will update patch soon. (I will try to upload this today if not I will upload the patch the after the thanksgiving)

Thanks
Sandhya","04/Dec/08 18:56;turagasandy;Hi All,

      Please find the attached patch that has a small modification in PCEnhancer.java and test cases.  When @MappedSuperClass annotation is specified, the bytecode for the  AddNewobjectIdInstanceMethod() in the enhancer should be looking for This.getClass() instead of the classname. 
I changed that part. This change resolves the issue of not able to persist same keys of the subclasses when MappedSuperClass annotation is specified. 

Thanks
Sandhya Turaga

","08/Dec/08 21:29;faywang;patch is committed to trunk r724490,  and openjpa 1.3.x r724491.","26/Jun/09 03:53;openjpa1388;I need the fix as I am hitting it in my project.

Is there a version 1.3.0 build I can download ? Could not find it in the download page.

Thanks","26/Jun/09 11:33;drwoods;Neither 1.3.0 nor 2.0.0 have been released yet.
You can download the assembly from the latest nightly build of 1.3.0-SNAPSHOT from -
http://people.apache.org/repo/m2-snapshot-repository/org/apache/openjpa/apache-openjpa/1.3.0-SNAPSHOT/
Or the latest 2.0.0-SNAPSHOT build from -
http://people.apache.org/repo/m2-snapshot-repository/org/apache/openjpa/apache-openjpa/2.0.0-SNAPSHOT/
","26/Jun/09 11:52;drwoods;Give it about an hour and the published build content will be updated under -
http://openjpa.apache.org/builds/1.3.0-SNAPSHOT/
","26/Jun/09 18:32;mikedd;Hi Ben,

The information was there (on the downloads page) but it wasn't terribly intuitive. I've added direct links to the snapshot repository on people.apache.org for all the versions that I publish (same links that Donald posted). 

Thanks for bringing it up, and thanks Donald for posting it in a more intuitive place. ","17/Sep/12 19:05;rogerkeays;I've hit this bug in OpenJPA 2.0.0 doing a merge operation, similar to what is described in https://issues.apache.org/jira/browse/OPENJPA-1671

Trying to reproduce it now.","17/Sep/12 20:31;rogerkeays;I can reproduce my problem and opened a separate bug for it since it seems to be related to serialization.

https://issues.apache.org/jira/browse/OPENJPA-2262",,,,,,,,,,,,,,,,,,,,,,,,,,,,
possible NPE,OPENJPA-789,12409284,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,ppoddar@apache.org,fern,fern,26/Nov/08 17:42,09/Mar/10 18:31,14/Mar/19 03:02,20/Oct/09 05:13,2.0.0-M2,,,,,,,,,2.0.0-M3,,,,,kernel,,,,,,0,,"Still reviewing code.

This time in kernel/QueryImpl.java.  You see that ""assertNotSerialized()"" method, if you go look at that, it just checks to see if ""_broker == null"", but just the line before that method call, we use ""_broker.beginOperation(true)"".  So the check happens a second too late to prevent an NPE.  I think that assertNotSerialized should be moved up to be the first line in the method.  No sense doing any work what so ever, if we don't have a broker.


NOW:
    private Object execute(int operation, Map params) {
        if (params == null)
            params = Collections.EMPTY_MAP;

        lock();
        try {
            _broker.beginOperation(true);
            try {
                assertNotSerialized();
                assertOpen();
....

TO:

    private Object execute(int operation, Map params) {
        assertNotSerialized();
        if (params == null)
            params = Collections.EMPTY_MAP;

        lock();
        try {
            _broker.beginOperation(true);
            try {
                assertOpen();
....

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161095,,,2008-11-26 17:42:11.0,,,,,,,0|i1drjb:,288558,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
slices query.getSingleResult is broken,OPENJPA-787,12409239,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,fern,fern,26/Nov/08 03:15,09/Mar/10 18:31,14/Mar/19 03:02,20/Dec/08 06:56,2.0.0-M2,,,,,,,,,2.0.0-M2,,,,,slice,,,,,,0,,"Pinaki Poddar wrote:
>   Query.getSingleResult() is badly broken (or, more precisely non-existent). 
>   Currently, use the workaround for Query.getSingleResult() i.e.
>     Query.getResultList().get(0) ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161093,,,Wed Nov 26 22:34:34 UTC 2008,,,,,,,0|i0yvvr:,201635,,,,,,,,"26/Nov/08 22:34;fern;very simple patch.  should fix this issue.


--- openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java        (revision 721000)
+++ openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java        (working copy)
@@ -147,10 +147,10 @@
                }
                boolean[] ascending = getAscending(q);
                boolean isAscending = ascending.length > 0;
-               boolean isUnique    = q.getContext().isUnique();
+               boolean isAggregate = q.getContext().isAggregate();
                boolean hasRange    = q.getContext().getEndRange() != Long.MAX_VALUE;
                ResultObjectProvider result = null;
-               if (isUnique) {
+               if (isAggregate) {
                    result = new UniqueResultObjectProvider(tmp, q, 
                            getQueryExpressions());
                } else if (isAscending) {




But though it looks like it's working better.  Now I'm hitting another bug, that it looks like somehow the old EnityManager/Broker is being reused across requests.  I know this because it works fine for first request, but second request complains that the Broker is already closed.  So I might be opening up a new bug for that.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Exception is thrown during retrieval of an entity which contains a persistent collection of embeddable,OPENJPA-777,12408961,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,faywang,faywang,21/Nov/08 00:49,09/Mar/10 18:31,14/Mar/19 03:02,18/Dec/08 15:52,1.2.0,1.2.1,1.3.0,2.0.0-M2,,,,,,1.2.1,1.3.0,2.0.0-M2,,,,,,,,,0,,"When an entity contains a persistent collection of embeddables and the embeddable has a to-One relation in it, the following exception is thrown during retrieval of this entity:

<openjpa-1.2.1-SNAPSHOT-r422266:712930M fatal general error> org.apache.openjpa.persistence.PersistenceException: org.apache.openjpa.persistence.jdbc.annotations.PColl_EntityA.embedCollection.org.apache.openjpa.persistence.jdbc.annotations.PColl_EntityB.m2oC
	at org.apache.openjpa.kernel.StateManagerImpl.setExtraFieldData(StateManagerImpl.java:721)
	at org.apache.openjpa.kernel.StateManagerImpl.setIntermediate(StateManagerImpl.java:698)
	at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.loadEmbedded(RelationFieldStrategy.java:968)
	at org.apache.openjpa.jdbc.meta.strats.EmbedValueHandler.toObjectValue(EmbedValueHandler.java:165)
	at org.apache.openjpa.jdbc.meta.strats.ElementEmbedValueHandler.toObjectValue(ElementEmbedValueHandler.java:132)
	at org.apache.openjpa.jdbc.meta.strats.HandlerStrategies.loadObject(HandlerStrategies.java:202)
	at org.apache.openjpa.jdbc.meta.strats.HandlerCollectionTableFieldStrategy.loadElement(HandlerCollectionTableFieldStrategy.java:78)
	at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.load(StoreCollectionFieldStrategy.java:611)
	at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:819)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:626)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:2921)
	at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:2999)
	at org.apache.openjpa.kernel.StateManagerImpl.beforeAccessField(StateManagerImpl.java:1493)
",,,,,,,,,,,,,,,,,,,,,,21/Nov/08 01:00;faywang;openjpa-777-testcase.patch;https://issues.apache.org/jira/secure/attachment/12394381/openjpa-777-testcase.patch,21/Nov/08 00:59;faywang;openjpa-777.patch;https://issues.apache.org/jira/secure/attachment/12394380/openjpa-777.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161083,,,2008-11-21 00:49:22.0,,,,,,,0|i0za9z:,203967,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Executing native queries with Firebird,OPENJPA-774,12408793,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,doubleaxe,doubleaxe,19/Nov/08 03:40,23/Mar/10 18:32,14/Mar/19 03:02,03/Mar/10 15:42,1.1.0,1.2.0,1.3.0,2.0.0-M2,,,,,,1.3.0,2.0.0-beta3,,,,sql,,,,,,0,,"Native queries cannot be executed with Firebird database. The following exception occur:
DEBUG - Log4JLogFactory$LogAdapter.trace(72) | Executing query: [insert into ANAGRAFICHE (COD_TITOLARE, NOME, CODICE_FISCALE, DATA_NASCITA) values (?, ?, ?, ?)] with parameters: {2=xz0FEdrz92sd, 0=43, 3=Tue Aug 30 00:00:00 UTC 1644, 1=B95JHSkDV}
WARN - GeronimoConnectionEventListener.connectionErrorOccurred(88) | connectionErrorOccurred called with null
org.firebirdsql.jdbc.FBSQLException: You cannot set value of an non-existing parameter.
	at org.firebirdsql.jdbc.FBProcedureCall$NullParam.setValue(FBProcedureCall.java:424)
	at org.firebirdsql.jdbc.AbstractCallableStatement.setLong(AbstractCallableStatement.java:1094)
	at org.tranql.connector.jdbc.PreparedStatementHandle.setLong(PreparedStatementHandle.java:247)
	at org.apache.ode.utils.LoggingStatementWrapper.setLong(LoggingStatementWrapper.java:495)
	at org.apache.openjpa.lib.jdbc.DelegatingCallableStatement.setLong(DelegatingCallableStatement.java:299)
	at org.apache.openjpa.jdbc.sql.DBDictionary.setLong(DBDictionary.java:998)
	at org.apache.openjpa.jdbc.sql.DBDictionary.setUnknown(DBDictionary.java:1283)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.setParameters(SQLBuffer.java:568)
	at org.apache.openjpa.jdbc.kernel.SQLStoreQuery$SQLExecutor.executeUpdate(SQLStoreQuery.java:231)
	at org.apache.openjpa.kernel.QueryImpl.update(QueryImpl.java:1038)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:808)
	at org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:883)
	at org.apache.openjpa.kernel.DelegatingQuery.updateAll(DelegatingQuery.java:573)
	at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:319)

Exception is thrown because for ""insert"" statement prepareCall is executed instead of prepareStatement. For other databases it is the same, but Firebird's FBProcedureCall is not the same as FBPreparedStatement. Patch for issue follows.","Tomcat 5.5, OpenJPA 1.1.0, Firebird 2.1",,,,,,,,,,,,,,,,,,,,,19/Nov/08 03:43;doubleaxe;OPENJPA-774.patch;https://issues.apache.org/jira/secure/attachment/12394214/OPENJPA-774.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-03-03 12:42:39.518,,,no_permission,,,,,,,,,,,161080,,,Wed Mar 03 12:42:39 UTC 2010,,,,,,,0|i0z5en:,203178,,,,,,,,19/Nov/08 03:43;doubleaxe;patch for issue,"03/Mar/10 12:42;milosz;Kevin, how about making this resolved?",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Query parsing error with IN expression and String functions such as UPPER(),OPENJPA-764,12408184,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ppoddar@apache.org,ppoddar@apache.org,10/Nov/08 20:57,09/Mar/10 18:31,14/Mar/19 03:02,10/Nov/08 21:36,,,,,,,,,,2.0.0-M2,,,,,,,,,,,0,,"Following JPQL query causes parse exception
           ""select a from A a where UPPER(a.name) IN (:list)""
while the following does not
           ""select a from A a where a.name IN (:list)""

Parse tree definition seems to be the cause.

Originally reported in Nabble mailing list post[1]

[1] http://n2.nabble.com/ParseException-when-using-UPPER-Keyword-with-an-IN-CLAUSE-tc1480819.html",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161071,,,2008-11-10 20:57:22.0,,,,,,,0|i0za6f:,203951,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Batch execution fails for Oracle when batch limit set to -1 (unlimited batch size),OPENJPA-762,12407809,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,04/Nov/08 20:05,09/Mar/10 18:31,14/Mar/19 03:02,04/Nov/08 21:07,1.2.0,,,,,,,,,1.2.1,1.3.0,2.0.0-M2,,,,,,,,,0,,Batch execution fails for Oracle when batch limit set to -1 (unlimited batch size),,,,,,,,,,,,,,,,,,,,,,04/Nov/08 20:08;faywang;OPENJPA-762.patch;https://issues.apache.org/jira/secure/attachment/12393326/OPENJPA-762.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161069,,,Tue Nov 04 21:07:15 UTC 2008,,,,,,,0|i0yxm7:,201916,,,,,,,,"04/Nov/08 21:07;faywang;Patch is committed in 1.2.x r711397, 1.3.x r711400, trunk r711404.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SchemaTool failed with a NPE in ForeignKey.join,OPENJPA-761,12407802,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,04/Nov/08 18:02,21/Sep/16 14:21,14/Mar/19 03:02,04/Nov/08 21:58,1.0.4,1.1.0,1.2.1,1.3.0,2.0.0-M2,,,,,1.3.0,2.0.0-M2,,,,jdbc,,,,,,0,,"A test used the SchemaTool to reflect ""all"" schema in a Oracle DB but run in a NPE as observed below:

     [exec] 131  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""com.ibm.ws.persistence.jdbc.sql.OracleDictionary"".
     [exec] 1127  INFO   [main] openjpa.Tool - Reflecting on schemas ""all"".  This process may take some time.  Enable the org.apache.openjpa.jdbc.Schema logging category to see messages about the collection of schema data.
     [exec] Exception in thread ""main"" java.lang.NullPointerException
     [exec] 	at org.apache.openjpa.jdbc.schema.ForeignKey.join(ForeignKey.java:521)
     [exec] 	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateForeignKeys(SchemaGenerator.java:794)
     [exec] 	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateForeignKeys(SchemaGenerator.java:431)
     [exec] 	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateSchemas(SchemaGenerator.java:278)
     [exec] 	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateSchemas(SchemaGenerator.java:243)
     [exec] 	at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:1433)
     [exec] 	at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:1403)
     [exec] 	at org.apache.openjpa.jdbc.schema.SchemaTool$1.run(SchemaTool.java:1348)
     [exec] 	at org.apache.openjpa.lib.conf.Configurations.launchRunnable(Configurations.java:708)
     [exec] 	at org.apache.openjpa.lib.conf.Configurations.runAgainstAllAnchors(Configurations.java:693)
     [exec] 	at org.apache.openjpa.jdbc.schema.SchemaTool.main(SchemaTool.java:1343)

Albert Lee",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161068,,,Tue Nov 04 18:07:50 UTC 2008,,,,,,,0|i1dr0n:,288474,,,,,,,,"04/Nov/08 18:07;allee8285;- I run the SchemaTool against each individual schema in the Oracle db and all works except 2 schema, OM and PM, There are total of 37 schema in the database.

- The problems exhibited  for these 2 schema looks like below which is different from the NPE. At least it posted a meaningful message.
4641  TRACE  [main] openjpa.jdbc.JDBC - <t 1183336072, conn 1139688430> [0 ms] close
Exception in thread ""main"" java.lang.RuntimeException: java.sql.SQLException: Table ""OE.CUSTOMERS"" has a foreign key to table ""HR.EMPLOYEES""
 that has not been generated.  You must run the schema generator on all inter-related tables at once.
        at org.apache.openjpa.lib.conf.Configurations.launchRunnable(Configurations.java:711)
        at org.apache.openjpa.lib.conf.Configurations.runAgainstAllAnchors(Configurations.java:693)
        at org.apache.openjpa.jdbc.schema.SchemaTool.main(SchemaTool.java:1343)
Caused by: java.sql.SQLException: Table ""OE.CUSTOMERS"" has a foreign key to table ""HR.EMPLOYEES"" that has not been generated.  You must run
the schema generator on all inter-related tables at once.
        at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateForeignKeys(SchemaGenerator.java:772)
        at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateForeignKeys(SchemaGenerator.java:431)
I re-run and debug the schemaTool against all the schema and I was able to reproduce the exception (NPE) condition. The table that is in question is OE.PURCHASERS.

- Then I generated the DDL for the OE schema and I found that

CREATE TABLE OE.PURCHASEORDERS (
		SYS_NC_ROWINFO$ null
	);

ALTER TABLE OE.PURCHASEORDERS ADD CONSTRAINT USER_IS_VALID FOREIGN KEY (null)
	REFERENCES HR.EMPLOYEES (EMPLOYEE_ID)
	ON DELETE RESTRICT
	ON UPDATE CASCADE;

- Notice the funny ""SYS_NC_ROWINFO$ null"" column definition in OE.PURCHASEORDERS  and null in the FOREIGN KEY constraint definition.

- I try to re-create the table using the same syntax and was rejected by the db.

I believe this table is abnormal and was create/modified in some ways that I don't know how it gets to this configuration. 

To improve serviceability, a null check of of the fk table column and a more meaningful would be appropriate.

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"OpenJPA thows EntityExistsException trying persist a preexisting, detached entity",OPENJPA-755,12407487,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,dinkar,dinkar,30/Oct/08 05:19,09/Mar/10 18:31,14/Mar/19 03:02,14/Nov/08 00:11,,,,,,,,,,1.2.1,1.3.0,2.0.0-M2,,,kernel,,,,,,0,,"I have a CustomerInventory entity that has a reference to an Item entity. The cascade property for Item is set to ALL. I create a new CustomerInventory, and attach to it an Item that was previously found and detached (by closing the em). I add the CustomerInventory to an existing Customer, and merge in the updated Customer. 

At commit time, OpenJPA tries to persist Item, leading to this exception:

<openjpa-2.0.0-SNAPSHOT-runknown fatal store error> org.apache.openjpa.persistence.RollbackException: Attempt to persist detached object ""org.apache.openjpa.persistence.detachment.model.DMItem-org.apache.openjpa.persistence.detachment.model.DMItem-1225343083922"".  If this is a new instance, make sure any version and/or auto-generated primary key fields are null/default when persisting.
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:523)
	at org.apache.openjpa.persistence.detachment.TestDetachedEntityCascadePersist.testDetachedEntityCascadePersist(TestDetachedEntityCascadePersist.java:73)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:143)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
Caused by: <openjpa-2.0.0-SNAPSHOT-runknown nonfatal store error> org.apache.openjpa.persistence.EntityExistsException: Attempt to persist detached object ""org.apache.openjpa.persistence.detachment.model.DMItem-org.apache.openjpa.persistence.detachment.model.DMItem-1225343083922"".  If this is a new instance, make sure any version and/or auto-generated primary key fields are null/default when persisting.
FailedObject: org.apache.openjpa.persistence.detachment.model.DMItem-org.apache.openjpa.persistence.detachment.model.DMItem-1225343083922
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2422)
	at org.apache.openjpa.kernel.SingleFieldManager.preFlushPC(SingleFieldManager.java:759)
	at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:594)
	at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:562)
	at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:478)
	at org.apache.openjpa.kernel.StateManagerImpl.preFlush(StateManagerImpl.java:2832)
	at org.apache.openjpa.kernel.PNewState.beforeFlush(PNewState.java:39)
	at org.apache.openjpa.kernel.StateManagerImpl.beforeFlush(StateManagerImpl.java:960)
	at org.apache.openjpa.kernel.BrokerImpl.flushTransAdditions(BrokerImpl.java:2089)
	at org.apache.openjpa.kernel.BrokerImpl.flushAdditions(BrokerImpl.java:2068)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1950)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1909)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1827)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1351)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:877)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:512)
	... 20 more
",,,,,,,,,,,,,,,,,,,,,,30/Oct/08 06:00;dinkar;OPENJPA-755-test.patch;https://issues.apache.org/jira/secure/attachment/12393033/OPENJPA-755-test.patch,30/Oct/08 05:40;dinkar;OPENJPA-755.patch;https://issues.apache.org/jira/secure/attachment/12393032/OPENJPA-755.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-10-31 18:41:08.349,,,no_permission,,,,,,,,,,,161063,,,Fri Nov 14 00:11:03 UTC 2008,,,,,,,0|i0zacn:,203979,,,,,,,,"30/Oct/08 05:40;dinkar;There is a check for a not-new, detached entity in SingleFieldManager:

if (!_broker.isDetachedNew() && _broker.isDetached(obj))
                return; // allow but ignore

but this was done only for the ValueMetaData.CASCADE_NONE case. Where the preexisting, detached Item entity is encountered, the case is  ValueMetaData.CASCADE_IMMEDIATE. The check above should also be done for this condition. The runtime code path already goes through this check for Item in another place - in SingleFieldManager.persist(), when Customer is being merged. 

This patch adds this check for the code path through the commit() call.

","30/Oct/08 06:00;dinkar;Adding a test to verify the fix. Patch has the following files:

org.apache.openjpa.persistence.detachment.model.DMItem.java
org.apache.openjpa.persistence.detachment.model.DMCustomerInventory.java
org.apache.openjpa.persistence.detachment.model.DMCustomer.java
org.apache.openjpa.persistence.detachment.model.TestDetachedEntityCascadePersist.java

Ran the OpenJPA regression tests and also the TCK - all pass.",31/Oct/08 18:41;techhusky;Committed to trunk in r709527.,14/Nov/08 00:11;fancy;Fix applied to 1.2.x branch under r713858.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
missing snapshot builds,OPENJPA-753,12407285,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,fern,fern,27/Oct/08 16:07,09/Mar/10 18:35,14/Mar/19 03:02,22/Nov/08 20:25,1.2.1,1.3.0,,,,,,,,,,,,,build / infrastructure,,,,,,0,,"I was looking for the latest builds, and I could not find the snapshot builds.

Michael Dick then replied:

The snapshot repository was lost when we moved to a different machine for
nightly builds (you can see that the snapshots haven't been updated since
August). I'll work on getting them published in subsequent builds. If you
have a JIRA account would you mind opening an issue?",,0,0,,0%,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-11-06 19:09:02.64,,,no_permission,,,,,,,,,,,161061,,,Sat Nov 22 20:25:44 UTC 2008,,,,,,,0|i0z7o7:,203545,,,,,,,,"06/Nov/08 19:09;mikedd;Currently there's a permission problem with the slice directory on people.apache.org and I can't deploy snapshot builds which include it (ie OpenJPA version >= 1.1).

When we get that issue resolved I'll update the snapshots, in the mean time a snapshot build for 1.0.4 is available. ","20/Nov/08 23:39;fern;so.. just wondering the status.  I just looked under one of the snapshot repositories and found some openjpa builds.. but wondering if they are good and update now..

http://people.apache.org/repo/m2-snapshot-repository/org/apache/openjpa/openjpa/",22/Nov/08 20:25;mikedd;The snapshot builds should be back now. The snapshots are updated if there have been changes (roughtly nightly). The machine that publishes the builds was blocked from accessing people.apache.org for a while (it's been restored now) and the builds should be current.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Typos in the manual,OPENJPA-751,12407114,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,allee8285,milosz,milosz,23/Oct/08 20:01,29/Oct/08 18:42,14/Mar/19 03:02,29/Oct/08 18:40,1.3.0,,,,,,,,,1.3.0,2.0.0-M2,,,,docs,,,,,,0,,The manual contains a few typographical errors.,,,,,,,,,,,,,,,,,,,,,,23/Oct/08 20:02;milosz;OPENJPA-751.patch;https://issues.apache.org/jira/secure/attachment/12392748/OPENJPA-751.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-10-29 18:40:10.624,,,no_permission,,,,,,,,,,,161059,,,Wed Oct 29 18:40:10 UTC 2008,,,,,,,0|i1dr1r:,288479,,,,,,,,23/Oct/08 20:02;milosz;The patch corrects the typos.,"29/Oct/08 18:40;allee8285;Milosz,

Thank you for your careful review and contribution to the OpenJPA project. I have committed your changes to the repository.

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OptimisticLockException is thrown when numeric truncation occurs on Sybase,OPENJPA-750,12406711,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,techhusky,techhusky,17/Oct/08 20:26,22/Apr/10 20:32,14/Mar/19 03:02,23/Oct/08 14:51,1.3.0,,,,,,,,,1.3.0,,,,,jdbc,,,,,,0,,"OpenJPA throws an OptimisicLockException after an insert is issued to Sybase and there is no SQLException and the update count does not match the expected value.  The root cause is that the insert is trying to insert a numeric value which is larger than the numeric field.  Sybase issues a SQLWarning  (preparedStatement.getWarnings()) and the insert fails.  An OptimisticLockException is thrown with misleading statement text.

I recommend we:

1) Add a config property to disable numeric truncation, if possible.
2) Check for SQLWarning's after an ps exec fails and minimally log them.  Or throw them as a more appropriate exception?

This issue is very similar to OPENJPA-745, except 745 deals with character truncation.","Sybase 15, jconn3.jar",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-10-17 22:13:35.252,,,no_permission,,,,,,,,,,,161058,,,Thu Oct 23 14:51:24 UTC 2008,,,,,,,0|i0z7w7:,203581,,,,,,,,"17/Oct/08 22:13;faywang;Hi Jeremy, for your option (1), you might want to look at Sybase arithabort numeric_truncation flag. For compliance with the ANSI SQL standard, enter 
""set arithabort numeric_truncation on"". For details, see http://manuals.sybase.com/onlinebooks/group-as/asg1250e/sqlug/@Generic__BookTextView/3524;pt=693/*","23/Oct/08 14:51;techhusky;Committed in revision 707270.

Resolved issue by adding a new option, IgnoreNumericTruncation to the Sybase dictionary.  In addition, code was added to the batching and standard prepared statement managers to log any SQL warnings that result from statement execution.  That will help make issues such as this simpler to diagnose for those JDBC drivers that surface individual or batch operation failures as a warning.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Disable QuerySQLCache by default,OPENJPA-748,12406615,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,16/Oct/08 16:18,24/Feb/10 14:22,14/Mar/19 03:02,18/Jan/10 20:05,1.2.0,1.3.0,,,,,,,,2.0.0-beta,,,,,jdbc,,,,,,1,,"I posted this dev forum question regarding QuerySQLCache:

---
We've had a few regression-type issues (OPENJPA-660 & OPENJPA-731)
since the addition of QuerySQLCache in 1.2.0.  While this cache has
shown to provide significant performance improvements for certain
scenarios, I think we should consider disabling the cache by default.
The main reason is the potential for future regression issues.
Another reason is that we didn't follow the pattern set by existing
caches.  With the exception of the query compilation cache (which is
relatively static after queries are initialized), the other caches are
disabled by default.  While the cache is supposed to be transparent,
it could (and has shown to) affect the behavior of an application that
has been working for quite some time on a prior release.

Arguably, QuerySQLCache may just need more rigorous testing.  While
additional testing may help, testing every scenario is difficult and
if we miss one, regression issues due to performance enhancements are
pretty hard to swallow.  I think a better approach is to allow users
to enable the cache if they choose to do so.
---

And received positive responses.  The necessary updates will be made to disable the cache by default and committed to trunk.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161056,,,Mon Jan 18 20:05:30 UTC 2010,,,,,,,0|i0z6yf:,203429,,,,,,,,18/Jan/10 20:05;techhusky;No longer an issue since PreparedQueryCache replaced QuerySQLCache in 2.0.0.  Changing default behavior in 1.2 is unlikely.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sybase by default silently truncates a string which is longer than the column length without raising an exception ,OPENJPA-745,12406339,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,faywang,faywang,13/Oct/08 22:36,09/Mar/10 18:32,14/Mar/19 03:02,22/Oct/08 23:34,1.2.0,,,,,,,,,1.2.1,1.3.0,,,,,,,,,,0,,"By default, Sybase silently truncates a string which is longer than the column length without raising an exception. To override this behavior, string_rtruncation must be set on. In order to be consistent with other databases (which raise exceptions when a string length is longer than the column length), we will set string_rtruncation on by default for Sybase. For an application that wants to keep Sybase silent truncation behavior, a DBDictionary property ""setStringRightTruncationOn"" is introduced. When it is set to false in the persistence.xml, the string will be silently truncated during insert/update. ",,,,,,,,,,,,,,,,OPENJPA-750,,,,,,20/Oct/08 15:34;faywang;OPENJPA-745-1.patch;https://issues.apache.org/jira/secure/attachment/12392494/OPENJPA-745-1.patch,14/Oct/08 17:39;faywang;OPENJPA-745.patch;https://issues.apache.org/jira/secure/attachment/12392111/OPENJPA-745.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-10-20 04:20:29.464,,,no_permission,,,,,,,,,,,161054,,,Wed Oct 22 23:34:23 UTC 2008,,,,,,,0|i1dr2f:,288482,,,,,,,,"20/Oct/08 04:20;ppoddar@apache.org;Following part of the patch in JDBCStoreManager appears to be too specifc

     public Connection getConnection() {
         connect(true);
+        try {
+            _dict.raiseRightTruncationException(_conn);
+        } catch (SQLException se) {
+            throw SQLExceptions.getStore(se, _dict);
+        }
         return _conn;
     }

Suggested
 a) more generic name such as DBDictionary.setConnection(Connection conn) or DBDictionary.initializeSettings(Connection conn) or similar.
 b) more importantly, the more appropriate location for this invocation is internal connect(boolean) method itself where the exception handling is carried out.",20/Oct/08 15:34;faywang;The attached patch is per Pinaki's suggestion. Thanks for your feedback!,"20/Oct/08 22:27;mikedd;Shouldn't : 
--- openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java	(revision 706319)
+++ openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java	(working copy)
@@ -920,6 +920,7 @@
        try {
            // connect if the connection is currently null, or if
            // the connection has been closed out from under us
            if (_conn == null)
                 _conn = connectInternal();
             if (ref)
                 _conn.ref();
+            _dict.initializeSettings(_conn);
         } catch (SQLException se) {
             throw SQLExceptions.getStore(se, _dict);
         } finally {


actually be 
        try {
            // connect if the connection is currently null, or if
            // the connection has been closed out from under us
-            if (_conn == null) 
+            if (_conn == null) {
                 _conn = connectInternal();
+                _dict.initializeSettings(_conn);
+           }
             if (ref)
                 _conn.ref();
         } catch (SQLException se) {
             throw SQLExceptions.getStore(se, _dict);
         } finally {

It seems like we'd only need to set the truncation property the first time we obtain a connection, not every time the store uses it. ",21/Oct/08 02:13;faywang;commit with r706493 and r706494.,22/Oct/08 23:34;faywang;make the fix in synch with the fix in OPENJPA-750. commit in openjpa truck with r-707214 and in openjpa 1.2.x with r-707222.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OptimisticLockException persisting collection containing Lob fields with Oracle,OPENJPA-743,12406176,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,10/Oct/08 13:52,09/Mar/10 18:35,14/Mar/19 03:02,11/Oct/08 04:21,1.2.0,,,,,,,,,,,,,,jdbc,,,,,,0,,"Persisting an object graph with an entity containing a persistent collection of objects which contain a Lob field may fail on Oracle if statement batching is enabled.  The failure will depend on the order of operations, which can be somewhat intermittent.  If more than one insert into the table containing the Lob column are batched together and there is a mix of null and non-null data value parameters, the batch insert operation will fail with an OptimisticLockException.  

A simple (but not especially performance friendly) way to work around the problem is to disable statement batching via: 
<property name=""openjpa.jdbc.DBDictionary"" value=""oracle(batchLimit=0)""/>  Otherwise, if possible, make sure all Lob fields are set to a non-null value.","OpenJPA 1.2.0, Oracle 10g ojdbc14.jar, version 10.2.0.1.0",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161052,,,Sat Oct 11 04:21:21 UTC 2008,,,,,,,0|i0z7nr:,203543,,,,,,,,"11/Oct/08 04:21;techhusky;When setting up a parameters of a prepared statement, OpenJPA sets null clob field values to an empty clob parameter type, while it sets non-null values to a character stream.  When statement batching is enabled, the Oracle 1.4 driver fails to insert all the batched rows due to using mixed parameter types, even though the parameter types/values are compatible with the table column and can be inserted using separate statements.  

This problem no longer exists in version 11.0.7.0 of the Oracle JDK 5 JDBC driver, ojdbc5.jar.  It was not, however resolved in the latest 1.4 driver, version 10.2.0.4.  Preferably, get the latest  ojdbc5 driver to correct the problem.  If use of ojdbc14.jar is necessary, the recommended workaround is to disable statement batching.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"In MySQL use LONGBLOB, MEDIUMBLOB etc.. when needed, cause BLOB only holds 64kb of data.",OPENJPA-740,12405967,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,drwoods,s.gianni,s.gianni,07/Oct/08 22:15,03/Nov/10 16:02,14/Mar/19 03:02,08/Mar/10 21:50,1.2.0,1.2.1,1.2.2,1.3.0,2.0.0-beta,2.0.0-beta2,2.0.0-M3,,,1.3.0,2.0.0-beta3,,,,sql,,,,,,0,,"When a column is annotated as a BLOB of using @Persistent to use streaming blobs, and the underlying database is MySQL, OpenJPA will create a column of type BLOB. Unfortunately, in MySQL a BLOB column can hold a (vary) limited amount of data, while (especially when using streaming blobs) the user would probably expect it to hold a large amount of data.

Also adding the @Column annotation and specifying a size bigger than what a BLOB column in MySQL can hold, OpenJPA still creates only a BLOB column.

I think OpenJPA should be able to create the proper column type depending on the @Column annotation if present, or otherwise default at least to a MEDIUMBLOB to preserve cross-database compatibility as expected.

The simplest patch i can think of is setting blobTypeName=""MEDIUMBLOB"" in the MySQLDictionary constructor.

Otherwise, overriding the getTypeName to properly parse the length and return the correct BLOB/TEXT type for mysql.",,,,,,,,,,,,,,,,OPENJPA-1870,,,,,,08/Mar/10 19:31;drwoods;OPENJPA-740-13x.patch;https://issues.apache.org/jira/secure/attachment/12438219/OPENJPA-740-13x.patch,08/Apr/09 16:52;s.gianni;OPENJPA-740-mysqlblob.patch;https://issues.apache.org/jira/secure/attachment/12404982/OPENJPA-740-mysqlblob.patch,08/Mar/10 19:31;drwoods;OPENJPA-740-trunk.patch;https://issues.apache.org/jira/secure/attachment/12438218/OPENJPA-740-trunk.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2010-03-06 18:11:22.923,,,no_permission,,,,,,,,,,,161049,,,Mon Mar 08 20:25:01 UTC 2010,,,Patch Available,,,,0|i0yvm7:,201592,,,,,,,,"08/Apr/09 16:52;s.gianni;This patchs uses the right column table for mysql based on the size specified for the column. I had this patch for a few months now, but no one told me how to test it in junit, so unfortunately I haven't provided a junit test case for it.

Sice this patch is old, I don't know if it still applies to recent OpenJPA versions. If I have time to, I'll do a fresh checkout and test it.",06/Mar/10 18:11;norman;The Problem still exists in 1.2.2. And for me its really a blocker !,"06/Mar/10 18:13;norman;Our bugreport listed here is related to it:

https://issues.apache.org/jira/browse/IMAP-114",08/Mar/10 19:25;drwoods;Updated 1.3.x and trunk patches to match the latest svn revisions.,08/Mar/10 19:31;drwoods;Fixed order for col.size() checks to correctly return the type....,"08/Mar/10 19:43;milosz;For those not able to use OpenJPA versions with fix - If only MySQL is being used or separate configurations are used for different databases (i.e. DBDictionary auto-detection is not used), setting the following property in persistence.xml should be a workaround:

<property name=""openjpa.jdbc.DBDictionary"" value=""blobTypeName=LONGBLOB""/>
","08/Mar/10 19:48;milosz;Donald, just wondering about the patch - will the column type be correct (i.e. equals the type specified in blobTypeName public variable) when the size of the column is not specified?
","08/Mar/10 20:25;drwoods;Thanks Milosz, I just added a check for size==0 so it'll use the old blob size (64KB).
For those cases, users should use your prior comment of overriding the blobTypeName.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Entity contains pseudo-attached embeddable after detach,OPENJPA-733,12405163,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,25/Sep/08 17:29,07/Jan/11 14:21,14/Mar/19 03:02,06/Oct/08 17:40,1.2.0,,,,,,,,,1.2.1,1.3.0,,,,kernel,,,,,,0,,"Problem reported by Chris Tillman on user forum and can be easily reproduced with the code provided:

When upgrading a standalone Java application from OpenJPA 1.1 to 1.2 i ran
into a problem regarding embedded classes.

Accessing a field from an embedded class (say, Address) in a detached entity
(Customer) doesn't seem to work anymore. OpenJPA 1.2 throws an
InvalidStateException. It worked fine with OpenJPA 1.1.

The field (street) contains the correct value as loaded from the database,
but when the getter is used, e.g. customer.getAddress().getStreet(), the ISE
is thrown:

org.apache.openjpa.persistence.InvalidStateException: The context has been
closed.
       at org.apache.openjpa.kernel.BrokerImpl.assertOpen(BrokerImpl.java:4367)
       at
org.apache.openjpa.kernel.BrokerImpl.beginOperation(BrokerImpl.java:1766)
       at org.apache.openjpa.kernel.BrokerImpl.isActive(BrokerImpl.java:1736)
       at
org.apache.openjpa.kernel.StateManagerImpl.beforeRead(StateManagerImpl.java:941)
       at
org.apache.openjpa.kernel.StateManagerImpl.accessingField(StateManagerImpl.java:1476)
       at org.test.Address.pcGetstreet(Address.java)
       at org.test.Address.getStreet(Address.java:22)
       at org.test.Test.main(Test.java:30)

Upon investigation, it seems to work OK in OpenJPA 1.2 using runtime
enhancement (Java 6) but not using compile-time enhancement. However, in
OpenJPA 1.1 it's the other way around.

OpenJPA 1.1 with compile-time enhancement uses a DetachedStateManager for
both the entity and the embeddable. As can be seen from the stacktrace,
OpenJPA 1.2 uses a StateManagerImpl instead for the embeddable.

Is this a regression in OpenJPA 1.2?

Test code below:
//-------------------------

package org.test;

import java.util.List;

import javax.persistence.*;

public class Test {
       public static void main(String[] args) {
               EntityManagerFactory factory = Persistence
                               .createEntityManagerFactory(""test"");

               Customer customer = new Customer();
               Address address = new Address();

               customer.setLastName(""Doe"");
               address.setStreet(""Main Street"");
               customer.setAddress(address);

               try {
                       persistCustomer(factory, customer);

                       customer = queryCustomers(factory,
                                       ""select customer from Customer customer"" +
                                       "" where customer.lastName = 'Doe'"")
                                       .get(0);

                       System.out.println(customer.getLastName());
                       System.out.println(customer.getAddress().getStreet());

                       factory.close();
               } catch (Throwable t) {
                       t.printStackTrace();
               }
       }

       static void persistCustomer(EntityManagerFactory factory, Customer
customer)
                       throws Exception {
               final EntityManager em = factory.createEntityManager();
               final EntityTransaction tx = em.getTransaction();

               tx.begin();

               try {
                       em.persist(customer);

                       tx.commit();
               } finally {
                       if (!tx.isActive()) {
                               em.close();
                       }
               }
       }

       public static List<Customer> queryCustomers(EntityManagerFactory factory,
                       String query) throws Exception {
               final EntityManager em = factory.createEntityManager();
               final EntityTransaction tx = em.getTransaction();

               tx.begin();

               try {
                       final List<Customer> list = (List<Customer>) em.createQuery(query)
                                       .getResultList();

                       tx.commit();

                       return list;
               } finally {
                       if (!tx.isActive()) {
                               em.close();
                       }
               }
       }
}
//-------------------------

package org.test;

import javax.persistence.*;

@Entity
public class Customer {
       @Id @GeneratedValue long id;

       @Basic String lastName;

       @Embedded Address address;

       public String getLastName() {
               return lastName;
       }

       public void setLastName(String lastName) {
               this.lastName = lastName;
       }

       public Address getAddress() {
               return address;
       }

       public void setAddress(Address address) {
               this.address = address;
       }
}
//-------------------------

package org.test;

import javax.persistence.*;

@Embeddable
public class Address {
       @Basic String street;

       public String getStreet() {
               return street;
       }

       public void setStreet(String street) {
               this.street = street;
       }
}

",,,,,,,,,,,,,,,,OPENJPA-1919,OPENJPA-209,,,,,29/Sep/08 22:01;techhusky;OPENJPA-733.patch;https://issues.apache.org/jira/secure/attachment/12391167/OPENJPA-733.patch,06/Oct/08 19:40;techhusky;OPENJPA-733_smimpl.patch;https://issues.apache.org/jira/secure/attachment/12391568/OPENJPA-733_smimpl.patch,06/Oct/08 19:40;techhusky;OPENJPA-733_test.patch;https://issues.apache.org/jira/secure/attachment/12391569/OPENJPA-733_test.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2008-10-06 18:13:37.937,,,no_permission,,,,,,,,,,,161042,,,Fri Oct 10 20:11:18 UTC 2008,,,,,,,0|i0z2cv:,202684,,,,,,,,"29/Sep/08 22:01;techhusky;Attaching a preliminary patch for trunk.  I've only tested with the submitted test case.  I still need to run the full unit test suite.  If all tests pass, will convert submitted test to OpenJPA jUnit and commit code changes.

In summary, embeddables were not being added to the L1 cache as the result of a query so they were not processed as part of the detach operation.  The StateManagerImpl.getObjectId is a bit misleading since it returns the oid of the owner, not the embeddable.  The owner was already in the L1 cache, so the embeddable was not loaded.  Modified the logic to check the L1 for the embeddable oid.",06/Oct/08 17:40;techhusky;Chris applied the patch and it corrected the problem.  Committed in revision 700563.  Marking issue as resolved.,06/Oct/08 18:13;mikedd;Considering for 1.2.1,"06/Oct/08 19:40;techhusky;Attaching clean patches (no EOL issue) for StateManagerImpl and TestEmbedded.  I created them with trunk, but was able to successfully apply them to 1.2.x.",10/Oct/08 19:44;techhusky;Here is a link to forum conversation on nabble for reference:  http://n2.nabble.com/Problem-with-detaching-embedded-class-in-OpenJPA-1.2-using-compile-time-enhancement-td1117628.html,10/Oct/08 20:11;techhusky;The change to StateManagerImpl in OPENJPA-209 caused this regression.  ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Updates to entities via Lifecycle callback methods ,OPENJPA-732,12405004,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,kwsutter,kwsutter,23/Sep/08 19:51,02/Oct/09 18:31,14/Mar/19 03:02,29/Oct/08 19:06,1.2.1,1.3.0,,,,,,,,1.2.2,2.0.0-M2,,,,kernel,,,,,,0,,"http://n2.nabble.com/Updates-to-entities-via-Lifecycle-callback-methods-td1110631.html

In a nutshell, if we are to allow the updating of the entities passed into the Lifecycle callback methods, then we have a couple of problems (given the scenario of updating the entity passed into the @PreUpdate method):

o  The designated @Version field is getting updated more often than desired causing the transaction to rollback.
o  The @PostUpdate method is getting invoked more than once.

I will post a testcase shortly.  If and when we decide to fix this, this simple testcase will need to be expanded to include the updating of entities in other scenarios as well.

I am also getting verification from the JPA Expert Group as to whether these entities are supposed to be updatable or not.  As one of the dev postings indicated, our OpenJPA documentation indicates that they are updatable.  But, the JPA spec itself is not clear on this capability.  Other vendors, such as Hibernate, allow for this.",,,,,,,,,,,OPENJPA-327,,OPENJPA-327,,,OPENJPA-1092,,,,,,09/Jul/09 19:49;bjreed;OPENJPA-732-1.0.patch;https://issues.apache.org/jira/secure/attachment/12413052/OPENJPA-732-1.0.patch,09/Jul/09 19:49;bjreed;OPENJPA-732-1.2.patch;https://issues.apache.org/jira/secure/attachment/12413053/OPENJPA-732-1.2.patch,23/Sep/08 20:10;kwsutter;openjpa-732-test.zip;https://issues.apache.org/jira/secure/attachment/12390781/openjpa-732-test.zip,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2008-10-02 22:51:36.345,,,no_permission,,,,,,,,,,,161041,,,Fri Oct 02 18:31:36 UTC 2009,,,,,,,0|i0yz9z:,202185,,,,,,,,23/Sep/08 20:10;kwsutter;Testcase for this JIRA Issue.,02/Oct/08 22:51;allee8285;Reopen issue due to test regression.,09/Jul/09 15:43;mikedd;Re-attaching patches provided by B.J. Reed for issue OPENJPA-327. As it turns out the same fix resolves both issues and I'd like to use a single JIRA issue for tracking.,09/Jul/09 19:49;bjreed;Patches broke some other test cases...changing HashSet to LinkedHashSet (like current trunk version of BrokerImpl) fixes these,"02/Oct/09 18:31;drwoods;was fixed in 1.2.2 and trunk, not 1.3.0",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bug on FetchType.EAGER when QuerySQLCache is turned on,OPENJPA-731,12404757,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,19/Sep/08 17:24,09/Mar/10 18:32,14/Mar/19 03:02,26/Sep/08 03:09,1.2.0,1.2.1,,,,,,,,1.2.1,1.3.0,,,,,,,,,,0,,"This JIRA is open on behalf of Enrico:

OpenJPA 1.2.0 Bug on FetchType.EAGER
Friday, September 19, 2008 12:49 AM
From: ""egoosen"" <egoosen2@metropolitan.co.za>
Add sender to Contacts
To: users@openjpa.apache.org

I'm experiencing a strange bug in 1.2.0, on an eager loaded one to many
relationship.
The first time I run the code, openJPA retrieves the parent entity and eager
fetches the CORRECT child entities.
The second time around, it fetches the parent entity and fetches the
INCORRECT child entities (specifically, it fetches the child entities of the
parent entity in the previous query).

Here's the SQL to illustrate:
First run:
SELECT t0.AMDCTL_ID, t0.VRS_NBR, t0.AMDSEQ_CDE, t0.DPLORD_NBR, t0.FND_CDE,
t0.RSL_DTE FROM EBSTATUS.TBL_AMDCTL t0 WHERE t0.FND_CDE = ?
[params=(String) 0000001]
SELECT t0.AMDCTL_ID, t1.AMDDES_ID, t1.VRS_NBR, t1.AMD_DES, t1.AMDCTL_ID,
t1.EFC_DTE FROM EBSTATUS.TBL_AMDCTL t0 INNER JOIN EBSTATUS.TBL_AMDDES t1 ON
t0.AMDCTL_ID = t1.AMDCTL_ID WHERE t0.FND_CDE = ? ORDER BY t0.AMDCTL_ID ASC
[params=(String) 0000001]

Second run:
SELECT t0.AMDCTL_ID, t0.VRS_NBR, t0.AMDSEQ_CDE, t0.DPLORD_NBR, t0.FND_CDE,
t0.RSL_DTE FROM EBSTATUS.TBL_AMDCTL t0 WHERE t0.FND_CDE = ?
[params=(String) 0001001]
SELECT t0.AMDCTL_ID, t1.AMDDES_ID, t1.VRS_NBR, t1.AMD_DES, t1.AMDCTL_ID,
t1.EFC_DTE FROM EBSTATUS.TBL_AMDCTL t0 INNER JOIN EBSTATUS.TBL_AMDDES t1 ON
t0.AMDCTL_ID = t1.AMDCTL_ID WHERE t0.FND_CDE = ? ORDER BY t0.AMDCTL_ID ASC
[params=(String) 0000001]

Somehow its caching the second query, even though I've turned off the
DataCache and QueryCache.

I've had to revert back to OpenJPA 1.1.0.

Here's my mappings:
TblAmdctl.java
@OneToMany(mappedBy=""tblAmdctl"",fetch = FetchType.EAGER,cascade = {
CascadeType.PERSIST,CascadeType.MERGE})
private Collection<TblAmddes> tblAmddess = new ArrayList<TblAmddes>();

TblAmddes.java
@ManyToOne(fetch = FetchType.LAZY,cascade = {
CascadeType.PERSIST,CascadeType.MERGE })
@JoinColumns({@JoinColumn(name =
""AMDCTL_ID"",referencedColumnName=""AMDCTL_ID"")})   
@ForeignKey
private TblAmdctl tblAmdctl; ",,,,,,,,,,,,,,,,,,,,,,26/Sep/08 00:10;faywang;openjpa-731.txt;https://issues.apache.org/jira/secure/attachment/12390975/openjpa-731.txt,19/Sep/08 17:32;faywang;testcase.jar;https://issues.apache.org/jira/secure/attachment/12390524/testcase.jar,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-09-26 03:09:55.08,,,no_permission,,,,,,,,,,,161040,,,Fri Oct 03 15:17:33 UTC 2008,,,,,,,0|i0z76f:,203465,,,,,,,,"19/Sep/08 17:32;faywang;Hi Enrico, attached is the test case based on your report. However, this test case works fine. Could you attach your entity classes (TblAmdctl.java, and TblAmddes.java)? Also, do you use find operation or Query to get the parent entity? Can you provide a code snippet for your operation? Thanks!",26/Sep/08 03:09;fancy;Fix checked in under r699156,03/Oct/08 15:17;mikedd;Merged change to 1.2.1.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Image mapping-table.png missing in HTML manual,OPENJPA-727,12404526,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,s.gianni,s.gianni,17/Sep/08 10:42,09/Mar/10 18:32,14/Mar/19 03:02,17/Sep/08 15:57,,,,,,,,,,1.0.4,1.2.1,1.3.0,,,docs,,,,,,0,,The image is missing. Seems like it's the only missing image in that page.,go to url http://openjpa.apache.org/builds/latest/docs/manual/manual.html,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-09-17 15:26:56.416,,,no_permission,,,,,,,,,,,161036,,,Wed Sep 17 15:57:45 UTC 2008,,,,,,,0|i1dr47:,288490,,,,,,,,"17/Sep/08 15:26;mikedd;From what I can tell that image has never been available. I don't have a copy of the original tool used to produce the UML and my photoshop skills are a bit lacking. For the time being I'm going to remove the reference to the image. 

For future reference the missing image can be found in section 12.1 (search for ""The example below maps classes""). ","17/Sep/08 15:57;mikedd;Marking issue as resolved. If anyone can donate an image that can go in this section I'm happy to add it. 

We'll revisit this section when we have tooling support to add new UML diagrams (we'll probably want to revisit many of the images t provide a consistent look and feel). ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Corrections for the manual,OPENJPA-724,12404303,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,milosz,milosz,13/Sep/08 17:08,09/Mar/10 18:32,14/Mar/19 03:02,17/Sep/08 16:22,1.2.0,1.3.0,,,,,,,,1.0.4,1.2.1,1.3.0,,,docs,,,,,,0,,The manual contains a few mistakes.,,,,,,,,,,,,,,,,,,,,,,13/Sep/08 17:11;milosz;OPENJPA-724.patch;https://issues.apache.org/jira/secure/attachment/12390059/OPENJPA-724.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-09-17 16:22:34.801,,,no_permission,,,,,,,,,,,161033,,,Wed Sep 17 16:22:34 UTC 2008,,,,,,,0|i1dr4v:,288493,,,,,,,,"13/Sep/08 17:11;milosz;What the patch corrects:

jpa_overview_query.xml
- The two queries demonstrating JPQL case insensitivity were actually
  identical. One of them is now written in lower case to demonstrate JPQL case
  insensitivity.
- The two queries demonstrating the importance of parentheses actually
  returned the same result. I put another example which is a bit contrived,
  it is not so easy to provide a meaningful short example here...
- A missing dot added.
- The sentence about the reserved word OF moved from EXISTS section to MEMBER
  OF section.
- The sentence about DISTINCT moved from ORDER BY section to JPQL Aggregate
  Functions section.
- A typo corrected.
- The ORDER BY example was referring to an undefined identification variable
  'o'.

ref_guide_slice.xml
- Typos corrected.

ref_guide_pc.xml
- Example 5.5. ""Finding an Entity with an Entity Identity Field"" was referring
  to an undefined variable and ""em"" variable was not used.

ref_guide_dbsetup.xml
- A typo corrected.

supported_databases.xml
- A typo corrected.

ref_guide_remote.xml
- Added a missing example of JMS provider.
- A typo corrected.
- Added another missing example of JMS provider.

jpa_overview_mapping.xml
- In example 12.15. ""Join Table Mapping"" made XML consistent with annotations.
- A typo corrected.
- In example 12.16. ""Join Table Map Mapping"" made XML consistent with
  annotations.
",17/Sep/08 16:22;mikedd;Thanks very much for the patch!,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GeneralException in PCEnhancer during class transform in Turkish locale AppServer setting,OPENJPA-719,12404089,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,10/Sep/08 15:36,21/Sep/16 14:21,14/Mar/19 03:02,25/Sep/08 14:13,1.0.3,1.0.4,1.1.0,1.2.0,1.2.1,1.3.0,,,,1.2.1,1.3.0,,,,kernel,,,,,,0,,"When Turkish locale is used in EE (AppServer) environment, entity class transformation failed with the following exception.

org.apache.openjpa.util.GeneralException: An error occurred while enhancing 
itemejb3.ItemJPA. Exception message: org.apache.openjpa.enhance.StateManager.replace�ntField(org.apache.openjpa.enhance.PersistenceCapable, int)
	at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:538)
	at org.apache.openjpa.enhance.PCClassFileTransformer.transform0(PCClassFileTransformer.java:146)
	at org.apache.openjpa.enhance.PCClassFileTransformer.transform(PCClassFileTransformer.java:120)
	at org.apache.openjpa.persistence.PersistenceProviderImpl$ClassTransformerImpl.transform(PersistenceProviderImpl.java:210)
	at com.ibm.ws.jpa.management.JPAPUnitInfo.transformClass(JPAPUnitInfo.java:1815)
        ......
Caused by: java.lang.NoSuchMethodException: 
org.apache.openjpa.enhance.StateManager.replace�ntField(org.apache.openjpa.enhance.PersistenceCapable, int)
	at java.lang.Class.throwNoSuchMethodException(Class.java:283)
	at java.lang.Class.getDeclaredMethod(Class.java:609)
	at org.apache.openjpa.lib.util.J2DoPrivHelper$8.run(J2DoPrivHelper.java:288)
	at java.security.AccessController.doPrivileged(AccessController.java:251)
	at org.apache.openjpa.enhance.PCEnhancer.getMethod(PCEnhancer.java:2597)
	at org.apache.openjpa.enhance.PCEnhancer.getStateManagerMethod(PCEnhancer.java:2546)
	at org.apache.openjpa.enhance.PCEnhancer.addReplaceFieldsMethods(PCEnhancer.java:1338)
	at org.apache.openjpa.enhance.PCEnhancer.addPCMethods(PCEnhancer.java:1070)
	at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:523)
	... 33 more

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161029,,,Wed Sep 10 15:58:30 UTC 2008,,,,,,,0|i1dr5b:,288495,,,,,,,,"10/Sep/08 15:58;allee8285;In Turkish locale, there are 2 forms of letter 'i'. A dotted 'i' and a non-dotted 'i'.  Java String.toLowerCase and toUpperCase perform the following case transformation:

toLowerCase(   dotted 'i' (0x69) )  ->  dotted 'i' (0x69)
toUpperCase(   dotted 'i' (0x69) )  ->  dotted 'I' (0x130)
toLowerCase(   non-dotted 'I' (0x49) )  ->  non-dotted 'i' (0x131)
toUpperCase(   non-dotted 'I' (0x49) )  ->  non-dotted 'I' (0x49)

toLowerCase(   non-dotted 'i' (0x131) )  ->  non-dotted 'i' (0x131)
toUpperCase(   non-dotted 'i' (0x131) )  ->  non-dotted 'I' (0x49)
toLowerCase(   dotted 'I' (0x130) )  ->  dotted 'i' (0x69)
toUpperCase(   dotted 'I' (0x130) )  ->  dotted 'I' (0x130)

In PCEnhance ( and most other OpenJPA code ), String.toUpperCase and toLowerCase are used regardless of this particularity, which translated the replaceIntField (and other variations of this method) to replace�ntField. Hence the observed exception.

In this scenario, java fields and methods used for Reflection must not be locale sensitive, hence toLowerCase/toUpperCase(Locale.ENGLISH) should be used instead.

There are other use cases in OpenJPA that should also consider to be locale insensitive, e.g. SQL reserved words should also use Locale.ENGLISH when toUpperCase/toLowerCase is called.

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"OpenJpa does not generate IDs properly. ""duplicate key value in a unique or primary key constraint"" while merging object tree.",OPENJPA-715,12403677,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,ekinsokmen,ekinsokmen,04/Sep/08 13:07,09/Mar/10 18:32,14/Mar/19 03:02,18/Sep/08 15:41,1.0.0,1.1.0,1.2.0,,,,,,,1.0.4,1.2.1,1.3.0,,,,,,,,,0,,"While merging object A in following relationship [ A (*-*) B (1-*) C ] we get the following error. The test case is attached and I tested it with openjpa 1.0.0, 1.1.0 and 1.2.0 official releases with same error. The main problem is the error does not occur if there are just 1 or 2 C objects attached to B. If we add more C to B the probability of getting the error increases (sad but true). You can see a for loop in the test case and a constant named ""MAGICAL_NUMBER"". If we set the magical number to 3 or less than we don't get this error and all objects are persisted just fine. But if we increase it to 50 (to be sure) we get the error below. 

There is also strange a workaround on line 63 of the test case. If we uncomment line 63 and just get the IDs of new C objects just after merge(A) but before commit () we can display proper IDs and the operation will be committed successfully. Otherwise the IDs of new C objects stay ""0""  (again sad but true :).  Maybe this hint can help on understanding and solving the issue.

The test case is created depending on a real life scenario. We get the same error with derby and mysql.

Here is the error after running the test case:
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 3.433 sec <<< FAILURE!
testChainEntities(org.apache.openjpa.persistence.relations.TestChainEntities)  Time elapsed: 3.362 sec  <<< ERROR!
<openjpa-1.1.0-r422266:659716 fatal store error> org.apache.openjpa.persistence.RollbackException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
        at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:523)
        at org.apache.openjpa.persistence.relations.TestChainEntities.chainUpdate(TestChainEntities.java:64)
        at org.apache.openjpa.persistence.relations.TestChainEntities.testChainEntities(TestChainEntities.java:32)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:122)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:334)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:980)
Caused by: <openjpa-1.1.0-r422266:659716 fatal general error> org.apache.openjpa.persistence.PersistenceException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
        at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2160)
        at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2007)
        at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1905)
        at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1823)
        at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
        at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1347)
        at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:877)
        at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:512)
        ... 29 more
Caused by: <openjpa-1.1.0-r422266:659716 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by 'SQL080903042502080' defined on 'CHAINENTITYC'. {prepstmnt 18739556 INSERT INTO ChainEntityC (cId, chainEntityBId, name, optLock, CHAINENTITYB_BID) VALUES (?, ?, ?, ?, ?) [params=(long) 0, (long) 0, (String) Test_C_48, (int) 1, (long) 3651]} [code=20000, state=23505]
FailedObject: org.apache.openjpa.persistence.relations.ChainEntityC@f6f1b6
        at org.apache.openjpa.jdbc.sql.SQLExceptions.narrow(SQLExceptions.java:146)
        at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4150)
        at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
        at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:72)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:131)
        at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushAndUpdate(BatchingPreparedStatementManagerImpl.java:82)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:89)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:72)
        at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:543)
        at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:105)
        at org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager.flush(BatchingConstraintUpdateManager.java:56)
        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:89)
        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:549)
        at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
        ... 36 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by 'SQL080903042502080' defined on 'CHAINENTITYC'. {prepstmnt 18739556 INSERT INTO ChainEntityC (cId, chainEntityBId, name, optLock, CHAINENTITYB_BID) VALUES (?, ?, ?, ?, ?) [params=(long) 0, (long) 0, (String) Test_C_48, (int) 1, (long) 3651]} [code=20000, state=23505]
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:192)
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$700(LoggingConnectionDecorator.java:57)
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:866)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1398)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.executeUpdate(PreparedStatementManagerImpl.java:151)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:120)
        ... 46 more


Results :

Tests in error:
  testChainEntities(org.apache.openjpa.persistence.relations.TestChainEntities)

Tests run: 1, Failures: 0, Errors: 1, Skipped: 0

[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] There are test failures.
","Fedora 6
java version ""1.5.0_11""",,,,,,,,,,,,,,,,,,,,,04/Sep/08 20:44;faywang;openjpa-715.patch;https://issues.apache.org/jira/secure/attachment/12389538/openjpa-715.patch,04/Sep/08 13:08;ekinsokmen;testcase_jira715.zip;https://issues.apache.org/jira/secure/attachment/12389497/testcase_jira715.zip,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-09-04 20:44:07.605,,,no_permission,,,,,,,,,,,161025,,,Thu Sep 18 15:41:09 UTC 2008,,,,,,,0|i0z2cf:,202682,,,,,,,,"04/Sep/08 13:10;ekinsokmen;You can run test case by copying files to openjpa-persistence-jdbc module and running
mvn test -Dtest=TestChainEntities","04/Sep/08 20:44;faywang;The duplicate key problem is due to the fact that the primary key for ChainEntityC is only generated for the first two ChainEntityC objects in the collection. Starting from the third ChainEntityC object, the logic in openjpa is such that the object id will not be generated at all (it then assumes the default value of 0). That is why if the test caes has more than 3 ChainEntityC objects in the collection in ChainEntityB, we will see duplicate key error as more than one ChainEntityC has primary key = 0.  The attached patch fixes this problem. Any comment is mostly appreciated.","04/Sep/08 23:23;faywang;As Kevin pointed out, sometimes the test case works fine with MAGICAL_NUMBER = 4 or 5 or 6 or .... In other words, the result is unpredictable. This is because during flush, the BrokerImpl will flush an un-ordered set of transactional objects. If the order of the flush is such that any C instance is flushed after A is flushed, that C instance will have valid object id. If all the C instances are flushed before A, then only the first 2 C instances will have valid object id.  

Specifically, right after A is done flushing, only the first 2 C instances have valid object id. If there are any C to be flushed in BrokerImpl, the beforeFlush of its state, PNewState, will be invoked, and assignObjectId will be called to generate valid object id. ","05/Sep/08 16:10;ekinsokmen;I applied and tested the patch. The issue is solved. Thanks.
",08/Sep/08 21:37;kwsutter;Resolved in 1.2.x and 1.3.0 (trunk).,18/Sep/08 15:29;kwsutter;Re-opening to migrate the fix back to the 1.0.x service stream.  A user requested this via private e-mail.,18/Sep/08 15:41;kwsutter;Migrated change back to 1.0.x.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""Encountered unmanaged object in persistent field"" error while merging object tree",OPENJPA-714,12403675,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,ekinsokmen,ekinsokmen,04/Sep/08 12:37,09/Mar/10 18:31,14/Mar/19 03:02,12/Jan/10 19:35,1.1.0,1.2.0,,,,,,,,1.2.2,1.3.0,2.0.0-beta,,,,,,,,,1,,"I get following error while merging a persisted entity A after adding new child entities to it.  The following relation exists between entities:  A -> (many to many) B -> (one to many) C. If I add ""cascade= {CascadeType.MERGE, CascadeType.PERSIST}"" to ChainEntityC.chainEntityB field It works.

My opinion is the cascade type on entity C should not be necessary because C is the last entity in the chain and should be cascaded from A to B to C. Cascade from C to B does not sound logical. The information is already given using foreignkey and cascase annotation. 

The test code is attached and works if you copy it to openjpa-persistence-jdbc test module. 

Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 3.62 sec <<< FAILURE!
testChainEntities(org.apache.openjpa.persistence.relations.TestChainEntities)  Time elapsed: 3.561 sec  <<< ERROR!
<openjpa-1.1.0-r422266:659716 nonfatal user error> org.apache.openjpa.persistence.InvalidStateException: Encountered unmanaged object in persistent field ""org.apache.openjpa.persistence.relations.ChainEntityC.chainEntityB"" during flush.  However, this field does not allow cascade persist. Set the cascade attribute for this field to CascadeType.PERSIST or CascadeType.ALL (JPA annotations) or ""persist"" or ""all"" (JPA orm.xml), or enable cascade-persist globally, or manually persist the related field value prior to flushing. You cannot flush unmanaged objects or graphs that have persistent associations to unmanaged objects.
FailedObject: org.apache.openjpa.persistence.relations.ChainEntityB@42a818
        at org.apache.openjpa.kernel.SingleFieldManager.preFlushPC(SingleFieldManager.java:753)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:594)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:562)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:478)
        at org.apache.openjpa.kernel.StateManagerImpl.preFlush(StateManagerImpl.java:2819)
        at org.apache.openjpa.kernel.PNewProvisionalState.nonprovisional(PNewProvisionalState.java:44)
        at org.apache.openjpa.kernel.StateManagerImpl.nonprovisional(StateManagerImpl.java:1130)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlushPC(SingleFieldManager.java:772)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlushPCs(SingleFieldManager.java:735)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:637)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:562)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:478)
        at org.apache.openjpa.kernel.StateManagerImpl.preFlush(StateManagerImpl.java:2819)
        at org.apache.openjpa.kernel.PNewProvisionalState.nonprovisional(PNewProvisionalState.java:44)
        at org.apache.openjpa.kernel.StateManagerImpl.nonprovisional(StateManagerImpl.java:1130)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlushPC(SingleFieldManager.java:772)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlushPCs(SingleFieldManager.java:735)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:637)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:562)
        at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:478)
        at org.apache.openjpa.kernel.StateManagerImpl.preFlush(StateManagerImpl.java:2819)
        at org.apache.openjpa.kernel.PDirtyState.beforeFlush(PDirtyState.java:37)
        at org.apache.openjpa.kernel.StateManagerImpl.beforeFlush(StateManagerImpl.java:957)
        at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1945)
        at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1905)
        at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1823)
        at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
        at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1347)
        at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:877)
        at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:512)
        at org.apache.openjpa.persistence.relations.TestChainEntities.chainUpdate(TestChainEntities.java:59)
        at org.apache.openjpa.persistence.relations.TestChainEntities.testChainEntities(TestChainEntities.java:27)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:122)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:334)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:980)


Results :

Tests in error:
  testChainEntities(org.apache.openjpa.persistence.relations.TestChainEntities)

Tests run: 1, Failures: 0, Errors: 1, Skipped: 0
","Fedora Linux 6
java version ""1.5.0_11""",,,,,,,,,,,,,,,,,,,,,15/Dec/09 16:33;fyrewyld;OpenJPA_1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12428053/OpenJPA_1.2.x.patch,04/Sep/08 12:41;ekinsokmen;testcase_jira714.zip;https://issues.apache.org/jira/secure/attachment/12389495/testcase_jira714.zip,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-09-05 15:27:55.861,,,no_permission,,,,,,,,,,,161024,,,Fri Jan 08 17:48:34 UTC 2010,,,,,,,0|i0z2bz:,202680,,,,,,,,"04/Sep/08 12:41;ekinsokmen;The test code is attached and works if you copy it into openjpa-persistence-jdbc module. 

Error output get using command:
mvn test -Dtest=TestChainEntities
","05/Sep/08 15:27;techhusky;Adding my original response from the user mailing list (below) for documentation purposes.  Arguably, I think OpenJPA is behaving within the spec, but it does seem like there should be enough information to do the merge.  I have your test running and will take a more in-depth look at this issue.

On Wed, Jul 9, 2008 at 7:52 PM, Jeremy Bauer <techhusky@gmail.com> wrote:

> I ran into a similar issue last week while using the merge operation.
> I found that since I had a bi-directional relationship with unmanaged
> entities (B <---> C in your case), OpenJPA needed both PERSIST and
> MERGE cascade enabled in order to maintain both sides of the
> relationship.  That way, new related entities can be persisted and
> existing entities can be merged from either side of the relationship.
> This behavior does not appear to be specifically defined by section
> 3.2.4.1 of the JPA spec, but it is also in my opinion, not
> contradictory to the requirements which are defined.  I could be
> totally off, but I was able to twist my own arm hard enough to
> convince myself that OpenJPA is working as expected.  :-)
>
> Besides adding adding the cascade options to C, if you make the B --->
> C relationship uni-directional or merge B (making it managed) before
> relating it to C (and vice-versa), the test also worked for me without
> problems.

",15/Dec/09 16:33;fyrewyld;Updated the junit tests for this patch,08/Jan/10 17:48;jpaheath;See comments for description of changes.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
openjpa-1.2.0.jar file is 11 MB,OPENJPA-713,12403673,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,patrick.peck,patrick.peck,04/Sep/08 11:46,09/Mar/10 18:32,14/Mar/19 03:02,17/Sep/08 08:50,1.0.3,1.2.0,,,,,,,,1.0.4,1.2.1,1.3.0,,,build / infrastructure,,,,,,1,,"The openjpa-1.2.0.jar file has a size of 11 MB.

This is because it packs the class files and the javadocs of these class files.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-09-04 13:23:14.352,,,no_permission,,,,,,,,,,,161023,,,Wed Sep 17 08:50:59 UTC 2008,,,,,,,0|i0z2bj:,202678,,,,,,,,"04/Sep/08 13:23;kwsutter;Yes, this was discovered and discussed on the mailing list during the 1.2.0 release process.  These ""extra"" files were actually introduced in earlier releases, but not noticed until the 1.2.0 release.  There are some benefits to having both the source and binaries in a single jar as an aid with debugging in an IDE.  To resolve this issue, we've discussed the idea of possibly separating everything into their own jars -- source, binaries, manuals, and javadoc.  It's makes for smaller jar files, but then development shops will probably need all four jars for their job.  Catch-22.

Thanks for opening the Issue.",05/Sep/08 09:39;antoniogmc;The same thing in openjpa-1.0.3.jar,17/Sep/08 08:50;mikedd;Resolved in svn. Javadoc and source jars are excluded when we create the aggregate openjpa-x.y.z.jar,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Not correctly parsing the ""having"" clause with aggregate functions (ie. max, min, etc)",OPENJPA-712,12403621,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,kwsutter,kwsutter,03/Sep/08 16:32,29/Sep/10 23:51,14/Mar/19 03:02,06/Sep/08 03:50,1.2.1,1.3.0,,,,,,,,1.2.3,1.3.0,,,,kernel,,,,,,0,,"Per the discussion on the dev forum (http://n2.nabble.com/Bug-in-HAVING-clause-(JPQL)-td835780.html)...  

I found this easy to reproduce.  It seems that our jjpql parser is not properly processing the aggregate functions within the Having clause.

It seems that these two (valid?) queries are throwing an exception:

  select m.idPublisher, max(m.datePublished)
    from Magazine m
 group by m.idPublisher
  having max(m.datePublished) is null

  select m.idPublisher, max(m.datePublished)
    from Magazine m
 group by m.idPublisher
  having max(m.datePublished) = current_date

The exception thrown is:

<openjpa-1.3.0-SNAPSHOT-runknown nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Encountered ""max ( m . datePublished ) is"" at character 90, but expected: [""("", "")"", ""*"", ""+"", ""-"", ""."", ""/"", "":"", ""<"", ""<="", ""<>"", ""="", "">"", "">="", ""?"", ""ABS"", ""ALL"", ""AND"", ""ANY"", ""AS"", ""ASC"", ""AVG"", ""BETWEEN"", ""BOTH"", ""BY"", ""CONCAT"", ""COUNT"", ""CURRENT_DATE"", ""CURRENT_TIME"", ""CURRENT_TIMESTAMP"", ""DELETE"", ""DESC"", ""DISTINCT"", ""EMPTY"", ""ESCAPE"", ""EXISTS"", ""FETCH"", ""FROM"", ""GROUP"", ""HAVING"", ""IN"", ""INNER"", ""IS"", ""JOIN"", ""LEADING"", ""LEFT"", ""LENGTH"", ""LIKE"", ""LOCATE"", ""LOWER"", ""MAX"", ""MEMBER"", ""MIN"", ""MOD"", ""NEW"", ""NOT"", ""NULL"", ""OBJECT"", ""OF"", ""OR"", ""ORDER"", ""OUTER"", ""SELECT"", ""SET"", ""SIZE"", ""SOME"", ""SQRT"", ""SUBSTRING"", ""SUM"", ""TRAILING"", ""TRIM"", ""UPDATE"", ""UPPER"", ""WHERE"", <BOOLEAN_LITERAL>, <DECIMAL_LITERAL>, <IDENTIFIER>, <INTEGER_LITERAL>, <STRING_LITERAL>].
       at org.apache.openjpa.kernel.jpql.JPQL.generateParseException(JPQL.java:9501)
       at org.apache.openjpa.kernel.jpql.JPQL.jj_consume_token(JPQL.java:9378)
...

For test case, one could use these classes:

/openjpa/trunk/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Magazine.java
/openjpa/trunk/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Publisher.java
","Configuration:
- OpenJPA 1.2.0 / OpenJPA 1.3.0 SNAPSHOT
- Enhancing at Build Time
- MySQL 5.0.22",,,,,,,,,,,,,,,,,,,,,29/Sep/10 20:10;jpaheath;OPENJPA-712-1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12455945/OPENJPA-712-1.2.x.patch,03/Sep/08 21:47;faywang;openjpa-712-1.patch;https://issues.apache.org/jira/secure/attachment/12389461/openjpa-712-1.patch,03/Sep/08 16:56;faywang;openjpa-712.patch;https://issues.apache.org/jira/secure/attachment/12389444/openjpa-712.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2008-09-03 16:56:08.382,,,no_permission,,,,,,,,,,,38257,,,Wed Sep 29 20:10:38 UTC 2010,,,Patch Available,,,,0|i0z6nj:,203380,,,,,,,,"03/Sep/08 16:56;faywang;The change in JPQL.jjt takes into account aggregate expression in the null expression and datetime expression. After apply the patch, you will need to do ""mvn compile"" for the change to take effect. ",03/Sep/08 21:47;faywang;Attached is the test case.,06/Sep/08 03:50;fancy;Fix checked in under r692609,"29/Sep/10 20:10;jpaheath;I'm providing patch OPENJPA-712-1.2.x.patch which, as its name implies, is for 1.2.x and includes a 'backport' of OPENJPA-712.patch and OPENJPA-712-1.patch.  

Thanks,

Heath",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PDF manual lacks images,OPENJPA-711,12403595,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,milosz,milosz,03/Sep/08 08:26,09/Mar/10 18:32,14/Mar/19 03:02,16/Sep/08 19:45,1.2.0,1.3.0,,,,,,,,1.0.4,1.2.1,1.3.0,,,docs,,,,,,0,,Images are missing in PDF versions of the manuals - affects at least 1.2.0 and the latest. 1.0.0 does have the images.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-09-11 14:28:13.853,,,no_permission,,,,,,,,,,,161022,,,Tue Sep 16 19:45:24 UTC 2008,,,,,,,0|i1dr5z:,288498,,,,,,,,"11/Sep/08 14:28;mikedd;The current version of the docbook plugin requires Java Advanced Imaging, or jimi to process our image files. I believe one of those libraries were automatically included in the past, but at the moment they're both missing. 

JAI and JIMI are not available in the central maven repository (or I didn't find them), so we'll have to download them manually in order to use them. I'll update the pom files appropriately when I get the nightly build issue sorted out. ","16/Sep/08 19:45;mikedd;Subsequent builds for 1.0.x, 1.2.x and 1.3.x will include images. The latest build at http://openjpa.apache.org/builds/latest/docs/manual/manual.pdf also includes images.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unordered collection field adds ORDER BY clause,OPENJPA-710,12403562,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,02/Sep/08 21:14,21/Sep/16 14:21,14/Mar/19 03:02,03/Sep/08 00:29,1.0.0,1.0.1,1.0.2,1.0.3,1.0.4,1.1.0,1.2.0,1.2.1,1.3.0,1.0.4,1.2.0,1.2.1,1.3.0,,kernel,,,,,,0,,"An ORDER BY clause is added while selecting even for collection-valued fields that do not require ordering. 

For example, consider a typical Parent-Child model with bi-directional relationship where Parent.children is declared and/or initialized as a Set rather than a List will result in the following SQL
       ""SELECT t0.id, t0.name, t1.id FROM PARENT t0 LEFT OUTER JOIN CHILD t1 ON t0.id = t1.PARENT_ID ORDER BY t1.PARENT_ID""
corresponding to JPQL ""select p from Parent p left join fetch p.children"".

Is ORDER BY clause necessary in this context? I
t also adds an extra performance overhead on the SQL query execution for a fairly frequent usage pattern.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-09-03 01:55:23.094,,,no_permission,,,,,,,,,,,161021,,,Wed Sep 03 01:55:23 UTC 2008,,,,,,,0|i0z6on:,203385,,,,,,,,03/Sep/08 01:55;kwsutter;Added additional versions (both affects and fix).,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Embedded fields in Secondary table generates wrong foreign key,OPENJPA-705,12403029,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,25/Aug/08 22:00,22/Apr/10 20:32,14/Mar/19 03:02,26/Aug/08 13:32,,,,,,,,,,1.3.0,,,,,,,,,,,0,,"When embedded entity is mapped to a secondary table, the primary key of the secondary table that refers to the owner table is named wrongly and different from the primaryKeyJoinColumn value specified in the @SecondaryTable annotation.

Originally reported in OpenJPA User forum [1] as the following example

@Entity
@Table(name = ""CUSTOMER"")
@SecondaryTable(name = ""CUSTOMER_EXT"", 
                                  pkJoinColumns = @PrimaryKeyJoinColumn(name = ""CUST_ID"", referencedColumnName = ""CUST_ID""))

public class Customer {
   @Embedded
   @AttributeOverrides( {
   @AttributeOverride(name = ""from"", column = @Column(name = ""FROM_DT"", table = ""CUSTOMER_EXT"")),
   @AttributeOverride(name = ""to"", column = @Column(name = ""TO_DT"", table = ""CUSTOMER_EXT""))} )
    private DateRange dr; 

The mapping should generate CUSTOMER_EXT table with 3 columns: CUST_ID, FROM_DT, TO_DT.

However, it generates a column named DATERANGE_CUST_ID instead of CUST_ID as specified in  @SecondaryTable annotation.


[1] http://n2.nabble.com/Embed-on-Secondary-Table-tc782286.html",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161016,,,2008-08-25 22:00:14.0,,,,,,,0|i0z6j3:,203360,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MappingTool fails requires appropriate DESCSTAT parm value on DB2 for z/OS,OPENJPA-702,12402997,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,techhusky,techhusky,techhusky,25/Aug/08 15:38,09/Mar/10 18:32,14/Mar/19 03:02,25/Aug/08 20:14,1.3.0,,,,,,,,,1.2.1,1.3.0,,,,docs,,,,,,0,,"When running with the IBM JCC driver to a DB2 on z/OS system the mapping tool may fail with the stack trace below if the DB2 DESCSTAT subsystem parameter is not set to 'YES'.  This parameter controls whether column names are returned in a JDBC metadata query.  Specifically, the mapping tool uses the JDBC-spec defined column names to query column metadata and that query will fail if DESCSTAT is set to 'NO'.  By default DB2 on z/OS version 8 and later set the DESCSTAT parameter to 'YES'.  However, if it gets set to 'NO' , explicitly or possibly via a DB migration, the mapping tool will fail.

org.apache.openjpa.persistence.PersistenceException: [ibm]
 [db2][jcc][10150][10300] Invalid parameter: Unknown column name TABLE_SCHEM.
 	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:553)
 	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:453)
 	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerF
actory.java:159)
 	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory
.java:119)
 	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.
java:189)
 	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFact
ory.java:142)
 	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(Enti
tyManagerFactoryImpl.java:192)
 	at  ...

I will post a patch shortly that includes a documentation update for the DB2 known issues section of the doc.
","OpenJPA trunk, DB2 for z/OS V8, IBM JCC type 4 JDBC driver.",,,,,,,,,,,,,,,,,,,,,25/Aug/08 16:13;techhusky;OPENJPA-702.patch;https://issues.apache.org/jira/secure/attachment/12388855/OPENJPA-702.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161014,,,Mon Aug 25 16:13:38 UTC 2008,,,,,,,0|i1dr6v:,288502,,,,,,,,25/Aug/08 16:13;techhusky;Attaching patch which contains documentation update for this issue.  Please commit to trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DB2 lastGeneratedKeyQuery should use new syntax for db2UDBV82OrLater,OPENJPA-700,12402892,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,fancy,fancy,fancy,22/Aug/08 17:40,22/Apr/10 20:32,14/Mar/19 03:02,22/Aug/08 17:50,1.3.0,,,,,,,,,1.3.0,,,,,jdbc,,,,,,0,,"DB2 UDB version 8.2 or later supports newer systax for lastGeneratedkeyQuery:

SELECT IDENTITY_VAL_LOCAL() FROM  SYSIBM.SYSDUMMY1",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161012,,,Fri Aug 22 17:50:34 UTC 2008,,,,,,,0|i1dr7b:,288504,,,,,,,,22/Aug/08 17:50;fancy;fix checked in under r688135,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"SQLWarnings not handled properly with WarningAction set to ""handle""",OPENJPA-699,12402891,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,xiaoqinfeng2000,xiaoqinfeng2000,22/Aug/08 17:24,09/Mar/10 18:31,14/Mar/19 03:02,27/Aug/08 16:47,1.0.0,,,,,,,,,2.0.0-M1,,,,,diagnostics,,,,,,0,,"If set  ""kodo.ConnectionFactoryProperties"" ""warningAction"" to ""throw"" or ""handle"", when an INSERT statement fails due 
to an attempt to insert null into a non-null column, log output is  ""The statement has been 
terminated"".
If didn't set  ""warningAction"", the default value is ""ignore"". It logs correct SQLException which is as follows:

Cannot 
insert the value NULL into column 'TestTimeNotNullNoDefaultUtc', table 
'STADatabase.dbo.DefaultValuesJ'; column does not allow nulls. INSERT fails. 
{prepstmnt 112461492 
... ...

In org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.LoggingPreparedStatement.executeUpdate(), the 
code is
            public int executeUpdate(String sql) throws SQLException {
                _sql = sql;
                logSQL(this);
                long start = System.currentTimeMillis();
                try {
                    return super.executeUpdate(sql);
                } catch (SQLException se) {
                    throw wrap(se, LoggingStatement.this);
                } finally {
                    logTime(start);
                    handleSQLWarning(LoggingStatement.this);
                }
            }
In this test case, it got a SQLWarning with msg 'The statement has been 
terminated' and a SQLException which tells Column null is not allowed.
When WarningAction is set to 'throw' or 'handle' and if handle doesn't 
consume the warning but throw it, the SQLWarning is thrown from finally 
block.
The SQLWarning which it is a subclass of SQLException will be processed by 
DBdictionary.newStoreException() so we see the incorrect message.

","Kodo 4.1.4
OpenJPA 1.0.0
MS SQL 2005
MS JDBC DRIVER VERSION  1.1 
JDK 1.5",,,,,,,,,,,,,,,,,,,,,26/Aug/08 17:40;xiaoqinfeng2000;openJPA-699-v2.patch;https://issues.apache.org/jira/secure/attachment/12388928/openJPA-699-v2.patch,22/Aug/08 21:30;xiaoqinfeng2000;openJPA-699.patch;https://issues.apache.org/jira/secure/attachment/12388776/openJPA-699.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-08-25 16:38:59.699,,,no_permission,,,,,,,,,,,161011,,,Wed Aug 27 16:47:11 UTC 2008,,,,,,,0|i0z2an:,202674,,,,,,,,"22/Aug/08 21:30;xiaoqinfeng2000;This is the proposed patch. 
Proposed solution is when a SQLException is catched and WarningAction is set to 'throw' or 'handle', we skip handleSQLwarning.

Solution is tested on customer case.
","25/Aug/08 16:38;awhite;Why don't we just always skip SQL warnings when we're throwing an exception?  I.e. just move all handleSQLWarning(...) calls to within the try{ ... } after calling super(...) rather than in the finally block?  It seems that when there is a thrown exception, warnings will always be either extraneous or completely meaningless as in this bug report.","25/Aug/08 17:30;xiaoqinfeng2000;I was thinking to add fix with least change of existing behavior. So customer can still get log message of warning with other warning action property when exception is thrown. 
I agree that usually when exception is thrown, warnings are meaningless.
I am fine with move handleSQLWarning() call to try block.
","25/Aug/08 17:40;joe weinstein;Hi. Actually sometimes the DBMS and driver implement it so the one SQLException
is fairly generic, with a lot of detail relegated to the messages in the SQLWarnings.
I have even seen SQLExceptions which state ""Please see the information in the
chained SQLWarnings""!
Joe Weinstein","25/Aug/08 18:33;awhite;If Joe is right then neither my proposed solution nor the attached patch are acceptable.  We need to capture the output of both the exception and any warnings.  So I propose the following changes to LoggingConnectionDecorator:

1. Change the following pattern: 
try {...} catch(SQLException se) { throw wrap(se...); } finally { ... handleSQLWarnings(...); }
to:
SQLException err = null;
try {...} catch(SQLException se) { err = wrap(se...); } finally { ... handleSQLErrors(..., err); }

2. Change all the handleSQLWarnings methods except handleSQLWarnings(SQLWarning) to be named handleSQLErrors and to accept an extra SQLException argument.  The try/finally blocks in these methods will become try/catch/finally blocks where the catch captures the thrown exception.  At the end of the method we combine the passed-in exception with the thrown exception and throw the result as a single exception (unless either/both are null of course, in which case we throw the non-null one or nothing at all).  

3. Fix all the prepareStatement/createStatement methods that currently don't have handleSQLWarnings in a finally block at all to use a try/catch/finally block as outlined in change #1 above.

Does that sound acceptable?  We might still get extraneous ""The statement has been closed"" output in the combined exceptions we throw under certain drivers, but at least no information will get lost.",25/Aug/08 19:07;xiaoqinfeng2000;That is a good plan.,26/Aug/08 17:40;xiaoqinfeng2000;Here is the revised patch according to our discussion.,27/Aug/08 16:47;awhite;Applied v2 patch per comments in SVN revision 689518.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Callable SQL statement  are not logged,OPENJPA-698,12402882,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,22/Aug/08 15:41,22/Apr/10 20:32,14/Mar/19 03:02,25/Aug/08 14:03,,,,,,,,,,1.3.0,,,,,,,,,,,0,,Native SQLs that manifest as JDBC CallableStatement (as opposed to PreparedStatements) are not logged.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161010,,,2008-08-22 15:41:50.0,,,,,,,0|i1dr7j:,288505,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@VersionColumns annotation throws exception when multiple columns are specified,OPENJPA-697,12402836,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,dinkar,dinkar,22/Aug/08 03:47,12/Sep/09 04:46,14/Mar/19 03:02,12/Sep/09 04:46,2.0.0,,,,,,,,,1.3.0,,,,,jpa,,,,,,0,,"The OpenJPA manual very briefly talks about the @VersionColumns annotation, but its usage is not clear. I have an entity that tries to use this annotation (below), but I get back an exception when I run the mapping tool against it:

""Exception in thread ""main"" <openjpa-1.3.0-SNAPSHOT-runknown fatal user error>
org.apache.openjpa.util.MetaDataException: For ""entities.Employee<version>"", expected 1 column(s),
but found 2.""

@Entity
@VersionColumns({@VersionColumn(name=""vcol1""),@VersionColumn(name=""vcol2"")})
@SecondaryTable(name=""EADDRESS"", pkJoinColumns=@PrimaryKeyJoinColumn(name=""EMPID""))
public class Employee {
        @Id @GeneratedValue(strategy=GenerationType.AUTO)
        private int empid;
        private String name;
       
        @Column(table=""EADDRESS"")
        private String street1;
        @Column(table=""EADDRESS"")
        private String street2;
        @Column(table=""EADDRESS"")
        private String city;
        @Column(table=""EADDRESS"")
        private int zipcode;
}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-08-29 16:58:04.006,,,no_permission,,,,,,,,,,,161009,,,Fri Aug 29 17:00:18 UTC 2008,,,,,,,0|i0yx53:,201839,,,,,,,,29/Aug/08 16:58;ppoddar@apache.org;A relevant use case for multi-column versioning is setting version columns across primary and secondary tables. The version strategy and schema definition does not address the case where the columns are spread across multiple tables.,29/Aug/08 17:00;ppoddar@apache.org;Changes the priority as the related changes to support multi-column versioning requires new capabilities.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cache TransactionSynchronizationRegistry per EMF (vs JVM),OPENJPA-696,12402799,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,kwsutter,kwsutter,21/Aug/08 15:25,06/Jun/15 21:19,14/Mar/19 03:02,10/Jul/13 02:16,1.0.0,1.0.1,1.0.2,1.0.3,1.1.0,1.2.0,,,,2.3.0,,,,,kernel,,,,,,0,,"Discussed in OpenJPA forum first:  http://n2.nabble.com/TransactionSynchronizationRegistry-reference-cached-permanently-td727197.html#a727197

This Issue is requesting that we cache the reference for the TransactionSynchronizationRegistry in the EMF instead of per JVM.  This would be similar to what we did with the TransactionManager in the past.  Reference the forum postings for background and justification on the request.",,,,,,,,,,,,,,,,,,,,,,25/Sep/08 19:04;mikedd;OPENJPA-696.patch.txt;https://issues.apache.org/jira/secure/attachment/12390943/OPENJPA-696.patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-09-25 18:05:47.205,,,no_permission,,,,,,,,,,,161008,,,Wed Jul 10 02:16:01 UTC 2013,,,,,,,0|i00erz:,322,,,,,,,,"25/Sep/08 18:05;mikedd;I think the root cause here is that the xxManagedRuntime classes are static members of the AutomaticManagedRuntime class. The attached patch initializes them in AutomaticManagedRuntime's constructor. 

I've done some sniff testing and it looks like it will address the issue. I wasn't able to reproduce the exact problem reported though. If there's an easy way to test the patch with OpenEJB I'm happy to try that out as well. ","10/Jul/13 02:14;jira-bot;Commit 1501634 from [~mikedd]
[ https://svn.apache.org/r1501634 ]

OPENJPA-696: Make transaction synchronization registries non-static.

Patch is old - feel free to revert if something breaks.",10/Jul/13 02:16;mikedd;Committed patch - it's safe as far as I know. If it produces problems we can revert and cancel this issue. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Link to latest manuals in OpenJPA website is broken,OPENJPA-695,12402649,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,ppoddar@apache.org,ppoddar@apache.org,19/Aug/08 17:32,22/Apr/10 20:32,14/Mar/19 03:02,11/Sep/08 18:21,1.2.0,,,,,,,,,1.3.0,,,,,,,,,,,0,,"Link to latest manuals [2] in OpenJPA website [1] is broken.

[1] http://openjpa.apache.org/documentation.html
[2] http://openjpa.apache.org/docs/latest/manual/index.html",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-09-03 08:21:10.449,,,no_permission,,,,,,,,,,,161007,,,Thu Sep 11 18:21:47 UTC 2008,,,,,,,0|i0z2a7:,202672,,,,,,,,"03/Sep/08 08:21;milosz;There is some manual under the ""latest"" link but it lacks CSS and images. Also, the link to Javadocs is broken.

The ""OpenJPA 1.2.0 releases"" heading could rather say ""OpenJPA 1.2.x releases"".
","11/Sep/08 18:21;mikedd;The latest documentation is available (again) at http://openjpa.apache.org/builds/latest/docs/manual/. 

The latest directory will be updated semi-nightly (depending on svn activity), and can be done manually by anyone with write access to the openjpa site on people.apache.org by running the following commands. 

trunk$ mvn -Pjavadoc-profile,docbook-profile package
trunk$ cd openjpa-project
trunk/openjpa-project$ mvn -Dnightly.user.name=YOUR_USERID -Dnightly.password=YOUR_PASSWORD -Pnightly-upload package

The username and password may also be specified in a maven profile in ${user.home}/.m2/settings.xml for better security. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Can not persist Parent-Child mapping when child refers to parent via parent's primary identity (and not parent's object reference) and parent uses database sequence for its own identity,OPENJPA-693,12402261,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,13/Aug/08 01:08,22/Apr/10 20:32,14/Mar/19 03:02,25/Aug/08 14:40,,,,,,,,,,1.3.0,,,,,,,,,,,0,,"The following use case is reported in the users' group [1].

A typical Parent-Child (Address has many Phones) relationship. But Phone refers to Address by its primary key. And database assigns the primary key of the Address.
When and how to set the child's reference field to its parent?

Approach A:
1. Remove all children from Parent, but remember them
2. flush() the Parent.
3. Database will now assign identity to Parent
4. Add the children back and set each child's identifier to the newly assigned identifier of the Parent
5. commit

The other approach B which is cleaner
1. Add a @PostPersist method to Parent.java as follows
     @PostPersist
     public void postPersist() {
           if (children== null) return;
           for (Child child : children)
               parent.setParentId(this.getId());
     }

2. commit()

Unfortunately Approach B does not work as expected with existing OpenJPA because it prohibits Phone.addressId value to be reassigned during a flush cycle as resulted from Address.postPersist() method.

I have added a fix to relax that prohibition under some circumstances but I am concerned whether this relaxing of restriction will now allow other truly invalid use cases those the original restriction was duly imposing. 

The fix passes the OpenJPA test corpus -- but that is also not proof enough of its robustness.

Comments/thoughts?
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,161005,,,2008-08-13 01:08:41.0,,,,,,,0|i0z53j:,203128,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bi-directional One-to-Many mapping with a JoinTable fails for Update or Delete operation,OPENJPA-692,12402066,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,09/Aug/08 19:13,22/Apr/10 20:32,14/Mar/19 03:02,25/Aug/08 14:06,,,,,,,,,,1.3.0,,,,,,,,,,,0,,"Originally reported in user group message [1] by Frank Schwarz 

If
a) Entities A and B that are related in a one-to-many and many-to-one bi-directional relation (typical Parent-Child pattern)
b) mapped using a JoinTable instead of conventional mappedBy 

then
update/delete operation fails with OptimisticException (which itself is a catch-all and sometimes misleading). 


Typical mapping that encounters this error:

public class Person {
	@Id
	private long ssn;
	
	@OneToMany(cascade=CascadeType.ALL)
	@JoinTable(name=""J_PERSON_ADDRESSES"",
			joinColumns               = @JoinColumn(name=""PERSON_SSN"",    referencedColumnName=""SSN""),
			inverseJoinColumns = @JoinColumn(name=""ADDRESS_PHONE"", referencedColumnName=""PHONE""))
    private Set<Address> addresses = new HashSet<Address>();

public class Address {
   @Id
   private String phone;
	
    @ManyToOne
    @JoinColumn(table=""J_PERSON_ADDRESSES"", referencedColumnName=""SSN"")
    private Person person;

[1] http://n2.nabble.com/bidirectional-one-to-many-relationship-with-join-table-tc678479.html
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-08-10 08:09:32.037,,,no_permission,,,,,,,,,,,161004,,,Tue Aug 12 06:46:39 UTC 2008,,,,,,,0|i0z7u7:,203572,,,,,,,,"10/Aug/08 08:09;fs5;I did some additional testing with Hibernate3. It seems that Hibernate is very robust on this topic.

The following mappings worked as expected:
1.
@Entity
public class Person {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private long id;

	@OneToMany(mappedBy = ""person"", cascade = CascadeType.ALL)
	@JoinTable(name=""PERSON_ADDRESS"",
                  joinColumns=@JoinColumn(name=""PERSON_ID"", referencedColumnName=""ID""),
                  inverseJoinColumns=@JoinColumn(name=""ADDRESS_ID"", referencedColumnName=""ID""))
	private Set<Address> addresses = new HashSet<Address>();
}

@Entity
@SecondaryTable(name=""PERSON_ADDRESS"", pkJoinColumns=@PrimaryKeyJoinColumn(name=""ADDRESS_ID""))
public class Address {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private long id;

	@ManyToOne
	@JoinColumn(table=""PERSON_ADDRESS"", referencedColumnName=""ID"")
	private Person person;
}
------%<----------------

2.
@Entity
public class Person {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private long id;

	@OneToMany(mappedBy = ""person"", cascade = CascadeType.ALL)
	private Set<Address> addresses = new HashSet<Address>();
}

@Entity
@SecondaryTable(name=""PERSON_ADDRESS"", pkJoinColumns=@PrimaryKeyJoinColumn(name=""ADDRESS_ID""))
public class Address {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private long id;

	@ManyToOne
	@JoinColumn(table=""PERSON_ADDRESS"") 
	private Person person;
}
------%<----------------

3.
@Entity
public class Person {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private long id;

	@OneToMany(mappedBy = ""person"", cascade = CascadeType.ALL)
	private Set<Address> addresses = new HashSet<Address>();
}

@Entity
public class Address {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private long id;

	@ManyToOne
	@JoinTable(name=""PERSON_ADDRESS"", joinColumns=@JoinColumn(name=""ADDRESS_ID""))
	private Person person;
}


Not working with Hibernate is leaving out the ""mappedBy"" attribute of the Person.addresses field annotation in the first mapping example.

Personally, I would like to see the third example mapping working. It uses minimal annotations but remains semantically understandable. And it conforms with the spirit of JSR220 disapproving additional annotations on a ""mapped-by"" field.","11/Aug/08 06:32;ppoddar@apache.org;With SVN Commit 68442, OpenJPA addresses the bi-directional mapping with a JoinTable when mapping is annotated is two independent mappings at both ends of the relationship i.e. no 'mappedBy' attribute links the two ends.
Can you try that mapping with these latest changes to let us know whether that works for you? I have tested them and the check-in test cases are available with revision 68443.

The other variants you have mentioned with @SecondaryTable annotations need to be tested with OpenJPA. ","11/Aug/08 09:34;fs5;I tried the mapping as specified in the description field of this case.

It works with current trunk (revision 684688/1.3.0-SNAPSHOT). Schema, SQL statements and runtime behavior are OK with one exception:

Dissolving relationship, e.g.:
			Address address = person.getAddresses().iterator().next();
			person.getAddresses().remove(address);
			address.setPerson(null);

leads to UPDATE PERSON_ADDRESS SET PERSON_SSN = ? WHERE ADDRESS_PHONE = ? [params=(null) null, (long) 3]
Actually it has to be DELETE FROM PERSON_ADDRESS WHERE ADDRESS_PHONE = ? [params=(long) 3]. Otherwise the join-table will get filled with meaningless <NULL, ADDRESS_PHONE> tupels
","12/Aug/08 06:46;fs5;With latest changes in trunk the dissolution of associations seems to work, i.e. an SQL delete statement is now used instead of an SQL update-set-null statement.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem enhancing test cases with Maven 2.0.9 ,OPENJPA-685,12402031,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,dezzio,dezzio,08/Aug/08 20:04,09/Mar/10 18:32,14/Mar/19 03:02,22/Sep/08 20:10,,,,,,,,,,1.0.4,1.2.1,1.3.0,,,build / infrastructure,,,,,,0,,"Starting with Maven 2.0.8 (later corrected to 2.0.9) there is a problem with the enhancement step that leads to numerous (yet apparently non-fatal) exceptions being thrown during the enhancement step.  Debugging reveals that the problem occurs when the code is trying to unzip pom.xml.  The problem may arise from some difference in the Maven Ant plugin.

The exception seen looks like the following:

java.util.zip.ZipException: error in opening zip file
        at java.util.zip.ZipFile.open(Native Method)
        at java.util.zip.ZipFile.<init>(ZipFile.java:203)
        at java.util.zip.ZipFile.<init>(ZipFile.java:234)
        at org.apache.tools.ant.AntClassLoader.getResourceURL(AntClassLoader.java:919)
        at org.apache.tools.ant.AntClassLoader.getResource(AntClassLoader.java:832)
        at java.lang.ClassLoader.getResource(ClassLoader.java:972)
        at org.apache.openjpa.lib.util.J2DoPrivHelper$13.run(J2DoPrivHelper.java:377)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.getSourceFile(AnnotationPersistenceMetaDataParser.java:684)
        at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.getMetaData(AnnotationPersistenceMetaDataParser.java:660)
        at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parseClassAnnotations(AnnotationPersistenceMetaDataParser.java:480)
        at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parse(AnnotationPersistenceMetaDataParser.java:352)
        at org.apache.openjpa.persistence.PersistenceMetaDataFactory.load(PersistenceMetaDataFactory.java:229)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:474)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:294)
        at org.apache.openjpa.meta.ValueMetaDataImpl.resolveDeclaredType(ValueMetaDataImpl.java:431)
        at org.apache.openjpa.meta.ValueMetaDataImpl.resolve(ValueMetaDataImpl.java:410)
        at org.apache.openjpa.meta.FieldMetaData.resolve(FieldMetaData.java:1676)
        at org.apache.openjpa.meta.ClassMetaData.resolveMeta(ClassMetaData.java:1690)
        at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1625)
        at org.apache.openjpa.meta.MetaDataRepository.processBuffer(MetaDataRepository.java:717)
        at org.apache.openjpa.meta.MetaDataRepository.resolveMeta(MetaDataRepository.java:616)
        at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:541)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:308)
        at org.apache.openjpa.meta.MetaDataRepository.resolveMeta(MetaDataRepository.java:581)
        at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:541)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:308)
        at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:248)
        at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:4492)
        at org.apache.openjpa.ant.PCEnhancerTask.executeOn(PCEnhancerTask.java:89)
        at org.apache.openjpa.lib.ant.AbstractTask.execute(AbstractTask.java:172)
        at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
        at org.apache.tools.ant.Task.perform(Task.java:364)
        at org.apache.tools.ant.Target.execute(Target.java:341)
        at org.apache.tools.ant.Target.performTasks(Target.java:369)
        at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)
        at org.apache.tools.ant.helper.SingleCheckExecutor.executeTargets(SingleCheckExecutor.java:37)
        at org.apache.tools.ant.Project.executeTargets(Project.java:1068)
        at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:382)
        at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.java:107)
        at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
        at org.apache.tools.ant.Task.perform(Task.java:364)
        at org.apache.tools.ant.Target.execute(Target.java:341)
        at org.apache.tools.ant.Target.performTasks(Target.java:369)
        at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)
        at org.apache.tools.ant.helper.SingleCheckExecutor.executeTargets(SingleCheckExecutor.java:37)
        at org.apache.tools.ant.Project.executeTargets(Project.java:1068)
        at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:382)
        at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
        at org.apache.tools.ant.Task.perform(Task.java:364)
        at org.apache.tools.ant.Target.execute(Target.java:341)
        at org.apache.maven.plugin.antrun.AbstractAntMojo.executeTasks(AbstractAntMojo.java:108)
        at org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:83)
        at org.apache.maven.plugin.DefaultPluginManager.executeMojo(DefaultPluginManager.java:451)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoals(DefaultLifecycleExecutor.java:558)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalWithLifecycle(DefaultLifecycleExecutor.java:499)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoal(DefaultLifecycleExecutor.java:478)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalAndHandleFailures(DefaultLifecycleExecutor.java:330)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeTaskSegments(DefaultLifecycleExecutor.java:291)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.execute(DefaultLifecycleExecutor.java:142)
        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:336)
        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:129)
        at org.apache.maven.cli.MavenCli.main(MavenCli.java:287)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315)
        at org.codehaus.classworlds.Launcher.launch(Launcher.java:255)
        at org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:430)
        at org.codehaus.classworlds.Launcher.main(Launcher.java:375)",Maven 2.0.9 (latest available) and Sun JVM 1.5.0_14.,0,0,,0%,0,0,,,,,,,,,,,,,,,22/Sep/08 14:05;mikedd;OPENJPA_685.patch.txt;https://issues.apache.org/jira/secure/attachment/12390647/OPENJPA_685.patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-08-08 20:38:06.412,,,no_permission,,,,,,,,,,,160997,,,Mon Sep 22 17:40:48 UTC 2008,,,,,,,0|i0z55j:,203137,,,,,,,,08/Aug/08 20:05;dezzio;It may be relevant that I am using Windows XP.,"08/Aug/08 20:38;allee8285;David,

Try cleaning up (rename/remove) your local repository at .m2/* and let maven download the right level of dependencies seem to resolve this problem condition.  If I recall, Mike D. reminded me to stay with maven 2.0.8 to avoid other problems.

Albert Lee.","10/Aug/08 20:08;ppoddar@apache.org;I have been silently suffering from this symptom for months.
Did not occur that the cause may lie with Maven version. But, once you mention it, it is true that the problem did appear as I moved into a new box with and used a newer version of Maven (2.0.9).

","11/Aug/08 15:17;dezzio;Hi Albert,

I first saw this problem with Maven 2.0.8 in April.  I tried your suggestion with Maven 2.0.9.  Report behavior persists.

My configuration:

C:\code\svn\RW_OpenJPAMainline>mvn -v
Maven version: 2.0.9
Java version: 1.5.0_14
OS name: ""windows xp"" version: ""5.1"" arch: ""x86"" Family: ""windows""

C:\code\svn\RW_OpenJPAMainline>java -version
java version ""1.5.0_14""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_14-b03)
Java HotSpot(TM) Client VM (build 1.5.0_14-b03, mixed mode)

C:\code\svn\RW_OpenJPAMainline>ver

Microsoft Windows XP [Version 5.1.2600]
","11/Aug/08 18:23;dezzio;Hi Albert,

Right, you are.  Contrary to my prior belief, the problem does not occur (for me) with Maven 2.0.8.  I followed your instructions to rebuild the repository for 2.0.8 (just as I have done with the other versions), and the enhancement step was clean.

Thanks,

David","20/Sep/08 01:40;maxoffman;I observed similar diagnostics with a Maven 2.0.9 maven-antrun-plugin -launched enhancement. The culprit was in:

        <path id=""cp"">
            <path refid=""maven.test.classpath"" />
            <path refid=""maven.compile.classpath"" />
            <path refid=""maven.dependency.classpath"" />
        </path>
 
After removing <path refid=""maven.dependency.classpath"" /> there were no more exceptions. I believe that ""maven.dependency.classpath""  has been deprecated in favor of ""maven.compile.classpath"" .
",22/Sep/08 12:46;mikedd;Per remarks at http://jira.codehaus.org/browse/MANTRUN-38 maven.dependency.classpath will be deprecated in the future. I'm not sure it *is* deprecated in the latest version of the antrun plugin though. ,"22/Sep/08 14:05;mikedd;I have not been able to reproduce the issue on Linux. From the documentation on the antrun plugin page it looks like maven.dependency.classpath is (or will be) deprecated). The maven.compile.classpath is a subset of maven.test.classpath and can also be removed. 

I took both references out of the build files and produced the attached patch. If one of the people who can reproduce the problem could verify that the patch works I'll go ahead and commit the changes. Otherwise I'll try to scrounge up a Windows box.",22/Sep/08 17:40;techhusky;I experienced the same issue using mvn 2.0.8 & 2.0.9 on Windows.  I applied your patched and ran a trunk build with 2.0.9 and it looks good.  +1 to commit.,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Flush followed by refresh on a new instance returns an instance with all fields but id cleared,OPENJPA-680,12401950,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ssegu,ssegu,ssegu,08/Aug/08 01:12,21/Sep/16 14:21,14/Mar/19 03:02,03/Mar/10 18:33,1.2.0,1.2.1,1.3.0,,,,,,,1.2.0,1.2.2,1.3.0,2.0.0-M1,,kernel,,,,,,1,,This looks to be resolved.  I'll mark the fix versions according to the commits and then resolve it.,,,,,,,,,,,,,,,,,,,,,,23/Aug/08 01:19;ssegu;OPENJPA-680.patch;https://issues.apache.org/jira/secure/attachment/12388785/OPENJPA-680.patch,08/Aug/08 01:13;ssegu;testcase.zip;https://issues.apache.org/jira/secure/attachment/12387791/testcase.zip,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-08-12 21:40:16.831,,,no_permission,,,,,,,,,,,160992,,,Thu Mar 11 02:44:23 UTC 2010,,,,,,,0|i1dqqv:,288430,,,,,,,,08/Aug/08 01:13;ssegu;Testcase,"12/Aug/08 21:40;allee8285;This patch has regressed the TCK in trunk and 1.2.x branch. The errors reported in openjpa-tck.log are:

------------------------------------------
********************************************************************************
Beginning Test:  com.sun.ts.tests.ejb30.persistence.callback.listener.Client.postLoadMultiTest_from_standalone
********************************************************************************
08-12-2008 04:52:05:  Harness - harness.executeMode is set to ""0""
08-12-2008 04:52:05:  Harness - sClassPathFromExecProps = 
command: com.sun.ts.lib.harness.ExecTSTestCmd CLASSPATH=../classes:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/classes:/root/.m2/repository/org/apache/derby/derby/10.2.1.6/derby-10.2.1.6.jar:/root/.m2/repository/javax/persistence/persistence-api/1.0b/persistence-api-1.0b.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-kernel/target/classes:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-lib/target/openjpa-lib-1.3.0-SNAPSHOT.jar:/root/.m2/repository/commons-logging/commons-logging/1.0.4/commons-logging-1.0.4.jar:/root/.m2/repository/log4j/log4j/1.2.13/log4j-1.2.13.jar:/root/.m2/repository/commons-lang/commons-lang/2.1/commons-lang-2.1.jar:/root/.m2/repository/ant/ant/1.6.5/ant-1.6.5.jar:/root/.m2/repository/commons-collections/commons-collections/3.2/commons-collections-3.2.jar:/root/.m2/repository/net/sourceforge/serp/serp/1.13.1/serp-1.13.1.jar:/root/.m2/repository/org/apache/geronimo/specs/geronimo-jms_1.1_spec/1.0.1/geronimo-jms_1.1_spec-1.0.1.jar:/root/.m2/repository/org/apache/geronimo/specs/geronimo-jta_1.1_spec/1.1/geronimo-jta_1.1_spec-1.1.jar:/root/.m2/repository/commons-pool/commons-pool/1.3/commons-pool-1.3.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/ant_sun.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/apiCheck.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/javatest.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/jaxen-core.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/jaxen-jdom.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/jdom.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/saxpath.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/sigtest.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/tsharness.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/tspackager.jar:/opt/jetbrains/TeamCity/plugins/maven-2.0.8/boot/classworlds-1.1.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/:../lib/tsharness.jar:../lib/sigtest.jar:../classes:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/classes:/root/.m2/repository/org/apache/derby/derby/10.2.1.6/derby-10.2.1.6.jar:/root/.m2/repository/javax/persistence/persistence-api/1.0b/persistence-api-1.0b.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-kernel/target/classes:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-lib/target/openjpa-lib-1.3.0-SNAPSHOT.jar:/root/.m2/repository/commons-logging/commons-logging/1.0.4/commons-logging-1.0.4.jar:/root/.m2/repository/log4j/log4j/1.2.13/log4j-1.2.13.jar:/root/.m2/repository/commons-lang/commons-lang/2.1/commons-lang-2.1.jar:/root/.m2/repository/ant/ant/1.6.5/ant-1.6.5.jar:/root/.m2/repository/commons-collections/commons-collections/3.2/commons-collections-3.2.jar:/root/.m2/repository/net/sourceforge/serp/serp/1.13.1/serp-1.13.1.jar:/root/.m2/repository/org/apache/geronimo/specs/geronimo-jms_1.1_spec/1.0.1/geronimo-jms_1.1_spec-1.0.1.jar:/root/.m2/repository/org/apache/geronimo/specs/geronimo-jta_1.1_spec/1.1/geronimo-jta_1.1_spec-1.1.jar:/root/.m2/repository/commons-pool/commons-pool/1.3/commons-pool-1.3.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/ant_sun.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/apiCheck.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/javatest.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/jaxen-core.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/jaxen-jdom.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/jdom.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/saxpath.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/sigtest.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/tsharness.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/lib/tspackager.jar:/opt/jetbrains/TeamCity/plugins/maven-2.0.8/boot/classworlds-1.1.jar:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/:../lib/javatest.jar:../tools/ant/lib/ant.jar:/opt/jetbrains/jdk/sun/jdk5/jre/../lib/tools.jar:DISPLAY=:0.0:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-integration/tck/target/tck/jpatck/src/../dist/com/sun/ts/tests/ejb30/persistence/callback/listener/ejb3_pm_callback_listener.jar HOME=/root windir= SYSTEMROOT= /opt/jetbrains/jdk/sun/jdk5/jre/bin/java -Dcts.tmp=../tmp -Djava.security.policy=../bin/harness.policy -Ddeliverable.class=com.sun.ts.lib.deliverable.jpa.JPADeliverable -javaagent:/opt/jetbrains/TeamCity/work/98561997f875f84e/openjpa-all/target/openjpa-1.3.0-SNAPSHOT.jar -Dopenjpa.MetaDataFactory=jpa(DefaultAccessType=PROPERTY) com.sun.ts.tests.common.vehicle.VehicleClient -p ../tmp/tstest.jte -t postLoadMultiTest -vehicle standalone
************************************************************
* props file set to ""/tmp/root-cts-props.txt""
************************************************************
setup
platform.mode is set to standalone, so tests are running in J2SE environment standalone mode.persistence.unit.name is set to JPATCK
persistence unit properites from user: {openjpa.jdbc.DBDictionary=StoreCharsAsNumbers=false, openjpa.FetchBatchSize=-1, openjpa.Compatibility=StrictIdentityValues=true, javax.persistence.provider=org.apache.openjpa.persistence.PersistenceProviderImpl, openjpa.ConnectionURL=jdbc:derby:derby-database;create=true, openjpa.Sequence=time, openjpa.ConnectionDriverName=org.apache.derby.jdbc.EmbeddedDriver, openjpa.Log=DefaultLevel=WARN, openjpa.ConnectionUserName=nousername, openjpa.jdbc.SchemaFactory=native(ForeignKeys=true), openjpa.ConnectionPassword=nopassword}
persistence unit properites verified: {openjpa.jdbc.DBDictionary=StoreCharsAsNumbers=false, openjpa.FetchBatchSize=-1, openjpa.Compatibility=StrictIdentityValues=true, javax.persistence.provider=org.apache.openjpa.persistence.PersistenceProviderImpl, openjpa.ConnectionURL=jdbc:derby:derby-database;create=true, openjpa.Sequence=time, openjpa.ConnectionDriverName=org.apache.derby.jdbc.EmbeddedDriver, openjpa.Log=DefaultLevel=WARN, openjpa.ConnectionUserName=nousername, openjpa.jdbc.SchemaFactory=native(ForeignKeys=true), openjpa.ConnectionPassword=nopassword}
Product: In prePersist in class com.sun.ts.tests.ejb30.persistence.callback.common.ListenerA@c8c7d6
Product: In prePersist in class com.sun.ts.tests.ejb30.persistence.callback.common.ListenerB@18c5e67
Product: In prePersist in class com.sun.ts.tests.ejb30.persistence.callback.common.ListenerC@89c116
Product: In postPersist.com.sun.ts.tests.ejb30.persistence.callback.common.ListenerA@1c79dfc
Product: In postPersist.com.sun.ts.tests.ejb30.persistence.callback.common.ListenerB@553763
Product: In postPersist.com.sun.ts.tests.ejb30.persistence.callback.common.ListenerC@a75737
Product: In postLoad.com.sun.ts.tests.ejb30.persistence.callback.common.ListenerA@7f3b8a
Product: In postLoad.com.sun.ts.tests.ejb30.persistence.callback.common.ListenerB@11e1bbf
Product: In postLoad.com.sun.ts.tests.ejb30.persistence.callback.common.ListenerC@1afd9cc
Product: In postLoad.com.sun.ts.tests.ejb30.persistence.callback.common.ListenerA@3e926
Product: In postLoad.com.sun.ts.tests.ejb30.persistence.callback.common.ListenerB@bfd66a
Product: In postLoad.com.sun.ts.tests.ejb30.persistence.callback.common.ListenerC@95f290
org.apache.openjpa.kernel.DelegatingResultList@1566a6c
08-12-2008 04:52:11:  ERROR: Expecting result list: [ListenerA, ListenerB, ListenerC], but actual: [ListenerA, ListenerB, ListenerC, ListenerA, ListenerB, ListenerC]
08-12-2008 04:52:11:  ERROR: Exception at: 
08-12-2008 04:52:11:  ERROR: com.sun.ts.lib.harness.EETest$Fault: Expecting result list: [ListenerA, ListenerB, ListenerC], but actual: [ListenerA, ListenerB, ListenerC, ListenerA, ListenerB, ListenerC]
	at com.sun.ts.tests.ejb30.common.helper.Helper.compareResultList(Helper.java:30)
	at com.sun.ts.tests.ejb30.common.helper.Helper.compareResultList(Helper.java:36)
	at com.sun.ts.tests.ejb30.persistence.callback.listener.Client.postLoadMultiTest(Client.java:565)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at com.sun.ts.lib.harness.EETest.run(EETest.java:495)
	at com.sun.ts.lib.harness.ServiceEETest.run(ServiceEETest.java:112)
	at com.sun.ts.tests.common.vehicle.EmptyVehicleRunner.run(EmptyVehicleRunner.java:30)
	at com.sun.ts.lib.harness.ServiceEETest.run(ServiceEETest.java:102)
	at com.sun.ts.lib.harness.EETest.getPropsReady(EETest.java:392)
	at com.sun.ts.lib.harness.ServiceEETest.run(ServiceEETest.java:209)
	at com.sun.ts.lib.harness.EETest.run(EETest.java:204)
	at com.sun.ts.tests.common.vehicle.VehicleClient.main(VehicleClient.java:27)
Find All Products
Find All Orders
Find All LineItems
Cleanup done, calling super.cleanup
STATUS:Failed.Test case throws exception: com.sun.ts.lib.harness.EETest$Fault: Expecting result list: [ListenerA, ListenerB, ListenerC], but actual: [ListenerA, ListenerB, ListenerC, ListenerA, ListenerB, ListenerC]
********************************************************************************
Finished Test:  FAILED........com.sun.ts.tests.ejb30.persistence.callback.listener.Client.postLoadMultiTest_from_standalone
********************************************************************************
Number of tests completed:  22 (21 passed, 1 failed, 0 with errors)


There are 3 more similar failures in:

Finished Test:  FAILED........com.sun.ts.tests.ejb30.persistence.callback.listeneroverride.Client.postLoadMultiTest_from_standalone
Finished Test:  FAILED........com.sun.ts.tests.ejb30.persistence.callback.method.Client.postLoadMultiTest_from_standalone
Finished Test:  FAILED........com.sun.ts.tests.ejb30.persistence.callback.methodoverride.Client.postLoadMultiTest_from_standalone

I have verified this by removing the patch in both trunk and 1.2.x and TCK is passing again.

I am going revert the change out of trunk and 1.2.x.

Albert Lee.",23/Aug/08 01:19;ssegu;after load and after refresh callbacks of openjpa were each resulting in a post load call resulting in the duplicates. Patch addressing the same and re-introducing the original fix.,"03/Mar/10 17:53;no1uno;From the JPA 2.0 specification, section 3.2.5, ""If [entity] X is a new, detached, or removed entity, the IllegalArgumentException is thrown"".

This does not appear to be the case under OpenJPA 1.2.2:

		SimpleEntity e = new SimpleEntity();
		em.persist(e);
		em.refresh(e);
		return e;

I realize that OpenJPA 1.2.x is based on OpenJPA 1.0.  That specification is ambiguous as to what behavior would be expected.
",03/Mar/10 18:03;no1uno;Seeing the same behavior with OpenJPA 2.0.0-beta.,"03/Mar/10 18:30;kwsutter;Jerry,
In your example, SimpleEntity e is no longer ""new"" once you called persist(e).  At that point, e is now a managed instance and is a member of the persistence context.  So, the IllegalArgumentException would not be expected in this case.

Kevin","11/Mar/10 02:44;no1uno;Thanks, Kevin.  It took a bit of thought, but I've come to understand the error of my ways.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.ArrayIndexOutOfBoundsException may occur when a relation field is annotated as a primary key and a foreign key,OPENJPA-679,12401930,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,07/Aug/08 21:32,09/Mar/10 18:32,14/Mar/19 03:02,24/Mar/09 00:51,,,,,,,,,,1.2.1,1.3.0,,,,,,,,,,0,,"<openjpa-1.2.0-SNAPSHOT-rexported nonfatal general error>
org.apache.openjpa.persistence.PersistenceException: 0
    at
org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:196)
    at
org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)
    at
org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:192)
    at
org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:145)
....

Caused by: java.lang.ArrayIndexOutOfBoundsException: 0
    at
org.apache.openjpa.jdbc.sql.DBDictionary.getForeignKeyConstraintSQL(DBDictionary.java:3373)
    at
org.apache.openjpa.jdbc.sql.DBDictionary.getAddForeignKeySQL(DBDictionary.java:3252)
    at
org.apache.openjpa.jdbc.schema.SchemaTool.addForeignKey(SchemaTool.java:1066)
    at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:604)
    at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:344)
    at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:321)
    at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:501)
    at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:453)
    at
org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:159)
    at
org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:119)
    at
org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:189)
",,,,,,,,,,,,,,,,,,,,,,10/Mar/09 04:37;faywang;OPENJPA-679.patch;https://issues.apache.org/jira/secure/attachment/12401802/OPENJPA-679.patch,11/Aug/08 18:46;fancy;identifying_rel_test.zip;https://issues.apache.org/jira/secure/attachment/12387977/identifying_rel_test.zip,07/Aug/08 22:06;faywang;openjpa_679.patch;https://issues.apache.org/jira/secure/attachment/12387773/openjpa_679.patch,09/Aug/08 00:20;faywang;openjpa_679_1.patch;https://issues.apache.org/jira/secure/attachment/12387860/openjpa_679_1.patch,11/Aug/08 19:42;faywang;testcase_679.patch;https://issues.apache.org/jira/secure/attachment/12387984/testcase_679.patch,,,,,,,,,,5.0,,,,,,,,,,,,,,,,,,,2008-08-11 18:46:07.503,,,no_permission,,,,,,,,,,,160991,,,Tue Mar 10 14:36:28 UTC 2009,,,,,,,0|i0z7kv:,203530,,,,,,,,"07/Aug/08 21:38;faywang;This problem is found by Gopalakrishnan U. A JIRA is open on behalf on him. This problem may happen when a relation field is annotated as both a primary key and a foreign key. When Openjpa resolves the class matedata, it first resolves the primary keys of all the entities in the persistent unit. After the primary keys of all the entities are resolved, it then goes ahead to resolve the non-relation field. It is normally in the stage of resolving non-relation fields that the foreign key is constructed.

Since  a relation field is a primary key, it gets resolved in the first stage. However, since it is also a relation field, the foreign key construction is triggered when setting the strategy  to this field. If the primary key information of the parent entity is not yet available, some of the foreign key fields will be missing. If it happens that the primary key information of the parent entity is already resolved (just as some experiment shows by manipulating the entity class name so that the primary key of the parent entity gets resolved first before the child entity), then the foreign key constructed in this stage will be good and complete.

",07/Aug/08 22:06;faywang;The attached patch will force the field mapping in question to be resolved again after the primary keys of all the entities in the persistent unit are resolved. Any comments are mostly appreciated. A test case will be attached shortly.,09/Aug/08 00:20;faywang;The patch is based on the most updated ClassMapping.java,"11/Aug/08 18:46;fancy;Hi All,
Attaching a test scenario provided by Gopalakrishnan U that  reproduced the ArrayIndexOutOfBoundsException in OpenJPA .

The problem is in resolving foreignkey for the following annotation in CM class of the testcase:

@Entity
@IdClass(CM.CMId.class)
public class CM {

    @ManyToOne
    @ForeignKey
    @Id
    private E e;

Notice that the ManyToOne relation is annotated as @ForeignKey and @Id,  
OpenJpa failed in resolving the  foreignKey mapping for CM entity.

Gopal worked around this problem by 
rename class C to class WC
rename class CM to WCM

OpenJPA revolves class mapping in the alphabetic order of entity names.
As you see that by renaming C to WC and CM to WCM, the entity class E gets resolved first, hence, the forigenKey field e in CM gets resolved correctly.

Fay's patch is to making sure that foreignKey mapping is resolved no matter to in what  the order we resolve the entities.

",11/Aug/08 19:42;faywang;The attached openjpa test case is based on the original test case provided by Gopalakrishnan U.,12/Aug/08 05:17;fancy;Fix checked in under r685042,"08/Mar/09 18:04;mikedd;This issue causes problems with the reverse mapping tool. To reproduce the problem just run the reversemapping example..

I'm reopening the issue to either fix the problem or revert to the original behavior. ",10/Mar/09 04:37;faywang;This patch will fix the ReverseMappingTool problem.,10/Mar/09 14:36;mikedd;Thanks for the updated patch Fay. I'm testing the fix on 1.2.1 now. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,
EntityManager.createQuery() does not throw IllegalArgumentException,OPENJPA-678,12401913,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,xiaoqinfeng2000,xiaoqinfeng2000,07/Aug/08 18:31,09/Mar/10 18:32,14/Mar/19 03:02,15/Aug/08 19:05,1.1.0,,,,,,,,,0.9.7,1.2.0,1.3.0,,,query,,,,,,0,,EntityManager.createQuery(String qlString) does not throw IllegalArgumentException as expected in case the query is incorrect. See javax.persistence.EntityManager API doc.,,,,,,,,,,,,,,,,,,,,,,07/Aug/08 18:34;xiaoqinfeng2000;TestException.java;https://issues.apache.org/jira/secure/attachment/12387763/TestException.java,07/Aug/08 22:17;xiaoqinfeng2000;openjpa-678.patch;https://issues.apache.org/jira/secure/attachment/12387776/openjpa-678.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-08-15 19:05:34.122,,,no_permission,,,,,,,,,,,160990,,,Fri Aug 15 19:05:34 UTC 2008,,,,,,,0|i0zbbz:,204138,,,,,,,,07/Aug/08 18:34;xiaoqinfeng2000;Test testThrowsIllegalArgumentExceptionForCreateQuery() is added in org.apache.openjpa.persistence.exception.TestException.,07/Aug/08 22:17;xiaoqinfeng2000;proposed fix for openjpa-678. ,15/Aug/08 19:05;awhite;Similar patch applied in SVN revision 686325.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Single Table Inheritance Strategy causes entity identity issues,OPENJPA-677,12401800,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,corp,corp,06/Aug/08 16:14,21/Sep/16 14:21,14/Mar/19 03:02,21/Sep/11 15:09,1.1.0,1.2.0,1.2.1,1.3.0,,,,,,1.2.3,1.3.0,2.0.0-M1,,,,,,,,,0,,"Entity objects that are pulled out from the database using bean methods (get*()) are not the same objects that are pulled out using using other methods(find(), getReference()). 

This occurs only when using Single Table Inheritance.

This works on 0.9.7, in other versions Exception is thrown (https://issues.apache.org/jira/browse/OPENJPA-494) , in latest version from trunk test fails.",IBM Java 1.5,,,,,,,,,,,,,,,,,,,,,06/Aug/08 16:15;corp;TestJPAIdentityWhenSingleTable.zip;https://issues.apache.org/jira/secure/attachment/12387654/TestJPAIdentityWhenSingleTable.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-08-08 06:46:26.89,,,no_permission,,,,,,,,,,,59913,,,Wed Sep 21 15:09:07 UTC 2011,,,,,,,0|i0z0w7:,202447,,,,,,,,"06/Aug/08 16:15;corp;In order to run tests:
1. Add OpenJPA libraries to the build path.
2. Change the path in the build.properties file.
3. Run the enchanceWorkspaceAndDeleteDB task from build.xml.","08/Aug/08 06:46;ppoddar@apache.org;The bug is reproducible.

The workaround is to change RegularUsr.admin field from lazily loaded to eagerly loaded.

The bug seems to be how OpenJPA determines the concrete type of a relation from the record row data and the discrimnator column. In this case
mysql> select * from computeruser;
---------------------------------------
| oid   DTYPE    ADMIN_OID 
---------------------------------------
 101     admin       NULL 
 102     user           101 
---------------------------------------

During load of row 102, i.e. '102 'user' 101', OpenJPA tries to store a FK (pointing to Admin) for the row 102 (which represents a RegularUser).
However, because the row's discrimnator value is 'user', OpenJPA wrongly assumes that 101 is identifier for RegularUser and that is the oid is store intermediately in RegularUser-102's admin field.

Later when OpenJPA reads the full row 101, (say for find()) it does construct a Admin-102 instance but that other identifier has created a different Admin object  and hence the error.

Eager loading gets rid of the problem because then both the rows are read in a single query and the ambiguity of discriminator value  does not arise.","08/Aug/08 08:11;ppoddar@apache.org;This is an intermediate (and inaccurate) fix for the problem.
This will only work when the most-derived class is target of a relation.
For example, declared type of RegularUser.admin is Admin which is the most-derived class in this case and hence only the fix works. Otherwise, most likely it will show the same error.

Will attempt to put a more comprehensive fix ","08/Aug/08 09:00;ppoddar@apache.org;The later fix is more general. Please confirm if this fix resolves the reported issue or not.
",12/Aug/08 21:25;corp;Thank you.,25/Mar/11 16:02;mikedd;Trunk was 1.3.0-SNAPSHOT when this was committed. ,"21/Sep/11 15:09;mikedd;Closing issues which have code changes and have not been modified for a while. 

If there is more work to be done for this issue please check whether it has already been included in an OpenJPA release. 

If the changes are in an OpenJPA release please open a new issue and link to this one. 

If the changes are not in an OpenJPA release you may reopen this issue or create a new issue. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Connection used for NativeSequences is not closed,OPENJPA-676,12401793,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,mikedd,mikedd,06/Aug/08 15:29,03/Mar/09 01:49,14/Mar/19 03:02,03/Mar/09 01:49,1.2.0,1.3.0,,,,,,,,1.2.1,,,,,,,,,,,0,,"The connection used to get the next sequence value for Native Sequences is used, but will not be closed until the EntityManager is closed. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160989,,,2008-08-06 15:29:48.0,,,,,,,0|i0z72f:,203447,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
javaagent enhancer (PCEnhancerAgent) ignores persistence units after the first in persistence.xml,OPENJPA-674,12401748,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,dinkar,dinkar,06/Aug/08 01:02,06/Aug/08 01:33,14/Mar/19 03:02,06/Aug/08 01:33,,,,,,,,,,1.2.0,1.3.0,,,,,,,,,,0,,"A persistence.xml file has multiple PUs defined. A program makes use of a PU which is NOT the first PU in the list. The classes are not enhanced at build time, but are enhanced at runtime via the javaagent. No anchor arguments are passed to the javaagent.

Because PCEnhancerAgent ignores PUs following the first, OpenJPA tries to use an appropriate runtime enhancing strategy for a class, but is not always be able to. The program gets this error back:

Error Message: [Error while processing persistent field <blah>
Error details: The accessor for field getTheAddress in type <blah> is private or package-visible. OpenJPA requires accessors in unenhanced instances to be public or protected. If you do not want to add such an accessor, you must run the OpenJPA enhancer after compilation, or deploy to an environment that supports deploy-time enhancement, such as a Java EE 5 application server.

The root problem is that the javaagent choses only the first  PU's classes for enhancement, and ignores the remaining PUs from persistence.xml. A workaround is to explicity specify the PU referenced by the program as an argument to the javaagent.",,,,,,,,,,,,,,,,,,,,,,06/Aug/08 01:09;dinkar;PCEnhancerAgent.patch;https://issues.apache.org/jira/secure/attachment/12387608/PCEnhancerAgent.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-08-06 01:33:39.258,,,no_permission,,,,,,,,,,,160987,,,Wed Aug 06 01:33:39 UTC 2008,,,,,,,0|i0z6rz:,203400,,,,,,,,"06/Aug/08 01:09;dinkar;Patch follows a strategy similar to the invocation for PCEnhancer. The list of fully qualified PUs (filtered by arguments to the javaagent, or unfiltered if no arguments are specified)  is obtained and looped over. The code to do runtime enhancement per individual PU is unchanged.",06/Aug/08 01:33;fancy;Fix checked in under r683075  for svn trunk and 1.2.x branch.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Discriminator column is missing from table when inheritance is used without annotation,OPENJPA-670,12401267,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,29/Jul/08 21:05,09/Mar/10 18:32,14/Mar/19 03:02,31/Jul/08 15:37,1.2.0,1.3.0,,,,,,,,1.2.0,1.3.0,,,,jdbc,,,,,,0,,"According to the EJB 3.0 JPA spec (pp. 191, section 9.1.29):

""If the Inheritance annotation is not specified or if no inheritance type is specified for an entity class
hierarchy, the SINGLE_TABLE mapping strategy is used.""

I've found that if an entity inheritance hierarchy is specified without an explicit DiscriminatorColumn or Inheritance annotation, a single table will be used for mapping, but there will be no discriminator column in the table.  

pp. 191 - 192, section 9.1.30 of the spec reads:

""For the SINGLE_TABLE mapping strategy, and typically also for the JOINED strategy, the persistence
provider will use a type discriminator column.""

and

""If the DiscriminatorColumn annotation is missing, and a discriminator column is required, the
name of the discriminator column defaults to ""DTYPE"" and the discriminator type to STRING.""

Without a discriminator column a scenario such as:

entity B extends entity A
entity C extends entity A

""select c from C""  will return entities of type A, B, and C (which is a data integrity issue) because there is no way to distinguish between the entity types.

The simple workaround is to specify an @Inheritance or @DiscriminatorColumn annotation on the root class, but OpenJPA should exhibit default behavior defined by the spec when these annotations are not specified.

I have a patch and jUnits in the works and will post them shortly.
",,,,,,,,,,,,,,,,,,,,,,30/Jul/08 14:54;techhusky;openjpa-670.patch;https://issues.apache.org/jira/secure/attachment/12387198/openjpa-670.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-07-31 15:37:36.307,,,no_permission,,,,,,,,,,,160983,,,Thu Jul 31 15:37:36 UTC 2008,,,,,,,0|i0z52v:,203125,,,,,,,,"30/Jul/08 14:54;techhusky;Attaching patch containing fix and jUnits for trunk (currently 1.3.0).  Please review and if no comments, commit for trunk and 1.2.x.

In case it isn't clear from the code and comments, the update to PersistenceTestCase is to clean up tables used by managed interfaces.  They are by definition abstract and were being skipped during the cleanup process.

",31/Jul/08 15:37;mikedd;Fixed in trunk and 1.2.x,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NativeSequences can be incremented within the business transaction,OPENJPA-669,12401190,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,28/Jul/08 21:11,28/Jul/08 21:24,14/Mar/19 03:02,28/Jul/08 21:24,0.9.6,0.9.7,1.0.0,1.0.1,1.0.2,1.0.3,1.1.0,,,1.2.0,,,,,,,,,,,0,,"SQL Sequences are independent of the transaction. Therefore the same connection which is used to insert a row can be used to increment the sequence value. 

Currently we treat these native sequences in the same manner as updating a sequence table - ie the work will be done on connection2 (aka the non-jta-data-source). This appears to be unnecessary and requires an additional datasource when running in a managed environment which can't suspend the current transaction 

To resolve the problem I added a nativeSequenceType attribute to the DBDictionary class. This setting will be used to determine the whether the databases sequences are transactional, contiguous or non transactional (Default is contiguous). If the native sequences are transactional or contiguous they will be executed within the current transaction and will not require a second connection factory. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160982,,,2008-07-28 21:11:05.0,,,,,,,0|i0ywzj:,201814,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Test failures with IBM JDK (xml parsing),OPENJPA-668,12401185,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,28/Jul/08 20:13,09/Mar/10 18:32,14/Mar/19 03:02,28/Jul/08 22:41,1.2.0,,,,,,,,,1.2.0,,,,,jdbc,,,,,,0,,"Just attempted to run trunk's test bucket with the IBM JDK and found two testcase failures:

TestUniqueConstraintWithXMLDescriptor.testMapping
TestEnhancementWithMultiplePUs.testEnhancementOfAllPUsWithinAResource 

It looks like these problems are due to ""incorrect"" orm.xml.  I have fixed these locally and will check them in shortly.

This comes back to the fact that the validation aspect of the xml parser for the Sun JDK is turned off by default (due to an old problem).  But, the validation is left on with the IBM JDK parser.  That's how we are able to detect the problem.  This is documented in openjpa-513.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160981,,,2008-07-28 20:13:04.0,,,,,,,0|i0z7iv:,203521,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA allows commit where fields with @Column(nullable=false) set to null ,OPENJPA-665,12400929,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,24/Jul/08 17:42,13/Jan/15 13:52,14/Mar/19 03:02,05/Aug/08 13:55,,,,,,,,,,1.2.0,,,,,jpa,,,,,,0,,"OpenJPA disallows setting of null values to basic fields that are not optional.
But it allows setting null values to basic fields whose column is set as nullable=false.",,,,,,,,,,,,,OPENJPA-811,,,OPENJPA-2559,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-08-05 13:20:36.197,,,no_permission,,,,,,,,,,,160978,,,Tue Aug 05 13:55:43 UTC 2008,,,,,,,0|i0z7dr:,203498,,,,,,,,05/Aug/08 13:20;mikedd;This change introduced a regression with LOBs which may not be set to null. I'm reopening the issue to address LOBs,"05/Aug/08 13:55;mikedd;Sorry, I didn't sync up this morning. Pinaki has already fixed this issue in trunk with rev 682610. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"OpenJPA should prohibit when the name of a schema components such as Table, Column, Constraint exceeds maximum permissible length for the database platform ",OPENJPA-664,12400918,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,24/Jul/08 15:16,09/Mar/10 18:32,14/Mar/19 03:02,24/Jul/08 18:47,,,,,,,,,,1.2.0,,,,,jdbc,,,,,,0,,"Names of schema components can be user specified, generated following JPA convention or heuristics. If a name is longer than maximum limit imposed by the database platform, OpenJPA mapping tool fails at SQL DDL execution rather than being detected such violation earlier by the implementation. 

  ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160977,,,2008-07-24 15:16:11.0,,,,,,,0|i1dqs7:,288436,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Version field returns null when explicitly projected in SELECT clause,OPENJPA-662,12400506,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,dinkar,dinkar,17/Jul/08 18:59,26/Mar/13 19:33,14/Mar/19 03:02,23/Jul/08 14:04,,,,,,,,,,2.0.0-M1,,,,,query,,,,,,0,,"With this entity:

An entity has a version field, with AUTO strategy.

@Entity
public class Department {
    @Id 
    private int id;
    
    @Version
    @GeneratedValue(strategy=GenerationType.AUTO)
    private int myVersion;
    
    private String name;
}

A record is inserted... 

		Department d = new Department();
		d.setName(""SALES"");
		em.getTransaction().begin();
		em.persist(d);
		em.getTransaction().commit();
		em.close();

...and queried. 

If the select is over the entity, ""SELECT d from Department d"", the version field is set up  correctly in the returned entity.

But if the version field is explicitly projected, ""SELECT d.id, d.myVersion, d.name from Department d"", the id and the name values are returned fine, but the myVersion value is null.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160975,,,2008-07-17 18:59:43.0,,,,,,,0|i1dqsn:,288438,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException when using OneToMany Relation and collection is subclass using Discriminator with SINGLE_TABLE strategy.,OPENJPA-660,12400364,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,vbhatia,vbhatia,16/Jul/08 10:09,21/Sep/16 14:21,14/Mar/19 03:02,25/Jul/08 20:50,1.0.0,1.0.1,1.0.2,1.0.3,1.0.4,1.1.0,1.2.0,,,1.2.0,,,,,jpa,,,,,,0,,"If the entity has OneToMany relation and collection is declared as subclass which uses SINGLE_TABLE inheritance strategy, it fetches all rows irrespective of Discriminator value and throws ClassCastException.

There is entity Department (table dept) having OneToMany relation with another entity FullTimeEmployee. 

  @OneToMany (mappedBy=""dept"", cascade=CascadeType.ALL)
  private Collection<FullTimeEmployee> fullTimeEmployees;

There is abstract class Employee with
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name=""TYPE"")

There are two entity classes FullTimeEmployee and PartTimeEmployee which extends Employee (table emp) with Discriminator values 'F' and 'P' respectively.

Now, suppose emp table contains 2 rows of PartTimeEmployee and 2 rows of FullTimeEmployee and if test class fetches Department object and calls dept.getFullTimeEmployees(), it throws ClassCastException as it gets 4 rows and doesn't use discriminator and subclass type while generating SQL query.",,,,,,,,,,,,,,,,,,,,,,18/Jul/08 15:27;faywang;patch.txt;https://issues.apache.org/jira/secure/attachment/12386402/patch.txt,16/Jul/08 10:12;vbhatia;testInheritance.zip;https://issues.apache.org/jira/secure/attachment/12386166/testInheritance.zip,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-07-16 16:51:24.117,,,no_permission,,,,,,,,,,,160974,,,Fri Jul 18 15:27:59 UTC 2008,,,,,,,0|i0z7jb:,203523,,,,,,,,16/Jul/08 10:12;vbhatia;Testcase with junit test TestCollection class.,"16/Jul/08 16:51;ppoddar@apache.org;The test will pass if typed collection fields declare ElementClassCriteria as follows (+ marks added lines)

    @OneToMany (mappedBy=""dept"", cascade= CascadeType.PERSIST)
+  @ElementClassCriteria
    private Collection<PartTimeEmployee> partTimeEmployees;
  
    @OneToMany (mappedBy=""dept"", cascade= CascadeType.PERSIST)
+  @ElementClassCriteria
    private Collection<FullTimeEmployee> fullTimeEmployees;
 
","16/Jul/08 17:28;vbhatia;Thanks Pinaki for the suggestion, but it is causing 

2640  testInheritance  TRACE  [main] openjpa.jdbc.SQL - <t 6889270, conn 20693770> executing prepstmnt 89154
06 SELECT t0.ssn, t0.type, t0.salary FROM EMP t0 WHERE t0.DEPT_NAME = ? AND t0.type = ? [params=(String) Mat
hs]
2656  testInheritance  TRACE  [main] openjpa.jdbc.SQL - <t 6889270, conn 20693770> [0 ms] spent
E
Time: 3.281
There was 1 error:
1) testInheritance(com.test.jpa.inheritance.TestCollection)<openjpa-1.2.0-SNAPSHOT-r422266:676787 nonfatal g
eneral error> org.apache.openjpa.persistence.PersistenceException: ORA-01008: not all variables bound
 {prepstmnt 5084131 SELECT t0.ssn, t0.type, t0.salary FROM EMP t0 WHERE t0.DEPT_NAME = ? AND t0.type = ? [pa
rams=(String) Maths]} [code=1008, state=72000]
        at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4228)
        at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4193)
        at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
        at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:88)
        at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:64)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:613)
        at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
        at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
        at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:2919)
        at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:2997)
        at org.apache.openjpa.kernel.StateManagerImpl.beforeAccessField(StateManagerImpl.java:1491)
        at org.apache.openjpa.kernel.StateManagerImpl.accessingField(StateManagerImpl.java:1476)
        at com.test.jpa.inheritance.Department.pcGetfullTimeEmployees(Department.java)
        at com.test.jpa.inheritance.Department.getFullTimeEmployees(Department.java:30)
        at com.test.jpa.inheritance.TestCollection.testInheritance(TestCollection.java:52)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: ORA-01008: not all variables bound
 {prepstmnt 5084131 SELECT t0.ssn, t0.type, t0.salary FROM EMP t0 WHERE t0.DEPT_NAME = ? AND t0.type = ? [pa
rams=(String) Maths]} [code=1008, state=72000]
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:192)
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$700(LoggingConnectionDecorator.java
:57)
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement
.executeQuery(LoggingConnectionDecorator.java:852)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.
java:262)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeQuery(JDBCStoreMan
ager.java:1494)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.
java:252)

It looks like it is svn r652913 (OPENJPA-407) which has made changes in StoreCollectionFieldStrategy.load() method resulting in this issue.

            ClassMapping mapping = field.getDefiningMapping();
            Object oid = sm.getObjectId();
            Column[] cols = mapping.getPrimaryKeyColumns();
            if (sel == null)
                sel = ((LogicalUnion.UnionSelect)union.getSelects()[0]).
                getDelegate();

            sel.wherePrimaryKey(mapping, cols, cols, oid, store, 
                	null, null, parmList);","16/Jul/08 18:11;vbhatia;Using <property name=""openjpa.jdbc.QuerySQLCache"" value=""false""/> has resolved the issue. Please close it.","18/Jul/08 15:27;faywang;The attached patch fixes this problem. To load a toMany relationship, there is normally a foreign key corresponing to the primary key in the owner class in the where clause. The value of the primary key in the owner class is passed via the argument sm to the load method.  The parameter problem exposed by OPENJPA-660 is the missing non-foreign key parameters. The fix is to detect any non-FK parameters and add them to the parameter list. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
No state snapshot is available on @Embedded class when using runtime enhancement via spring-tomcat-weaver ,OPENJPA-659,12400230,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,logemann,logemann,14/Jul/08 17:33,09/Mar/10 18:32,14/Mar/19 03:02,14/Jul/08 20:49,1.1.0,,,,,,,,,1.2.0,,,,,kernel,,,,,,0,,"i am getting this exception:

org.springframework.orm.jpa.JpaSystemException: No state snapshot is available for instance of type ""de.logentis.bwh.model.Payment"", but this instance uses state-comparison for dirty detection.; nested exception is <openjpa-1.1.0-r422266:657916 fatal general error> org.apache.openjpa.persistence.PersistenceException...

Here are the relevant pieces of the casses:

@Entity
@Table(name = ""orders"")
@VersionColumn(name = ""_version"")
public class Order {
...
   @Embedded
   Payment payment;
}

@Embeddable
public class Payment {

   @Basic
   @Enumerated(EnumType.STRING)
   @Column(name = ""paymenttype"")
   PaymentType type;

   @Column(name = ""currency"")
   String currency;

   @Column(name = ""pricing"")
   String pricing;

   @Column(name = ""cost"")
   int cost;
}

The point is, persisting is no problem at all, the exception will be thrown by issueing:

Query query = getEntityManager().createQuery(""select o FROM Order o"");
query.getResultList();","Tomcat6, Java6, Mac OS X, Spring 2.5",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-07-14 18:13:30.63,,,no_permission,,,,,,,,,,,160973,,,Mon Jul 14 20:49:42 UTC 2008,,,,,,,0|i0z51z:,203121,,,,,,,,14/Jul/08 17:34;logemann;The problem doesnt occur when relying on build time enhancement via PCEnhancerTask. ,"14/Jul/08 18:13;ppoddar@apache.org;What is the identity strategy used by Order.class? 
While reproducing the error in JSE environment, I am noticing that the crucial factor is the datastore identity used by a class. Otherwise, the issue does not seem to appear. ","14/Jul/08 20:49;ppoddar@apache.org;Revision 676727:

Dirty checking fails for runtime enhanced classes. The original case reported the failure in a Spring-Tomcat-Weaver with Embdded field. But as TestSimpleUnenhancedQuery can raise the same failure in a simpler settings. The fix is related to initializing a SaveFieldManager conditional to having loaded fields at invocation of saveFields(). The fix removes the condition and ensures that a SaveFieldManager is assocaited even when saveFields() is invoked without any field loaded.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Compile error: ""The method getTextContent() is undefined for the type Node""",OPENJPA-657,12400074,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,dinkar,dinkar,10/Jul/08 23:36,09/Mar/10 18:32,14/Mar/19 03:02,10/Jul/08 23:57,,,,,,,,,,1.2.0,,,,,jdbc,,,,,,0,,"Got this compile error:

The method getTextContent() is undefined for the type Node
in
openjpa/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java	line 124	

Maven resolves the org.w3c.dom.Node dependency by downloading this:

.m2/repository/xml-apis/xml-apis/1.0.b2/xml-apis.1.0.b2.jar

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-07-10 23:57:21.522,,,no_permission,,,,,,,,,,,160971,,,Thu Jul 10 23:57:21 UTC 2008,,,,,,,0|i0zb6n:,204114,,,,,,,,10/Jul/08 23:57;ppoddar@apache.org;The patch verified in Dinkar Rao's (who originally reported the issue) environment .,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect connection URL causes NPE when using JDBC Driver,OPENJPA-656,12400050,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,techhusky,techhusky,10/Jul/08 19:06,09/Mar/10 18:32,14/Mar/19 03:02,11/Jul/08 13:55,1.2.0,,,,,,,,,1.2.0,,,,,,,,,,,0,,"If a JDBC URL is specified with an incorrect protocol or subprotocol in combination with a JDBC Driver class when configuring a PU an NPE is thrown within the OpenJPA code when trying to create an entity manager.  The NPE bubbles out to a not-so-useful PersistenceException with internal StoreException containing message text ""null"".  

For example:  (note the missing colon after the subprotocol)

openjpa.ConnectionDriverName=com.ibm.db2.jcc.DB2Driver
openjpa.ConnectionURL=jdbc:db2//my.database.com:800/MYDB  

Results in:

     [java] <openjpa-1.2.0-SNAPSHOT-r422266:667312 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: There were errors initializing your configuration: <openjpa-1.2.0-SNAPSHOT-r422266:667312 fatal store error> org.apache.openjpa.util.StoreException: null
     [java]     at org.apache.openjpa.jdbc.schema.DataSourceFactory.installDBDictionary(DataSourceFactory.java:240)
     [java]     at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getConnectionFactory(JDBCConfigurationImpl.java:692)
     [java]     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
     [java]     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:45)
     [java]     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
     [java]     at java.lang.reflect.Method.invoke(Method.java:599)
     [java]     at org.apache.openjpa.lib.conf.ConfigurationImpl.instantiateAll(ConfigurationImpl.java:288)
     [java]     at org.apache.openjpa.conf.OpenJPAConfigurationImpl.instantiateAll(OpenJPAConfigurationImpl.java:1429)
     [java]     at org.apache.openjpa.kernel.AbstractBrokerFactory.makeReadOnly(AbstractBrokerFactory.java:646)
     [java]     at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:183)
     [java]     at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)
     [java]     at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:192)
     [java]     at com.ibm.ws.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:42)
     [java]     at com.ibm.ws.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:27)
     [java]     at suite.r70.base.wasvadd.wsjpa_scripts.wsenhancer.VerifyEnhancementTest.main(VerifyEnhancementTest.java:22)
     [java] Caused by: java.lang.NullPointerException
     [java]     at org.apache.openjpa.lib.jdbc.DelegatingConnection.getAutoCommit(DelegatingConnection.java:202)",,0,0,,0%,0,0,,,,,,,,,,,,,,,10/Jul/08 21:06;techhusky;OPENJPA-656.patch;https://issues.apache.org/jira/secure/attachment/12385805/OPENJPA-656.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-07-11 13:56:48.234,,,no_permission,,,,,,,,,,,160970,,,Fri Jul 11 13:56:48 UTC 2008,,,,,,,0|i1dqtb:,288441,,,,,,,,"10/Jul/08 21:06;techhusky;Attaching patch with code fix and jUnits for 1.2.0/trunk.  Per the JDBC spec, ""The driver should return ""null"" if it realizes it is the wrong kind of driver to connect to the given URL.""  The most typical case for getting a null Connection is when the protocol or subprotocol do not match what the driver expects. The fix checks for a null Connection being returned by the driver in org.apache.openjpa.jdbc.schema.SimpleDriverDataSource.getConnection().  If the Connection is null, a SQLException containing a detailed message is thrown.  

Please review and if no comments commit for 1.2.0.",11/Jul/08 13:56;ppoddar@apache.org;revision 675952.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missing dictionary properties in OpenJPA docs,OPENJPA-654,12399810,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,dezzio,dezzio,dezzio,08/Jul/08 12:39,21/Sep/16 14:21,14/Mar/19 03:02,14/Jul/08 13:59,1.1.0,,,,,,,,,1.2.0,,,,,docs,,,,,,0,,"The following properties are found in DBDictionary.java, but are not (unlike most) documented in the User's Guide, section ""4.4.1. DBDictionary Properties"":

allowsAliasInBulkClause
batchLimit
bitLengthFunction
booleanTypeName
castFunction
closePoolSQL
concatenateDelimiter
concatenateFunction
currentDateFunction
currentTimeFunction
currentTimestampFunction
datePrecision
dropTableSQL
fixedSizeTypeNames
getStringVal
inClauseLimit
maxEmbeddedBlobSize
maxEmbeddedClobSize
platform
rangePosition
requiresCastForComparisons
requiresCastForMathFunctions
requiresTargetForDelete
searchStringEscape
sequenceNameSQL
sequenceSQL
sequenceSchemaSQL
supportsAutoAssign
supportsCascadeUpdateAction
supportsComments
supportsCorrelatedSubselect
supportsDefaultUpdateAction
supportsModOperator
supportsNullUpdateAction
supportsRestrictUpdateAction
supportsXMLColumn
trimBothFunction
trimLeadingFunction
trimTrailingFunction
xmlTypeName
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160968,,,Mon Jul 14 13:59:45 UTC 2008,,,,,,,0|i0z7zr:,203597,,,,,,,,"14/Jul/08 13:59;dezzio;Revision 676592 to 1.1.x branch resolves this issue.  Did not add two database dictionary properties: BitLengthFunction and ConcatenateDelimiter.  These two properties are not yet used in the OpenJPA code, and therefore, I did not document them.  Earlier changes at revisions 675366, 675368, and 675700 (also to 1.1.x branch) put the database dictionary properties into alphabetical order and corrected the descriptions of a few of them.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Concurrency issue with query cache enabled,OPENJPA-653,12399726,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,07/Jul/08 14:14,09/Mar/10 18:32,14/Mar/19 03:02,07/Jul/08 19:44,1.2.0,,,,,,,,,1.2.0,,,,,datacache,,,,,,0,,"A Java EE application with query result caching enabled and with many concurrent users is failing with a ConcurrentModificationException in org.apache.openjpa.datacache.QueryCacheStoreQuery.  Specifically, the failure is in the inner class.method CachingResultObjectProvider.checkFinished(Object, boolean) and occurs while iterating the _data TreeMap within the QueryResult constructor.  

Examination of this method showed that the tree map is synchronized in the beginning of the method and then later when the  map is cleared in abortCaching().  It is not synchronized when a new QueryResult is constructed.  This allows a thread to iterate over the map (during the constructor) while another thread is modifying it.  ",,,,,,,,,,,,,,,,,,,,,,07/Jul/08 14:40;techhusky;OPENJPA-653.patch;https://issues.apache.org/jira/secure/attachment/12385412/OPENJPA-653.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160967,,,Mon Jul 07 14:40:23 UTC 2008,,,,,,,0|i0zb4v:,204106,,,,,,,,"07/Jul/08 14:40;techhusky;Attaching patch for 1.2.0/trunk which synchronizes the data tree map over QueryResult construction.  I considered making the TreeMap object a synchronized sorted map, but the JavaDoc indicated that an external synch was still necessary when iterating the collection.  Sadly, due to the nature of the problem I have not been able to produce a jUnit which reproduces the failure.  If I am able to produce a test I will post it at a later date.

Please review and if no issues, commit for 1.2.0.  

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Document openjpa.RuntimeUnenhancedClasses=unsupported/warn configuration property,OPENJPA-650,12399467,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,vorburger,vorburger,02/Jul/08 17:40,09/Mar/10 18:32,14/Mar/19 03:02,17/Sep/08 23:24,1.0.2,1.0.3,1.1.0,1.2.0,,,,,,1.0.4,1.2.1,1.3.0,,,docs,UnenhancedClasses,,,,,0,,"The openjpa.RuntimeUnenhancedClasses configuration property (which supports the values of 'unsupported' & 'warn' that I learnt about on the mailing list, may be more) is missing documentation.

A good place in the doc to say something about this very very useful and important to know about property may be the ""2.4. Omitting the OpenJPA enhancer"" chapter?

PS, clarification: OPENJPA-651 is an Improvement suggesting making this the default; this one (OPENJPA-650) is ""only"" a Bug report ranting that documentation for openjpa.RuntimeUnenhancedClasses is missing - this doc should be provided whatever the decision on OPENJPA-651 turns out to be.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-09-17 23:24:18.136,,,no_permission,,,,,,,,,,,160964,,,Wed Sep 17 23:24:18 UTC 2008,,,,,,,0|i0z7kf:,203528,,,,,,,,"17/Sep/08 12:49;vorburger;I don't think http://openjpa.apache.org/builds/latest/docs/javadoc/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.html counts as documentation? ;-) This should be in the Manual, with more explanations.","17/Sep/08 23:24;mikedd;I've added documentation for the RuntimeUnenhancedClasses property to the manual. It will be in the next nightly build and future releases for 1.0.x,1.2.x, and 1.3.x. 

It's a bit rudimentary but at least it's a starting point. We'll revisit in OpenJPA-651 when we make a decision on what to do with the default value.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Dynamic update to DataCacheTimeout property is not updated in the ClassMetadata,OPENJPA-647,12399304,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,sandeeps@bea.com,sandeeps@bea.com,30/Jun/08 18:34,09/Mar/10 18:32,14/Mar/19 03:02,02/Jul/08 19:51,1.1.0,,,,,,,,,1.2.0,,,,,datacache,,,,,,0,,The org.apache.openjpa.meta.ClassMetaData caches the value of the DataCacheTimeout when it is first accessed. On a subsequent update of the OpenJPAConfiguration's  property this cached value is not cleared and the ClassMetaData instances in the repository that have initialized the DataCacheTimeout from either the parent class or the global default continue to use the old value. We need to build smarts in this class so that the configuration cache can be cleared on an update and this property reflects true dynamic behaviour.,"OpenJPA 1.1.0
version id: openjpa-1.1.0-r422266:656510
Apache svn revision: 422266:656510

os.name: Windows XP
os.version: 5.1
os.arch: x86

java.version: 1.6.0_05
java.vendor: BEA Systems, Inc.",86400,86400,,0%,86400,86400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-07-02 19:51:32.242,,,no_permission,,,,,,,,,,,160961,,,Wed Jul 02 19:51:32 UTC 2008,,,,,,,0|i0z513:,203117,,,,,,,,02/Jul/08 19:51;ppoddar@apache.org;SVN Revision: 673476,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JDK problems with defineClass and enum class types,OPENJPA-646,12399184,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,27/Jun/08 16:42,30/Jul/13 22:19,14/Mar/19 03:02,08/Sep/08 20:12,1.2.0,,,,,,,,,1.2.1,1.3.0,,,,kernel,,,,,,0,,"This Issue was first presented on our dev mailing list:

http://www.nabble.com/Sun-JDK-problem-with-duplicate-annotations-td18101863.html

I have also shared some additional experiences with Abe to get his views, but haven't heard anything back yet.  So, I will create this JIRA Issue and work it from there.

The original problem was limited to the Sun JDK.  But, in a soon-to-be-available update to the IBM JDK, the same problem surfaces.  At least the same exception is presented.  The actual call stack is different due to the different Sun and IBM packages, but it's a similar problem.

Basically, we are having a problem with our TempClassLoader attempting to use the defineClass() method on the CascadeType enum class.  Our javax.persistence.CascadeType version doesn't experience this problem because we use Class.forName() to load the javax classes.  In this scenario, I have an alt.persistence.CascadeType that falls into our normal class definition processing and attempts to use defineClass().  This method invocation completes okay.  But, later when our code attempts to access the metadata associated with this type, we get the ArrayStoreException from the JDK.

I will post both a simple project that reproduces the problem as well as a ""hack"" patch that gets us around the problem.  I also have a PMR opened against the IBM JDK to see if they can help resolve it.

Kevin
",,,,,,,,,,,,,,,,OPENJPA-672,,,,,,27/Jun/08 16:52;kwsutter;openjpa-646.patch;https://issues.apache.org/jira/secure/attachment/12384847/openjpa-646.patch,27/Jun/08 16:49;kwsutter;pmr.zip;https://issues.apache.org/jira/secure/attachment/12384846/pmr.zip,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-07-30 16:20:56.173,,,no_permission,,,,,,,,,,,160960,,,Tue Jul 30 22:19:12 UTC 2013,,,,,,,0|i0z7jz:,203526,,,,,,,,"27/Jun/08 16:49;kwsutter;File pmr.zip is a simplified version of the problem that I put together for the IBM JDK problem report.  To reproduce the problem, you have to build a jar file for this project and run the testcase with the -javaagent parameter.  Or, you could just point the javaagent at the OpenJPA runtime jar file and use the ""real"" TempClassLoader implementation.  Either way, you should be able to reproduce the problem.","27/Jun/08 16:52;kwsutter;This hack of a patch just modifies our TempClassLoader implementation to treat enum class types like annotation class types and use the Class.forName() mechanism to load the class instead of the defineClass() mechanism.  Until I get educated on what exactly is wrong with our current processing, I don't want to commit this change.  But, in case someone runs into this situation, this is a potential workaround.",30/Jul/08 16:20;mikedd;Moving to next release,"31/Jul/08 22:42;kwsutter;I accidentally opened a new Issue for this same problem (OPENJPA-672).  Just to get this Issue up to date, here are some of the details from that new Issue:

From working with the JDK team, the problem is surfacing because the ClassLoader (AppClassLoader) that is used to load the Enum type when the alt.persistence.OneToMany is loaded is not the same ClassLoader (TemporaryClassLoader) when the Enum type is loaded by our enhancement processing.  Thus, the AnnotationTypeMismatchExceptionProxy from the JDK.

One way to workaround the problem is to add a test for Enum types in the TemporaryClassLoader and use the AppClassLoader in this case (much like we do for Annotation types):

           if (isAnnotation(classBytes) || isEnum(classBytes))
               return Class.forName(name, resolve, getClass().getClassLoader());

The JDK team suggested removing the check for isAnnotation (and isEnum) altogether since that resolved the simple testcase that I had put together for their benefit.  Unfortunately, that doesn't work for our enhancement processing for a couple of reasons.  The _strats structure in PersistentMetaDataDefaults depended on the org.apache.openjpa.persistence.PersistentCollection class.  By removing the conditional above, then we had a mismatch in classloaders for this data structure, much like the jdk problem.

I tried changing the key for this _strats structure to use the class name string instead of the actual class instance.  This got us around our immediate concern, but eventually I hit another JDK issue with mismatched classloaders when processing the annotations in AnnotationPersistentMetaDataParser:

                   parsePersistentCollection(fmd, (PersistentCollection)
                       el.getAnnotation(PersistentCollection.class));

The loading of this PersistentCollection.class used the AppClassLoader, so the lookup via getAnnotation didn't find anything since the original annotation was loaded by the TemporaryClassLoader.  Trying to get around this situation was creating some pretty ugly code.

So, I am leaning towards the original workaround as a ""solution"" with proper commenting.  By allowing the AppClassLoader to load enum types (vs the TemporaryClassLoader), we would ""pollute"" the AppClassLoader with left over enum classes.  This would seem to be a minor drawback.  Of course, if we ever need to allow for the enhancement of enum classes, then we're up a creek...

Enough detail for now.  Comments and suggestions are welcome.",08/Sep/08 20:12;kwsutter;Resolved in the 1.2.x branch and 1.3.0 trunk.,23/Jul/13 16:12;garpinc;Changing test class to an enum class results in linkage error in jdk 1.7 where it works in jdk 1.6. Need to re-address this behavior for jdk 1.7.,"23/Jul/13 16:33;kwsutter;Are you indicating that the fix for this JIRA is related to the JDK 7 issue you are tracking with OpenJPA-2399?  The last comment on the dev mailing list indicated that you couldn't get different results for JDK 6 and 7 with this testcase.  Can you clarify what you changed and what you are experiencing now?  I'm not questioning that some problems exists with JDK 7 usage, but I'm trying to figure out how or what aspect of this JIRA is related.  Thanks.",30/Jul/13 22:19;garpinc;Yes. I'm indicating that this issue is related to OpenJPA-2399. I discovered how to enable the javaagent aspect of the test case. This allowed me to first replicate the issue referenced in this JIRA and then I did the prescribed uncomment in the TemporaryClassLoader that resulted in the fix. Then I changed the test class to an enum class and I got the symptoms of OpenJPA-2399.. Feel free to contact me on skype with handle garpinc to follow up. I got diverted temporarily to a different project but now i'm back dealing with this issue again.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Date millisecond precision lost for Informix IDS and SQLServer,OPENJPA-645,12399111,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,dinkar,dinkar,26/Jun/08 20:01,10/Mar/10 03:32,14/Mar/19 03:02,26/Jun/08 20:22,1.0.3,1.1.0,,,,,,,,1.0.4,1.2.0,1.3.0,2.0.0-M1,,jdbc,,,,,,0,,"An entity has an attribute of type java.util.Date, annotated with @Temporal(TemporalType.TIMESTAMP):

@Temporal(TemporalType.TIMESTAMP)
public Date udate;

This gets mapped in Informix to a column of type:

udate DATETIME YEAR TO FRACTION (3)

and in SQLServer to 

udate DATETIME

When the udate attribute is assigned a value with millisecond precision, say ""12:34:56:789"", OpenJPA chops off the millisecond fractional part when it generates the INSERT statement.

In DBDictionary, for this type, we come to setDate() with the 'val' parameter set to the correct java.util.Date value ""12:34:56:789"". (The millisecond value is stored in the (Gregorian.Date) cdate.millis attribute of java.util.Date). setDate() then calls setTimestamp() - the last else - with a new instance of java.sql.Timestamp:

setTimestamp(stmnt, idx, new Timestamp(val.getTime()), null, col);

java.sql.Timestamp is made up of 2 parts - a date part that stores the time upto seconds, and a separate attribute, called nanos, that stores everything that is fractional of seconds. 

So the new Timestamp value that is sent to setTimestamp() has this:

(Gregorian.Date) cdate = 12:34:56
nanos = 789000000

In setTimestamp() there is a check for supportsTimestampNanos. Because in the InformixDictionary and SQLServer dictionaries this is set to false, the code then zeros out the nanos field:

if (supportsTimestampNanos)
    val.setNanos(nanos);
else
    val.setNanos(0);

Consequently, all fractional seconds information is lost for these 2 database types from the INSERT statement for this timestamp value. 

The nanos field in java.sql.Timestamp does not really mean that only nanoseconds are stored there - it means that any fractional value, after seconds  will be stored there.This problem happens not only with the Date field in the entity, but also with java.util.Calendar and java.sql.Timestamp. The solution is to always set the nanoseconds value in the (java.sql.Timestamp)val field. The check for supportsTimestampNanos, as well as the flag itself, is not needed, because both IDS and SQLServer do allow fractional seconds.

Will attach a patch ASAP. Albert has reviewed the proposed solution.",,,,,,,,,,,,,,,,,,,,,,19/Aug/09 12:50;bjreed;OPENJPA-645-1.0.x.patch;https://issues.apache.org/jira/secure/attachment/12417014/OPENJPA-645-1.0.x.patch,26/Jun/08 20:05;dinkar;patch-645.txt;https://issues.apache.org/jira/secure/attachment/12384787/patch-645.txt,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-06-26 20:22:32.293,,,no_permission,,,,,,,,,,,160959,,,Wed Mar 10 03:32:45 UTC 2010,,,,,,,0|i1dqu7:,288445,,,,,,,,26/Jun/08 20:22;fancy;fix checked in under r672017,"19/Aug/09 12:50;bjreed;In 1.0.x, SQL Server has already been updated to allow the fractional portion of seconds to be stored.  The OPENJPA-645-1.0.x patch does the same for InformixDictionary and removes the flag from DBDictionary.",10/Mar/10 03:32;mikedd;The changes predate 1.2.0 (1.2.x branch created under revision 680507). It's missed the release notes though and is certainly fixed in 2.0.0M1. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Handle databaseProductVersion string from newer jcc driver for DB2 ISeries,OPENJPA-644,12399110,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,26/Jun/08 19:28,09/Mar/10 18:32,14/Mar/19 03:02,26/Jun/08 19:46,1.2.0,,,,,,,,,1.0.4,1.2.0,,,,jdbc,,,,,,0,,"A recent change in the newer db2jcc.jar has changed the databaseProductVersion to ""QSQ05040"" for V5R4M0,  ""QSQ06010"" for V6R1M0.
DB2Dictionary need to handle the new databaseProductVersion string for  DB2 ISeries.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160958,,,Thu Jun 26 19:46:33 UTC 2008,,,,,,,0|i0z7if:,203519,,,,,,,,26/Jun/08 19:46;fancy;fix checked in under r672008,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sybase create foreign key on delete set null failed with syntax error,OPENJPA-642,12398930,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,faywang,faywang,24/Jun/08 16:43,09/Mar/10 18:32,14/Mar/19 03:02,25/Jun/08 15:47,,,,,,,,,,1.2.0,,,,,,,,,,,0,,"The following alter table statement is rejected:

ALTER TABLE dbo.JPADeptBean 
    ADD CONSTRAINT FK_EmpBean_mgr FOREIGN KEY (MGR_EMPID) REFERENCES dbo.JPAEmpBean (empid) ON DELETE SET NULL

with com.sybase.jdbc3.jdbc.SybSQLException: Incorrect syntax near the keyword 'ON'.

According to Sybase IQ 12.7, Sybase  only supports foreign key on delete/update restrict.

http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.dc38151_1270/html/iqref/BABCGFHG.htm
",,,,,,,,,,,,,,,,,,,,,,24/Jun/08 16:45;faywang;openjpa-642.patch;https://issues.apache.org/jira/secure/attachment/12384597/openjpa-642.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-06-25 15:47:42.297,,,no_permission,,,,,,,,,,,160956,,,Wed Jun 25 15:47:56 UTC 2008,,,,,,,0|i0z7cv:,203494,,,,,,,,25/Jun/08 15:47;mikedd;Committed fix under revision 671585,25/Jun/08 15:47;mikedd;Thanks for the patch Fay!,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassNotFoundException for InstrumentationFactory upon startup,OPENJPA-640,12398823,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,curtisr7,mingfai,mingfai,23/Jun/08 10:41,16/Jul/10 19:40,14/Mar/19 03:02,16/Jul/10 19:40,1.0.2,1.1.0,1.2.0,,,,,,,2.0.0-beta3,,,,,kernel,,,,,,5,,"This problem exists for a long time and it affects more than other people as well. Refer to an old thread in the mail list.
http://mail-archives.apache.org/mod_mbox/openjpa-users/200801.mbox/%3C478963D8.209@gmail.com%3E

java.lang.ClassNotFoundException: org.apache.openjpa.enhance.InstrumentationFactory
	at java.net.URLClassLoader$1.run(URLClassLoader.java:200)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:276)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
	at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:280)
	at sun.instrument.InstrumentationImpl.loadClassAndCallAgentmain(InstrumentationImpl.java:348)

Previously, I had an old trick to patch the org.apache.openjpa.enhance.InstrumentationFactory.jar to include the InstrumentationFactory but it doesn't work now. 

Remarks: the problem is merely about displaying a piece of stacktrace but there is no actual impact to the OpenJPA function. (that's why I marked the priority as minor.)","JDK6, 1.2.0-trunk",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-02-05 09:18:27.491,,,no_permission,,,,,,,,,,,160954,,,Fri Jul 16 19:40:15 UTC 2010,,,,,,,0|i1dquv:,288448,,,,,,,,23/Jun/08 10:43;mingfai;added remarks,"05/Feb/09 09:18;adam.hardy@cyberspaceroad.com;I'd like to bring this one to the front because of two things:

(1) when debugging, the thrown exceptions stop the debugger every time I submit a request to the webserver. Not much fun when everything runs so slowly anyway.

(2) support staff get very jittery about stacktraces in the logs and don't really understand that there isn't actually something wrong. ","15/Oct/09 02:22;kurtstam;We're getting it on the jUDDI project too:

http://ci.apache.org/builders/juddi-trunk-openjpa/builds/6/steps/compile/logs/stdio

scroll down toward the bottom. It worries me that something is wrong. Is it ok to release jUDDI with this stack trace?","26/Mar/10 15:00;jleong;Does this problem still exist for OpenJPA 1.2.2?  If so, is it still innocuous to OpenJPA functionality as noted by the description?
We're getting:
Exception in thread ""Attachment 65390"" java.lang.ClassNotFoundException: org.apache.openjpa.enhance.InstrumentationFactory
	at java.lang.ClassNotFoundException.<init>(ClassNotFoundException.java:77)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:383)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:643)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:346)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:609)
	at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:292)
	at sun.instrument.InstrumentationImpl.loadClassAndCallAgentmain(InstrumentationImpl.java:360)
	at com.ibm.tools.attach.javaSE.Attachment.loadAgentLibraryImpl(Native Method)
	at com.ibm.tools.attach.javaSE.Attachment.loadAgentLibrary(Attachment.java:253)
	at com.ibm.tools.attach.javaSE.Attachment.parseLoadAgent(Attachment.java:235)
	at com.ibm.tools.attach.javaSE.Attachment.doCommand(Attachment.java:154)
	at com.ibm.tools.attach.javaSE.Attachment.run(Attachment.java:116)
JVMJ9TI003E Agent_OnLoad failed for library instrument

Thanks!",26/Mar/10 19:14;curtisr7;@Joseph - If you are enhancing your entities are build time this error won't cause you any problems.,"16/Jul/10 19:40;curtisr7;This issue should be fixed in 2.0.0 and trunk with the changes that Jeremy made for OPENJPA-1410. 

If the issue still exists on one of those releases, please re-open.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Significant performance degradation when data cache is enabled,OPENJPA-637,12398364,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,16/Jun/08 20:25,09/Mar/10 18:32,14/Mar/19 03:02,30/Jun/08 18:37,1.2.0,,,,,,,,,1.2.0,,,,,datacache,lib,,,,,0,,"Performance testing is showing a severe data cache performance degradation when moving from 1.0.x OpenJPA code to 1.2.0 level code.  Profiling showed the problem to be in the new random eviction scheme which runs when the cache reaches its maximum number of entries.  This code was changed significantly when OpenJPA moved to Java 5 java.util.concurrent.ConcurrentHashMap and away from the OpenJPA implementation of ConcurrentHashMap.  A macro-benchmark showed a 20% performance degradation from base 1.2.0 code when the cache reaches its maximum size; prompting eviction in order to add new cache entries.

I've found that the new random eviction code appears to be improved in the very recent 666903 commit, but data cache performance remains considerably slower than the 1.0.x implementation.  Profiles with the 666903 changes show test threads to be waiting on the reentrant write lock in the CacheMap wrapper (which now wrappers a max size capable, null handling, subclass of java.util.concurrent.ConcurrentHashMap).  Investigation is underway to determine whether the write lock is necessary (ie. can java.util.conncurrentConcurrentHashMap manage the cache without the need for external locking) and/or if changes could be made which would result in a significant reduction in contention for the lock.  Any thoughts/ideas on that would be extremely helpful.

Performance tests run with the 1.2.0 code base, using the OpenJPA version of ConcurrentHashMap (instead of the Java 5 java.util.concurrent.ConcurrentHashMap-based implementation) have shown that  performance of the data cache is significantly better when the legacy OpenJPA implementation is used.  Based on the results, it appears that OpenJPA should be using the the legacy ConcurrentHashMap instead of the Java 5-based implementation -- or the new Java 5-based implementation needs to be improved considerably in order to perform as well as 1.0.x.

I am opening this as a 1.2.0 issue, although it very likely affects 1.1.x as well.  Testing has not been performed on 1.1.x to confirm the problem exists on that release.",,,,,,,,,,,,,,,,,,,,,,23/Jun/08 19:36;techhusky;CacheImplTest.jar;https://issues.apache.org/jira/secure/attachment/12384524/CacheImplTest.jar,17/Jun/08 16:50;techhusky;OPENJPA-637.patch;https://issues.apache.org/jira/secure/attachment/12384142/OPENJPA-637.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-06-18 02:27:25.192,,,no_permission,,,,,,,,,,,160951,,,Mon Jun 30 18:37:11 UTC 2008,,,,,,,0|i0z51j:,203119,,,,,,,,"17/Jun/08 16:50;techhusky;Attaching a patch for 1.2.0 which adds-back and utilizes the OpenJPA ConcurrentHashMap implementation.  Based on benchmark results and additional testing with the Java 5-based implementation, use of the OpenJPA implementation appears to be the best course of action.  Comments, please.",18/Jun/08 02:27;pcl;How many cores / CPUs were being used in the benchmark runs?,18/Jun/08 14:48;techhusky;The benchmark system is a hyper-threaded 4-way 3.8GHz Xeon.  The benchmark is exercised with 50 concurrent users.,"18/Jun/08 17:45;pcl;What were the comparative results with an appropriately-sized cache for the data set? (i.e., without cache eviction)","18/Jun/08 20:27;techhusky;Several attempts were made to tune the max size of the data cache with base 1.2.0 code. Performance started to degrade at a certain point by further increasing the max cache size . The benchmark showed better results with a max size of 5000 than it did for 10000+. (Default (1000) and 15000 were also tested, 5000 appeared to be optimal for this workload.) The database tables used in the benchmark fluctuate around 35000 rows, which roughly equate to entities.

Out of curiousity, instead of using CacheMap as the cache store in ConcurrentDataCache, java.util.concurrent.ConcurrentHashMap was used directly in its place (soft ref, write locking, and pinning support were removed for simplification). This also eliminated the max size and null handling aspects of the cache. Benchmark performance with this configuration was very similar to measurements taken with the data cache disabled. Database (on a separate server) utilization was down considerably, which was good & expected, but the benchmark was not showing a performance improvement. In contrast, 1.2.0 using the 1.0.x code showed a ~20% improvement when the data cache (max cache size 5000) was enabled.","18/Jun/08 23:21;pcl;Interesting. Thanks for the additional detail. We'll look into it on our end -- the initial change was the result of benchmark analysis. Hopefully we can work out what the difference is. At a minimum, we should re-introduce the old cache so that the better implementation for a given work load can be easily selected via configuration.","19/Jun/08 19:41;techhusky;Thanks, Patrick.  I think providing caching options (and doc explaining the behavioral differences) is a good approach.  I'll be disconnected for a few days, so I'll catch up with you when I return.","23/Jun/08 19:36;techhusky;I've attached a standalone test for running some tests using various cache implementations and configurations.  It behaves similarly to the benchmark that exposed this problem.  The test allows  configuration of number of threads, max data size, max cache size, whether external locking is enabled, and the cache implementation type.

This test is showing similar results as to what I've previously posted; a write lock causing contention when the cache becomes full.  When the external write lock (a reentrant lock over and above internal cache locking) is enabled and the data size is ~5000 entries larger than the max cache size performance drops significantly.  The external lock simulates the reentrant lock used by DataCacheStoreManager to ensure the cache does not get updated with an old version of data.

This test should provide a better idea of what I'm seeing.  Aside, there is an option to run directly with java.util.concurrent.ConcurrentHashMap and it performs very well - although there is no null masking or maximum size on the cache.  

To get a list of options:  java -cp CacheImplTest.jar;commons-collections-3.2.jar cachetest.Main

Patrick - What behavior/environment does your benchmark test?  Is it possible that your cache size is very near the size of your data so you are not hitting the problem?","25/Jun/08 19:57;techhusky;Since Patrick agrees that we should do something to alleviate this performance concern, I would like to at least get us back on par with our previous releases. To that end, I would like to ask to have the patch I submitted to be integrated. I created a sub-task (OPENJPA-643) so that we don't lose track of providing a more flexible, configurable option. But, until we get  that ironed out, I really don't want to hold up the rest of our performance analysis.
","30/Jun/08 18:37;techhusky;With the OpenJPA ConcurrentHashMap cache implementation back in place, benchmark results with data cache enabled are back in-line with the 1.0.x release.  Future work regarding a data cache implementation configuration option will be handled through OPENJPA-643.",,,,,,,,,,,,,,,,,,,,,,,,,,,
SQLException not reported from Batched statement,OPENJPA-634,12398017,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,fancy,fancy,11/Jun/08 02:37,30/Sep/08 16:25,14/Mar/19 03:02,02/Jul/08 14:18,1.2.0,,,,,,,,,1.2.0,,,,,jdbc,,,,,,0,,Batched update resulted in SQLException was not propagated back to application.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-07-01 16:22:10.444,,,no_permission,,,,,,,,,,,160949,,,Tue Jul 01 16:22:10 UTC 2008,,,,,,,0|i1dqvz:,288453,,,,,,,,26/Jun/08 19:48;fancy;fix checked in under r666512,"01/Jul/08 16:22;allee8285;The previous fixes did not completely correct the problem scenario.

In AbstractUpdateManager.flush(), it keeps track of 2 exception collections, one as a local variable in flush() and the 2nd one maintained by the prepare statement manger. These 2 collections are combined into a single collection and returned by flush().

This approach caused the return collection not maintaining the order of exceptions took place during the flush. Typically the first exception contains the relevant information about the cause of failure and it allows the application to examine the cause and perform appropriate recovery action.

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
setFirstResult and setMaxResults not working for Oracle.,OPENJPA-632,12397984,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,10/Jun/08 21:29,14/Apr/09 09:38,14/Mar/19 03:02,10/Jun/08 21:33,1.0.1,1.0.2,,,,,,,,1.0.3,,,,,,,,,,,0,,"Marc caught this problem a few months ago and fixed it in trunk. I've discovered that the problem exists in 1.0.x as well and I'm porting the fix. 

I believe we already have sufficient test coverage - but we need to run the regression bucket more regularly on licensed databases (ie Oracle, DB2).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160947,,,Tue Jun 10 21:33:19 UTC 2008,,,,,,,0|i0yy0v:,201982,,,,,,,,"10/Jun/08 21:33;mikedd;Reposting the comments Marc made when he committed rev 584463 for posterity :

""The overridden toSelect() signature in the OracleDictionary was no longer appropriate since the DBDictionary.toSelect() change in revision #577972 (which fixed OPENJPA-378). This resulted in the special Oracle range handing to no longer take place, resulting in setFirstResult() and setMaxResults() effectively being ignored for Oracle.""",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Honor batchlimit=1 in statement batching support.,OPENJPA-630,12397845,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,09/Jun/08 21:49,11/Jun/08 22:13,14/Mar/19 03:02,09/Jun/08 22:07,1.0.2,1.1.0,,,,,,,,1.2.0,,,,,kernel,,,,,,0,,"When batchlimit is set to 1, the statement batching support attempts to batch if the consecutive statements have the same SQL request syntax. But eventually, it will execute each statement individually.  This logic yielded some undesired behavior in Informix which caused failure in the SQL request.

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160945,,,2008-06-09 21:49:00.0,,,,,,,0|i1dqw7:,288454,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
When creating foreign keys the schema name is not trimmed for WS before checking DB,OPENJPA-629,12397825,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,09/Jun/08 16:51,13/Aug/09 15:05,14/Mar/19 03:02,09/Jun/08 17:56,1.2.0,,,,,,,,,1.0.4,1.2.0,,,,,,,,,,0,,"When creating foreign keys the SchemaGenerator does not trim trailing whitespace when checking for existing keys in the database. 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160944,,,Mon Jun 09 17:56:19 UTC 2008,,,,,,,0|i0z5nj:,203218,,,,,,,,09/Jun/08 17:09;mikedd;Reopening. As far as I know the problem only occurs with Informix. Updating fix to made it a DBDictionary option. ,"09/Jun/08 17:56;mikedd;Fixed under revision 665801. The changes only affect the path that I know to have been causing a problem with Informix. 

In the future we may need to expand the use of this flag. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Issue Found With Recursive One-To_Many Relations in 1.1.0,OPENJPA-628,12397816,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,mikedd,rkrier,rkrier,09/Jun/08 16:04,09/Mar/10 18:32,14/Mar/19 03:02,05/Aug/08 17:44,1.1.0,,,,,,,,,1.2.0,,,,,kernel,,,,,,0,,"There seems to be an issue with recursive one-to-many relations that did not exist prior to 1.1.0.  I have tested my scenario on both 1.0.1 and 1.0.2 and the behavior works as expected, but the exact same scenario does not work under 1.1.0.  It seems that level two joins do not persist on an update of an object graph.

To illustrate my problem I've included the source and a application to run the test.  The entity classes are as follows:

1)       A given ""Tree"" object holds one-to-many ""Node"" objects.  ""Tree"" is neither derived by nor derived from any other classes.
2)       A given ""Node"" object holds one-to-many child ""Node"" objects.  ""Node"" is neither derived by nor derived from any classes.

Scenario 1:

1)       Create a ""Tree"" object.
2)       Add one or more ""Node"" objects to ""Tree""
3)       Add one or more child ""Node"" objects to one or more of the ""node"" objects associated with ""tree"".
4)       Persist and commit ""tree"".
5)       Close the entity manager.

Result: The tree, nodes and child nodes are persisted to the database as expected.  Referential integrity is correct.

Scenario 2:

1)       Create a ""Tree"" object.
2)       Add one or more ""Node"" objects to ""Tree""
3)       Persist and commit the tree.
4)       Close the entity manager.

Result:  The tree and nodes are persisted to the database as expected.

5)       Read the ""tree"" from a new entity manager
6)       Add child nodes to one or more of the ""nodes"" objects associated with ""tree""
7)       Commit the ""tree""
8)       Close the entity manager.

Result: Under 1.0.1 and 1.0.2, the child nodes are persisted to the database as expected.  Referential integrity is correct.  Under 1.1.0, the child nodes are not persisted to the database.  No errors or exceptions are thrown.  This appears to be broken with the 1.1.0 release.

I have included my test application for you to review.  The test was run against a SQL Server database, however you should be able to easily modify the persistence.xml file to run against any database platform you wish.  The table structure is as follows:

Counters:

            PrimKey: NUMERIC(18,0) (18,0) PrimaryKey, NOT NULL
            Counter: NUMERIC(18,0) (18, 0) NOT NULL
 
Trees:
            OID: NUMERIC(18,0) PrimaryKey, NOT NULL
            ParentOID: NUMERIC(18,0) NULL
            Sequence: NUMERIC(18,0) NULL
            Name: VARCHAR(50) NOT NULL
            Version: NUMERIC(18,0) NOT NULL

Nodes:
            OID: NUMERIC(18,0) PrimaryKey, NOT NULL
            Name: VARCHAR(50) NOT NULL
            Version: NUMERIC(18,0) NOT NULL

Please let me know if you have any questions.  Thanks for your attention into this matter.


",Does not appear to be affect by environment (OS or DB Platform),,,,,,,,,,,,,,,,,,,,,09/Jun/08 16:06;rkrier;One2Many_issue_1.1.0.zip;https://issues.apache.org/jira/secure/attachment/12383697/One2Many_issue_1.1.0.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-08-02 16:37:15.859,,,no_permission,,,,,,,,,,,160943,,,Tue Aug 05 16:10:09 UTC 2008,,,,,,,0|i0yw3r:,201671,,,,,,,,09/Jun/08 16:06;rkrier;This is the source code used to reproduce the problem I've described.,"09/Jun/08 19:20;rkrier;Patrick,

I found the optimization you made for revision 610922 created this problem. When I revert ""org.apache.openjpa.util.ProxyCollections"" to the previous revision (553010) the problem goes away.

The problem appears to me that if you always call List.add(index, object) where index always equals the size of the list, the dirty state of the object does not correctly get set. For example:

list.add(0, obj1);
list.add(1, obj2);
list.add(2, obj3);

does not work, but:

list.add(0, obj1);
list.add(0, obj2);
list.add(0, obj3);

does, and:

list.add(obj1);
list.add(obj2);
list.add(obj3);

does as well. ","02/Aug/08 16:37;ppoddar@apache.org;=============================================================================
r610922 | pcl | 2008-01-10 14:37:36 -0600 (Thu, 10 Jan 2008) | 1 line

proxy collection optimization for adding to the end of a list vs. adding elsewhere
==============================================================================

Yes -- this is a change with far-reaching consequences including regression of this test case :)

610922 should be reverted back.
It is changing code paths that dynamic proxies (generated in bytecode) depend on.
 



",05/Aug/08 16:10;mikedd;Re-targetting since we've re-spun 1.2.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error when removing embeddable entities from a persistent collection,OPENJPA-625,12397581,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,mseidel,mseidel,05/Jun/08 14:00,09/Mar/10 18:32,14/Mar/19 03:02,19/Jun/08 16:48,1.1.0,,,,,,,,,1.2.0,,,,,kernel,,,,,,0,,"Say you have an EntityA which is annotated as @Embeddable and an EntityB which contains a mapping like

@PersistentCollection(elementEmbedded = true, elementType = EntityA.class, fetch = FetchType.LAZY)
private List<EntityA> list;

Now if you remove an entry from the list of a persistent EntityB and commit the transaction it leads to the following exception:

Caused by: <openjpa-1.1.0-runknown fatal user error> org.apache.openjpa.persistence.ArgumentException: Could not locate metadata for the class using oid ""org.apache.openjpa.datacache.DataCachePCDataImpl@8c248cb"" of type ""class org.apache.openjpa.datacache.DataCachePCDataImpl"".  
FailedObject: org.apache.openjpa.datacache.DataCachePCDataImpl@8c248cb
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:1025)
        at org.apache.openjpa.kernel.BrokerImpl.newStateManagerImpl(BrokerImpl.java:1176)
        at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:964)
        at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:913)
        at org.apache.openjpa.kernel.AbstractPCData.toRelationFields(AbstractPCData.java:217)
        at org.apache.openjpa.kernel.AbstractPCData.toNestedFields(AbstractPCData.java:184)
        at org.apache.openjpa.kernel.AbstractPCData.toField(AbstractPCData.java:78)
        at org.apache.openjpa.kernel.PCDataImpl.loadField(PCDataImpl.java:197)
        at org.apache.openjpa.kernel.PCDataImpl.load(PCDataImpl.java:167)
        at org.apache.openjpa.datacache.DataCacheStoreManager.load(DataCacheStoreManager.java:383)
        at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
        at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
        at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:2911)
        at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:2989)
        at org.apache.openjpa.kernel.StateManagerImpl.fetchObjectField(StateManagerImpl.java:2238)
        at org.apache.openjpa.kernel.StateManagerImpl.fetchField(StateManagerImpl.java:775)
        at org.apache.openjpa.kernel.StateManagerImpl.cascadeDelete(StateManagerImpl.java:2860)
        at org.apache.openjpa.kernel.BrokerImpl.deleteDeref(BrokerImpl.java:2117)
        at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1955)
        at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1905)
        at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1823)
        at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
        at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1347)
        at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:877)
        at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:512)
        ... 12 more

After some digging I think I found the cause in the AbstractPCData.toNestedFields method:

case JavaTypes.PC:
     if (vmd.isEmbedded())
        for (Iterator itr = data.iterator(); itr.hasNext();)
             ret.add(toEmbeddedField(sm, vmd, itr.next(), fetch, context));
// no break

should probably be:

case JavaTypes.PC:
    if (vmd.isEmbedded()) {
         for (Iterator itr = data.iterator(); itr.hasNext();)
              ret.add(toEmbeddedField(sm, vmd, itr.next(), fetch, context));
         return ret;
    }
// no break

At least it worked for me this way.
","OpenJPA 1.1.0
Java 6
MySQL 5
Extended Persistence Context
DataCache enabled",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-06-19 16:48:56.128,,,no_permission,,,,,,,,,,,160940,,,Thu Jun 19 16:48:56 UTC 2008,,,,,,,0|i0z29r:,202670,,,,,,,,19/Jun/08 16:48;ppoddar@apache.org;SVN Revision 668268.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Informix -lock timieout, cursor not open problem for NonJTA datasource transaction RESOURCE_LOCAL in JEE",OPENJPA-622,12397505,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,04/Jun/08 19:47,29/Jul/09 15:24,14/Mar/19 03:02,04/Jun/08 20:00,1.0.3,1.1.0,1.2.0,,,,,,,1.0.4,1.2.0,,,,,,,,,,0,,"in JEE environement, a NON-JTA datasource with transaction type RESORUCE_LOCAL causes many problems:
1. lock timeout
2. cursor not open
3. can not position in ...
",,,,,,,,,,,,,,,,,,,,,,27/Jul/09 20:46;fyrewyld;OpenJPA_1.0.x_OPENJPA-622.patch;https://issues.apache.org/jira/secure/attachment/12414660/OpenJPA_1.0.x_OPENJPA-622.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-07-27 20:46:51.001,,,no_permission,,,,,,,,,,,38435,,,Wed Jul 29 15:24:08 UTC 2009,,,Patch Available,,,,0|i0ywxb:,201804,,,,,,,,04/Jun/08 20:00;fancy;fix committed under r663358,27/Jul/09 20:46;fyrewyld;Built a version of the OPENJPA-622 patch for 1.0.x,29/Jul/09 15:24;mikedd;Applying patch from Jody Grassel for version 1.0.x. Fix added in revsion 798945. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Typos in the manual,OPENJPA-619,12397311,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,ppoddar@apache.org,milosz,milosz,02/Jun/08 19:37,09/Mar/10 18:32,14/Mar/19 03:02,28/Jul/08 17:10,1.1.0,,,,,,,,,1.2.0,,,,,docs,,,,,,0,,The manual contains a few typographical errors.,,,,,,,,,,,,,,,,,,,,,,02/Jun/08 19:38;milosz;openjpa-619.patch;https://issues.apache.org/jira/secure/attachment/12383244/openjpa-619.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160935,,,Mon Jun 02 19:38:51 UTC 2008,,,,,,,0|i1dqxr:,288461,,,,,,,,02/Jun/08 19:38;milosz;The patch contains corrections of typos I have found during reading the manual.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
openJPA threw exception when parsing entity metadata in JBoss,OPENJPA-618,12397095,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,maojianfeng,maojianfeng,29/May/08 18:22,09/Mar/10 18:35,14/Mar/19 03:02,06/Jun/08 21:06,1.1.0,,,,,,,,,,,,,,jpa,,,,,,0,,"1. Create a  Enterprise Application Project
2. Create a  EJB project which contains a stateless session which uses a couple of entity classes (use annotation)
3. Create a WAR project that has a servlet class uses the statelessbean and a index.jsp
4. start the jboss server inside Eclipse
5. deploy the EAR project to the JBoss server
6. open a browser to access the index.jsp

It seems that openJPA was trying to enhance the entity classes, although they were enhanced at build time already. And then it exceptioned out when parsing the nested jars in the  ear. 


11:58:19,437 INFO  [ServerImpl] Starting JBoss (Microcontainer)...
11:58:19,437 INFO  [ServerImpl] Release ID: JBoss [Morpheus] 5.0.0.Beta4 (build: SVNTag=JBoss_5_0_0_Beta4 date=200802091115)
11:58:19,453 INFO  [ServerImpl] Home Dir: C:\jboss-5.0.0.Beta4
11:58:19,453 INFO  [ServerImpl] Home URL: file:/C:/jboss-5.0.0.Beta4/
11:58:19,453 INFO  [ServerImpl] Library URL: file:/C:/jboss-5.0.0.Beta4/lib/
11:58:19,453 INFO  [ServerImpl] Patch URL: null
11:58:19,453 INFO  [ServerImpl] Server Name: default
11:58:19,453 INFO  [ServerImpl] Server Home Dir: C:\jboss-5.0.0.Beta4\server\default
11:58:19,453 INFO  [ServerImpl] Server Home URL: file:/C:/jboss-5.0.0.Beta4/server/default/
11:58:19,453 INFO  [ServerImpl] Server Data Dir: C:\jboss-5.0.0.Beta4\server\default\data
11:58:19,453 INFO  [ServerImpl] Server Temp Dir: C:\jboss-5.0.0.Beta4\server\default\tmp
11:58:19,453 INFO  [ServerImpl] Server Config URL: file:/C:/jboss-5.0.0.Beta4/server/default/conf/
11:58:19,453 INFO  [ServerImpl] Server Library URL: file:/C:/jboss-5.0.0.Beta4/server/default/lib/
11:58:19,453 INFO  [ServerImpl] Root Deployment Filename: jboss-service.xml
11:58:19,828 INFO  [ServerImpl] Starting Microcontainer, bootstrapURL=file:/C:/jboss-5.0.0.Beta4/server/default/conf/bootstrap-beans.xml
11:58:20,750 INFO  [ProfileImpl] Using profile root:C:\jboss-5.0.0.Beta4\server\default
11:58:21,156 INFO  [ServerInfo] Java version: 1.5.0,IBM Corporation
11:58:21,156 INFO  [ServerInfo] Java VM: IBM J9 VM 2.3,IBM Corporation
11:58:21,156 INFO  [ServerInfo] OS-System: Windows XP 5.1 build 2600 Service Pack 2,x86
11:58:21,187 INFO  [JMXKernel] Legacy JMX core initialized
11:58:23,328 INFO  [WebService] Using RMI server codebase: http://127.0.0.1:8083/
11:58:23,734 INFO  [TransactionManagerService] JBossTS Transaction Service (JTA version) - JBoss Inc.
11:58:23,734 INFO  [TransactionManagerService] Setting up property manager MBean and JMX layer
11:58:23,953 INFO  [TransactionManagerService] Starting recovery manager
11:58:24,078 INFO  [TransactionManagerService] Recovery manager started
11:58:24,078 INFO  [TransactionManagerService] Binding TransactionManager JNDI Reference
11:58:36,109 INFO  [PersistenceUnitParsingDeployer] Found persistence units [org.jboss.ejb3.metadata.jpa.spec.PersistenceUnitMetaData@14001400{name=com.ibm.u2.u2jpa.jboss.EJB}]
11:58:39,234 INFO  [AspectDeployer] Deploying xml into org.jboss.aop.AspectManager@41e841e8 for BaseClassLoader@9140914{vfsfile:/C:/jboss-5.0.0.Beta4/server/default/deploy/ejb3-interceptors-aop.xml}
11:58:39,843 INFO  [MCKernelAbstraction] installing bean: persistence.units:ear=com.ibm.u2.u2jpa.jboss.EAR.ear,jar=com.ibm.u2.u2jpa.jboss.EJB.jar,unitName=com.ibm.u2.u2jpa.jboss.EJB with dependencies:
11:58:39,843 INFO  [MCKernelAbstraction]   and demands:
11:58:39,843 INFO  [MCKernelAbstraction] 	jboss.jca:name=DefaultDS,service=DataSourceBinding
11:58:39,843 INFO  [MCKernelAbstraction]   and supplies:
11:58:39,906 INFO  [MCKernelAbstraction] installing bean: jboss.j2ee:ear=com.ibm.u2.u2jpa.jboss.EAR.ear,jar=com.ibm.u2.u2jpa.jboss.EJB.jar,name=MyStatelessSessionBean,service=EJB3 with dependencies:
11:58:39,906 INFO  [MCKernelAbstraction]   and demands:
11:58:39,906 INFO  [MCKernelAbstraction] 	jboss.ejb:service=EJBTimerService
11:58:39,906 INFO  [MCKernelAbstraction] 	persistence.units:ear=com.ibm.u2.u2jpa.jboss.EAR.ear,jar=com.ibm.u2.u2jpa.jboss.EJB.jar,unitName=com.ibm.u2.u2jpa.jboss.EJB
11:58:39,906 INFO  [MCKernelAbstraction]   and supplies:
11:58:39,906 INFO  [MCKernelAbstraction] 	Class:sampleear.RemoteBusinessInterface
11:58:40,609 INFO  [RARDeployment] Required license terms exist, view vfsfile:/C:/jboss-5.0.0.Beta4/server/default/deploy/jboss-local-jdbc.rar/META-INF/ra.xml
11:58:40,609 INFO  [RARDeployment] Required license terms exist, view vfsfile:/C:/jboss-5.0.0.Beta4/server/default/deploy/jboss-xa-jdbc.rar/META-INF/ra.xml
11:58:40,656 INFO  [ConnectionFactoryBindingService] Bound ConnectionManager 'jboss.jca:service=DataSourceBinding,name=DefaultDS' to JNDI name 'java:DefaultDS'
11:58:41,000 WARN  [QuartzTimerServiceFactory] sql failed: CREATE TABLE qrtz_job_details(JOB_NAME VARCHAR(80) NOT NULL, JOB_GROUP VARCHAR(80) NOT NULL, DESCRIPTION VARCHAR(120) NULL, JOB_CLASS_NAME VARCHAR(128) NOT NULL, IS_DURABLE VARCHAR(1) NOT NULL, IS_VOLATILE VARCHAR(1) NOT NULL, IS_STATEFUL VARCHAR(1) NOT NULL, REQUESTS_RECOVERY VARCHAR(1) NOT NULL, JOB_DATA BINARY NULL, PRIMARY KEY (JOB_NAME,JOB_GROUP))
11:58:41,093 INFO  [SimpleThreadPool] Job execution threads will use class loader of thread: main
11:58:41,125 INFO  [QuartzScheduler] Quartz Scheduler v.1.5.2 created.
11:58:41,125 INFO  [JobStoreCMT] Using db table-based data access locking (synchronization).
11:58:41,125 INFO  [JobStoreCMT] Removed 0 Volatile Trigger(s).
11:58:41,125 INFO  [JobStoreCMT] Removed 0 Volatile Job(s).
11:58:41,125 INFO  [JobStoreCMT] JobStoreCMT initialized.
11:58:41,125 INFO  [StdSchedulerFactory] Quartz scheduler 'JBossEJB3QuartzScheduler' initialized from an externally provided properties instance.
11:58:41,125 INFO  [StdSchedulerFactory] Quartz scheduler version: 1.5.2
11:58:41,140 INFO  [JobStoreCMT] Freed 0 triggers from 'acquired' / 'blocked' state.
11:58:41,140 INFO  [JobStoreCMT] Recovering 0 jobs that were in-progress at the time of the last shut-down.
11:58:41,140 INFO  [JobStoreCMT] Recovery complete.
11:58:41,140 INFO  [JobStoreCMT] Removed 0 'complete' triggers.
11:58:41,140 INFO  [JobStoreCMT] Removed 0 stale fired job entries.
11:58:41,140 INFO  [QuartzScheduler] Scheduler JBossEJB3QuartzScheduler_$_NON_CLUSTERED started.
11:58:41,250 INFO  [PersistenceUnitDeployment] Starting persistence unit persistence.units:ear=com.ibm.u2.u2jpa.jboss.EAR.ear,jar=com.ibm.u2.u2jpa.jboss.EJB.jar,unitName=com.ibm.u2.u2jpa.jboss.EJB
11:58:42,593 INFO  [EJBContainer] STARTED EJB: sampleear.MyStatelessSessionBean ejbName: MyStatelessSessionBean
11:58:43,875 INFO  [AprLifecycleListener] The Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: C:\Program Files\IBM\Java50\jre\bin;.;C:\Program Files\IBM\Java50\bin\..\jre\bin\j9vm;C:\Program Files\IBM\Java50\bin\..\jre\bin;C:\PROGRA~1\MKSTOO~1\bin;C:\PROGRA~1\MKSTOO~1\bin\X11;C:\PROGRA~1\MKSTOO~1\mksnt;C:\Program Files\ThinkPad\Utilities;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\Program Files\IBM\Infoprint Select;C:\Notes;C:\Program Files\XLView;C:\lotus\compnent;C:\Utilities;C:\WINDOWS\Downloaded Program Files;C:\Program Files\IBM\Personal Communications\;C:\Program Files\IBM\Trace Facility\;c:\Program Files\Microsoft SQL Server\90\Tools\binn\;C:\Program Files\ThinkPad\ConnectUtilities;C:\Program Files\QuickTime\QTSystem\;C:\Program Files\Subversion\bin;C:\PROGRA~1\IBM\SQLLIB~1\BIN;C:\PROGRA~1\IBM\SQLLIB~1\FUNCTION;C:\PROGRA~1\IBM\SQLLIB~1\SAMPLES\REPL;C:\IBM\ud72\bin;C:\Program Files\Microsoft Visual Studio\Common\Tools\WinNT;C:\Program Files\Microsoft Visual Studio\Common\MSDev98\Bin;C:\Program Files\Microsoft Visual Studio\Common\Tools;C:\Program Files\Microsoft Visual Studio\VC98\bin;C:\Program Files\IBM\Java50\bin;c:\ibm\uv\bin;c:\ant\bin;c:\python25;
11:58:44,078 INFO  [Http11Protocol] Initializing Coyote HTTP/1.1 on http-127.0.0.1-8080
11:58:44,078 INFO  [AjpProtocol] Initializing Coyote AJP/1.3 on ajp-127.0.0.1-8009
11:58:44,078 INFO  [Catalina] Initialization processed in 971 ms
11:58:44,078 INFO  [StandardService] Starting service jboss.web
11:58:44,093 INFO  [StandardEngine] Starting Servlet Engine: JBoss Web/2.1.0.CR12
11:58:44,156 INFO  [Catalina] Server startup in 80 ms
11:58:44,187 INFO  [TomcatDeployment] deploy, ctxPath=/com.ibm.u2.u2jpa.jboss.WAR, vfsUrl=com.ibm.u2.u2jpa.jboss.EAR.ear/com.ibm.u2.u2jpa.jboss.WAR.war
11:58:45,687 INFO  [TomcatDeployment] deploy, ctxPath=/invoker, vfsUrl=http-invoker.sar/invoker.war
11:58:46,296 INFO  [NativeServerConfig] JBoss Web Services - Native
11:58:46,296 INFO  [NativeServerConfig] jbossws-native-2.0.3.GA (build=200801241020)
11:58:47,937 INFO  [TomcatDeployment] deploy, ctxPath=/jbossws, vfsUrl=jbossws.sar/jbossws-context.war
11:58:48,031 INFO  [RARDeployment] Required license terms exist, view vfsfile:/C:/jboss-5.0.0.Beta4/server/default/deploy/jms-ra.rar/META-INF/ra.xml
11:58:48,062 INFO  [TomcatDeployment] deploy, ctxPath=/jmx-console, vfsUrl=jmx-console.war
11:58:49,250 INFO  [JMXConnectorServerService] JMX Connector server: service:jmx:rmi://127.0.0.1/jndi/rmi://127.0.0.1:1090/jmxconnector
11:58:49,281 INFO  [RARDeployment] Required license terms exist, view vfsfile:/C:/jboss-5.0.0.Beta4/server/default/deploy/mail-ra.rar/META-INF/ra.xml
11:58:49,375 INFO  [MailService] Mail Service bound to java:/Mail
11:58:49,609 INFO  [TomcatDeployment] deploy, ctxPath=/web-console, vfsUrl=management/console-mgr.sar/web-console.war
11:58:50,437 WARN  [SecurityMetadataStore] WARNING! POTENTIAL SECURITY RISK. It has been detected that the MessageSucker component which sucks messages from one node to another has not had its password changed from the installation default. Please see the JBoss Messaging user guide for instructions on how to do this.
11:58:50,890 INFO  [ServerPeer] JBoss Messaging 1.4.1.Beta1 server [0] started
11:58:50,953 WARN  [ConnectionFactoryJNDIMapper] supportsFailover attribute is true on connection factory: jboss.messaging.connectionfactory:service=ClusteredConnectionFactory but post office is non clustered. So connection factory will *not* support failover
11:58:50,953 WARN  [ConnectionFactoryJNDIMapper] supportsLoadBalancing attribute is true on connection factory: jboss.messaging.connectionfactory:service=ClusteredConnectionFactory but post office is non clustered. So connection factory will *not* support load balancing
11:58:51,093 INFO  [ConnectionFactory] Connector bisocket://127.0.0.1:4457 has leasing enabled, lease period 10000 milliseconds
11:58:51,093 INFO  [ConnectionFactory] org.jboss.jms.server.connectionfactory.ConnectionFactory@34943494 started
11:58:51,093 INFO  [ConnectionFactory] Connector bisocket://127.0.0.1:4457 has leasing enabled, lease period 10000 milliseconds
11:58:51,093 INFO  [ConnectionFactory] org.jboss.jms.server.connectionfactory.ConnectionFactory@1c901c90 started
11:58:51,093 INFO  [ConnectionFactory] Connector bisocket://127.0.0.1:4457 has leasing enabled, lease period 10000 milliseconds
11:58:51,093 INFO  [ConnectionFactory] org.jboss.jms.server.connectionfactory.ConnectionFactory@4ee04ee0 started
11:58:51,109 INFO  [QueueService] Queue[/queue/ExpiryQueue] started, fullSize=200000, pageSize=2000, downCacheSize=2000
11:58:51,109 INFO  [QueueService] Queue[/queue/DLQ] started, fullSize=200000, pageSize=2000, downCacheSize=2000
11:58:51,109 INFO  [ConnectionFactoryBindingService] Bound ConnectionManager 'jboss.jca:service=ConnectionFactoryBinding,name=JmsXA' to JNDI name 'java:JmsXA'
11:58:51,140 INFO  [RARDeployment] Required license terms exist, view vfsfile:/C:/jboss-5.0.0.Beta4/server/default/deploy/quartz-ra.rar/META-INF/ra.xml
11:58:51,187 INFO  [SimpleThreadPool] Job execution threads will use class loader of thread: main
11:58:51,187 INFO  [QuartzScheduler] Quartz Scheduler v.1.5.2 created.
11:58:51,187 INFO  [RAMJobStore] RAMJobStore initialized.
11:58:51,187 INFO  [StdSchedulerFactory] Quartz scheduler 'DefaultQuartzScheduler' initialized from default resource file in Quartz package: 'quartz.properties'
11:58:51,187 INFO  [StdSchedulerFactory] Quartz scheduler version: 1.5.2
11:58:51,187 INFO  [QuartzScheduler] Scheduler DefaultQuartzScheduler_$_NON_CLUSTERED started.
11:58:51,203 INFO  [TomcatDeployment] deploy, ctxPath=/, vfsUrl=ROOT.war
11:58:51,375 INFO  [TomcatDeployment] deploy, ctxPath=/test, vfsUrl=test.war
11:58:51,515 INFO  [Http11Protocol] Starting Coyote HTTP/1.1 on http-127.0.0.1-8080
11:58:51,578 INFO  [AjpProtocol] Starting Coyote AJP/1.3 on ajp-127.0.0.1-8009
11:58:51,578 INFO  [ServerImpl] JBoss (Microcontainer) [5.0.0.Beta4 (build: SVNTag=JBoss_5_0_0_Beta4 date=200802091115)] Started in 32s:125ms
11:59:37,500 ERROR [[MyServlet]] Servlet.service() for servlet MyServlet threw exception
javax.ejb.EJBException: <openjpa-1.1.0-r422266:657916 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: org.xml.sax.SAXException: file:/C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/nestedjar12377.tmp [Location: Line: 1, C: 1]: org.xml.sax.SAXParseException: Content is not allowed in prolog.
	at org.jboss.ejb3.tx.Ejb3TxPolicy.handleExceptionInOurTx(Ejb3TxPolicy.java:63)
	at org.jboss.aspects.tx.TxPolicy.invokeInOurTx(TxPolicy.java:83)
	at org.jboss.aspects.tx.TxInterceptor$Required.invoke(TxInterceptor.java:193)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:101)
	at org.jboss.aspects.tx.TxPropagationInterceptor.invoke(TxPropagationInterceptor.java:76)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:101)
	at org.jboss.ejb3.stateless.StatelessInstanceInterceptor.invoke(StatelessInstanceInterceptor.java:64)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:101)
	at org.jboss.ejb3.tx.NullInterceptor.invoke(NullInterceptor.java:42)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:101)
	at org.jboss.ejb3.security.Ejb3AuthenticationInterceptorv2.invoke(Ejb3AuthenticationInterceptorv2.java:166)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:101)
	at org.jboss.ejb3.ENCPropagationInterceptor.invoke(ENCPropagationInterceptor.java:46)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:101)
	at org.jboss.ejb3.asynchronous.AsynchronousInterceptor.invoke(AsynchronousInterceptor.java:106)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:101)
	at org.jboss.ejb3.stateless.StatelessContainer.dynamicInvoke(StatelessContainer.java:313)
	at org.jboss.ejb3.remoting.IsLocalInterceptor.invokeLocal(IsLocalInterceptor.java:81)
	at org.jboss.ejb3.remoting.IsLocalInterceptor.invoke(IsLocalInterceptor.java:72)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:101)
	at org.jboss.ejb3.stateless.StatelessRemoteProxy.invoke(StatelessRemoteProxy.java:108)
	at $Proxy80.sayHello(Unknown Source)
	at sampleear.MyServlet.doGet(MyServlet.java:21)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:690)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:803)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.jboss.web.tomcat.filters.ReplyHeaderFilter.doFilter(ReplyHeaderFilter.java:96)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:175)
	at org.jboss.web.tomcat.security.SecurityAssociationValve.invoke(SecurityAssociationValve.java:189)
	at org.jboss.web.tomcat.security.JaccContextValve.invoke(JaccContextValve.java:90)
	at org.jboss.web.tomcat.security.SecurityContextEstablishmentValve.invoke(SecurityContextEstablishmentValve.java:96)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)
	at org.jboss.web.tomcat.service.jca.CachedConnectionValve.invoke(CachedConnectionValve.java:157)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:309)
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:844)
	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:601)
	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:447)
	at java.lang.Thread.run(Thread.java:801)
Caused by: 
<openjpa-1.1.0-r422266:657916 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: org.xml.sax.SAXException: file:/C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/nestedjar12377.tmp [Location: Line: 1, C: 1]: org.xml.sax.SAXParseException: Content is not allowed in prolog.
	at org.apache.openjpa.persistence.PersistenceMetaDataFactory.parseXML(PersistenceMetaDataFactory.java:249)
	at org.apache.openjpa.persistence.PersistenceMetaDataFactory.load(PersistenceMetaDataFactory.java:198)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:474)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:294)
	at org.apache.openjpa.kernel.BrokerImpl.newObjectId(BrokerImpl.java:1114)
	at org.apache.openjpa.kernel.DelegatingBroker.newObjectId(DelegatingBroker.java:268)
	at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:451)
	at org.jboss.ejb3.entity.TransactionScopedEntityManager.find(TransactionScopedEntityManager.java:166)
	at sampleear.MyStatelessSessionBean.sayHello(MyStatelessSessionBean.java:14)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeTarget(MethodInvocation.java:121)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:110)
	at org.jboss.ejb3.interceptor.InvocationContextImpl.proceed(InvocationContextImpl.java:166)
	at org.jboss.ejb3.interceptor.EJB3InterceptorsInterceptor.invoke(EJB3InterceptorsInterceptor.java:63)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:101)
	at org.jboss.ejb3.entity.TransactionScopedEntityManagerInterceptor.invoke(TransactionScopedEntityManagerInterceptor.java:54)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:101)
	at org.jboss.ejb3.AllowedOperationsInterceptor.invoke(AllowedOperationsInterceptor.java:47)
	at org.jboss.aop.joinpoint.MethodInvocation.invokeNext(MethodInvocation.java:101)
	at org.jboss.aspects.tx.TxPolicy.invokeInOurTx(TxPolicy.java:79)
	... 42 more
Caused by: 
java.lang.Exception: java.io.IOException: org.xml.sax.SAXException: file:/C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/nestedjar12377.tmp [Location: Line: 1, C: 1]: org.xml.sax.SAXParseException: Content is not allowed in prolog.
	at org.apache.openjpa.util.Exceptions.replaceNestedThrowables(Exceptions.java:249)
	at org.apache.openjpa.persistence.PersistenceException.writeObject(PersistenceException.java:100)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at org.jboss.serial.persister.RegularObjectPersister.writeSlotWithMethod(RegularObjectPersister.java:120)
	at org.jboss.serial.persister.RegularObjectPersister.defaultWrite(RegularObjectPersister.java:86)
	at org.jboss.serial.persister.RegularObjectPersister.writeData(RegularObjectPersister.java:62)
	at org.jboss.serial.objectmetamodel.ObjectDescriptorFactory.describeObject(ObjectDescriptorFactory.java:276)
	at org.jboss.serial.objectmetamodel.DataContainer$DataContainerOutput.writeObject(DataContainer.java:390)
	at org.jboss.serial.persister.RegularObjectPersister.writeSlotWithFields(RegularObjectPersister.java:182)
	at org.jboss.serial.persister.ObjectOutputStreamProxy.writeFields(ObjectOutputStreamProxy.java:79)
	at org.jboss.serial.persister.ObjectOutputStreamProxy.defaultWriteObject(ObjectOutputStreamProxy.java:68)
	at java.lang.Throwable.writeObject(Throwable.java:320)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at org.jboss.serial.persister.RegularObjectPersister.writeSlotWithMethod(RegularObjectPersister.java:120)
	at org.jboss.serial.persister.RegularObjectPersister.defaultWrite(RegularObjectPersister.java:86)
	at org.jboss.serial.persister.RegularObjectPersister.writeData(RegularObjectPersister.java:62)
	at org.jboss.serial.objectmetamodel.ObjectDescriptorFactory.describeObject(ObjectDescriptorFactory.java:276)
	at org.jboss.serial.objectmetamodel.DataContainer$DataContainerOutput.writeObject(DataContainer.java:390)
	at org.jboss.serial.io.MarshalledObjectForLocalCalls.<init>(MarshalledObjectForLocalCalls.java:38)
	at org.jboss.ejb3.session.SessionContainer.marshallException(SessionContainer.java:319)
	at org.jboss.ejb3.stateless.StatelessContainer.dynamicInvoke(StatelessContainer.java:319)
	... 27 more
","Windows, Eclipse 3.3.2, Jboss 5.0 beta4",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-06-06 21:06:02.173,,,no_permission,,,,,,,,,,,160934,,,Thu Feb 25 20:18:34 UTC 2010,,,,,,,0|i0z9l3:,203855,,,,,,,,06/Jun/08 21:06;mikedd;I've been working with Jianfeng offline on this issue. It looks like a temporary jar file is created by Eclipse when the application is deployed to JBoss. After a bit of experimentation Jianfeng downloaded the JBoss plugins for Eclipse - which resolved the issue. ,"25/Feb/10 20:18;layeeqs@gmail.com;Hi,

I am Facing the same issue. I am getting the following exception when i
first try to create the entity manager in openJPA. This error is occured
only for the first attempt after the first attempt it start working like a
charm.

[Location: Line: 1, C: 1]: org.xml.sax.SAXParseException: Content is not
allowed in prolog.

I am getting this exception in my ejb jar file.

Help is appreciated.

Please let me know if need any more info on the issue.


Regards,
Layeeq Shaik.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Use of hardcoded DB platform strings should be avoided,OPENJPA-617,12397037,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,29/May/08 01:29,09/Mar/10 18:32,14/Mar/19 03:02,29/May/08 04:00,,,,,,,,,,1.2.0,,,,,,,,,,,0,,"This is a bad practice in the code that I recently put in.
Hard-coded ""Oracle"" string should be avoided.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160933,,,Thu May 29 04:00:44 UTC 2008,,,,,,,0|i0z7a7:,203482,,,,,,,,"29/May/08 04:00;fancy;1. The hard coded ""Oracle"" String has been removed.
2. Not all jdbc driver have  the connection  APIs available.
   Tthe trace info for the  initial connection propertities are only available to JDBC 3 drivers.
   For this reaon, this particular message trace is removed from DataSourceFactory,
   but placed in DBDictionary.
   Because of this move, some message text has be relocated into org.apache.openjpa.jdbc.sql package.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SqlServer does not support Timestamp precision in nano second,OPENJPA-614,12396945,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,fancy,fancy,fancy,28/May/08 00:53,09/Mar/10 18:32,14/Mar/19 03:02,28/May/08 00:56,,,,,,,,,,1.2.0,,,,,jdbc,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160930,,,Wed May 28 00:56:10 UTC 2008,,,,,,,0|i1dqy7:,288463,,,,,,,,28/May/08 00:56;fancy;fix checked in under r660767,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Add support for calculating update value in QueryImpl.updateInMemory,OPENJPA-612,12396785,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,faywang,faywang,25/May/08 22:38,09/Mar/10 18:32,14/Mar/19 03:02,28/May/08 22:27,,,,,,,,,,1.2.0,,,,,,,,,,,0,,"Since Informix does not support update with in/exists subquery in the where clause, when doing the bulk update against informix, e.g., 

     ""update DeptBeanAno d set d.budget = (d.budget * ?1 + ?2) where d.reportsTo.no = ?3""
 
we encounter the error of ""only-update-primitives"" during updateInMemory. 

     The attached patch fixes this problem by beefing up the support for arithmetic calcuation of the update value for updateInMemory.

",,,,,,,,,,,,,,,,,,,,,,25/May/08 22:39;faywang;openjpa.patch;https://issues.apache.org/jira/secure/attachment/12382742/openjpa.patch,27/May/08 22:41;faywang;openjpa0526.patch;https://issues.apache.org/jira/secure/attachment/12382880/openjpa0526.patch,28/May/08 18:38;faywang;openjpa0528a.patch;https://issues.apache.org/jira/secure/attachment/12382954/openjpa0528a.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2008-05-27 17:09:31.715,,,no_permission,,,,,,,,,,,160928,,,Wed May 28 22:27:21 UTC 2008,,,,,,,0|i0z793:,203477,,,,,,,,"27/May/08 17:09;allee8285;I am wondering if evaluate() in the abstract base class should throw an exception rather than returning a null?

Index: openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java
===================================================================
--- openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java	(revision 659216)
+    
+    public Object evaluate(Object value, Object ob, Object[] params, 
+        OpenJPAStateManager sm) {
+        return null;
+    }    

Otherwise, val will be null and could it cause undesirable/different behavior for AbstractStoreQuery subclass that has no implementation and/or NPE further on? 

Index: openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java
===================================================================
--- openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java	(revision 659216)
             } else {
-                throw new UserException(_loc.get(""only-update-primitives""));
+                try {
+                    val = evaluate(value, ob, params, sm, q);
+                } catch (UnsupportedException e1) {
+                    throw new UserException(_loc.get(""fail-to-get-update-value""));
+                }
             }

Albert Lee.",27/May/08 22:41;faywang;This patch is per Albert's comments to throw UnsupportedException in AbstractStoreQuery.,"28/May/08 18:38;faywang;I have streamlined the code and added string function supports to the updateInMemory. The following queries have been tested against Informix backend:

query=""update DeptBeanAno d set d.name = CONCAT(d.name, '288') where d.reportsTo.no = ?1""
query=""update DeptBeanAno d set d.name = SUBSTRING(d.name, 1, LENGTH(d.name)) where d.reportsTo.no = ?1""
query=""update DeptBeanAno d set d.name = UPPER(d.name) where d.reportsTo.no = ?1""
query=""update DeptBeanAno d set d.name = LOWER(d.name) where d.reportsTo.no = ?1""
query=""update DeptBeanAno d set d.name = TRIM(LEADING ' ' FROM d.name) where d.reportsTo.no = ?1""
query=""update DeptBeanAno d set d.name = TRIM(TRAILING ' ' FROM d.name) where d.reportsTo.no = ?1""
query=""update DeptBeanAno d set d.name = TRIM(' ' FROM d.name) where d.reportsTo.no = ?1""
query=""update DeptBeanAno d set d.name = SUBSTRING(d.name, 1, LOCATE(d.name, 'e', 1)) where d.reportsTo.no = ?1""
query=""update DeptBeanAno d set d.idx = LOCATE(d.name, 'e', 3) where d.reportsTo.no = ?1""
","28/May/08 22:27;fancy;InMemoryUpdate support for  Math function and String function evaluation are done.
The remaining work for functions returning numeric value such as ABS, SQRT, SIZE  etc. will be done on needed basis.
A subtask will be opened for that.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Extraneous ""( )"" on DISTINCT, ALL, ANY results in  SQL syntax errors on some database systems",OPENJPA-607,12396602,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,22/May/08 07:03,09/Mar/10 18:32,14/Mar/19 03:02,22/May/08 15:58,,,,,,,,,,1.2.0,,,,,,,,,,,0,,"In testing various back-end database systems such as Sybase, Informix. there are cases where the extra pair of () resulted in SQL Syntax error:
For example,
1. in generating ALL, ANY subquery, there is extraneous pair of ""(  )""  that are tolerated by most systems such as DB2, Oracle but not Sybase.
WHERE (t0.DEPT_DEPTNO = ANY ((SELECT t1.deptno FROM DeptBean t1 WHERE (t1.deptno = ? )))

2.In the case of DISTINCT function, Informix reports syntax error when argument/s of the DISTINCT is/are parenthesized:
SELECT COUNT(DISTINCT (t1.name)) FROM EmpBean t1

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-05-22 08:02:15.434,,,no_permission,,,,,,,,,,,160923,,,Fri May 23 16:40:01 UTC 2008,,,,,,,0|i0zbgn:,204159,,,,,,,,"22/May/08 08:02;mikedd;Hi Catalina,

What's the benefit of leaving the parenthesis in? If they're truly extraneous I would think that the default would be to not use them unless they're needed. 

The code changes provided affect ALL, DISTINCT and ANY, but does the same problem occur with other UnaryOps? ",22/May/08 15:58;fancy;This problem is fixed under r659027.,"23/May/08 16:40;fancy;case 1. ALL and ANY :
apply to subquery only.  OpenJPA always pushdown subquery in enclosing parenthesis.
ALL or ANY operator puts additional pair of parenthesis.
The fix is to not putting in unneeded pair, because Sybase reports syntax
error for ANY or ALL subquery having the extra enclosing parenthesis.
case 2. Distinct function
first, do not confuse this DISTINCT function with SELECT DISTINCT.
SELECT DISTINCT will not got through the Distinct.class code.
The Distinct function is only associated with a COUNT function.
It is safe that given the fact  OpenJpa only pushdown  COUNT(DISTINCT one-item),
we can enclose one-item with or without parenthesis.
The fix is not to enclose one-time to get around syntax error reported by Informix.

So far, I have verified the fix against DB2, Oracle, Sybase, SQLServer and Informix.

Help needed to verify other back-end systems.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
InformixDictionary default setting beaks many testcases,OPENJPA-606,12396467,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,fancy,fancy,21/May/08 01:33,09/Mar/10 18:32,14/Mar/19 03:02,04/Jun/08 19:44,1.2.0,,,,,,,,,1.0.4,1.2.0,,,,sql,,,,,,0,,"In testing Informix backend store,  there are many query test string failed:
1. parameter of a boolean value does not work, should use 't for true, 'f' for false
 WHERE (t1.isManager = ?) [params=(boolean) false]
  
   should generate  WHERE (t1.isManager = ?) [params=(String) f]

2. SELECT COUNT(DISTINCT(t1.name)) reported  syntax error  [code=-201, state=42000]

    should generate COUNT(DISTINCT t1.name ) 

3. CROSS JOIN syntax error 
 
    should generate JOIN with ON 1 = 1

   
4. There is no equivalent  function for LOCATE.  Informix users must create INSTR as a user defined function.  


3. CONCAT function in '||' does not take parameter markers
  WHERE ((?||t0.name) LIKE ? ESCAPE '\')

  should generate  CONCAT(?, t0.name)

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-05-21 09:42:39.6,,,no_permission,,,,,,,,,,,160922,,,Wed Jun 04 19:44:06 UTC 2008,,,,,,,0|i0z4y7:,203104,,,,,,,,"21/May/08 09:42;mikedd;It seems that we can move some of the logic in Distinct.java into the DBDictionary. Or at least add a flag in the DBDictionary that indicates whether ( ) are needed. Leaving :
if (sel.getConfiguration().getDBDictionaryInstance().platform.indexOf(""Informix"") > -1) {

in the code is rather ugly.",04/Jun/08 19:44;fancy;resolved in r659731,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Informix will throw an exception when a unique index is explictily created on the primary key columns,OPENJPA-605,12396441,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,faywang,faywang,20/May/08 19:08,09/Mar/10 18:32,14/Mar/19 03:02,21/May/08 07:46,,,,,,,,,,1.0.4,1.2.0,,,,,,,,,,0,,"When an entity is defined as following (unique index annotation on the primary key field. In this situation): 

@Entity
@Table(name=""AddressBean"")   
public class AddressBeanAno implements IAddressBean,  Serializable {
    @EmbeddedId
    @Index(name=""street_index"",unique=true)
    @Column(length=30)
    private AddressPK street;

Informix will issue an error:

Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: Index already exists on column. {stmnt 1440372186 CREATE UNIQUE INDEX street_index ON AddressBean (street)} [code=-350, state=S0011]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:192)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$3(LoggingConnectionDecorator.java:189)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingStatement.executeUpdate(LoggingConnectionDecorator.java:762)
	at org.apache.openjpa.lib.jdbc.DelegatingStatement.executeUpdate(DelegatingStatement.java:114)
	at org.apache.openjpa.jdbc.schema.SchemaTool.executeSQL(SchemaTool.java:1204)
	at org.apache.openjpa.jdbc.schema.SchemaTool.createIndex(SchemaTool.java:1019)
	at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:554)
	at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:344)
	at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:321)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:501)

Per Informaix SQL syntax guide (Create Index section):
You can not add a unique index to a column or column list that a primary -key constraint on it. The reason is  that defining the column or column list as the primary key causes the database server to create a unique internal index on the column or column list. So you cannot create another unique index on this column or column list with CREATE INDEX statement.    


",,,,,,,,,,,,,,,,,,,,,,21/May/08 05:43;faywang;openjpa.patch;https://issues.apache.org/jira/secure/attachment/12382433/openjpa.patch,21/May/08 03:25;faywang;openjpa.patch;https://issues.apache.org/jira/secure/attachment/12382429/openjpa.patch,20/May/08 19:37;faywang;openjpa.patch;https://issues.apache.org/jira/secure/attachment/12382409/openjpa.patch,20/May/08 19:18;faywang;openjpa.patch;https://issues.apache.org/jira/secure/attachment/12382407/openjpa.patch,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2008-05-20 19:46:21.299,,,no_permission,,,,,,,,,,,160921,,,Wed May 21 05:43:07 UTC 2008,,,,,,,0|i0z50f:,203114,,,,,,,,20/May/08 19:18;faywang;The attached patch fixes this problem.,20/May/08 19:37;faywang;The patch fixes the NPE introduced from the earlier one.,"20/May/08 19:46;allee8285;Fay,

    Can the proposed solution encapsulate in the dictionary? I.e.

     public boolean createIndex(Index idx, Table table)
         throws SQLException {
         if ( !_dict.needsToCreateIndex(idx,table)) {
                    return true;
         }
        .......

     public class InformixDictionary .... {
         public boolean needsToCreateIndex(Index idx, Table table) {
            Column[] cols = idx.getColumns();
            Column[] pkCols = table.getPrimaryKey().getColumns();
            if (cols.length == pkCols.length) {
                String[] colNames = new String[cols.length];
                String[] pkColNames = new String[cols.length];
                for (int i = 0; i < cols.length; i++) 
                    colNames[i] = cols[i].getName();
                for (int i = 0; i < pkCols.length; i++) 
                    pkColNames[i] = pkCols[i].getName();
                if (java.util.Arrays.equals(colNames, pkColNames))
                    return false;
             }
             return true;
          }
     }

    public class DBDictionary ....{
        public boolean needsToCreateIndex(Index idx, Table table) {
            return true;
        }
    }

Thanks,
Albert Lee.","20/May/08 20:05;ppoddar@apache.org;Agree with Albert's suggestion.
An extra method may not be required though. 

The method implementation in InformixDBDictionary could be:
   public String[] getCreateIndexSQL(Index index) {
      return (isIndexOnThe PrimaryKey(index)) ? new String[0] ? super.getCreateIndexSQL(index);
   } 

where isIndexOnThePrimaryKey(index) can encapsulate the logic presented in the patch. ","20/May/08 21:15;ppoddar@apache.org;The method
     public boolean columnsMatch(Column[] ocols)

in LocalConstraint.java may be useful for the logic expressed in the patch.",21/May/08 03:25;faywang;This patch is per Pinaki's comments.,"21/May/08 05:43;faywang;Sorry, I did not notice Albert's comments. This patch is based on his comments.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException at org.apache.openjpa.jdbc.meta.strats.RelationToManyInverseKeyFieldStrategy.map,OPENJPA-602,12396006,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,vorburger,vorburger,14/May/08 09:51,09/Mar/10 18:32,14/Mar/19 03:02,19/Jun/08 16:26,1.1.0,,,,,,,,,1.2.0,,,,,jdbc,,,,,,0,,"The example I'll attach crashes with an NPE when running the mappingtool.

Caused by: java.lang.NullPointerException
	at org.apache.openjpa.jdbc.meta.strats.RelationToManyInverseKeyFieldStrategy.map(RelationToManyInverseKeyFieldStrategy.java:136)
	at org.apache.openjpa.jdbc.meta.strats.RelationCollectionInverseKeyFieldStrategy.map(RelationCollectionInverseKeyFieldStrategy.java:95)
	at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:120)
	at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:80)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:438)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:403)
	at org.apache.openjpa.jdbc.meta.ClassMapping.resolveMapping(ClassMapping.java:812)

The goal of this JIRA is not (neccessarily) to support the kind of mapping that would be required for this (which may be hard), but to at least print a clear error and not an NPE...
",,,,,,,,,,,,,,,,,,,,,,14/May/08 09:53;vorburger;FullStackTrace-OPENJPA-602.txt;https://issues.apache.org/jira/secure/attachment/12382033/FullStackTrace-OPENJPA-602.txt,14/May/08 09:52;vorburger;OneToMany-test.zip;https://issues.apache.org/jira/secure/attachment/12382032/OneToMany-test.zip,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-06-04 12:43:50.189,,,no_permission,,,,,,,,,,,160918,,,Thu Jun 19 16:26:32 UTC 2008,,,,,,,0|i1dqfz:,288381,,,,,,,,"14/May/08 09:54;vorburger;-----Original Message-----
From: Michael Vorburger [mailto:mvorburger@odyssey-group.com] 
Sent: mercredi, 30. avril 2008 17:07
To: users@openjpa.apache.org; dev@openjpa.apache.org
Subject: NPE at RelationToManyInverseKeyFieldStrategy when using mappedBy inverse

Hello,
 
I'm running into an NPE in RelationToManyInverseKeyFieldStrategy
(copy/pasted below) when using an OneToMany inverse relation with mappedBy and InheritanceType.TABLE_PER_CLASS in 1.1.0-SNAPSHOT...

Test summary: A common abstract superclass Translatable which has a @OneToManySet<Translation>, and many subclasses of that like e.g. a SomethingTranslatable, and many more.  The idea is that mapping should lead to a Translation table holding the items for SomethingTranslatable and all other superclasses.  Then SomethingTranslatable and many other tables (no physical Translatable table).  There shouldn't be a join table for each SomethingTranslatable, as it's a OneToManySet, it doesn't make sense, so the owning side is a @ManyToOne in Translation back to Translatable.  Granted a physical FK will not be possible in such a schema - accepted, but it should still be possible to map this?  It works until I use @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) on Translatable, with it - boum, NPE.","16/May/08 09:57;vorburger;-----Original Message-----
From: Fay Wang [mailto:fyw300@yahoo.com] 
Sent: jeudi, 15. mai 2008 00:52
To: users@openjpa.apache.org; dev@openjpa.apache.org
Subject: RE: NPE at RelationToManyInverseKeyFieldStrategy when using mappedBy inverse

Here is my finding: The NPE problem is the combination of (1) abstract class, (2) inheritance strategy of TABLE_PER_CLASS, and (3) toMany relationship. When you have (1) and (2), or (1) and (3), or (2) and (3), you will be fine.  However, when the three things are put together, the class strategy of this entity class becomes NoneClassStrategy (since abstract class with inheritance strategy of TABLE_PER_CLASS will not have a corresponding database table). With NoneClassStrategy, the foreign key required for the toMany relationship will not be constructed, resulting in NPE. I am not clear whether JPA spec ever mentioned that no relation fields in the abstract class when inheritance strategy is table per concrete class. If not, this seems to be a bug in OpenJPA.

@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) public abstract class EntityA { 

    @Id
    @GeneratedValue
    private Long id;
    
    @Version
    private Long version;

    @OneToMany(cascade=CascadeType.PERSIST,
          mappedBy=""entityA"")
    private java.util.Set<EntityB> entityBs;

    public java.util.Set<EntiytB> getEntityBs() {
          return entityBs;
    }

    public void setEntityBs(java.util.Set<EntityB> entityBs) {
	  this.entityBs = entityBs;
    }  
  }
}

If you only have (1) and (2), you will be fine because 


-----Original Message-----
From: Fay Wang [mailto:fyw300@yahoo.com] 
Sent: mercredi, 14. mai 2008 18:45
To: users@openjpa.apache.org; dev@openjpa.apache.org
Subject: RE: NPE at RelationToManyInverseKeyFieldStrategy when using mappedBy inverse

I take it back. I found that when I put the fields and methods in EntityBase class directly in the Translatable class instead of having Translatable inherit from EntityBase class, I still get NPE. This problem seems having nothing to do with MappedSuperclass annotation.

-Fay

-----Original Message-----
From: Fay Wang [mailto:fyw300@yahoo.com] 
Sent: mercredi, 14. mai 2008 18:23
To: users@openjpa.apache.org; dev@openjpa.apache.org
Subject: RE: NPE at RelationToManyInverseKeyFieldStrategy when using mappedBy inverse

Hi Mike,
    Your super class EntityBase is annotated as @MappedSuperclass. Your Translatable class which inherits from EntityBase has inheritance strategy of TABLE_PER_CLASS. Since MappedSuperclass itself is not a persistence class and can not act in the capacity of an entity, it does not have a corresponding table in the database. I think this is why openjpa got confused and could not find foreign key between the parent class and the child class. When I removed Inheritance strategy annotation from Translatable class, your test case went through. Having said that, I think the NPE should be fixed and proper error message should be thrown.

-Fay","04/Jun/08 12:43;timkaltenbrunner;Hi,

I have the same problem at my current project. I have an existing database structure created with Kodo JDO. Now I want to use OpenJPA but keep the old database structure. Will someone fix this problem or will you only throw an exception. I am also not sure if the specification specifies that this case should be possible but JDO implementation do support it and therefore it would be nice to have it in OpenJPA . 

Cheers Tim
","10/Jun/08 20:46;ppoddar@apache.org;SVN Revision 666314 [1]  addresses this issue. Used a modified version the attached patch as the domain model in a test case. 
It will be helpful if the reporter can verify 
        a) whether the newly added test case reflects the intended domain model 
and b) whether the change resolves the original issue.

Known limitation:
  As the root of persistent hierarchy is abstract and table-per-class strategy is being used, 
 aggregate JPQL query e.g. ""SELECT COUNT(p) FROM Translatable p"" will not be possible 
 because the concrete subclasses such as SomethingTranslatable or SomeOtherTranslatable are unjoined.


[1] http://svn.apache.org/viewvc?view=rev&revision=666314","19/Jun/08 16:26;ppoddar@apache.org;SVN revision 666314.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JPQL delete query with an alias for tablename and without any further clauses gives an error on MySQL,OPENJPA-597,12395679,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,sandeeps@bea.com,sandeeps@bea.com,09/May/08 03:03,09/Mar/10 18:32,14/Mar/19 03:02,16/May/08 20:55,1.1.0,,,,,,,,,1.1.0,,,,,jdbc,,,,,,0,,"If we have a JPQL query like this:
int countDeleted = em.createQuery('Delete from Person o').executeUpdate();

We get an exception on MySQL because the converted SQL with an alias gives a syntax error :

[testlogic] java.lang.Exception: org.apache.openjpa.lib.jdbc.ReportingSQLException: 
You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version 
for the right syntax to use near '' at line 1 {prepstmnt 2137108 DELETE FROM DYN_DESC_PERSON t0 [reused=0]} [code=1064, state=42000]
[testlogic] 	at org.apache.openjpa.util.Exceptions.replaceNestedThrowables(Exceptions.java:242)
[testlogic] 	at org.apache.openjpa.persistence.PersistenceException.writeObject(PersistenceException.java:100)

For mySQL version 5.0 the MySQLDBDictionary defaults for supportsSubselect and allowsAliasInBulkClause are both true. For these params the DBDictionary.toBulkOperation() generates a sql like DELETE FROM DYN_DESC_PERSON t0 which does not work in mySQL. 

The syntax for DELETE statements that use table aliases changed between MySQL 4.0 and 4.1. In MySQL 4.0, you should use the true table name to refer to any table from which rows should be deleted: 

DELETE test FROM test AS t1, test2 WHERE ...
In MySQL 4.1, if you declare an alias for a table, you must use the alias when referring to the table: 

DELETE t1 FROM test AS t1, test2 WHERE ...","OpenJPA 1.1.0-SNAPSHOT
version id: openjpa-1.1.0-SNAPSHOT-r422266:653008
Apache svn revision: 422266:653008

os.name: Windows XP
os.version: 5.1
os.arch: x86

java.version: 1.6.0_05
java.vendor: BEA Systems, Inc.",86400,86400,,0%,86400,86400,,,,,,,,,,,,,,,09/May/08 03:09;sandeeps@bea.com;OPENJPA-597.patch;https://issues.apache.org/jira/secure/attachment/12381732/OPENJPA-597.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-05-09 14:57:28.905,,,no_permission,,,,,,,,,,,160913,,,Mon May 12 17:11:39 UTC 2008,,,,,,,0|i0z29b:,202668,,,,,,,,09/May/08 03:09;sandeeps@bea.com;Patch to optionally include either the table names or the aliass as the delete targets in the DELETE sql that is generated based on the requiresTargetForDelete that defaults to false and set to true in the mysql dictionary.,"09/May/08 14:57;mikedd;Will the resulting SQL work for all versions of MySQL (3.0, 4.0, 4.1 and 5.0)?  From the description it looks like we should generate different SQL for 4.0 and 4.1, but I don't see any code to do that in the patch. 

If the resulting SQL will work with all supported versions of MySQL then I'm fine with that - if it will only work with 5.0 and 4.1 (for example) then I think we should be smart enough to detect which version we're dealing with and initialize MySQLDictionary appropriately. ","12/May/08 17:11;sandeeps@bea.com;Yes it will work with all versions of mySQL.  The following snippet in the getDeleteTargets() method generates:

For 4.1 and higher: DELETE t0 FROM DYN_DESC_PERSON t0 
For earlier versions:  DELETE DYN_DESC_PERSON FROM DYN_DESC_PERSON

if (allowsAliasInBulkClause) {
+            deleteTargets.append(tableAlias.substring(spaceIndex + 1));
+          } else {
+            deleteTargets.append(tableAlias.substring(0, spaceIndex));
+          }

The MySQLDictionary sets the allowsAliasInBulkClause propety to false for in the connectedConfiguration method for mysql version earlier than 4.1, the default value for this property is true which is valid for version 4.1 and higher.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException during in-memory update with Informix IDS 10.0 ,OPENJPA-596,12395662,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,dinkar,dinkar,08/May/08 21:21,09/Mar/10 18:32,14/Mar/19 03:02,22/May/08 16:02,,,,,,,,,,1.2.0,,,,,query,,,,,,0,,"With Informix IDS 10.0, running this update statement:

update Customer as c set c.creditRating=:newRating  where c.creditRating=:oldRating

gives the CCE pasted below, when records matching the predicate are found. 

Exception: <openjpa-0.0.0-rnull nonfatal user error> org.apache.openjpa.persistence.ArgumentException: org.apache.openjpa.jdbc.kernel.exps.PCPath
<openjpa-0.0.0-rnull nonfatal user error> org.apache.openjpa.persistence.ArgumentException: org.apache.openjpa.jdbc.kernel.exps.PCPath
	at org.apache.openjpa.kernel.QueryImpl.updateInMemory(QueryImpl.java:1055)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeUpdate(ExpressionStoreQuery.java:697)
	at org.apache.openjpa.kernel.QueryImpl.update(QueryImpl.java:1038)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:851)
	at org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:887)
	at org.apache.openjpa.kernel.DelegatingQuery.updateAll(DelegatingQuery.java:581)
	at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:336)
	at demo.TestPDQSample.findGetSetCustomer(TestPDQSample.java:303)
	at demo.TestPDQSample.findGetSetObjects(TestPDQSample.java:206)
	at demo.TestPDQSample.testPersistenceUnit(TestPDQSample.java:65)
	at demo.TestPDQSample.main(TestPDQSample.java:41)
Caused by: java.lang.ClassCastException: org.apache.openjpa.jdbc.kernel.exps.PCPath
	at org.apache.openjpa.kernel.QueryImpl.updateInMemory(QueryImpl.java:1069)
	at org.apache.openjpa.kernel.QueryImpl.updateInMemory(QueryImpl.java:1050)",,,,,,,,,,,,,,,,,,,,,,08/May/08 22:07;dinkar;patch-596.txt;https://issues.apache.org/jira/secure/attachment/12381724/patch-596.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-05-12 18:50:40.432,,,no_permission,,,,,,,,,,,160912,,,Thu May 22 16:02:42 UTC 2008,,,,,,,0|i0z7hb:,203514,,,,,,,,"08/May/08 22:07;dinkar;Patch gets the correct reference to FieldMetadata from the key, which is always of type PCPath.","12/May/08 18:50;pcl;The attached patch adds a dependency from openjpa-kernel to openjpa-jdbc, which is not allowed.",22/May/08 16:02;fancy;fixed under svn r658541.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"An error occurred while parsing the query filter ""SELECT t FROM PessimisticA t WHERE t.id = ?1"". Error message: No field named ""id"" in class ""t""",OPENJPA-595,12395647,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,08/May/08 19:05,09/Mar/10 18:32,14/Mar/19 03:02,08/May/08 21:36,1.2.0,,,,,,,,,1.1.0,1.2.0,,,,query,,,,,,0,,"A common path() action in JPQL.jjt being used for Enum literal causes a simple aliase resolution to fail in
org.apache.openjpa.persistence.ArgumentException: An error occurred while parsing the query filter ""SELECT t FROM PessimisticA t WHERE t.id = ?1"". Error message: No field named ""id"" in class ""t"".

This could happen in an environment where there is a ""t"" class visible in the classpath.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160911,,,Thu May 08 21:36:17 UTC 2008,,,,,,,0|i0z7gn:,203511,,,,,,,,08/May/08 21:36;fancy;fixed under r654626,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect schema separator used for Informix tables,OPENJPA-594,12395643,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,dinkar,dinkar,08/May/08 17:38,09/Mar/10 18:32,14/Mar/19 03:02,08/May/08 23:39,1.0.1,1.0.2,,,,,,,,1.0.4,1.1.0,1.2.0,,,jdbc,,,,,,0,,"With Informix IDS 9.4 (or 10.0), when a schema  is specified in the table annotation or in the openjpa.jdbc.schema property, a SQL for CREATE TABLE with invalid syntax is generated:

CREATE TABLE MYSCHEMA:MYTABLE (...);

The correct separator between the schema and the table is ""dot"".",,0,0,,0%,0,0,,,,,,,,,,,,,,,27/Jul/09 20:47;fyrewyld;OpenJPA_1.0.x_OPENJPA-594.patch;https://issues.apache.org/jira/secure/attachment/12414661/OpenJPA_1.0.x_OPENJPA-594.patch,08/May/08 20:05;dinkar;patch-594.txt;https://issues.apache.org/jira/secure/attachment/12381712/patch-594.txt,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-05-08 18:55:39.675,,,no_permission,,,,,,,,,,,160910,,,Mon Jul 27 20:47:50 UTC 2009,,,,,,,0|i0z7hr:,203516,,,,,,,,"08/May/08 18:55;mikedd;Looks like this is true for Informix 9.3 as well (which is the oldest version supported by OpenJPA). From the SQL guide (page 4-46) the syntax looks something like this : 

CREATE TABLE [database@[dbservername]]:[schemaname].tablename . . .
                                            ","08/May/08 20:05;dinkar;In this patch, I took out the override for catalogSeparator, so it will default to ""dot"".","08/May/08 21:26;ppoddar@apache.org;The properties of a database dictionary are highly configurable and hence the following persistence.xml configuration may attain the the same effect without any code change
 
      <property name=""openjpa.jdbc.DBDictionary"" value=""informix(CatalogSeparator='.'"")/>
",12/May/08 18:05;pcl;Applied to 1.1.x branch.,27/Jul/09 20:47;fyrewyld;Built a version of the patch for OPENJPA-594 for 1.0.x,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The push-down sql for JPQL has unpredictable ordering in the set clause for update statement,OPENJPA-590,12395270,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,faywang,faywang,04/May/08 06:37,09/Mar/10 18:32,14/Mar/19 03:02,05/May/08 20:52,,,,,,,,,,1.2.0,,,,,,,,,,,0,,"      Our application requires the push-down sql from named/dynamic query be the same each time a same JPQL is executed. 
In the following JPQL example, however, 
	
      query=""UPDATE BasicA t set t.name= ?1, t.age = ?2 WHERE t.id = ?3""

      we observe that two different push-down sql could be generated:
      
      UPDATE PDQBasicA t0 SET name = ?, age = ? WHERE (t0.id = ?)

      UPDATE PDQBasicA t0 SET age = ?, name = ? WHERE (t0.id = ?)

      This unpredictable behavior breaks our application. The indeterministic ordering of the update list is due to the indeterministic ordering provided by HashMap and HashSet in QueryExpressions and JPQLExpressionBuilder, respectively.

      When the HashMap is changed to LinkedHashMap and HashSet to LinkedHashSet, the access order based on insertion will be preserved and the generated push-down sql will have predictable ordering of update list. The attached patch fixes this problem.",,,,,,,,,,,,,,,,,,,,,,04/May/08 06:37;faywang;openjpa.patch;https://issues.apache.org/jira/secure/attachment/12381385/openjpa.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160906,,,2008-05-04 06:37:00.0,,,,,,,0|i0z7fr:,203507,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Can not retrieve M-to-M data when DataCache is on,OPENJPA-589,12395269,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,faywang,faywang,04/May/08 06:10,11/May/10 22:09,14/Mar/19 03:02,12/May/08 22:51,,,,,,,,,,1.1.0,1.2.0,,,,datacache,,,,,,0,,"When DataCahe is on, the retrieval of M-to-M data will fail with the following exception:

<openjpa-1.0.1-r420667:592145 fatal user error> org.apache.openjpa.persistence.ArgumentException: Could not locate metadata for the class using oid ""10=10"" of type ""class java.util.HashMap$Entry"".  Registered oid type mappings: ""{class org.apache.openjpa.util.IntId=class dw.EntityB, class java.util.HashMap$Entry=null}""
FailedObject: 10=10 [java.util.HashMap$Entry]
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:986)
	at org.apache.openjpa.kernel.BrokerImpl.newStateManagerImpl(BrokerImpl.java:1121)
	at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:913)
	at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:862)
	at org.apache.openjpa.kernel.AbstractPCData.toRelationFields(AbstractPCData.java:214)
	at org.apache.openjpa.kernel.AbstractPCData.toNestedFields(AbstractPCData.java:181)
	at org.apache.openjpa.kernel.AbstractPCData.toField(AbstractPCData.java:95)
	at org.apache.openjpa.kernel.PCDataImpl.loadField(PCDataImpl.java:197)
	at org.apache.openjpa.kernel.PCDataImpl.load(PCDataImpl.java:167)
	at org.apache.openjpa.datacache.DataCacheStoreManager.load(DataCacheStoreManager.java:373)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:2867)
	at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:2945)
	at org.apache.openjpa.kernel.StateManagerImpl.beforeAccessField(StateManagerImpl.java:1449)
	at org.apache.openjpa.kernel.StateManagerImpl.accessingField(StateManagerImpl.java:1434)
	at dw.EntityE.pcGetentityf(EntityE.java)
	at dw.EntityE.print(EntityE.java:32)
	at dw.Test3.main(Test3.java:49)

The test case to reproduce this error is:

			EntityManagerFactory emf = Persistence
					.createEntityManagerFactory(""Test1"");
			
			EntityManager em = emf.createEntityManager();
			em.getTransaction().begin();

			EntityE e1 = new EntityE();
			e1.setId(1);
			e1.setName(""ABC"");
			em.persist(e1);
			EntityE e2 = new EntityE();
			e2.setId(2);
			e2.setName(""DEF"");
			em.persist(e2);
			
			EntityF f1 = new EntityF();
			f1.setId(10);
			em.persist(f1);
			EntityF f2 = new EntityF();
			f2.setId(20);
			em.persist(f2);
			
			e1.getEntityF().put(f1.getId(), f1);
			e1.getEntityF().put(f2.getId(), f2);
			e2.getEntityF().put(f1.getId(), f1);
			e2.getEntityF().put(f2.getId(), f2);
			
			f1.getEntityE().put(e1.getName(), e1);
			f1.getEntityE().put(e2.getName(), e2);
			f2.getEntityE().put(e1.getName(), e1);
			f2.getEntityE().put(e2.getName(), e2);
			e1.print();
			e2.print();
			f1.print();
			f2.print();
			em.getTransaction().commit();
			em.close();

			em = emf.createEntityManager();
			EntityE e1a = em.find(EntityE.class, 1);
			e1a.getEntityf();                         <========= exception is thrown here
			EntityE e2a = em.find(EntityE.class, 2);
			e2a.getEntityf();
			EntityF f1a = em.find(EntityF.class, 10);
			f1a.getEntitye();
			EntityF f2a = em.find(EntityF.class, 20);
			f2a.getEntitye();

Note that this test case created 4 entities:
EnityE: e1 (id = 1), e2 (id = 2), 
EntityF: f1 (id = 10), f2 (id = 20)

EntityE has a field entityf, which is a Map<Integer, EntityF>
EntityF has a field entitye, which is a Map<String, EntityE>

In this test case, entityf of e1 contains <10, f1>, and <20, f2>. The same for entityf of e2. On the other hand, 
entitye of f1 contains<""ABC"", e1>, and <""DEF"", e2>. The same for entitye of f2.

When DataCache is on, e1, e2, f1, and f2 are all stored in the data cache. Note that for the field of entityf in e1 and e2,
the value of Map (<10, object id of f1>, <20, object id of f2> is store in the datacache. For the field of entitye in f1 and f2,
the value of Map(<""ABC"", object id of e1>, <""DEF"", object id of e2> is stored in the data cache. 

The cause of the exception shown above occurs when the value of the Map is to be retrieved from the data cache.
Specifically, it happens in AbstractPCData.toField. The keys of the Map are correctly retrieved while the values of the 
Map are handled incorrectly. The attached patch fixes this problem.",,,,,,,,,,,,,,,,OPENJPA-1205,,,,,,11/May/10 22:09;jpaheath;OPENJPA-589-1.0.x.patch.txt;https://issues.apache.org/jira/secure/attachment/12444249/OPENJPA-589-1.0.x.patch.txt,01/Oct/09 15:53;fyrewyld;OpenJPA_1.0.x_OJ589.patch;https://issues.apache.org/jira/secure/attachment/12421029/OpenJPA_1.0.x_OJ589.patch,13/May/08 03:42;faywang;openjpa.patch;https://issues.apache.org/jira/secure/attachment/12381920/openjpa.patch,10/May/08 19:20;faywang;openjpa.patch;https://issues.apache.org/jira/secure/attachment/12381825/openjpa.patch,04/May/08 06:12;faywang;openjpa.patch;https://issues.apache.org/jira/secure/attachment/12381384/openjpa.patch,,,,,,,,,,5.0,,,,,,,,,,,,,,,,,,,2008-05-09 00:35:03.789,,,no_permission,,,,,,,,,,,160905,,,Thu Oct 01 15:53:33 UTC 2009,,,,,,,0|i0z4xb:,203100,,,,,,,,04/May/08 06:12;faywang;The attached patch fixes this problem.,09/May/08 00:35;fancy;patch committed  under r654658,09/May/08 14:29;mikedd;Reopening so that a testcase can be added . It looks like Fay has included most of the code needed in the JIRA issue so adding one shouldn't be too much trouble. ,10/May/08 19:20;faywang;This patch contains the test case for this JIRA.,12/May/08 22:51;pcl;Closing after committing the test cases to trunk.,13/May/08 03:42;faywang;This patch fixes test case problem.,01/Oct/09 15:53;fyrewyld;OpenJPA 1.0.x version patch for this JIRA issue,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Test for checking the absolute index of field metadata fails,OPENJPA-588,12395219,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,sandeeps@bea.com,sandeeps@bea.com,02/May/08 19:52,09/Mar/10 18:32,14/Mar/19 03:02,03/May/08 03:17,,,,,,,,,,1.1.0,,,,,,,,,,,0,,"We have a JDO metadata test which checks for the absolute index positions for the entity fields that are returned by the getIndex method of the FieldMetaData.

In this test ,we have an entity class MetaTest1
public class MetaTest1 {

    // these should not be persistent
    private static int staticField;
    private final String finalField = null;
    private transient char transientField;
    private MetaTest4 metaTest4Field;
    private MetaTest4[] metaTest4ArrayField;
    private Object objectField;
    private Long longWrapperField;
    private double doubleField;

    // persistent fields -- see metadata
    private String stringField;
    private Integer intWrapperField;
    private int intField;
    private MetaTest2 metaTest2Field;
    private MetaTest2[] metaTest2ArrayField;
    private int[] intArrayField;

    public static class Inner {

        private long longField;
    }
}

In the test, we get the MetaDataRepository and from it the ClassMetaData, 
then the FieldMetaData and so on.

The test fails at the line:

        assertEquals(6, _metaTest1.getField('stringField').getIndex());

Failure is :
[testlogic] junit.framework.AssertionFailedError: expected:<6> but was:<8>
[testlogic] 	at kodo.meta.TestClassMetaData.testAbsoluteFieldNumbering(TestClassMetaData.java:217)
[testlogic] 	at com.solarmetric.test.AbstractTestCase.run(AbstractTestCase.java:132)

The persistence mapping is defined in the JDO file

<jdo>
    <package name=""kodo.meta"">
        <!-- class MetaTest1 -->
        <class name=""MetaTest1"">
            <!-- field longWrapperField -->
            <field name=""longWrapperField"" persistence-modifier=""none"">
                <!-- comment1 on comment-test extension -->
                <!-- comment2 on comment-test extension -->
                <extension vendor-name=""test"" key=""comment-test"" value=""test""/>
            </field>
            <field name=""objectField"" persistence-modifier=""none""/>
            <field name=""transientField"" persistence-modifier=""none""/>
            <field name=""doubleField"" persistence-modifier=""transactional""/>
            <field name=""intField"" embedded=""false"" default-fetch-group=""false"" null-value=""exception""/>
            <field name=""intWrapperField"" null-value=""default""/>
        </class>
    </package>
</jdo>

There is no metadata mapping available for the MetaTest2 class. Initially the metadata is populated using reflection and assigns index positions to metaTest2Field and metaTest4ArrayField fields. During resolution the FieldMetaData[] _fields is reset and when ClassMetadata.getDeclaredIndex() is called later it is reinitialized but we dont set the index value on the FieldMetadata once assigned and this fails the test as it does not get the expected value for the index for the stringField.",,86400,86400,,0%,86400,86400,,,,,,,,,,,,,,,02/May/08 19:53;sandeeps@bea.com;openjpa-1.1.0-SNAPSHOT-r422266-650703.patch;https://issues.apache.org/jira/secure/attachment/12381340/openjpa-1.1.0-SNAPSHOT-r422266-650703.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160904,,,Fri May 02 19:53:57 UTC 2008,,,,,,,0|i0z4zr:,203111,,,,,,,,02/May/08 19:53;sandeeps@bea.com;Patch to set the index value on the FieldMetadata when reinitializing the fields array in the ClassMetaData class.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sybase queries that select columns from derived tables fail OOTB,OPENJPA-587,12395211,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,sandeeps@bea.com,sandeeps@bea.com,02/May/08 17:19,09/Mar/10 18:32,14/Mar/19 03:02,03/May/08 03:17,1.1.0,,,,,,,,,1.1.0,,,,,jdbc,,,,,,0,,"Sybase SQL syntax requires that all derived tables have a correlation name. The DBDictionary default for requiresAliasForSubselect is false. Overriding it to true in the Sybase dictionary class fixes the problem OOTB else users have to override it in the configuration by default with Sybase.

This test simply persists a JDO entity (having embedded entities) and then 
tries to execute a query as follows:
    public void testQuery() {
        PersistenceManager pm = getPM();
        Query q = pm.newQuery(EmbeddedOwnerPC.class,
            'stringField == \'string1\' && embedded.intField == 1 '
                + '&& complexEmbedded.stringField == \'recurseEmbedString\' '
                + '&& complexEmbedded.ownerField.id1 == 3 '
                + '&& complexEmbedded.stringSet.contains (\'foo\') '
                + '&& complexEmbedded.embedded != null '
                // just to test not null
                +
                '&& complexEmbedded.embedded.stringField == 
\'embedString2\'');

        Collection results = (Collection) q.execute();


Exception is : 
[testlogic] [2008-03-28 12:15:57,426] BEGIN 
org.apache.cactus.ServletTestCase.testQuery
[testlogic] 
file:/D:/weblogic/dev/src/wls/qa/tests/functional/jdo/kodo/datacache/datacacheR1.test.xml#testdatacache
[testlogic] <openjpa-1.1.0-SNAPSHOT-r420667:634150 nonfatal store error> 
kodo.jdo.DataStoreException: The derived table expression is missing a 
correlation name. Check derived table syntax in the Reference Manual.
 
  
org.apache.cactus.ServletTestCase.testQuery
[testlogic] file:/D:/weblogic/dev/src/wls/qa/tests/functional/jdo/kodo/datacache/datacacheR1.test.xml#testdatacache
[testlogic] <openjpa-1.1.0-SNAPSHOT-r420667:634150 nonfatal store error> 
kodo.jdo.DataStoreException: The derived table expression is missing a correlation name. Check derived table syntax in the Reference Manual.

[testlogic] 	at org.apache.openjpa.jdbc.sql.SQLExceptions.narrow(SQLExceptions.java:146)
[testlogic] 	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4081)
[testlogic] 	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
[testlogic] 	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:88)
[testlogic] 	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:64)
[testlogic] 	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.handleCheckedException(SelectResultObjectProvider.java:155)
[testlogic] 	at org.apache.openjpa.datacache.QueryCacheStoreQuery$CachingResultObjectProvider.handleCheckedException(QueryCacheStoreQuery.java:639)
[testlogic] 	at org.apache.openjpa.lib.rop.WindowResultList.size(WindowResultList.java:95)
[testlogic] 	at org.apache.openjpa.kernel.DelegatingResultList.size(DelegatingResultList.java:136)
[testlogic] 	at kodo.kernel.TestEmbedded.testQuery(TestEmbedded.java:296)
[testlogic] 	at org.apache.cactus.internal.AbstractCactusTestCase.runBareServer(AbstractCactusTestCase.java:149)
[testlogic] 	at org.apache.cactus.internal.server.AbstractWebTestCaller.doTest(AbstractWebTestCaller.java:119)
[testlogic] 	at org.apache.cactus.internal.server.AbstractWebTestController.handleRequest_aroundBody0(AbstractWebTestController.java:93)
[testlogic] 	at org.apache.cactus.internal.server.AbstractWebTestController.handleRequest_aroundBody1$advice(AbstractWebTestController.java:224)
[testlogic] 	at org.apache.cactus.internal.server.AbstractWebTestController.handleRequest(AbstractWebTestController.java:1)
[testlogic] 	at org.apache.cactus.server.ServletTestRedirector.doPost_aroundBody2(ServletTestRedirector.java:101)
[testlogic] 	at org.apache.cactus.server.ServletTestRedirector.doPost_aroundBody3$advice(ServletTestRedirector.java:224)
[testlogic] 	at org.apache.cactus.server.ServletTestRedirector.doPost(ServletTestRedirector.java:1)
[testlogic] 	at org.apache.cactus.server.ServletTestRedirector.doGet_aroundBody0(ServletTestRedirector.java:72)
[testlogic] 	at org.apache.cactus.server.ServletTestRedirector.doGet_aroundBody1$advice(ServletTestRedirector.java:224)
[testlogic] 	at org.apache.cactus.server.ServletTestRedirector.doGet(ServletTestRedirector.java:1)
[testlogic] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:707)
[testlogic] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)","OpenJPA 1.1.0-SNAPSHOT
version id: openjpa-1.1.0-SNAPSHOT-r422266:650703
Apache svn revision: 422266:650703",86400,86400,,0%,86400,86400,,,,,,,,,,,,,,,02/May/08 17:22;sandeeps@bea.com;openjpa-1.1.0-SNAPSHOT-r422266-650703.patch;https://issues.apache.org/jira/secure/attachment/12381322/openjpa-1.1.0-SNAPSHOT-r422266-650703.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160903,,,Fri May 02 17:22:27 UTC 2008,,,,,,,0|i0z7en:,203502,,,,,,,,02/May/08 17:22;sandeeps@bea.com;The patch to the Sybase dictionary class to override the requiresAliasForSubselect value to true which is the default for Sybase.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Binding Query parameter fails validation for Externalized field,OPENJPA-586,12395166,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,01/May/08 21:58,09/Mar/10 18:32,14/Mar/19 03:02,09/Jun/08 21:49,,,,,,,,,,1.2.0,,,,,,,,,,,0,,"OpenJPA supports a field f of declared type <T> be persisted in database corresponding to a different type <S> when  f specifies a two-way transformation between <S> and <T>. For example, a field f can be declared as java.net.URL but stored in database as String (i.e. VARCHAR). 

Now the question is:
    When an 'externalized' field f occurs in query predicate and is bound by a parameter p what should be the runtime type of p? 

   The documentation [1] says p can be of either <T> or <S>.

But the code breaks during parameter validation if Class(p) = <T> and with data conversion error if Class(p) = <S>

Example:
1.   Declare a persistent field f of type java.util.UUID externalized to java.lang.String with a pair of transformer functions

    @Persistent
    @Externalizer(""toString"")        
    @Factory(""UUID.fromString"")
    private UUID    uuid;

2. Use the field f in a Query with a binding parameter:
        String jpql = ""SELECT p FROM ExternalValues p WHERE p.uuid=:uuid"";
        Query query = em.createQuery(jpql);

3. Try to set parameter on the query:
         a) query.setParameter(""uuid"", new UUID(1,2));  // parameter type equals declared type of f
or
         b) query.setParameter(1, new UUID(1,2).toString()); // parameter type equals externalized type of f

4. Either of step 3a or 3b will result in runtime exception

[1] http://openjpa.apache.org/docs/latest/manual/manual.html#ref_guide_pc_extern",,,,,,,,,,,,,,,,,,,,,,01/May/08 22:03;ppoddar@apache.org;patch-586.1.txt;https://issues.apache.org/jira/secure/attachment/12381279/patch-586.1.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160902,,,Thu May 01 22:09:50 UTC 2008,,,,,,,0|i0z4z3:,203108,,,,,,,,"01/May/08 22:03;ppoddar@apache.org;This patch includes 
  a) source code modification: The binding parameter types are changed to declared type of the fields instead of their externalized types
  b) test cases are added to verify the changes ","01/May/08 22:09;ppoddar@apache.org;Here is snippet from Section 4.6.4.1 ""Positional Parameters"" of JPA 1.0 Spec:
""An input parameter evaluates to the abstract schema type of the corresponding parameter defined in the signature of the finder or select method with which the query is associated. It is the responsibility of the persistence provider to map the input parameter to the appropriate abstract schema type value"".  

Subjected to our interpretaion of ""evaluates"", the above directive seems to suggest that, for the given example, the runtime type of the binding parameter can be either java.util.UUID or java.lang.String. And OpenJPA documentation also seems to agree.

However, with current implementation, it may be non-trivial to validate the query parameter at JPA-façade layer for *both* types. It is rather prudent to restrict the user-supplied binding parameter be of declared type only (i.e. java.util.UUID) and not the externalized type (i.e. java.lang.String).   
That is what the attached patch (patch-586.1.txt) does.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Got EntityExistsException when invoking EntityManager.merge() to persist a new entity bean with generated id  and enhanced at deployment time ,OPENJPA-585,12395152,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,jasonzheng1970,jasonzheng1970,01/May/08 18:59,09/Mar/10 18:32,14/Mar/19 03:02,03/May/08 03:17,1.1.0,,,,,,,,,1.1.0,,,,,kernel,,,,,,0,,"I create a new entity object with generated id, enhance it at deployment time and persist it into db by invoking EntityManager.merge().
Department d = new Department();
d.setName('qa');
pc.merge(d);

Got below exception,
<openjpa-1.1.0-SNAPSHOT-r422266:647033 nonfatal store error> org.apache.openjpa.persistence.EntityExistsException: Attempt to persist detached object 'org.apache.openjpa.enhance.tests$functional$jee$misc$classredefinition$common$apps$appforredefinition$entity$Department$pcsubclass@acb905'. If this is a new instance, make sure any versino and/or auto-generated primary key fields are null/default when persisting.
FailedObject: 
org.apache.openjpa.enhance.tests$functional$jee$misc$classredefinition$common$apps$appforredefinition$entity$Department$pcsubclass@acb905
at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2403)
at org.apache.openjpa.kernel.AttachStrategy.persist(AttachStrategy.java:94)
at org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:95)
at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:241)
at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:101)
at org.apache.openjpa.kernel.BrokerImpl.attach(BrokerImpl.java:3191)
at kodo.kernel.KodoBroker.attach(KodoBroker.java:251)
at org.apache.openjpa.kernel.DelegatingBroker.attach(DelegatingBroker.java:1142)
at org.apache.openjpa.persistence.EntityManagerImpl.merge(EntityManagerImpl.java:740)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:597)
at weblogic.deployment.BasePersistenceContextProxyImpl.invoke(BasePersistenceContextProxyImpl.java:90)
...

This is caused by a bug in VersionAttachStrategy, which creates appId and passes it to persist() call for a new entity whose id is annotated with @GeneratedValue.

Jason",,,,,,,,,,,,,,,,,,,,,,01/May/08 19:06;jasonzheng1970;patch-585.txt;https://issues.apache.org/jira/secure/attachment/12381262/patch-585.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160901,,,Thu May 01 19:06:22 UTC 2008,,,,,,,0|i0z7cf:,203492,,,,,,,,"01/May/08 19:06;jasonzheng1970;This issue is caused by a bug in VersionAttachStrategy, which creates appId and passes it to persist() call for a new entity whose id is annotated with @GeneratedValue.

In this patch, I simply pass null as AppId if any of the primary keys for this entity is annotated with @GeneratedValue.

This patch is based on:
openjpa-1.1.0-SNAPSHOT-r422266:652035M",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JNDI lookup failures are not generating useful messages,OPENJPA-581,12394613,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,kwsutter,kwsutter,23/Apr/08 13:54,09/Mar/10 18:32,14/Mar/19 03:02,19/Jun/08 01:42,1.0.3,1.1.0,1.2.0,,,,,,,1.2.0,,,,,jdbc,,,,,,0,,"When using OpenJPA within a container-managed environment and the configuration is using <jta-data-source> and/or <non-jta-data-source> elements with jndi names, the error messages produced when the lookup fails doesn't help with deciphering the problem:

Exception data:
<openjpa-1.1.0-SNAPSHOT-r422266:641891 fatal user error> org.apache.openjpa.persistence.ArgumentException: A JDBC Driver or DataSource class name must be specified in the ConnectionDriverName property.

Looking at the code, even if the jndi lookup causes an exception, the exception is eaten.  This failure turns into a null datasource and then we fall into ""normal"" datasource processing with the openjpa.Connection* properties.  That's when we produce the above message because there is no driver specified.

In this particular case, the user had a typo in his persistence.xml for the jndi name.  It took too much debugging time to figure out that he had a typo.

Kevin",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-06-19 01:42:22.516,,,no_permission,,,,,,,,,,,160897,,,Thu Jun 19 01:42:22 UTC 2008,,,,,,,0|i0z7f3:,203504,,,,,,,,"19/Jun/08 01:42;ppoddar@apache.org;Revision 669356.
Prints a WARN level message when JNDI lookup fails for a null-null key.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Need a better algorithm to find DBDictionary classname in DBDictionaryFactory,OPENJPA-580,12394586,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,jasonzheng1970,jasonzheng1970,23/Apr/08 02:38,21/Sep/16 14:21,14/Mar/19 03:02,05/Nov/08 22:33,,,,,,,,,,1.2.0,1.3.0,2.0.0-M2,,,jdbc,,,,,,0,,"When I debug OpenJPA code, I am surprised to find that it creates an instance of AccessDictionary for a sample application which uses Derby.

The sample application is copied from book ""Pro EJB3"". The connection URL for the persistence unit is:
jdbc:derby://localhost:1527/fieldAccess;create=true

Since it contains 'Access' in the URL value, the OpenJPA code assumes it uses Access database. 

We need a better algorithm to find classname for DBDictionary in DBDictionaryFactory. For example, we can assume the database is Access only if the URL starts with 'jdbc:access'.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-11-05 19:11:12.744,,,no_permission,,,,,,,,,,,160896,,,Mon Jun 15 17:26:34 UTC 2009,,,,,,,0|i1dqi7:,288391,,,,,,,,"05/Nov/08 19:11;allee8285;After committing OPENJPA-780 changes, I researched a little more on this issue and collected the jdbc: url of various database, here is a list for future reference.

Oracle
jdbc:oracle:<drivertype>:@<hostname>:<port>:<database_sid>
jdbc:oracle:thin://<host>:<port>/<service>
jdbc:oracle:thin:<host>:<port>:<SID>
jdbc:oracle:thin:<TNSName>

Oracle OCI
jdbc:oracle:oci://<host>:<port>/<service>
jdbc:oracle:oci:<host>:<port>:<SID>
jdbc:oracle:oci:<TNSName>  

MS SQLServer 2000 Driver
jdbc:microsoft:sqlserver://host:port;databasename=name;user=yourUser;password=yourPwd

MS SQLServer 2005 Driver
jdbc:sqlserver://[serverName[\instanceName][:portNumber]][;property=value[;property=value]]

MS SQLServer (Sprinta)
jdbc:inetdae7:<HOST>:<PORT>?database=<DB>

MS SQLServer (JTurbo)
jdbc:JTurbo://<HOST>:<PORT>/<DB>

MS Access
jdbc:odbc:Driver={Microsoft Access Driver (*.mdb)};DBQ=[Full path to your database file];DriverID22;

jTDS JDBC Driver
jdbc:jtds:microsoft://<host>[:<port>][/<database>] 
jdbc:jtds:sqlserver://server[:port][/database][;property=value[;...]]
jdbc:jtds:sybase://server[:port][/database][;property=value[;...]]

mySQL
jdbc:mysql://[host][,failoverhost...][:port]/[database]
jdbc:mysql://[host:port],[host:port].../[database][?propertyName1][=propertyValue1][&propertyName2][=propertyValue2]

PostgreSQL
jdbc:postgresql:database
jdbc:postgresql://host/database
jdbc:postgresql://host:port/database

JBOSS
jdbc:AvenirDriver://127.0.0.1:1433/master;uid=sa;pwd=sa
jdbc:merant:sqlserver://suresh:1433
jdbc:JSQLConnect://localhost/database=Master&amp;user=sa&amp;password=sa
jdbc:weblogic:mssqlserver4:Master@suresh:1433?user=sa&amp;password=sa

SyBase
jdbc:sybase:Tds:<host>:<port>?ServiceName=<database_name>  

Intersystems Cache
jdbc:Cache://<host>:<port>/<namespace>

DaffodilDBDriver
jdbc:daffodilDB_embedded:<database>
jdbc:daffodilDB://<host>:<port3456>/<database>

DB2
jdbc:db2://<host>:<port50000>/<database>

DB2/400 (toolbox) JDBC connection URL
jdbc:as400://systemname

Front Base
jdbc:FrontBase://<host>:<port>/<database>

Hypersonic SQL (in-process)
jdbc:hsqldb:file:/opt/db/testdb

Hypersonic SQL (in-memory)
jdbc:hsqldb:mem:aname

Hypersonic SQL (server)
jdbc:hsqldb:<database>
jdbc:hsqldb:hsql://<host>:<port>

Informix
jdbc:informix-sqli://<host>:<port>/<database>:informixserver=<dbservername>

Derby
jdbc:derby:net://<host>:<port1527>/<databaseName>

Cloudscape
jdbc:cloudscape:MyDataBase

Cloudscape RMI
jdbc:rmi://hostname:portnumber/jdbc:cloudscape:MyDatabase

Mimer
jdbc:mimer://<host>:<port>/<database>

Pervasive
jdbc:pervasive://<host>:<port>/<database>  

PointBase
jdbc:pointbase:embedded:PBPUBLIC
jdbc:pointbase:server://<host>:<port>/<database>

Interbase
jdbc:interbase:jndi:LDAP_hostname:port_number/...

Borland JDataStore
jdbc:borland:dsremote://hostName/path/storeName.jds 
jdbc:borland:dslocal:storeName.jds

EasySoft
jdbc:easysoft://servername/datasource:logonuser=username:logonpassword=password 

PointBase
jdbc:empress:DATABASE=
jdbc:empress://SERVER=localhost;PORT=6322
jdbc:pointbase:embedded:sample

Interbase (Java driver) / FireBird
jdbc:firebirdsql:[host[/port]:]<database>
jdbc:firebirdsql:localhost/3050:/firebird/test.gdb

Interbase (Interclient driver)
jdbc:interbase://localhost:3060/C:/firebird/test.gdb

H2 Database (embedded)
jdbc:h2:test

H2 Database (Client Server)
jdbc:h2:tcp://localhost:9092/test

H2 Database (In Memory)
jdbc:h2:{ {.|mem:}[name] | [file:]fileName | {tcp|ssl}:[//]server[:port][,server2[:port]]/name }[;key=value...] 

Ingres JDBC connection URL
jdbc:edbc://localhost:II7/database

Albert Lee.",15/Jun/09 17:26;dezzio;Merged changes on DBDictionaryFactory and TestDictionaryFactory to Branch 1.1.x at rev 784867.  ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JDO Projection query with for a complex object with a clob field fails,OPENJPA-579,12394469,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,sandeeps@bea.com,sandeeps@bea.com,21/Apr/08 19:42,09/Mar/10 18:32,14/Mar/19 03:02,03/May/08 03:17,1.1.0,,,,,,,,,1.1.0,,,,,jdbc,,,,,,0,,"The following test case calls setResult on the Query interface to retrieve only the QueryTest2 var with a ordering clause. The generated SQL has an inner select distinct from which the final results are selected by the outer statement. 

        PersistenceManager pm = getPM();
        Query q = newQuery(pm, QueryTest4.class);
        q.declareVariables(""QueryTest2 var"");
        q.setResult(""oneToOne2, var"");
        q.setOrdering(""var.num ascending"");
        q.setFilter(""manyToMany3.contains (var)"");

Here is the SQL generated to retrieve the result.

SELECT s.t3_ID, s.t3_TYP, s.t3_VERSN, s.t3_BOOL, s.t3_CHARACTER0, s.t3_CLOBFIELD, s.t3_DATE0, s.t3_DECIMAL0, s.t3_NUM, s.t3_STRING FROM (SELECT DISTINCT t0.ID AS t0_ID, t3.ID AS t3_ID, t3.TYP AS t3_TYP, t3.VERSN AS t3_VERSN, t3.BOOL AS t3_BOOL, t3.CHARACTER0 AS t3_CHARACTER0, t3.DATE0 AS t3_DATE0, t3.DECIMAL0 AS t3_DECIMAL0, t3.NUM AS t3_NUM, t3.STRING AS t3_STRING, t3.ONETOONE AS t3_ONETOONE, t3.NUM2 AS t3_NUM2 FROM querytest4 t0 INNER JOIN query_manytomany3 t1 ON t0.ID = t1.ID LEFT OUTER JOIN querytest1 t3 ON t0.ONETOONE2 = t3.ID INNER JOIN querytest1 t2 ON t1.ELEMENT = t2.ID) s ORDER BY s.t2_NUM ASC

The generated field in the outer statement s.t3_CLOBFIELD is not present in the distinct clause and leads to the failure exception below.

1) testMultipleSameTypedObjectProjection(kodo.jdbc.query.TestJDBCProjections)<openjpa-1.1.0-SNAPSHOT-r422266:647033 nonfatal store error> kodo.jdo.DataStoreException: Unknown column 's.t3_CLOBFIELD' in 'field list'

        at org.apache.openjpa.jdbc.sql.SQLExceptions.narrow(SQLExceptions.java:146)
        at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4107)
        at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
        at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:88)
        at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:64)
        at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.handleCheckedException(SelectResultObjectProvider.java:155)
        at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:40)
        at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1222)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:989)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:804)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:774)
        at kodo.kernel.KodoQuery.execute(KodoQuery.java:43)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:770)
        at kodo.kernel.KodoQuery.execute(KodoQuery.java:39)
        at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:517)
        at kodo.jdo.QueryImpl.execute(QueryImpl.java:98)
        at kodo.query.ProjectionsTestCase.testMultipleSameTypedObjectProjection(ProjectionsTestCase.java:439)
        at kodo.jdbc.query.TestJDBCProjections.testMultipleSameTypedObjectProjection(TestJDBCProjections.java:137)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)

NestedThrowablesStackTrace:
com.mysql.jdbc.exceptions.MySQLSyntaxErrorException: Unknown column 's.t3_CLOBFIELD' in 'field list'
        at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:930)
        at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:2864)
        at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:1567)
        at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:1659)
        at com.mysql.jdbc.Connection.execSQL(Connection.java:3118)
        at com.mysql.jdbc.PreparedStatement.executeInternal(PreparedStatement.java:1143)
        at com.mysql.jdbc.PreparedStatement.executeQuery(PreparedStatement.java:1256)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:264)
        at com.solarmetric.jdbc.PoolConnection$PoolPreparedStatement.executeQuery(PoolConnection.java:260)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:262)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:262)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:262)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeQuery(JDBCStoreManager.java:1407)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:252)
        at org.apache.openjpa.jdbc.sql.SelectImpl.executeQuery(SelectImpl.java:449)
        at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:360)
        at kodo.jdbc.sql.KodoSelectImpl.execute(KodoSelectImpl.java:28)
        at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:319)
        at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:94)
        at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:34)
        at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1222)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:989)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:804)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:774)
        at kodo.kernel.KodoQuery.execute(KodoQuery.java:43)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:770)
        at kodo.kernel.KodoQuery.execute(KodoQuery.java:39)
        at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:517)
        at kodo.jdo.QueryImpl.execute(QueryImpl.java:98)
        at kodo.query.ProjectionsTestCase.testMultipleSameTypedObjectProjection(ProjectionsTestCase.java:439)
        at kodo.jdbc.query.TestJDBCProjections.testMultipleSameTypedObjectProjection(TestJDBCProjections.java:137)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
 
The fix for the above is in the HandlerFieldStrategy class. In the select distinct constructor the clobfield is being skipped but for the outer select it was getting included so adding condition to honor the eager mode fixes the problem. I will attach the patch shortly.","OpenJPA 1.1.0-SNAPSHOT
version id: openjpa-1.1.0-SNAPSHOT-r422266:647033
Apache svn revision: 422266:647033

os.name: Windows XP
os.version: 5.1
os.arch: x86

java.version: 1.6.0_05
java.vendor: BEA Systems, Inc.",86400,86400,,0%,86400,86400,,,,,,,,,,,,,,,21/Apr/08 19:49;sandeeps@bea.com;openjpa-1.1.0-SNAPSHOT-r422266-647033.patch;https://issues.apache.org/jira/secure/attachment/12380636/openjpa-1.1.0-SNAPSHOT-r422266-647033.patch,02/May/08 13:17;sandeeps@bea.com;openjpa-1.1.0-SNAPSHOT-r422266-650703.patch;https://issues.apache.org/jira/secure/attachment/12381309/openjpa-1.1.0-SNAPSHOT-r422266-650703.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-04-22 06:01:47.147,,,no_permission,,,,,,,,,,,160895,,,Fri May 02 13:17:09 UTC 2008,,,,,,,0|i0z7e7:,203500,,,,,,,,21/Apr/08 19:49;sandeeps@bea.com;Fix to the HandlerStrategy class.,22/Apr/08 06:01;pcl;Resolved in 1.1.x with r650217.,27/Apr/08 22:53;pcl;This was made obsolete by another fix.,02/May/08 13:17;sandeeps@bea.com;Reapply the patch to the MaxEmbeddedLobFieldStrategy class.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA doesn't create LoggingConnectionDecorator instance if log trace is not enabled,OPENJPA-577,12394345,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,jasonzheng1970,jasonzheng1970,18/Apr/08 21:15,09/Mar/10 18:32,14/Mar/19 03:02,27/Apr/08 22:51,1.1.0,,,,,,,,,1.1.0,,,,,jdbc,,,,,,0,,"In current openjpa code, a LoggingConnectionDecorator instance is created only if jdbcLog or sqlLog trace is enabled. This change was made for resolving issue http://issues.apache.org/jira/browse/OPENJPA-407.

$ svn diff -r 589723:590150 DataSourceFactory.java

Index: DataSourceFactory.java
===================================================================
--- DataSourceFactory.java      (revision 589723)
+++ DataSourceFactory.java      (revision 590150)
@@ -162,12 +162,15 @@
                     decorators.addAll(decs);
             }

-            // logging decorator
-            LoggingConnectionDecorator lcd = new LoggingConnectionDecorator();
-            Configurations.configureInstance(lcd, conf, opts);
-            lcd.getLogs().setJDBCLog(jdbcLog);
-            lcd.getLogs().setSQLLog(sqlLog);
-            decorators.add(lcd);
+            if (jdbcLog.isTraceEnabled() || sqlLog.isTraceEnabled()) {
+                // logging decorator
+                LoggingConnectionDecorator lcd =
+                    new LoggingConnectionDecorator();
+                Configurations.configureInstance(lcd, conf, opts);
+                lcd.getLogs().setJDBCLog(jdbcLog);
+                lcd.getLogs().setSQLLog(sqlLog);
+                decorators.add(lcd);
+            }

             dds.addDecorators(decorators);
             return dds;

With this change, openjpa.ConnectionFactoryProperties options (""PrettyPrint"", ""PrettyPrintLineLength"") and kodo.ConnectionFactoryProperties(""TrackParameters"") won't take effect unless log trace is enabled. 

Before this change we allow tracking parameters in error reporting when logging is disabled. I believe this is a regresson, and we should revert that change. ",,,,,,,,,,,,,,,,,,,,,,21/Apr/08 18:29;jasonzheng1970;OPENJPA-577.patch;https://issues.apache.org/jira/secure/attachment/12380625/OPENJPA-577.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-04-21 20:28:42.953,,,no_permission,,,,,,,,,,,160893,,,Mon Apr 21 20:28:42 UTC 2008,,,,,,,0|i1dqif:,288392,,,,,,,,"21/Apr/08 18:29;jasonzheng1970;The attached patch reverted the change made in r590150 for DataSourceFactory.java, so openjpa will create an instance of LoggingConnectionDecorator even if the log trace is disabled.
",21/Apr/08 20:28;pcl;Keeping open as a reminder to backport to trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Recursively embedded entities generate an extra and reduntant SQL call to the database.,OPENJPA-576,12394312,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,sandeeps@bea.com,sandeeps@bea.com,18/Apr/08 15:29,09/Mar/10 18:32,14/Mar/19 03:02,27/Apr/08 22:51,,,,,,,,,,1.1.0,,,,,jdbc,,,,,,0,,"Consider the following persistent class model. The accessor methods are removed for the sake of brevity.

public class EmbeddedOwnerPC {

    private int id1;
    private int id2;
    private String stringField;
    private EmbeddedPC embedded;
    private ComplexEmbeddedPC complexEmbedded;
}

public class EmbeddedPC {
    private int intField;
    private String stringField;
}

public class ComplexEmbeddedPC  extends RecursivelyEmbeddedPC {

    private String stringField;
    private EmbeddedOwnerPC ownerField;
    private Set stringSet = new HashSet();
}

public class RecursivelyEmbeddedPC {

    private EmbeddedPC embedded;
}


When trying to retrieve the EmbeddedOwner entity with a given fetch plan that includes the complexEmbedded and the embedded fields in the RecursivelyEmbeddedPC class it generate the following 2 SQL statements to load the entity.


SELECT t0.TYP, t0.VERSN, t0.EMBEDDED_NULL, t0.ID1, t0.ID2, t0.INTFIELD1, 
t0.STRINGFIELD3, t0.STRINGFIELD FROM EMBEDDEDOWNERPC t0 WHERE t0.ID1 = ? AND t0.ID2 = ? FOR UPDATE

SELECT t0.ID1, t0.ID2 FROM EMBEDDEDOWNERPC t0 WHERE t0.ID1 = ? AND t0.ID2 = ? 
FOR UPDATE

The second call is reduntant and not needed. The fix is to the EmbedFieldStrategy class load method to ensure that all fields that are required to be loaded as per the fetch plan and included from the result set and ONLY when this is not true then generate the extra call otherwise return a hollow embedded entity. In the above test case the extra call was generated to get the stringSet field which was not specified in the fetch plan but the call is made out nevertheless which just selects the primary keys with the same where clause.
","OpenJPA 1.1.0-SNAPSHOT
version id: openjpa-1.1.0-SNAPSHOT-r422266:647033
Apache svn revision: 422266:647033

os.name: Windows XP
os.version: 5.1
os.arch: x86

java.version: 1.6.0_05
java.vendor: BEA Systems, Inc.",86400,86400,,0%,86400,86400,,,,,,,,,,,,,,,22/Apr/08 22:01;sandeeps@bea.com;OPENJPA-576-v2.patch;https://issues.apache.org/jira/secure/attachment/12380730/OPENJPA-576-v2.patch,22/Apr/08 13:19;sandeeps@bea.com;OPENJPA-576-v2.patch;https://issues.apache.org/jira/secure/attachment/12380692/OPENJPA-576-v2.patch,18/Apr/08 15:33;sandeeps@bea.com;OPENJPA-576.patch;https://issues.apache.org/jira/secure/attachment/12380508/OPENJPA-576.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2008-04-21 18:20:50.633,,,no_permission,,,,,,,,,,,160892,,,Tue Apr 22 22:01:35 UTC 2008,,,,,,,0|i1dqin:,288393,,,,,,,,18/Apr/08 15:33;sandeeps@bea.com;Suggested fix for the issue.,"21/Apr/08 18:20;pcl;-        // after loading everything from result, load the rest of the
-        // configured fields
-        if (loaded)
-            em.load(fetch);
+        // After loading everything from result, load the rest of the
+        // configured fields if anything is missing.
+        if (!loaded) {
+          em.load(fetch);
+        }

This seems like a relatively significant semantic change. Can you describe why you inverted the initialization value of |loaded| and why you changed this logic at the end?

Also, what tests have you run this fix against?","22/Apr/08 06:17;pcl;From a conversation with Sandeep:

> We initialize the boolean loaded = true; so we go with the assumption
> that we don't need to reload anything and everything we need is already
> in the result set. The variable gets set to false only if a required
> field is not loaded as per the fetch configuration and then we retry
> 
>        if (!loaded) {
>          em.load(fetch);
>        }
> 
> So the embedded entity remains hollow if some of the fields are not
> present in the result set and they are not present in the fetch
> configuration.
",22/Apr/08 13:19;sandeeps@bea.com;Revised patch based on comments from Abe.,22/Apr/08 22:01;sandeeps@bea.com;Further refinement of the patch based on feedback from Abe White.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cached object in DataCache not evicted due to StatementBatching not reporting OptimisticException ,OPENJPA-574,12394163,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,17/Apr/08 00:54,09/Mar/10 18:32,14/Mar/19 03:02,28/May/08 19:59,1.1.0,1.2.0,,,,,,,,1.2.0,,,,,jdbc,,,,,,0,,"If  DataCache is enabled, and the default statement batching is active, there are cases that we fail to report OptimisticException. 
Because of that, the cached objects were not get removed from the cache.

We have testcases running with different backend and returns different updateCount value from batchExecute when update failed:
1. DB2/NT,  update count of 0 was returned 
2. Oracle 10g,  update count of -2 was returned.

The code in questioin is  in BatchingPreparedStatementManagerImpl.checkUpdateCount() method.

We think the returned update count of  0 and -2 should report OptimisticException for UPDATE/DELETE SQL requests.
Current implemented code reports OptimisticException if update count of -3 is returned.
We don't know if any JDBC driver would return -3 for update/delete that did not qualify due to version value mismatch (in the case that the cache is out of sync with the database).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160890,,,Wed May 28 19:59:00 UTC 2008,,,,,,,0|i0z7g7:,203509,,,,,,,,08/May/08 00:48;fancy;fixed in r654337.,"14/May/08 06:19;fancy;As more testing against various DB2 platforms and Oracle backends, problems uncovered in checkUpdateCount().
","28/May/08 19:59;fancy;resolved for the problems uncovered so far.  
if  new problem surfaced, will open subtask under this issue.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JPQL: The combination LIKE ESCAPE does not accept parameters,OPENJPA-573,12394155,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,goshoo,goshoo,16/Apr/08 22:20,01/Apr/09 15:17,14/Mar/19 03:02,01/Apr/09 15:17,1.0.2,1.1.0,,,,,,,,1.0.4,1.1.0,1.2.0,,,,,,,,,0,,"If i use constants like this :

SELECT object FROM MyObject object WHERE object.path LIKE '%|_%' ESCAPE '|'

all is ok, but if I want to use parameters - exception is thrown.

Example:

@Entity
@Table(name=""simple_object"")
public class MySimpleObject {

	@Id
	String Id ;
	
	@Basic
	@Column(name=""value"", nullable=false, length=36)
	String value  ;
.....................
.......................

EntityManager em = emf.createEntityManager() ;
Query q = em.createQuery(""SELECT x FROM MySimpleObject x WHERE x.value LIKE ?1 ESCAPE '|'"") ;
q.setParameter(1, ""%|_%"") ;
List<MySimpleObject> res = q.getResultList() ;

Exception in thread ""main"" <openjpa-1.1.0-SNAPSHOT-r422266:648359 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Encountered ""ESCAPE"" at character 54, but expected: [""AND"", ""GROUP"", ""HAVING"", ""OR"", ""ORDER"", <EOF>].
	at org.apache.openjpa.kernel.jpql.JPQL.generateParseException(JPQL.java:9499)
	at org.apache.openjpa.kernel.jpql.JPQL.jj_consume_token(JPQL.java:9376)
	at org.apache.openjpa.kernel.jpql.JPQL.parseQuery(JPQL.java:75)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.parse(JPQLExpressionBuilder.java:1733)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.<init>(JPQLExpressionBuilder.java:1720)
	at org.apache.openjpa.kernel.jpql.JPQLParser.parse(JPQLParser.java:48)
	at org.apache.openjpa.kernel.ExpressionStoreQuery.newCompilation(ExpressionStoreQuery.java:149)
	at org.apache.openjpa.datacache.QueryCacheStoreQuery.newCompilation(QueryCacheStoreQuery.java:239)
	at org.apache.openjpa.kernel.QueryImpl.newCompilation(QueryImpl.java:656)
	at org.apache.openjpa.kernel.QueryImpl.compilationFromCache(QueryImpl.java:638)
	at org.apache.openjpa.kernel.QueryImpl.compileForCompilation(QueryImpl.java:604)
	at org.apache.openjpa.kernel.QueryImpl.compileForExecutor(QueryImpl.java:666)
	at org.apache.openjpa.kernel.QueryImpl.getOperation(QueryImpl.java:1486)
	at org.apache.openjpa.kernel.DelegatingQuery.getOperation(DelegatingQuery.java:123)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:227)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:277)
	at Tester.testEscape(Tester.java:75)
	at Tester.main(Tester.java:93)
",SUN JDK 1.6.0.6 (AMD64) for Linux,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-04-17 00:18:57.575,,,no_permission,,,,,,,,,,,160889,,,Fri Mar 27 20:33:19 UTC 2009,,,,,,,0|i0z28v:,202666,,,,,,,,"17/Apr/08 00:18;fancy;An easy fix is on this line (line# 1253)  in JPQL.jjt:
input_parameter() | string_literal()

changed the above line to add parenthesis around it as the following, 
(input_parameter() | string_literal())

Catalina","17/Apr/08 15:31;goshoo;Thank you, Catalina. 

This patch works for me.
In case i want to set parameter for ESCAPE function what i should to change in JPQL.jjt ?
I suppose that something should be changed in the following lines:

void escape_character() #ESCAPECHARACTER :
{ Token t; }
{
	t = <STRING_LITERAL> { jjtThis.setToken (t); }
}

?

Thank you very much.",04/May/08 03:27;fancy;Fixed under Revision: 653176,27/Mar/09 20:33;mikedd;Reopening to merge to 1.0.x,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Delete, re-insert and setting relationship in the same transaction results in ",OPENJPA-568,12393768,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,sandeeps@bea.com,sandeeps@bea.com,11/Apr/08 16:28,09/Mar/10 18:32,14/Mar/19 03:02,18/Apr/08 15:12,1.1.0,,,,,,,,,1.1.0,,,,,kernel,,,,,,0,,"The test deletes and instance and creates another with the same primary keys and encounters an exception while making the new one persistent.

Here is the snippet from the test code:

        pm.currentTransaction().begin();
        MappingTest2 test2c = new MappingTest2();
        test2c.setPk1(test2b.getPk1());
        test2c.setPk2(test2b.getPk2());
        pm.deletePersistent(test2b);

        test4.getNManyMap().put(""key2"", test2);
        test4.getManyManyMap().remove(test2b);
        test4.getManyManyMap().put(test2, test2);
        pm.makePersistent(test2c);
        test4.setInverseOneOne(test2c);

        MappingTest4 test4c = new MappingTest4();
        test4c.setInverseOwnerOneOne(test2c);
        test2c.setOneOneOwner(test4c);
        pm.makePersistent(test4c);
        pm.currentTransaction().commit();


The problem with this issue was that the JDO PersistenceManager. makePersistent() is failing with the following exception:

[testlogic] <openjpa-1.1.0-SNAPSHOT-r420667:634150 nonfatal user error>
kodo.jdo.UserException: Operation attempted on a deleted instance.
[testlogic] FailedObject: kodo.jdbc.meta.MappingTest2-3::4
[testlogic] 	at org.apache.openjpa.kernel.PCState.error(PCState.java:443)
[testlogic] 	at 
org.apache.openjpa.kernel.PDeletedState.beforeOptimisticWrite(PDeletedState.java:76)
[testlogic] 	at 
org.apache.openjpa.kernel.StateManagerImpl.dirty(StateManagerImpl.java:1571)
[testlogic] 	at 
org.apache.openjpa.kernel.StateManagerImpl.settingObjectField(StateManagerImpl.java:1898)
[testlogic] 	at 
org.apache.openjpa.kernel.AttachStrategy.attachField(AttachStrategy.java:204)
[testlogic] 	at 
org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:164)
[testlogic] 	at 
org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:241)
[testlogic] 	at 
org.apache.openjpa.kernel.VersionAttachStrategy.attachInPlace(VersionAttachStrategy.java:267)
[testlogic] 	at 
org.apache.openjpa.kernel.VersionAttachStrategy.attachFieldsInPlace(VersionAttachStrategy.java:218)
[testlogic] 	at 
org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:133)
[testlogic] 	at 
org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:241)
[testlogic] 	at 
org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:101)
[testlogic] 	at 
org.apache.openjpa.kernel.BrokerImpl.attach(BrokerImpl.java:3191)
[testlogic] 	at kodo.kernel.KodoBroker.attach(KodoBroker.java:251)
[testlogic] 	at 
org.apache.openjpa.kernel.DelegatingBroker.attach(DelegatingBroker.java:1142)
[testlogic] 	at 
kodo.jdo.PersistenceManagerImpl.makePersistent(PersistenceManagerImpl.java:496)
[testlogic] 	at 
kodo.jdbc.kernel.TestFlush.testDeleteAndReInsert(TestFlush.java:124)

Synopsis:

When the second call to pm.makePersistent(test2c) is made it is not attached correctly. The effect of the prior pm.deletePersistent(test2b) which deletes the object with the same key is kept in the persistence context and hence when a relation is established with the deleted entity the third pm.makePersistent(test4c) call throws the above exception.

The fix that I have is to correct the logic in the org.apache.openjpa.kernel.VersionAttachStrategy.attach() method where it tries to make a determination of whether this is a new object by also checking whether the existing entity is deleted or not. And that fixes the problem. I will attach it as a patch shortly.

Thanks

Sandeep","This problem is reported with OpenJPA version: 

$ java org.apache.openjpa.conf.OpenJPAVersion 
OpenJPA 1.1.0-SNAPSHOT 
version id: openjpa-1.1.0-SNAPSHOT-r420667:634150 
Apache svn revision: 420667:634150 

os.name: Windows XP 
os.version: 5.1 
os.arch: x86 

java.version: 1.6.0_05 
java.vendor: BEA Systems, Inc. ",86400,86400,,0%,86400,86400,,,,,,,,,,,,,,,11/Apr/08 16:44;sandeeps@bea.com;openjpa-1.1.0-SNAPSHOT-r420667.634150.patch;https://issues.apache.org/jira/secure/attachment/12379932/openjpa-1.1.0-SNAPSHOT-r420667.634150.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-04-11 18:24:16.338,,,no_permission,,,,,,,,,,,160884,,,Fri Apr 18 15:12:48 UTC 2008,,,,,,,0|i0z5af:,203159,,,,,,,,11/Apr/08 16:44;sandeeps@bea.com;The fix to the VersionAttachStrategy class that addresses this issue.,"11/Apr/08 18:24;awhite;As of revision 646082, I believe this patch is invalid.  The patch was to fix some of the side effects of the original 245 fix, but this revision redid the 245 fix in a manner that eliminated the offending side effects.  

My hunch is that the test mentioned in this report will now pass even without this patch.  There are some esoteric configurations, though (like detached state being disabled) where a test like this might still fail.  I believe the proper fix is to amend BrokerImpl.isDetached(Object) to pass the OID_NODELETED flag when it makes its call to find(...).",18/Apr/08 15:12;sandeeps@bea.com;This problem is resolved by the prior fixes at change 646082.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@OrderColumn generates duplicate order numbers.,OPENJPA-567,12393637,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,vbhatia,vbhatia,10/Apr/08 10:11,09/Mar/10 18:32,14/Mar/19 03:02,27/Apr/08 22:50,1.0.2,,,,,,,,,1.1.0,1.2.0,,,,jdbc,,,,,,0,,"@OrderColumn generates and inserts duplicate entries. This is not always the issue, but only for first number, and it starts at 1 instead of 0. The problem is in class StoreCollectionFieldStrategy.load() method where variable seq needs to be initialized with -1.",,,,,,,,,,,,,,,,,,,,,,10/Apr/08 10:16;vbhatia;OrderColumnTest.zip;https://issues.apache.org/jira/secure/attachment/12379819/OrderColumnTest.zip,10/Apr/08 10:17;vbhatia;proposed-soln.patch;https://issues.apache.org/jira/secure/attachment/12379820/proposed-soln.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-04-22 22:02:46.757,,,no_permission,,,,,,,,,,,160883,,,Tue Apr 29 08:00:03 UTC 2008,,,,,,,0|i1dqjz:,288399,,,,,,,,10/Apr/08 10:16;vbhatia;Please see README.txt in zip file.,10/Apr/08 10:17;vbhatia;Proposed Solution.,"22/Apr/08 22:02;pcl;Patch looks good. I'm running a remote test against it now; it should submit to the 1.1.x branch shortly.

I had been curious about backward-compatibility with existing data sets; Srinivas points out that this isn't an issue since the result set will never be empty in the case that there is data, and so the existing data will be read.",29/Apr/08 08:00;vbhatia;Can the test case be added to regression test suite?,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA not supporting count(*) syntax,OPENJPA-566,12393501,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,ppoddar@apache.org,pathos,pathos,09/Apr/08 08:54,07/Apr/09 08:49,14/Mar/19 03:02,19/Jun/08 01:12,1.0.2,,,,,,,,,,,,,,query,,,,,,0,,"When executing a simple query using the (assumingly) valid count(*) syntax, accepted by Hibernate, OpenJPA throws an exception.

Caused by: <openjpa-1.0.2-r420667:627158 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: An error occurred while parsing the query filter 'SELECT count(*) FROM Order instance'. Error message: <openjpa-1.0.2-r420667:627158 nonfatal user error> org.apache.openjpa.kernel.jpql.ParseException: Encountered ""*"" at character 14, but expected: [""("", ""+"", ""-"", "":"", ""?"", ""ABS"", ""AVG"", ""COUNT"", ""DISTINCT"", ""LENGTH"", ""LOCATE"", ""MAX"", ""MIN"", ""MOD"", ""SELECT"", ""SIZE"", ""SQRT"", ""SUM"", <DECIMAL_LITERAL>, <IDENTIFIER>, <INTEGER_LITERAL>].
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.parse(JPQLExpressionBuilder.java:1665)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.<init>(JPQLExpressionBuilder.java:1645)
	at org.apache.openjpa.kernel.jpql.JPQLParser.parse(JPQLParser.java:47)
	at org.apache.openjpa.kernel.ExpressionStoreQuery.newCompilation(ExpressionStoreQuery.java:144)
	at org.apache.openjpa.datacache.QueryCacheStoreQuery.newCompilation(QueryCacheStoreQuery.java:236)
	at org.apache.openjpa.kernel.QueryImpl.newCompilation(QueryImpl.java:651)
	at org.apache.openjpa.kernel.QueryImpl.compilationFromCache(QueryImpl.java:633)
	at org.apache.openjpa.kernel.QueryImpl.compileForCompilation(QueryImpl.java:599)
	at org.apache.openjpa.kernel.QueryImpl.compileForExecutor(QueryImpl.java:661)
	at org.apache.openjpa.kernel.QueryImpl.getOperation(QueryImpl.java:1487)
	at org.apache.openjpa.kernel.DelegatingQuery.getOperation(DelegatingQuery.java:123)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:227)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:277)
	at com.toyota.tme.jpapoc.dao.GenericDaoJpa$7.doInJpa(GenericDaoJpa.java:416)
	at org.springframework.orm.jpa.JpaTemplate.execute(JpaTemplate.java:184)","Spring 2.5.3, JDK 1.5.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-04-09 23:29:50.04,,,no_permission,,,,,,,,,,,160882,,,Tue Apr 07 08:49:28 UTC 2009,,,,,,,0|i0yvl3:,201587,,,,,,,,"09/Apr/08 23:29;pcl;I do not believe that that is legal JPQL. From spec section 4:

aggregate_expression ::= 
    { AVG | MAX | MIN | SUM } ([DISTINCT] state_field_path_expression) | 
    COUNT ([DISTINCT] identification_variable | state_field_path_expression | 
        single_valued_association_path_expression) 

My read of that is that you have to do things like 'select count(p) from Product p'.",19/Jun/08 01:12;ppoddar@apache.org;count(*) is not supported by JPQL specification. ,07/Apr/09 08:49;jkronegg;This issue also occurs under Seam. See https://jira.jboss.org/jira/browse/JBSEAM-3032,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Duplicate @NamedQuery terminates subsequent @NameQuery definitions in @NamedQueries ,OPENJPA-565,12393479,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,09/Apr/08 03:38,15/Apr/08 18:14,14/Mar/19 03:02,11/Apr/08 14:44,1.0.2,1.0.3,1.1.0,,,,,,,1.0.3,1.1.0,1.2.0,,,kernel,,,,,,0,,"If duplicate @NameQuery is defined in @NameQueries as in, 

@NamedQueries (
  {  @NamedQuery(name=""findBasicAByBasicBid"", query=""select t.entitya from BasicB t WHERE t.id = ?1"" ),
     @NamedQuery(name=""findBasicAByBasicBid"", query=""select t.entitya from BasicB t WHERE t.id = ?1""),
     @NamedQuery(name=""findInhAddress"",	query=""select t from InhAddress t)
})

a warning  message is posted in the log

openjpa.MetaData - Found duplicate query ""findBasicAByBasicBid"" in ""class com.ibm.ws.query.pdq.entities.TypeTestBean"".  Ignoring.

Although the message said the query is ignored, it actually terminates the detection of the remaining NamedQuery definitions.

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160881,,,Fri Apr 11 14:40:06 UTC 2008,,,,,,,0|i1dqk7:,288400,,,,,,,,"11/Apr/08 14:40;allee8285;Clarification:

If query.name() is found in the repository cache, the ""before patch"" behavior is posting a ""ignore"" warning message and stop parsing the remaining @NamedQuery in the queries input parameter. Basically it is an no-op. The ""after patch"" behavior remains the same for @NamedQuery, since there is only one entry in the queries list. The only change in behavior is for @NamedQueries. If a duplicate NameQuery is found, it used to stop parsing the remaining @NamedQuery. After the patch, it will ignore the duplicated entry and continue to parse the remaining entries in the queries input list.

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE when trying to invoke FieldMetada.getOrders() when a PersistenCollection field is being loaded.,OPENJPA-562,12393460,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,sandeeps@bea.com,sandeeps@bea.com,08/Apr/08 21:35,09/Mar/10 18:32,14/Mar/19 03:02,08/Apr/08 22:36,1.1.0,,,,,,,,,1.1.0,,,,,kernel,,,,,,0,,"Consider the following snippet of an entity definition:

/**
 * <p>Entity used to test parsing of @OrderBy.</p>
 *
 * @author Abe White
 */
@Entity
public class OrderByEntity {

    @Id
    private long id;
    private String string;

    @PersistentCollection
    @OrderBy
    private List<String> strings = new ArrayList();

}

The @PersistentCollection annotation maps the declaration to the default collection table named orderbyentity_strings. The join column name in the container table is also defaulted to orderbyentity_id and the name of the Element column name is defaulted to element. 

The test code initially added string elements to the strings list and persisted it.

        OrderByEntity pc = new OrderByEntity();
        pc.setId(1L);
        pc.getStrings().add(""2"");
        pc.getStrings().add(""1"");
        pc.getStrings().add(""3"");

On a subsequent load of the persistent collection data by executing the following code, we hit into an NPE.

        pc = em.find(OrderByEntity.class, 1L);
        List<String> strings = pc.getStrings();

java.lang.NullPointerException
at org.apache.openjpa.meta.FieldMetaData.getOrders(FieldMetaData.java:1127)
at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.selectEager(StoreCollectionFieldStrategy.java:207)
at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.selectEagerJoin(StoreCollectionFieldStrategy.java:171)
at org.apache.openjpa.jdbc.meta.FieldMapping.selectEagerJoin(FieldMapping.java:713)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.select(JDBCStoreManager.java:927)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:503)
at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
at org.apache.openjpa.datacache.DataCacheStoreManager.load(DataCacheStoreManager.java:368)
at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:2911)
at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:2989)
at kodo.kernel.ProfilingStateManager.loadField(ProfilingStateManager.java:68)
at org.apache.openjpa.kernel.StateManagerImpl.beforeAccessField(StateManagerImpl.java:1489)
at kodo.kernel.ProfilingStateManager.beforeAccessField(ProfilingStateManager.java:49)
at org.apache.openjpa.kernel.StateManagerImpl.accessingField(StateManagerImpl.java:1474)

This problem is reported with OpenJPA version:

$ java org.apache.openjpa.conf.OpenJPAVersion
OpenJPA 1.1.0-SNAPSHOT
version id: openjpa-1.1.0-SNAPSHOT-r420667:634150
Apache svn revision: 420667:634150

os.name: Windows XP
os.version: 5.1
os.arch: x86

java.version: 1.6.0_05
java.vendor: BEA Systems, Inc.

The NPE occurs when the FieldMetadata.getOrders() method is invoked when trying to load the data in the strings collection field. The code is trying to get the ClassMetadata for the element type and then check the FieldMetadata is present in the declared fields. It fails because the element data type is java.lang.String and there is no ClassMetadata for it. By simply adding a null check for the returned class metadata this issue I could fix locally.

Here is the outout of the svn diff command.

C:\apache_openjpa_project\openjpa>svn diff
Index: openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java
===================================================================
--- openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java
(revision 643944)
+++ openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java
(working copy)
@@ -1124,9 +1124,11 @@
                     //set ""isUsedInOrderBy"" to the field
                     ClassMetaData elemCls = getElement()
                         .getDeclaredTypeMetaData();
-                    FieldMetaData fmd = elemCls.getDeclaredField(decs[i]);
-                    if (fmd != null)
-                       fmd.setUsedInOrderBy(true);
+                    if (elemCls != null) {
+                      FieldMetaData fmd = elemCls.getDeclaredField(decs[i]);
+                      if (fmd != null)
+                        fmd.setUsedInOrderBy(true);
+                    }
                 }
                 _orders = orders;
             }
","This error occured on Microsoft Windows XP SP2, Java version = 1.6.0 with mySQL 5.0 Database.",86400,86400,,0%,86400,86400,,,,,,,,,,,,,,,08/Apr/08 21:41;sandeeps@bea.com;openjpa-1.1.0-SNAPSHOT-r420667.634150.patch;https://issues.apache.org/jira/secure/attachment/12379687/openjpa-1.1.0-SNAPSHOT-r420667.634150.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160878,,,Tue Apr 08 21:41:37 UTC 2008,,,,,,,0|i0z287:,202663,,,,,,,,08/Apr/08 21:41;sandeeps@bea.com;The patch containing the fix for this issue.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.rmi.MarshalException due to mismatched serialization UIDs of: Source (RepId RMI:org.apache.openjpa.kernel.DetachedStateManager,OPENJPA-559,12393154,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,04/Apr/08 19:26,15/Apr/08 18:13,14/Mar/19 03:02,04/Apr/08 19:48,1.0.3,1.1.0,,,,,,,,1.0.3,1.1.0,,,,kernel,,,,,,0,,"When a JSE client requests JPA function via components in an application server, in some combination of client/server operating environment, the client request failed with the following exception even if the client and server are using the same level of OpenJPA code:

java.rmi.MarshalException.  Error Message is:CORBA MARSHAL 0x4942f896 No; nested exception is: 
	org.omg.CORBA.MARSHAL: Unable to read value from underlying bridge : Mismatched 
serialization UIDs : Source (RepId RMI:org.apache.openjpa.kernel.DetachedStateManager
:C7D15E4B35987A3F:766FF0A32408BC7A) = 766FF0A32408BC7A whereas Target (RepId 
RMI:org.apache.openjpa.kernel.DetachedStateManager:47697E6CFD3BF01F:548BD6248B0927C4)
 = 548BD6248B0927C4  

One of the test environment combination that we have observed this exception is a Win32 client and a SunOS application server configuration. The client uses IBM JDK and SunOS uses Sun JDK.

From the JavaDoc Serializable class:

""If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification. However, it is strongly recommended that all serializable classes explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected InvalidClassExceptions during deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the private modifier where possible, since such declarations apply only to the immediately declaring class--serialVersionUID fields are not useful as inherited members.""

Adding the following in DetachedStateManager resolved the problem.

    private static final long serialVersionUID = 6092198373388527556L;

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160875,,,2008-04-04 19:26:50.0,,,,,,,0|i0ywvj:,201796,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Primary key sequences broken with postgres schemas,OPENJPA-557,12393093,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,rogerkeays,rogerkeays,04/Apr/08 07:13,09/Mar/10 18:31,14/Mar/19 03:02,24/Dec/08 00:23,1.0.2,,,,,,,,,1.3.0,2.0.0-M2,,,,jdbc,,,,,,1,,"as per http://www.nabble.com/forum/ViewPost.jtp?post=15460899&framed=y

OpenJPA issues a SELECT currval('user_id_seq'); query to get the current PK value on postgres. This should *not* execute correctly when using a schema. The correct query is SELECT currval('schemaname.user_id_seq');",,,,,,,,,,,,,,,,,,,,,,21/Dec/08 11:58;milosz;OPENJPA-557.patch;https://issues.apache.org/jira/secure/attachment/12396561/OPENJPA-557.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-11-19 16:48:40.448,,,no_permission,,,,,,,,,,,160873,,,Wed Dec 24 00:23:45 UTC 2008,,,,,,,0|i0z1yv:,202621,,,,,,,,"04/Apr/08 07:14;rogerkeays;Here is my patch for OpenJPA 1.0.2. You might prefer to move the code to the superclass though.

Index: openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java
===================================================================
--- openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java      (revision 641780)
+++ openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java      (working copy)
@@ -149,6 +149,21 @@
             ""STORE"", ""VACUUM"", ""VERBOSE"", ""VERSION"",
         }));
     }
+    
+    /**
+     * Prepend schema names to sequence names if there is one. This
+     * method does not escape reserved words in the schema name or
+     * sequence name.
+     */
+    protected String getGeneratedKeySequenceName(Column col) {
+        String sequence = super.getGeneratedKeySequenceName(col);
+        String schema = col.getSchemaName();
+        if (schema != null && schema.length() > 0) {
+            return schema + ""."" + sequence;
+        } else {
+            return sequence;
+        }
+    }
 
     public Date getDate(ResultSet rs, int column)
         throws SQLException { 

This patch has been fine in production for me over the last week.

Adam Hardy also adds:

You might want to make that schema.toLowerCase()

Postgres diverges from the JDBC spec by making everything lower case and it
won't find an upper case schema. ","19/Nov/08 16:48;mihbor@wp.pl;I experienced this bug in geronimo 2.1.3

I checked out openjpa tag 1.0.3 sources, applied the patch, compiled and substituted the class file in openjpa-1.0.3.jar in geronimo 2.1.3 repository.
I confirm the patch works.

This issue is very important and I hope someone applies it to trunk soon :)

Thanks for the patch Roger!
","21/Dec/08 11:58;milosz;The patch attached fixes the problem as suggested by Mehmet in OPENJPA-582:

lastGeneratedKeyQuery = ""SELECT CURRVAL(''{1}_{0}_seq'')"";

This reflects well how PostgreSQL is creating implicit sequences for SERIAL (auto-increment) columns [1]. Lower casing is already handled in DBDictionary.convertSchemaCase(String) method.

I have updated the TestMultipleSchemaNames test case to make the issue visible. Previously the test case was failing in the beginning on PostgreSQL because of schema handling. Derby and DB2 create schema automatically in CREATE TABLE if schema does not exist. PostgreSQL requires explicit schema creation. I have added this to the test case. If we run the test case on Oracle or MySQL, the things are even worse because Oracle treats what we call schema a user name and MySQL treats it as database name.

I added two DogX classes and removed comments from some others as I found them misleading.

[1] http://www.postgresql.org/docs/8.3/interactive/datatype-numeric.html#DATATYPE-SERIAL","21/Dec/08 12:02;milosz;Applying the patch and running the test suite reveals another problem with schema handling in PostgreSQL. I will open a separate JIRA issue.
",24/Dec/08 00:23;fancy;Patch provided by Milosz Tylenda has been checked in under svn trunk r729180 and branch 1.3.x r729181.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The GetMapValue class should have/supply an alias for ORDER-BY clauses.,OPENJPA-554,12392967,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,joe weinstein,joe weinstein,02/Apr/08 19:47,09/Mar/10 18:32,14/Mar/19 03:02,07/Apr/08 16:27,1.0.2,,,,,,,,,1.0.3,,,,,jdbc,,,,,,0,,"A generated select query asks for one of it's columns returned as
a subselect, and then asks that the results be ordered by that subselect.
The DBMS is throwing a spurious error message, saying that in order to
do a SELECT DISTINCT/ORDER BY, the select list has to contain the
column to be ordered by. It's spurious because the query clearly does
list the identical subselect in the select list and the order-by, but the DBMS
is apparently not smart enough to equate those.

Here is a slightly simplified example:

      s.executeQuery(""SELECT DISTINCT ""
              + ""    t0.id, ""
              + ""    (SELECT PMH_testPCKeyStringValue.value ""
              + ""     FROM PMH_testPCKeyStringValue ""
              + ""     WHERE PMH_testPCKeyStringValue.PERSISTENTMAPHOLDER_ID = t0.id ""
              + ""     AND PMH_testPCKeyStringValue.testPCKeyStringValue = 1) ""
              + ""FROM PMH t0 ""
              + ""INNER JOIN PMH_testPCKeyStringValue t1 ON t0.id = t1.PERSISTENTMAPHOLDER_ID ""
              + ""WHERE (""
              + ""    (SELECT PMH_testPCKeyStringValue.value ""
              + ""     FROM PMH_testPCKeyStringValue ""
              + ""     WHERE PMH_testPCKeyStringValue.PERSISTENTMAPHOLDER_ID = t0.id ""
              + ""     AND PMH_testPCKeyStringValue.testPCKeyStringValue = 1) ""
              + ""     IS NOT NULL) ""
              + ""ORDER BY ""
              + ""    (SELECT PMH_testPCKeyStringValue.value ""
              + ""     FROM PMH_testPCKeyStringValue ""
              + ""     WHERE PMH_testPCKeyStringValue.PERSISTENTMAPHOLDER_ID = t0.id ""
              + ""     AND PMH_testPCKeyStringValue.testPCKeyStringValue = 1) ""
              + ""DESC"");

The actual SQL generated has parameter markers for the testPCKeyStringValue
value, and is executed with a prepared statement.

  A modified query that works, which initially simply enough, involves declaring
a column name for the subselect, and then using that column name in the order-by:

      s.executeQuery(""SELECT DISTINCT ""
              + ""    t0.id, ""
              + ""    (SELECT PMH_testPCKeyStringValue.value ""
              + ""     FROM PMH_testPCKeyStringValue ""
              + ""     WHERE PMH_testPCKeyStringValue.PERSISTENTMAPHOLDER_ID = t0.id ""
              + ""     AND PMH_testPCKeyStringValue.testPCKeyStringValue = 1) AS MY_COL_ALIAS ""
              + ""FROM PMH t0 ""
              + ""INNER JOIN PMH_testPCKeyStringValue t1 ON t0.id = t1.PERSISTENTMAPHOLDER_ID ""
              + ""WHERE (""
              + ""    (SELECT PMH_testPCKeyStringValue.value ""
              + ""     FROM PMH_testPCKeyStringValue ""
              + ""     WHERE PMH_testPCKeyStringValue.PERSISTENTMAPHOLDER_ID = t0.id ""
              + ""     AND PMH_testPCKeyStringValue.testPCKeyStringValue = 1) ""
              + ""     IS NOT NULL) ""
              + ""ORDER BY MY_COL_ALIAS ""
              + ""DESC"");

The fix, suggested by Abe White, and tested successfully by me (in this case/DBMS only) is:

"" - When we find JDOQL of the form ""<map>.get(<value>)"", we add the result
of ExpressionFactory.getMapValue(...) to the expression tree. 

- In the case we're concerned with the ExpressionFactory in question is
the org.apache.openjpa.jdbc.kernel.exps.JDBCExpressionFactory, and the
return value is an org.apache.openjpa.jdbc.kernel.exps.GetMapValue.

- The GetMapValue class manually constructs the SQL subselect to
retrieve the value for the given key.

Our goal is to alias the subselect in the SELECT portion of the query,
to keep the subselect unaliased in the WHERE portion, and to use the
SELECT alias in place of the subselect in the ORDER BY portion.
Luckily, I believe this can be accomplished easily with a few
modifcations to the GetMapValue class:

- Add a ""String _alias"" member to GetMapValue.  This will be a unique
alias within the select for the subselect we'll produce.  I recommend
generating this value with a monotonically-increasing int in
JDBCExpressionFactory and passing it to the GetMapValue constructor.
I.e.:

class JDBCExpressionFactory {
  private int _getMapValueAlias = 0;
  ...
  Value getMapValue(...) {
    return new GetMapValue(..., ""gmv"" + _getMapValueAlias++);
  }
}

- In GetMapValue.select(...), append "" AS "" + the _alias member to the
SQLBuffer returned by newSQLBuffer(...).

- In GetMapValue.orderBy(...), just order by the _alias member, not the
result of newSQLBuffer(...).    

This should work because when we construct the select (see
org.apache.openjpa.jdbc.exps.SelectConstructor) we automatically call
select(...) for any ordering value, in addition to orderBy(...).  So the
same GetMapValue instance will have a chance to create both its SELECT
SQL and its ORDER BY SQL.  

Notes:
- You might only want to use subselect aliasing at all if the
DBDictionary in use (accessible through ctx.store.getDBDictionary()) has
its requiresAliasForSubselect field set to true.  Or maybe it would be
best for all dictionaries.  I don't know -- it would require a test run
on all our supported databases to see what each one likes.  My hunch
would be to do it for all dictionaries.""",MS SQLServer,172800,172800,,0%,172800,172800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-04-07 16:27:09.172,,,no_permission,,,,,,,,,,,160870,,,Mon Apr 07 16:27:09 UTC 2008,,,,,,,0|i0z77z:,203472,,,,,,,,"02/Apr/08 19:52;joe weinstein;Here is the svn diff that solves my example:

Index: openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java
===================================================================
--- openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java
(revision 633245)
+++ openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java
(working copy)
@@ -59,6 +59,8 @@
     private final ClassMapping _type;
     private final SelectConstructor _cons = new SelectConstructor();

+    private int _getMapValueAlias = 0;
+
     /**
      * Constructor. Supply the type we're querying against.
      */
@@ -396,6 +398,6 @@
     }

     public Value getMapValue(Value map, Value arg) {
-        return new GetMapValue((Val) map, (Val) arg);
+        return new GetMapValue((Val) map, (Val) arg, ""gmv"" + _getMapValueAlias++);
     }
 }
Index: openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetMapValue.java
===================================================================
--- openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetMapValue.java
(revision 633245)
+++ openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetMapValue.java
(working copy)
@@ -47,13 +47,15 @@
     private final Val _key;
     private ClassMetaData _meta = null;
     private Class _cast = null;
+    private String _alias = null;

     /**
      * Constructor. Provide the map and key to operate on.
      */
-    public GetMapValue(Val map, Val key) {
+    public GetMapValue(Val map, Val key, String alias) {
         _map = map;
         _key = key;
+        _alias = alias;
     }

     public ClassMetaData getMetaData() {
@@ -111,7 +113,9 @@

     public void select(Select sel, ExpContext ctx, ExpState state,
         boolean pks) {
-        sel.select(newSQLBuffer(sel, ctx, state), this);
+        SQLBuffer sqb = newSQLBuffer(sel, ctx, state);
+        sqb.append("" AS "" + _alias );
+        sel.select(sqb, this);
     }

     public void selectColumns(Select sel, ExpContext ctx, ExpState state,
@@ -127,7 +131,7 @@

     public void orderBy(Select sel, ExpContext ctx, ExpState state,
         boolean asc) {
-        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);
+        sel.orderBy(_alias, asc, false);
     }

     private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {",07/Apr/08 16:27;awhite;Applied suggested fix in revision 645589.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Do not recognize Connection* properties in persistence.xml in appl server container,OPENJPA-552,12392960,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,02/Apr/08 18:10,15/Apr/08 18:13,14/Mar/19 03:02,04/Apr/08 19:49,1.0.2,1.0.3,1.1.0,,,,,,,1.0.3,1.1.0,,,,jdbc,,,,,,0,,"If Connection* properties are specified in a persistence unit and there is no <jta-data-source>, <non-jta-data-source> or default data source defined, 

        PU name : dweb24
       Root URL : file:/D:/dev/jdk/runtimes/base_v7_i7/profiles/AppSrv01/installedApps/kingoftownNode03Cell/dweb24Ear.ear/dweb24.war/WEB-INF/classes/
        Tx Type : JTA
           desc : 
       Provider : com.ibm.websphere.persistence.PersistenceProviderImpl [WSJPA-1.1.0-SNAPSHOT-r1118:1345, openjpa-1.1.0-SNAPSHOT-r420667:636531]
         JTA DS : <<null>> | null
      nonJTA DS : <<null>> | null
    exclude Cls : false
      file URLs : []
      mappigFNm : []
 managedClasses : [entities.Department,entities.Employee]
     Properties : {openjpa.ConnectionDriverName=com.ibm.db2.jcc.DB2Driver, openjpa.ConnectionPassword=db2admin, openjpa.ConnectionUserName=db2admin, openjpa.ConnectionURL=jdbc:db2://supermatrix:50000/SAMPLE:retrieveMessagesFromServerOnGetMessage=true;, openjpa.jdbc.Schema=ADMINISTRATOR}

then the following exception will be thrown from DataSourceFactory.newDataSource method:

    <openjpa-1.1.0-SNAPSHOT-r420667:636531 fatal user error> org.apache.openjpa.util.UserException: A JDBC Driver or DataSource class name must be specified in the ConnectionDriverName property.
	at org.apache.openjpa.jdbc.schema.DataSourceFactory.newDataSource(DataSourceFactory.java:72)
	at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.createConnectionFactory(JDBCConfigurationImpl.java:776)
	at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getDBDictionaryInstance(JDBCConfigurationImpl.java:553)
	at org.apache.openjpa.jdbc.meta.MappingRepository.endConfiguration(MappingRepository.java:1251)
	at org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:505)
	at org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:430)

This called path is initiated from PersistenceProviderImpl.createContainerEntityManagerFactory.  Consequentially, transformer is not being registered in the appl server container and no load time entity enhancement is performed.

openjpa.Runtime: Warn: An error occurred while registering a ClassTransformer with dweb24. The error is logged along with this warning. Load-time class transformation will not be available.

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,02/Apr/08 22:08;allee8285;OPENJPA-552.10x.patch;https://issues.apache.org/jira/secure/attachment/12379192/OPENJPA-552.10x.patch,02/Apr/08 22:08;allee8285;OPENJPA-552.11x.patch;https://issues.apache.org/jira/secure/attachment/12379193/OPENJPA-552.11x.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,49833,,,Wed Apr 02 22:08:34 UTC 2008,,,,,,,0|i0z593:,203153,,,,,,,,"02/Apr/08 18:25;allee8285;The cause of the problem sourced from:

PersistenceProviderImpl.java 

        private ClassTransformerImpl(ConfigurationProvider cp, String props, 
            final ClassLoader tmpLoader, OpenJPAConfiguration conf) {
            cp.setInto(conf);
            // don't allow connections
            conf.setConnectionUserName(null);  <<<<< Connection Properties are removed
            conf.setConnectionPassword(null); <<<<< Connection Properties are removed
            conf.setConnectionURL(null); <<<<< Connection Properties are removed
            conf.setConnectionDriverName(null); <<<<< Connection Properties are removed
            conf.setConnectionFactoryName(null); <<<<< Connection Properties are removed
            // use the tmp loader for everything
            conf.setClassResolver(new ClassResolver() {
                public ClassLoader getClassLoader(Class context, 
                    ClassLoader env) {
                    return tmpLoader;
                }
            });
            conf.setReadOnly(Configuration.INIT_STATE_FREEZING);
            MetaDataRepository repos = conf.getMetaDataRepositoryInstance();

So even the properties are defined in the configuration, they are removed before the MetaDataRepository instance is created. Hence no data source can be found and the described exception is thrown.

This change is introduced in r452141.  We assert that these setConnection*(null) statements are not needed because:
1) If the Connection* properties need to be nulled, why are the Connection2* properties are not affected.'
2) The pu can override the intention of these setter(null) calls by specifying the <jta-data-source> and make these operations irrevalent.

Albert Lee.",02/Apr/08 22:08;allee8285;Patch attached. Running maven test and TCK.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect example code factory.createEntityManager(PersistenceContextType.EXTENDED),OPENJPA-550,12392850,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,clr,clr,01/Apr/08 16:39,22/Apr/10 20:32,14/Mar/19 03:02,01/Aug/08 23:59,1.0.2,,,,,,,,,1.3.0,,,,,docs,,,,,,0,,"Example 3.1.  Interaction of Interfaces Outside Container

// get an EntityManager from the factory
EntityManager em = factory.createEntityManager(PersistenceContextType.EXTENDED);

There is no method that takes a PersistenceContextType as a parameter.",,,,,,,,,,,,OPENJPA-548,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160867,,,2008-04-01 16:39:25.0,,,,,,,0|i1dqm7:,288409,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
INNER JOIN Fetch query incorrectly generates  LEFT join SQL,OPENJPA-547,12392499,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,27/Mar/08 21:43,11/Apr/08 01:27,14/Mar/19 03:02,11/Apr/08 01:27,,,,,,,,,,1.0.3,1.1.0,,,,query,,,,,,0,,"INNER JOIN FETCH should not generate SQL LEFT join.

Example:

                         lineitems (ToMany, FetchType=LAZY)
  Order    <===================================> OrderItem
                         order (ToOne, FetchType=LAZY)

For Query:  select o from Order  left join fetch o.lineitems

SQL generated
    for DB2:

SELECT t0.oid, t0.version, t0.amount, t0.delivered, t1.ORDER_OID, t1.lid, t1.version, t1.cost, t1.quantity 
FROM TORDER t0 LEFT OUTER JOIN TORDERITEM t1 ON t0.oid = t1.ORDER_OID ORDER BY t1.ORDER_OID ASC 

    for Oracle:

SELECT t0.oid, t0.version, t0.amount, t0.delivered, t1.ORDER_OID, t1.lid, t1.version, t1.cost, t1.quantity FROM TORDER t0, TORDERITEM t1 WHERE t0.oid = t1.ORDER_OID(+) ORDER BY t1.ORDER_OID ASC

The above SQL pushdown looked good.

However, if left join fetch is changed to inner join fetch:
   select o from Order o inner join fetch o.lineitems

We are generating extra redundant LEFT joins:

   for DB2:
SELECT t0.oid, t0.version, t0.amount, t0.delivered, t2.ORDER_OID, t2.lid, t2.version, t2.cost, t2.quantity 
FROM TORDER t0 INNER JOIN TORDERITEM t1 ON t0.oid = t1.ORDER_OID LEFT OUTER JOIN TORDERITEM t2 ON t0.oid = t2.ORDER_OID ORDER BY t2.ORDER_OID ASC

   for Oracle:
SELECT t0.oid, t0.version, t0.amount, t0.delivered, t2.ORDER_OID, t2.lid, t2.version, t2.cost, t2.quantity FROM TORDER t0, TORDERITEM t1, TORDERITEM t2 WHERE t0.oid = t1.ORDER_OID AND t0.oid = t2.ORDER_OID(+) ORDER BY t2.ORDER_OID ASC

Why do we generate the  extra LEFT joins even for quereis explicitly requesting INNER join fetch ?
   
  
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160864,,,2008-03-27 21:43:02.0,,,,,,,0|i0z57j:,203146,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unclosed prepared statements in SQLStoreQuery.executeUpdate.,OPENJPA-543,12392195,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,24/Mar/08 18:38,24/Mar/08 18:45,14/Mar/19 03:02,24/Mar/08 18:45,1.0.0,1.0.1,1.0.2,,,,,,,1.0.3,1.1.0,,,,,,,,,,0,,SQLStoreQuery.executeUpdate only closes its prepared statements if an exception occurs. We should close the prepared statements immediately since they will tie up database resources (ie Oracle cursors). ,,3600,3600,,0%,3600,3600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160860,,,2008-03-24 18:38:47.0,,,,,,,0|i0ywun:,201792,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OracleDictionary.getEmptyClob uses its classloader instead of the current classloader. ,OPENJPA-542,12392192,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,24/Mar/08 18:14,17/Apr/08 18:29,14/Mar/19 03:02,24/Mar/08 18:46,1.0.0,1.0.1,1.0.2,,,,,,,1.0.3,1.1.0,,,,jdbc,,,,,,0,,"The OracleDictionary class calls Class.forName(""oracle.sql.CLOB"") and Class.forName(""oracle.sql.BLOB"") to get the class objects for BLOBs and CLOBs. This approach uses the classloader which loaded OracleDictionary, which might not have access to the Oracle JDBC classes ie if OpenJPA is in a different OSGi bundle from the jdbc driver. 

Instead we should get the current classloader which is more likely to contain the JDBC driver classes. ",,3600,3600,,0%,3600,3600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160859,,,2008-03-24 18:14:07.0,,,,,,,0|i0ywsv:,201784,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Classloading issue with WAS, Spring, and OpenJPA",OPENJPA-540,12391919,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,19/Mar/08 21:18,25/Mar/08 13:16,14/Mar/19 03:02,25/Mar/08 01:50,1.0.0,1.0.1,1.0.2,1.0.3,1.1.0,,,,,1.0.3,1.1.0,,,,kernel,,,,,,0,,"The WASManagedRuntime class needs to dynamically load and process a couple of WebSphere-specific classes in order to interact with the WebSphere Transaction Manager.  Currently, when these classes are loaded (ExtendedJTATransaction and SynchronizationCallback), there is some problem with the Method invocations that are invoked against the JNDI object that is looked up (java:comp/websphere/ExtendedJTATransaction).  There seems to be a mismatch between the Interface classes that are loaded to obtain the Method objects and the actual object that is returned by the JNDI lookup.  The callstack is similar to the following:

Caused by: <openjpa-1.0.1-r420667:592145 nonfatal user error> org.apache.openjpa.persistence.InvalidStateException: An error occured reflecting WebSphere proprietary interfaces. Please ensure that you are running the application from within WebSphere Application Server (version 5.0.2 or newer).
	at org.apache.openjpa.ee.WASManagedRuntime$WASTransaction.getGlobalId(WASManagedRuntime.java:157)
	at org.apache.openjpa.ee.WASManagedRuntime$WASTransaction.getStatus(WASManagedRuntime.java:104)
	... 49 more
Caused by: java.lang.IllegalArgumentException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at org.apache.openjpa.ee.WASManagedRuntime$WASTransaction.getGlobalId(WASManagedRuntime.java:155)
	... 50 more

The call to getGlobalId in WASManagedRuntime is like this:

                byte[] rval = (byte[]) _getGlobalId.invoke(_extendedTransaction, null);

Debugging this problem has narrowed it down to a classloading issue for this scenario of using WAS v6.1.0.13, Spring 2.5.2, and OpenJPA 1.0.x.  I'll post more on the proposed solution shortly.

Kevin",,,,,,,,,,,,,,,,,,,,,,19/Mar/08 22:26;kwsutter;openjpa-540.patch;https://issues.apache.org/jira/secure/attachment/12378277/openjpa-540.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160857,,,Wed Mar 19 22:26:51 UTC 2008,,,,,,,0|i0z56v:,203143,,,,,,,,"19/Mar/08 21:46;kwsutter;The classloading issue for this environment seems to be related to the loader returned by this invocation:

            ClassLoader loader = _conf.getClassResolverInstance()
                  .getClassLoader(getClass(), null);

The loader returned by the ClassResolverImpl (and there are no external ClassResolvers configured) is a Spring classloader:

[3/18/08 14:36:26:281 PDT] 00000013 SystemOut     O   BJK: loader=org.springframework.instrument.classloading.SimpleInstrumentableClassLoader@17e217e2

I'm not an expert with Spring, but it seems that this SimpleInstrumentableClassLoader uses OverridingClassLoader which calls getResourceAsStream, instruments the bytecodes, and then defines the class.

Unfortunately, this returned Class along with the associated Method classes do not seem to be compatible with the eventual Reflective Method invocations (reference the IllegalArgumentException in the Issue description).

All other classloaders that are available to us during this processing (this WASManagedRuntime classloader, the context classloader, and the jndi object's classloader) all seem to return a more ""reasonable"" classloader:

[3/18/08 14:36:26:281 PDT] 00000013 SystemOut     O   BJK: this loader=
com.ibm.ws.classloader.CompoundClassLoader@2de82de8

The WebSphere compound classloader works much better and provides us with the appropriate Class and Method objects to complete this WAS, Spring, and OpenJPA scenario.

I, personally, do not quite understand the logic in the ClassResolver code for obtaining or creating the appropriate classloader.  There's a comment in this Impl that says we need to do this to be compliant with section 12.5 of the spec.  The JPA spec only has 11 chapters, so this must be referring to some other spec.  JDO, maybe?  Since this part of the kernel, that very well could be.

But, even a more basic question is why do we need to get the loader from this ClassResolver instance?  It seems that if we are in the WASManagedRuntime class and we have found the WAS ExtendedJTATransaction object in JNDI, then why are we concerned about this ClassResolver?  It would seem that a simple call to to getClass().getClassLoader() would suffice for the WebSphere interfaces.

Since this WASManagedRuntime class is only used in the non-EJB3 environments (where the TransactionSynchronizationRegistry doesn't exist yet), making this type of change seems benign.  And, the various test scenarios that we have for WebSphere, Spring, and OpenJPA seem to work (again), it seems like a safe path.  I will post the proposed patch shortly.  Any comments or suggestions will be appreciated.

Thanks,
Kevin
",19/Mar/08 22:26;kwsutter;The patch looks more complicated than it really is due to some formatting cleanup...  The only real change is to skip the call to the ClassResolver to get the classloader and just use getClass().getClassLoader() instead.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Can't create a table with a field of java type ""Map"" in Derby.",OPENJPA-539,12391913,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,faywang,faywang,19/Mar/08 20:31,09/Mar/10 18:32,14/Mar/19 03:02,21/Mar/08 18:38,1.1.0,,,,,,,,,1.1.0,,,,,jdbc,,,,,,0,,"When a Map field is defined in an entity, the push-down SQL contains  Derby reserved word ""key"", causing the execution to fail. For example:

// Map Type
@ManyToMany
@JoinTable(name=""MMCTEA_GMT"")
private Map<Integer, MMContainerTypeEntityB> genericizedMapType;

The following SQL will be generated:

CREATE TABLE MMCTEA_GMT (MMCONTAINERTYPEENTITYA_ID INTEGER, key INTEGER, VALUE0_id INTEGER)

Its execution fails with exception stack trace below:

<openjpa-0.0.0-rnull nonfatal general error> org.apache.openjpa.persistence.PersistenceException: Syntax error: Encountered ""key"" at line 1, column 61.
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:553)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:453)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:159)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:119)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:187)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:192)
	at com.ibm.ws.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:42)
	at com.ibm.ws.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:1)
	at suite.r70.base.jpaspec.relationships.manyXmany.service.impl.jse.JSEManyXManyEntityService.initializeService(JSEManyXManyEntityService.java:51)
	at suite.r70.base.jpaspec.relationships.manyXmany.service.impl.jse.JSEManyXManyEntityService.<init>(JSEManyXManyEntityService.java:40)
	at suite.r70.base.jpaspec.relationships.manyXmany.tests.jse.JUnitManyXManyContainerTest.setUpTestCase(JUnitManyXManyContainerTest.java:60)
	at suite.r70.base.jpaspec.relationships.manyXmany.tests.jse.JUnitManyXManyContainerTest.setUp(JUnitManyXManyContainerTest.java:45)
	at junit.framework.TestCase.runBare(TestCase.java:125)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.junit.internal.runners.OldTestClassRunner.run(OldTestClassRunner.java:35)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:38)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
Caused by: java.sql.SQLException: Syntax error: Encountered ""key"" at line 1, column 61.
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)
	at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedStatement.executeUpdate(Unknown Source)
	at org.apache.commons.dbcp.DelegatingStatement.executeUpdate(DelegatingStatement.java:225)
	at org.apache.openjpa.lib.jdbc.DelegatingStatement.executeUpdate(DelegatingStatement.java:114)
	at org.apache.openjpa.jdbc.schema.SchemaTool.executeSQL(SchemaTool.java:1185)
	at org.apache.openjpa.jdbc.schema.SchemaTool.createTable(SchemaTool.java:949)
	at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:526)
	at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:344)
	at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:321)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:501)
	... 26 more

This is because in HandlerRelationMapTableFieldStrategy.map method, the following method
is called with ""key"" hardcoded to be the column name:

       _kcols = HandlerStrategies.map(key, ""key"", _kio, adapt);

The proposed change is to concatenate field name (in this case, ""genericizedMapType"")
with ""_key"" to make the resulting column name a non-reserved word in any
database:

       _kcols = HandlerStrategies.map(key, field.getName + ""_key"", _kio, adapt);
",Derby,,,,,,,,,,,,,,,,,,,,,20/Mar/08 15:48;faywang;OPENJPA-539.patch;https://issues.apache.org/jira/secure/attachment/12378320/OPENJPA-539.patch,19/Mar/08 20:37;faywang;OPENJPA-539.patch;https://issues.apache.org/jira/secure/attachment/12378270/OPENJPA-539.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-03-19 20:44:33.039,,,no_permission,,,,,,,,,,,160856,,,Fri Mar 21 18:38:54 UTC 2008,,,,,,,0|i0z7db:,203496,,,,,,,,19/Mar/08 20:37;faywang;The attached patch resolves the reserved word problem in the push-down SQL with Derby when a field of java type Map is defined in an entity.,"19/Mar/08 20:44;mikedd;Hi Fay,

Having a column named _key will cause other errors with Derby. I think a better fix would be to call getValidColumnName on the DBDictionary that is being used. That way the column name will only be changed for databases need it. ","20/Mar/08 15:24;faywang;The propoesd fix is not to use ""_key"", but to concatenate the field name with ""_key"". However, Mike's suggestion is more comprehensive and more systematic.  I will  attach a new patch based on his suggestion..","20/Mar/08 15:48;faywang;This patch is per Mike's suggestion, which calls DBDictionary.getValidColumnName to replace hard-coded ""key"". This solution also resolves Derby's reserved word problem.","21/Mar/08 17:33;mikedd;We still need a testcase for the problem, but other than that Fay's proposed patch looks good.",21/Mar/08 18:38;mikedd;Thanks for committing the changes Catalina. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
openjpa-parent pom should not overwrite central repository setting,OPENJPA-537,12391600,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,bommel,bommel,17/Mar/08 10:24,09/Mar/10 18:32,14/Mar/19 03:02,21/Mar/08 14:39,1.0.0,1.0.1,1.0.2,,,,,,,1.0.3,1.1.0,,,,build / infrastructure,,,,,,0,,"You can not use the openjpa version 1.0.2 in a Maven environment (the same for 1.0.1 and 1.0.0). 
This version tries to download the artifacts from http://www.ibiblio.org/maven2 (ibiblio doesn't work anymore.)
 
Please do not overwrite the central repository in a pom. A mirror of central should only be defined in your local settings.xml.

Please remove this from http://svn.apache.org/repos/asf/openjpa/trunk/pom.xml

<repository>
       <id>central</id>
        <name>Maven Repository Switchboard</name>
        <url>http://www.ibiblio.org/maven2</url>
 </repository>",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-03-20 14:54:27.688,,,no_permission,,,,,,,,,,,160854,,,Thu Mar 20 14:54:27 UTC 2008,,,,,,,0|i0za9j:,203965,,,,,,,,17/Mar/08 15:42;bommel;ibiblio is available again but the central repository definition should be removed ,"20/Mar/08 14:54;mikedd;I think this issue originated when we were using the spec jars from the sun repository. We didn't want to download everything from https://maven-repository.dev.java.net/nonav/repository though. 

I don't believe we need either repository anymore, unless anyone objects I'll remove them both. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
getMetaData() causes OutOfMemoryError under some cases,OPENJPA-536,12390908,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,,amy,amy,13/Mar/08 03:14,29/Jan/09 21:14,14/Mar/19 03:02,27/Apr/08 22:47,1.0.2,1.0.3,,,,,,,,0.9.7-r547073,1.0.4,1.1.0,,,jpa,,,,,,0,,"There are 3 classes: Item, Artist and Person. Artist extends Person. 
Invoking JPAFacadeHelper.getMetaData(emf, Item.class) will cause OutOfMemoryError thrown by org.apache.openjpa.meta.MetaDataRepository.processBuffer().

",Sun JDK 5,,,,,,,,,,,,,,,,,,,,,31/Mar/08 01:18;amy;364202.patch;https://issues.apache.org/jira/secure/attachment/12378914/364202.patch,13/Mar/08 05:55;amy;InheritanceComparator.diff;https://issues.apache.org/jira/secure/attachment/12377752/InheritanceComparator.diff,14/Mar/08 07:14;amy;MetaDataRepository.diff;https://issues.apache.org/jira/secure/attachment/12377876/MetaDataRepository.diff,29/Jan/09 16:59;fyrewyld;OPENJPA-536-1.0.x.patch;https://issues.apache.org/jira/secure/attachment/12399021/OPENJPA-536-1.0.x.patch,22/Apr/08 23:47;amy;OPENJPA-536-2.patch;https://issues.apache.org/jira/secure/attachment/12380739/OPENJPA-536-2.patch,22/Apr/08 06:43;amy;OPENJPA-536.patch;https://issues.apache.org/jira/secure/attachment/12380667/OPENJPA-536.patch,22/Apr/08 01:39;amy;OPENJPA-536.patch;https://issues.apache.org/jira/secure/attachment/12380658/OPENJPA-536.patch,20/Apr/08 01:10;amy;OPENJPA-536.patch;https://issues.apache.org/jira/secure/attachment/12380572/OPENJPA-536.patch,18/Apr/08 01:52;amy;OPENJPA-536.patch;https://issues.apache.org/jira/secure/attachment/12380460/OPENJPA-536.patch,17/Apr/08 02:49;amy;OPENJPA-536.patch;https://issues.apache.org/jira/secure/attachment/12380358/OPENJPA-536.patch,02/Apr/08 23:05;amy;OPENJPA-536.patch;https://issues.apache.org/jira/secure/attachment/12379202/OPENJPA-536.patch,01/Apr/08 21:23;amy;OPENJPA-536.patch;https://issues.apache.org/jira/secure/attachment/12379068/OPENJPA-536.patch,01/Apr/08 03:19;amy;OPENJPA-536.patch;https://issues.apache.org/jira/secure/attachment/12379001/OPENJPA-536.patch,13/Mar/08 05:36;amy;meta_testcase.zip;https://issues.apache.org/jira/secure/attachment/12377751/meta_testcase.zip,14.0,,,,,,,,,,,,,,,,,,,2008-04-01 01:57:24.253,,,no_permission,,,,,,,,,,,160853,,,Thu Jan 29 21:14:14 UTC 2009,,,,,,,0|i0yvgv:,201568,,,,,,,,"13/Mar/08 05:26;amy;It is because when constructing the TreeSet, the Item will be the root. The handling order will be Item, Person, Artist.
The the comparator will report Artist < Item and Person > Item. So the TreeSet will be 
    Item
  /         \
Artist   Person

Then when traversing the TreeSet and pop the first one, after Item is removed, the TreeSet will be 
    Person
   /
Artist
The comparator will report Person < Artist so the TreeSet is incorrect.",13/Mar/08 05:36;amy;The test case can be extracted and run under openjpa-persistence-jdbc\src\test\java\org\apache\openjpa\meta,"13/Mar/08 05:55;amy;In InheritanceComparator.java, assign Object.class to _base can make the test case pass. But it will break TestMetaDataInheritanceComparator","14/Mar/08 07:14;amy;Here is a better fix, I think. It can pass both my test case and TestMetaDataInheritanceComparator.
Basically the comparator doesn't have problem. But when comparing classes, the base class is needed to be set. Otherwise it might only compares the class name.","14/Mar/08 07:16;amy;I mean, the changes in MetaDataRepository.diff should be better than InheritanceComparator.diff, though it is not fully reviewed and tested.",31/Mar/08 01:18;amy;Patch including changed source and test case.,"01/Apr/08 01:57;allee8285;Amy,

First of all, thank you of your contribution to the solution of this problem.

I assume the last patch (i.e. 364202.patch) contains ALL the artifacts including the solutions and the test case for verification.

From looking at 364202.patch, it is very difficult to figure out what are the changes in MetaDataRepository.java due to formating differences between the before and after files. If you can submit a patch that shows only the necessary changes, it would greatly speed up the code review process for the committer to help you to commit the change.

Thanks,
Albert Lee.","01/Apr/08 02:06;allee8285;Following the instructions ( http://openjpa.apache.org/get-involved.html ) and the coding standard ( http://openjpa.apache.org/coding-standards.html ) help to eliminate the situation you ran into.

Thanks,
Albert Lee.


","01/Apr/08 03:17;amy;Thank you Albert.
I generated another patch which is the output of ""svn diff openjpa-kernel\src\main\java\org\apache\openjpa\meta\MetaDataRepository.java"". Hope you can review it. 
And I executed ""svn add"" for test cases:
svn add openjpa-persistence-jdbc\src\test\java\org\apache\openjpa\meta\Person.java openjpa-persistence-jdbc\src\test\java\org\apache\openjpa\meta\Item.java openjpa-persistence-jdbc\src\test\java\org\apache\openjpa\meta\Artist.java openjpa-persistence-jdbc\src\test\java\org\apache\openjpa\meta\TestGetMetaData.java
A         openjpa-persistence-jdbc\src\test\java\org\apache\openjpa\meta\Person.java
A         openjpa-persistence-jdbc\src\test\java\org\apache\openjpa\meta\Item.java
A         openjpa-persistence-jdbc\src\test\java\org\apache\openjpa\meta\Artist.java
A         openjpa-persistence-jdbc\src\test\java\org\apache\openjpa\meta\TestGetMetaData.java

Please correct me if anything is wrong.",01/Apr/08 03:18;amy;try to set the base of comparator.,01/Apr/08 03:19;amy;try to set the base of comparator,"01/Apr/08 03:21;amy;oops. pasted MetaDataRepository.java. Please ignore it. only OPENJPA-536.patch is ok, I think.

Why can't I delete the attachments? :-P","01/Apr/08 03:39;ppoddar@apache.org;Amy,
  Thanks for this critical patch. 

  It may by useful to name your patch as OPENJPA-XYZ.n.patch
  where XYZ is the JIRA issue number
              n is the serial number of the patch as often multiple patches are submitted by the same/different developer(s)","01/Apr/08 16:26;amy;Thank you Pinaki.
I'll remember the serial number.

Hope the fix is right. Will you review it?",01/Apr/08 21:23;amy;patch including source code diff and test case,"02/Apr/08 23:05;amy;This version of patch can pass both my test case and the remote test on TeamCity.
Please help to review it.","03/Apr/08 00:05;pcl;Resolved with r644115. For the record, I'm not in love with the statefulness involved in this algorithm, but that predates this issue.","16/Apr/08 23:59;amy;My previous fix doesn't resolve the problem completely.

I'll paste another one.","17/Apr/08 02:49;amy;This is the latest fix.
Please help to review it.","18/Apr/08 01:52;amy;this is the patch under branch 1.1.x.

it's a little weird that my subversion is a Chinese version. I don't know if the patch can be applied... :)",20/Apr/08 01:10;amy;a newer patch for 1.1.x,"22/Apr/08 01:39;amy;Modification of the patch:
1. use an internal LinkedList instead of involving a new class
2. add a private method addToBuffer() to MetaDataRepository to enable MetaDataInheritanceComparator.compare() when adding to buffer
3. use default remove() of LinkedList
4. set the default value of InheritanceComparator._base to Object.class
5. add one test case testGetMetaData. delete 2 test methods from TestMetaDataInheritanceComparator: testInheritanceComparatorWithoutBase() and testMetaDataInheritanceComparatorWithoutBase().

Please help to review.",22/Apr/08 06:43;amy;modified patch.,"22/Apr/08 17:35;awhite;Latest patch looks pretty good.  Two minor details:
1. The class should just be InheritanceOrderMetaDataList, not InheritanceOrderMetaDataList<ClassMetaData>.
2. You don't need all the ""if (buffer != null)"" checks.  buffer is never null.  In fact you could make it final.",22/Apr/08 23:47;amy;a little improvement,27/Apr/08 22:47;pcl;I think that we can put this one to rest finally.,29/Jan/09 16:59;fyrewyld;Patch to bring this bugfix back into the 1.0.x stream.,29/Jan/09 21:02;mikedd;Thanks for the patch Joe.,29/Jan/09 21:14;mikedd;Closing this issue on Amy's behalf. It's fixed in all applicable releases.,,,,,,,,
Javadoc spelling errors in SchemaFactory and Localizer,OPENJPA-535,12390765,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,allee8285,lkuehne,lkuehne,11/Mar/08 16:16,15/Apr/08 18:16,14/Mar/19 03:02,11/Mar/08 20:05,1.0.2,,,,,,,,,1.0.3,1.1.0,,,,docs,,,,,,0,,Type documentaton for SchemaFactory and Localizer contains typos,,300,300,,0%,300,300,,,,,,,,,,,,,,,11/Mar/08 16:18;lkuehne;jpa-javadoc.patch;https://issues.apache.org/jira/secure/attachment/12377624/jpa-javadoc.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-03-11 20:05:19.052,,,no_permission,,,,,,,,,,,160852,,,Tue Mar 11 20:05:19 UTC 2008,,,,,,,0|i1dqnj:,288415,,,,,,,,11/Mar/08 16:18;lkuehne;fix attached,"11/Mar/08 20:05;allee8285;Lars, Thanks for the corrections. Fixes checked into the svn repositories.

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bulk update can`t set null embedded object,OPENJPA-533,12390340,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,zoch,zoch,06/Mar/08 12:00,09/Mar/10 18:32,14/Mar/19 03:02,18/Jun/08 23:29,1.0.0,,,,,,,,,1.2.0,,,,,jpa,,,,,,1,,"Entity :
@Table(name = ""JOBS_APPLICATION"")
@NamedQuery(name = ""Application_resetByUserId"", query = ""UPDATE Application a SET a.user = NULL WHERE a.user.id = :userId"")

public class Application {
    @ManyToOne
    @JoinColumn(name = ""ID_USER"", nullable = true)
    @ForeignKey(deleteAction=ForeignKeyAction.NULL)
    private User user;
.............

execting named query 

      final long pUserId =  10 ;

        int result = em.createNamedQuery(""Application_resetByUserId"")
        .setParameter(""userId"", pUserId).executeUpdate() ;

exception:

<1.0.0 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: An error occurred while parsing the query filter ""UPDATE Application a SET a.user = null WHERE a.user.id = :userId"". Error message: Expression ""UPDATEVALUE"" requires at least one child.
	at org.apache.openjpa.kernel.exps.AbstractExpressionBuilder.parseException(AbstractExpressionBuilder.java:116)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.firstChild(JPQLExpressionBuilder.java:1439)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.onlyChild(JPQLExpressionBuilder.java:1403)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.evalSetClause(JPQLExpressionBuilder.java:465)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getQueryExpressions(JPQLExpressionBuilder.java:270)
	at org.apache.openjpa.kernel.jpql.JPQLParser.eval(JPQLParser.java:61)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.<init>(ExpressionStoreQuery.java:657)
	at org.apache.openjpa.kernel.ExpressionStoreQuery.newDataStoreExecutor(ExpressionStoreQuery.java:165)
	at org.apache.openjpa.datacache.QueryCacheStoreQuery.newDataStoreExecutor(QueryCacheStoreQuery.java:260)
	at org.apache.openjpa.kernel.QueryImpl.createExecutor(QueryImpl.java:725)
	at org.apache.openjpa.kernel.QueryImpl.compileForDataStore(QueryImpl.java:683)
	at org.apache.openjpa.kernel.QueryImpl.compileForExecutor(QueryImpl.java:665)
	at org.apache.openjpa.kernel.QueryImpl.compile(QueryImpl.java:565)
	at kodo.kernel.KodoQuery.compile(KodoQuery.java:75)",Bea Weblogic 10.0 MP1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-06-18 23:29:59.232,,,no_permission,,,,,,,,,,,160850,,,Wed Jun 18 23:29:59 UTC 2008,,,,,,,0|i0z273:,202658,,,,,,,,"18/Jun/08 23:29;ppoddar@apache.org;Revision 669332 allows UPDATE query parsing to allow single-valued association to be set to NULL.
Revision also includes modified version of the test cases attached with this issue. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SchemaTool performs no function if no pu is found.,OPENJPA-532,12390281,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,05/Mar/08 19:54,15/Apr/08 18:12,14/Mar/19 03:02,07/Mar/08 04:08,1.1.0,,,,,,,,,1.1.0,,,,,jdbc,,,,,,0,,"SchemaTools performs no function if no pu is found. It just returns without any message or feedback. E.g.

c:\> java org.apache.openjpa.jdbc.schema.SchemaTool -ConnectionDriverName com.ibm.db2.jcc.DB2Driver -ConnectionURL jdbc:db2:WSTEST -ConnectionUserName leealber -ConnectionPassword ******** -f schema.out -action reflect

c:\>",,,,,,,,,,,,,,,,,,,,,,05/Mar/08 21:58;allee8285;OPENJPA-532.patch;https://issues.apache.org/jira/secure/attachment/12377196/OPENJPA-532.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160849,,,Wed Mar 05 21:58:26 UTC 2008,,,,,,,0|i0z7an:,203484,,,,,,,,"05/Mar/08 21:58;allee8285;In Configurations.runAgainstAllAnchors() method, all the persistence units (anchors) from the configuration paths are first identified and  each anchor is then processed by the tool's runnable class. If no persistence unit is found, this method just returns back to the tool's main().

For schema and possibly other supported tools, persistence unit is not a required parameter. E.g. schema's -reflect action.  

I have attached a patch of the Configurations class allowing the parent tool to process the original tool semantics if no persistence unit (anchor) is found. In the case of SchemaTool, it will perform the desire function.

Comments and suggestions are appreciated.

Thanks,
Albert Lee.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Statement batching incorrectly re-arranged order of SQL statements organized by update managers,OPENJPA-530,12390015,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,03/Mar/08 01:19,17/Jul/08 14:31,14/Mar/19 03:02,07/Mar/08 04:10,1.1.0,,,,,,,,,1.1.0,,,,,jdbc,,,,,,0,,"BatchingPreparedStatementManagerImpl implements the core SQL statement execution function of the Statement Batching features. 

The current implementation of this class holds a cache that maps SQL prepared statements to a collection of parameters of batched requests for that prepared statement. When update manager finishes batching its requests, BatchingPreparedStatementManagerImpl.flush() method is called to submit the batch elements in the cache to the jdbc driver.

Essentially, this implementation discards all the ordering of statements being dispatched to the statement batching function by the update manager. This caused improper order of SQL statements to be sent to the data store. As a result, the underlying database may throw exception indicates the unexpected data condition. E.g. 

com.ibm.db2.jcc.b.SqlException: Error for batch element #2: DB2 SQL error: SQLCODE: -530, SQLSTATE: 23503, SQLERRMC: LEEALBER.EMPBEAN.SQL080226132752530
SQL0530N: The insert or update value of the FOREIGN KEY constraint-name is not equal to any value of the parent key of the parent table. ",,,,,,,,,,,,,,,,,,,,,,03/Mar/08 01:40;allee8285;OPENJPA-530.patch;https://issues.apache.org/jira/secure/attachment/12376948/OPENJPA-530.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-07-17 14:31:37.592,,,no_permission,,,,,,,,,,,160847,,,Thu Jul 17 14:31:37 UTC 2008,,,,,,,0|i0z567:,203140,,,,,,,,"03/Mar/08 01:40;allee8285;Reworked the batching processing and still maintain the order of statements dispatched by update manager using these rules:

1) When a row is requested to be executed, it is saved in a cache and associated to the sql string.
2) Any subsequent requests of the same sql statement continue to append to the cache.
3) If a request is different than the one currently in cache, the current cache is dispatched to the jdbc driver first and the current request is processed as in step 1).
4) When the cache is processed, normal preparedStatement.executeUpdate() is used to dispatch a single request. If there are more than one element in the batch, preparedStatement.addBatch()/executeBatch() is used to dispatch the requests.

Albert Lee.","17/Jul/08 14:31;bogdan.stroe;This problem appears in OpenJPA 1.0.2 also.
As a work-around (that loses the batch performance improvement as no batch is done at all) one can set this property in persistence.xml:
<property name=""openjpa.jdbc.UpdateManager"" value=""operation-order""/>",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FK columns which contain reserved workds are renamed incorrectly.,OPENJPA-528,12389926,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,29/Feb/08 22:09,24/Mar/08 15:13,14/Mar/19 03:02,24/Mar/08 15:13,,,,,,,,,,,,,,,,,,,,,0,,"The check for reserved words in FK column names happens before we append the _ID suffixes. As a result if a reserved word is found  we end up appending a number to the reserved word and then appending _ID. 

Whats worse is that the check for uniqueness also occurs before we append the _ID, which could lead to other problems down the road.",,,,,,,,,,,,,,,,,,,,,,19/Mar/08 19:47;techhusky;OPENJPA-528.patch;https://issues.apache.org/jira/secure/attachment/12378265/OPENJPA-528.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-03-19 19:42:34.829,,,no_permission,,,,,,,,,,,160845,,,Wed Mar 19 19:47:52 UTC 2008,,,,,,,0|i0z26n:,202656,,,,,,,,"19/Mar/08 19:42;techhusky;The original fix provided by Michael has been enhanced to eliminate the problems encountered in the TCK.

In short, when schema mapping occurs columns are inserted into a table object, including foreign key columns.  Then, when foreign keys are mapped into the same table the column name validator finds the column already exists and generates a new unique column with a numeric value appended.  This column is mapped to the foreign key.  Later, when the entity is persisted, the extra/incorrectly generated column name is not found in the database table.  The result is a SQLException.

To eliminate this problem, a new method was added to the DBDictionary to enable/disable the column name uniqueness check.  The method to populate the foreign key column was changed to disable uniqueness checking - since the FK column is already in the table.  Thus, an extra/incorrect column does not get generated.

A patch is provided as OPENJPA-528.patch.  Please review by tomorrow morning (3/20/08).",19/Mar/08 19:47;techhusky;Attachment,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Merge of new one-to-many list only persists last element.,OPENJPA-527,12389807,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,gmarkham,gmarkham,28/Feb/08 17:57,17/Jun/08 20:17,14/Mar/19 03:02,17/Jun/08 20:17,1.0.2,,,,,,,,,1.0.3,,,,,,,,,,,0,,"
If a transient new object is merged containing a one-to-many (with elementjoincolumn) list of transient new objects the last object in the list is the only object persisted.  This functionality has changed since 1.0.1 as the same code worked properly with that version.

Calling persist using an equivalent object works properly but this should work in both cases.

I'll attach a tgz of a maven project that illustrates the problem.  The project uses hsqldb internally and should run stand alone without anything but maven and java installed.",,,,,,,,,,,,,,,,,,,,,,28/Feb/08 18:10;gmarkham;mergetest.tgz;https://issues.apache.org/jira/secure/attachment/12376750/mergetest.tgz,28/Feb/08 18:10;gmarkham;mergetest.tgz;https://issues.apache.org/jira/secure/attachment/12376749/mergetest.tgz,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-06-17 20:17:48.681,,,no_permission,,,,,,,,,,,160844,,,Tue Jun 17 20:17:48 UTC 2008,,,,,,,0|i0yw7r:,201689,,,,,,,,28/Feb/08 18:10;gmarkham;This tgz file contains a standalone maven project that illustrates the problem.  You should be able to simply run 'mvn test' to run the failing junit test case against an embedded hsql database.  SQL logging is turned on in the persistence.xml to show that only one INSERT is run against table 'B' even though three objects should be persisted.,28/Feb/08 18:10;gmarkham;This tgz file contains a standalone maven project that illustrates the problem.  You should be able to simply run 'mvn test' to run the failing junit test case against an embedded hsql database.  SQL logging is turned on in the persistence.xml to show that only one INSERT is run against table 'B' even though three objects should be persisted.,"17/Jun/08 20:17;ppoddar@apache.org;The attached test passes with 1.2.0-SNAPSHOT.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Insert text more than 4K bytes to Clob column causes SQLException: Exhausted Resultset,OPENJPA-526,12389723,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,fancy,frankca,frankca,27/Feb/08 19:28,13/Jan/11 16:45,14/Mar/19 03:02,20/Sep/10 12:36,1.0.0,1.0.2,1.1.0,1.2.0,,,,,,2.1.0,,,,,,,,,,,0,,"Here's the persistence class:
public class Exam... {
    @Lob
    @Column(name = ""text"", nullable = false) ***** NOTE: set nullable = true will fix the problem but it leads to bug OPENJPA-525 *****
    private String text;
}

Here are the differences with nullable = true:
INSERT INTO exam (id, text) VALUES (?, ?) [params=(long) 1, (Clob) oracle.sql.CLOB@d402dd]
SELECT t0.text FROM exam t0 WHERE t0.id = ? FOR UPDATE [params=(long) 1]
With nullable = false:
INSERT INTO exam (id, text) VALUES (?, ?) [params=(long) 1, (Reader) java.io.StringReader@1603522]
SELECT t0.text FROM exam t0 WHERE t0.id = ? FOR UPDATE [params=(long) 1] [code=1400, state=23000]


Here's the full stack trace:
[2008-02-27 10:43:51,232][main][org.apache.openjpa.lib.log.Log4JLogFactory$LogAdapter:72][DEBUG] <t 11050211, conn 32112901> executing prepstmnt 15029693 INSERT INTO exam (id, last_updated_by, comments, sustained_on, text, version, course_id, professor_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?) [params=(long) 11, (String) test, (null) null, (Date) 2008-02-27, (Reader) java.io.StringReader@da9ea4, (int) 1, (long) 1, (long) 8]
[2008-02-27 10:43:51,248][main][org.apache.openjpa.lib.log.Log4JLogFactory$LogAdapter:72][DEBUG] <t 11050211, conn 32112901> [16 ms] spent
[2008-02-27 10:43:51,248][main][org.apache.openjpa.lib.log.Log4JLogFactory$LogAdapter:72][DEBUG] <t 11050211, conn 32112901> executing prepstmnt 24422114 SELECT t0.text FROM exam t0 WHERE t0.id = ? FOR UPDATE [params=(long) 11]
[2008-02-27 10:43:51,279][main][org.apache.openjpa.lib.log.Log4JLogFactory$LogAdapter:72][DEBUG] <t 11050211, conn 32112901> [31 ms] spent
[2008-02-27 10:43:51,279][main][org.apache.openjpa.lib.log.Log4JLogFactory$LogAdapter:76][DEBUG] An exception occurred while ending the transaction.  This exception will be re-thrown.
<openjpa-1.0.2-r420667:627158 fatal store error> org.apache.openjpa.util.StoreException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2108)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1955)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1853)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1771)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1293)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:861)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:408)
	at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:438)
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:662)
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:632)
	at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:319)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:116)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
	at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:631)
	at com.intellapps.university.service.impl.ServiceDahImpl$$EnhancerByCGLIB$$81ecf35d.insertExam(<generated>)
	at com.intellapps.university.service.impl.ServiceImpl.insertExam(ServiceImpl.java:98)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:301)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:182)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:106)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
	at $Proxy17.insertExam(Unknown Source)
	at com.intellapps.university.app.Main.testInsertExamWithLongText(Main.java:103)
	at com.intellapps.university.app.Main.main(Main.java:203)
Caused by: <openjpa-1.0.2-r420667:627158 nonfatal store error> org.apache.openjpa.util.StoreException: Exhausted Resultset
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3946)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:97)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:83)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:59)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:96)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:514)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	... 29 more
Caused by: java.sql.SQLException: Exhausted Resultset
	at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:112)
	at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:146)
	at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:208)
	at oracle.jdbc.driver.ScrollableResultSet.getOracleObject(ScrollableResultSet.java:510)
	at oracle.jdbc.driver.ScrollableResultSet.getCLOB(ScrollableResultSet.java:1446)
	at oracle.jdbc.driver.UpdatableResultSet.getCLOB(UpdatableResultSet.java:1639)
	at oracle.jdbc.driver.UpdatableResultSet.getClob(UpdatableResultSet.java:982)
	at org.apache.commons.dbcp.DelegatingResultSet.getClob(DelegatingResultSet.java:515)
	at org.apache.openjpa.lib.jdbc.DelegatingResultSet.getClob(DelegatingResultSet.java:576)
	at org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedClobFieldStrategy.putData(MaxEmbeddedClobFieldStrategy.java:69)
	at org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedLobFieldStrategy.customUpdate(MaxEmbeddedLobFieldStrategy.java:162)
	at org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedLobFieldStrategy.customInsert(MaxEmbeddedLobFieldStrategy.java:140)
	at org.apache.openjpa.jdbc.meta.FieldMapping.customInsert(FieldMapping.java:684)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager$CustomMapping.execute(AbstractUpdateManager.java:358)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:94)
	... 32 more
NestedThrowables:
<openjpa-1.0.2-r420667:627158 nonfatal store error> org.apache.openjpa.util.ReferentialIntegrityException: ORA-01400: cannot insert NULL into (""TEST"".""EXAM"".""TEXT"")
 {prepstmnt 15029693 INSERT INTO exam (id, last_updated_by, comments, sustained_on, text, version, course_id, professor_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?) [params=(long) 11, (String) test, (null) null, (Date) 2008-02-27, (Reader) java.io.StringReader@da9ea4, (int) 1, (long) 1, (long) 8]} [code=1400, state=23000]
FailedObject: com.intellapps.university.core.model.Exam@1417690
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3944)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:97)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:67)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:108)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:73)
	at org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager.flushPrimaryRow(OperationOrderUpdateManager.java:203)
	at org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:89)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:89)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:514)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1955)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1853)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1771)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1293)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:861)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:408)
	at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:438)
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:662)
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:632)
	at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:319)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:116)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
	at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:631)
	at com.intellapps.university.service.impl.ServiceDahImpl$$EnhancerByCGLIB$$81ecf35d.insertExam(<generated>)
	at com.intellapps.university.service.impl.ServiceImpl.insertExam(ServiceImpl.java:98)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:301)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:182)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:106)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
	at $Proxy17.insertExam(Unknown Source)
	at com.intellapps.university.app.Main.testInsertExamWithLongText(Main.java:103)
	at com.intellapps.university.app.Main.main(Main.java:203)
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: ORA-01400: cannot insert NULL into (""TEST"".""EXAM"".""TEXT"")
 {prepstmnt 15029693 INSERT INTO exam (id, last_updated_by, comments, sustained_on, text, version, course_id, professor_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?) [params=(long) 11, (String) test, (null) null, (Date) 2008-02-27, (Reader) java.io.StringReader@da9ea4, (int) 1, (long) 1, (long) 8]} [code=1400, state=23000]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:192)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$800(LoggingConnectionDecorator.java:57)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:858)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1363)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:97)
	... 36 more
NestedThrowables:
java.sql.SQLException: ORA-01400: cannot insert NULL into (""TEST"".""EXAM"".""TEXT"")

	at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:112)
	at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:331)
	at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:288)
	at oracle.jdbc.driver.T4C8Oall.receive(T4C8Oall.java:745)
	at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:216)
	at oracle.jdbc.driver.T4CPreparedStatement.executeForRows(T4CPreparedStatement.java:966)
	at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1170)
	at oracle.jdbc.driver.OraclePreparedStatement.executeInternal(OraclePreparedStatement.java:3339)
	at oracle.jdbc.driver.OraclePreparedStatement.executeUpdate(OraclePreparedStatement.java:3423)
	at org.apache.commons.dbcp.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:102)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:856)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1363)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:97)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:73)
	at org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager.flushPrimaryRow(OperationOrderUpdateManager.java:203)
	at org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:89)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:89)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:514)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1955)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1853)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1771)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1293)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:861)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:408)
	at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:438)
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:662)
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:632)
	at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:319)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:116)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
	at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:631)
	at com.intellapps.university.service.impl.ServiceDahImpl$$EnhancerByCGLIB$$81ecf35d.insertExam(<generated>)
	at com.intellapps.university.service.impl.ServiceImpl.insertExam(ServiceImpl.java:98)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:301)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:182)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:106)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
	at $Proxy17.insertExam(Unknown Source)
	at com.intellapps.university.app.Main.testInsertExamWithLongText(Main.java:103)
	at com.intellapps.university.app.Main.main(Main.java:203)
","OpenJPA 1.0.0, 1.0.2
Oracle XE 10g (JDBC driver 10.2.0.3.0
JRE 1.5.0_13",,,,,,,,,,,,,,,,,,,,,16/Mar/09 19:06;bjreed;OPENJPA-526.patch;https://issues.apache.org/jira/secure/attachment/12402303/OPENJPA-526.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-01-28 22:32:22.579,,,no_permission,,,,,,,,,,,160843,,,Thu Jan 13 16:45:22 UTC 2011,,,Patch Available,,,,0|i0yw2v:,201667,,,,,,,,"28/Jan/09 22:32;ericp56;It works fine with the BLOB is below the MaxEmbeddedBlobSize.  Here is a sample of the jpa trace when it is above the max size:

Notice how the ""SELECT ... FOR UPDATE"" query does not have the proper values.  It is passing 0, 0 instead of 1, 30061


13797  SurveyDB  TRACE  [main] openjpa.jdbc.SQL - <t 12684953, conn 0> executing prepstmnt 27999450 INSERT INTO SURVEY.QUESTION_RESULTS_COMMENTS (QUESTIONID, SURVEYRESULTSID, COMMENT_, soundfile) VALUES (?, ?, ?, ?) [params=(long) 1, (long) 30061, (String) x, (Blob) oracle.sql.BLOB@20224a]

13797  SurveyDB  TRACE  [main] openjpa.jdbc.SQL - <t 12684953, conn 0> [0 ms] spent

13813  SurveyDB  TRACE  [main] openjpa.jdbc.SQL - <t 12684953, conn 0> executing prepstmnt 19413030 INSERT INTO SURVEY.QUESTION_RESULTS (QUESTIONID, SURVEYRESULTSID, answer) VALUES (?, ?, ?) [params=(long) 1, (long) 30061, (int) 1]

13813  SurveyDB  TRACE  [main] openjpa.jdbc.SQL - <t 12684953, conn 0> [0 ms] spent

13813  SurveyDB  TRACE  [main] openjpa.jdbc.SQL - <t 12684953, conn 0> executing prepstmnt 6223775 SELECT t0.soundfile FROM SURVEY.QUESTION_RESULTS_COMMENTS t0 WHERE t0.QUESTIONID = ? AND t0.SURVEYRESULTSID = ? FOR UPDATE [params=(long) 0, (long) 0]

13875  SurveyDB  TRACE  [main] openjpa.jdbc.SQL - <t 12684953, conn 0> [62 ms] spent

13891  SurveyDB  TRACE  [main] openjpa.Runtime - An exception occurred while ending the transaction.  This exception will be re-thrown.

","29/Jan/09 18:29;fancy;Eric,
The clob/blob size limit is set in OracleDictionary as:
        maxEmbeddedBlobSize = 4000;
        maxEmbeddedClobSize = 4000;

Do you know if any Oracle release has the above limits ?
If there is no such limit, then the above 2 lines of code should be removed.

You could workaround the problem by  adding the following property in  your persistece.xml:

<property name=""openjpa.jdbc.DBDictionary"" value=""oracle(maxEmbeddedBlobSize=-1,maxEmbeddedClobSize=-1)""/>

Please give it a try.","16/Mar/09 19:06;bjreed;The code that is changed fixes 2 Oracle test problems with non nullable Clobs:

1.  When the string is too large to fit in the Oracle Clob normally, an empty string gets passed into the setClobString method.  This was causing the exception noted in this JIRA.
2.  When the user wants to set the Clob to an empty string, the empty string gets passed into setClobString.  OpenJPA would try to set the non nullable field to null.

Also included is a test case.  Lobs.java was not being used for any other tests, it looks like it was leftover from something else.

http://issues.apache.org/jira/browse/OPENJPA-525 is NOT fixed yet with this change, even though it is closely related.

","05/Apr/09 17:24;goshoo;Hello Frank. Do you can confirm this issue ?

I tested with BLOB field up to 8MB without problems with OpenJPA 1.2.1.

I use Oracle 11g JDBC thin driver which is compatible with 9iR2 and 10g servers.

It's is my field definition :

@Column(nullable=false)
byte[] binaryField ;


I set the following property :

<property name=""openjpa.jdbc.DBDictionary"" value=""oracle(maxEmbeddedBlobSize=-1,maxEmbeddedClobSize=-1)""/>","23/Feb/10 06:58;gauravjoshi;Hello,

I am getting the same exception, I am using Oracle 9.2 with OpenJPA 1.2.1 (even tested with 1.2.2 ver). My field definition is 
 @Lob
 @Column(name=""LAYOUT_XML"")
  private byte[] layoutXml;                               AND

@Lob
@Column(name=""SCENARIO_XML"")
 private byte[] scenarioXml;

I have even checked with both nullable false and true. and even have set the 
<property name=""openjpa.jdbc.DBDictionary"" value=""oracle(maxEmbeddedBlobSize=-1,maxEmbeddedClobSize=-1)""/>  as well.  

The column at the DB are of type blob and I get the following exception

org.jboss.resteasy.spi.UnhandledException: <openjpa-1.2.2-r422266:898935 fatal general error> org.apache.openjpa.persistence.PersistenceException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.jboss.resteasy.core.SynchronousDispatcher.handleApplicationException(SynchronousDispatcher.java:296)
	at org.jboss.resteasy.core.SynchronousDispatcher.handleException(SynchronousDispatcher.java:208)
	at org.jboss.resteasy.core.SynchronousDispatcher.handleInvokerException(SynchronousDispatcher.java:187)
	at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:371)
	at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:160)
	at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:113)
	at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:69)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:806)
	at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:502)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1121)
	at com.iontrading.common.license.LicenseCheckFilter.doFilter(LicenseCheckFilter.java:31)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1112)
	at com.iontrading.common.util.NoCacheFilter.doFilter(NoCacheFilter.java:42)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1112)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:265)
	at org.acegisecurity.intercept.web.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:107)
	at org.acegisecurity.intercept.web.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:72)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
	at org.acegisecurity.ui.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:124)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
	at org.acegisecurity.providers.anonymous.AnonymousProcessingFilter.doFilter(AnonymousProcessingFilter.java:125)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
	at org.acegisecurity.ui.AbstractProcessingFilter.doFilter(AbstractProcessingFilter.java:271)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
	at org.acegisecurity.ui.digestauth.DigestProcessingFilter.doFilter(DigestProcessingFilter.java:328)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
	at org.acegisecurity.context.HttpSessionContextIntegrationFilter.doFilter(HttpSessionContextIntegrationFilter.java:249)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
	at org.acegisecurity.util.FilterChainProxy.doFilter(FilterChainProxy.java:149)
	at org.acegisecurity.util.FilterToBeanProxy.doFilter(FilterToBeanProxy.java:98)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1112)
	at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:363)
	at org.mortbay.jetty.security.ConstraintsSecurityHandler.handle(ConstraintsSecurityHandler.java:220)
	at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:181)
	at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:822)
	at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:305)
	at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)
	at org.mortbay.jetty.Server.handle(Server.java:324)
	at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:550)
	at org.mortbay.jetty.HttpConnection$RequestHandler.content(HttpConnection.java:890)
	at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:743)
	at org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:215)
	at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:407)
	at org.mortbay.io.nio.SelectChannelEndPoint.run(SelectChannelEndPoint.java:421)
	at org.mortbay.thread.QueuedThreadPool$PoolThread.run(QueuedThreadPool.java:520)
Caused by: <openjpa-1.2.2-r422266:898935 fatal general error> org.apache.openjpa.persistence.PersistenceException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2187)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2029)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1927)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1698)
	at org.apache.openjpa.kernel.DelegatingBroker.flush(DelegatingBroker.java:989)
	at org.apache.openjpa.persistence.EntityManagerImpl.flush(EntityManagerImpl.java:592)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:198)
	at $Proxy21.flush(Unknown Source)
	at com.iontrading.common.plugins.workspaces.dao.WorkspaceDAOImpl.saveObject(WorkspaceDAOImpl.java:58)
	at com.iontrading.common.plugins.workspaces.dao.WorkspaceDAOImpl$$FastClassByCGLIB$$9bd19fe0.invoke(<generated>)
	at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:149)
	at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:700)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:106)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
	at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:635)
	at com.iontrading.common.plugins.workspaces.dao.WorkspaceDAOImpl$$EnhancerByCGLIB$$61498ea4.saveObject(<generated>)
	at com.iontrading.common.plugins.workspaces.service.impl.WorkspaceServiceImpl.addWorkspace(WorkspaceServiceImpl.java:57)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:119)
	at org.jboss.resteasy.core.ResourceMethod.invokeOnTarget(ResourceMethod.java:211)
	at org.jboss.resteasy.core.ResourceMethod.invoke(ResourceMethod.java:176)
	at org.jboss.resteasy.core.ResourceMethod.invoke(ResourceMethod.java:166)
	at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:356)
	... 41 more
Caused by: <openjpa-1.2.2-r422266:898935 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: Exhausted Resultset
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4246)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4211)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:88)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:64)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:96)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:721)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	... 73 more
Caused by: java.sql.SQLException: Exhausted Resultset
	at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:112)
	at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:146)
	at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:208)
	at oracle.jdbc.driver.ScrollableResultSet.getOracleObject(ScrollableResultSet.java:510)
	at oracle.jdbc.driver.ScrollableResultSet.getBLOB(ScrollableResultSet.java:1425)
	at oracle.jdbc.driver.UpdatableResultSet.getBLOB(UpdatableResultSet.java:1609)
	at oracle.jdbc.driver.UpdatableResultSet.getBlob(UpdatableResultSet.java:976)
	at org.apache.commons.dbcp.DelegatingResultSet.getBlob(DelegatingResultSet.java:512)
	at org.apache.openjpa.lib.jdbc.DelegatingResultSet.getBlob(DelegatingResultSet.java:580)
	at org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedByteArrayFieldStrategy.putData(MaxEmbeddedByteArrayFieldStrategy.java:75)
	at org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedLobFieldStrategy.customUpdate(MaxEmbeddedLobFieldStrategy.java:162)
	at org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedLobFieldStrategy.customInsert(MaxEmbeddedLobFieldStrategy.java:140)
	at org.apache.openjpa.jdbc.meta.FieldMapping.customInsert(FieldMapping.java:701)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager$CustomMapping.execute(AbstractUpdateManager.java:375)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:94)
",20/Aug/10 21:51;fancy;committed fix at revision 987598,20/Sep/10 12:36;drwoods;code committed to trunk 30 days ago.  reopen if more work is needed.,13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inserts new entity with NULL value for Clob column actually inserts empty string,OPENJPA-525,12389721,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,milosz,frankca,frankca,27/Feb/08 19:20,21/Sep/16 14:21,14/Mar/19 03:02,27/Sep/09 07:01,1.0.0,1.0.2,1.1.0,1.2.1,2.0.0,,,,,1.2.0,1.3.0,2.0.0-M3,,,,,,,,,0,,"Inserts new entity with NULL value for Clob column with ""nullable = true"" actually inserts empty string as the value!

Here's the persistence class:
public class Exam... {
    @Lob
    private String text;
}
","OpenJPA 1.0.0, 1.0.2
Oracle XE 10g (JDBC driver 10.2.0.3.0
JRE 1.5.0_13",,,,,,,,,,,,,,,OPENJPA-1289,OPENJPA-1263,OPENJPA-1248,OPENJPA-1249,,,24/Aug/09 10:39;amy;OPENJPA-525-3-branch1.1.x.patch;https://issues.apache.org/jira/secure/attachment/12417465/OPENJPA-525-3-branch1.1.x.patch,07/Jul/09 03:37;allee8285;OPENJPA-525.2.patch;https://issues.apache.org/jira/secure/attachment/12412698/OPENJPA-525.2.patch,16/Aug/09 12:21;milosz;OPENJPA-525.3.patch;https://issues.apache.org/jira/secure/attachment/12416706/OPENJPA-525.3.patch,16/Jun/09 01:38;amy;OPENJPA525.patch;https://issues.apache.org/jira/secure/attachment/12410739/OPENJPA525.patch,16/Jun/09 03:16;amy;OPENJPA525_1_1_x.patch;https://issues.apache.org/jira/secure/attachment/12410747/OPENJPA525_1_1_x.patch,,,,,,,,,,5.0,,,,,,,,,,,,,,,,,,,2009-06-05 07:54:04.886,,,no_permission,,,,,,,,,,,160842,,,Sun Sep 27 07:01:34 UTC 2009,,,Patch Available,,,,0|i0z27r:,202661,,,,,,,,"16/Jun/09 01:38;amy;The patch is created in trunk.

The bug in ResultSetResult prevents invocation to getClobString() on the dictionary class.
",16/Jun/09 03:16;amy;this is for branch1.1.x,18/Jun/09 20:47;dezzio;Applied Amy's 1.1.x patch to the 1.1.x branch at rev 786218,23/Jun/09 23:08;dezzio;Merged change 786218 (Amy's patch) to trunk at change 787868,"23/Jun/09 23:17;dezzio;This bug appears to affect all branches made prior to rev 787868, and branch owners may want to merge the change.  This bug should be closed after allowing a reasonable period of time for branch owners to take action.","24/Jun/09 18:06;milosz;Could you please check the possible impact this change has on the streaming LOB functionality? Not very sure it is because of this this but that functionality is now broken. The tests are named ReaderLobTest and InputStreamLobTest. Although they are not executed by the test suite, the functionality is described in user manual (I have no idea why someone named the tests that way causing the test suite to skip them - oversight?). Note that the tests require a database other than Derby to run on.

One of stack traces I am receiving with MySQL:

        at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:984)
        at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:878)
        at org.apache.openjpa.kernel.DelegatingBroker.find(DelegatingBroker.java:201)
        at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:464)
        at org.apache.openjpa.jdbc.meta.strats.AbstractLobTest.testSetResetAndFlush(AbstractLobTest.java:254)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at org.apache.openjpa.persistence.test.PersistenceTestCase.runBare(PersistenceTestCase.java:475)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:190)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:345)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009)
Caused by: java.lang.ClassCastException: org.apache.openjpa.jdbc.schema.DynamicSchemaFactory$DynamicColumn
        at org.apache.openjpa.jdbc.sql.ResultSetResult.getCharacterStreamInternal(ResultSetResult.java:305)
        at org.apache.openjpa.jdbc.sql.AbstractResult.getCharacterStream(AbstractResult.java:499)
        at org.apache.openjpa.jdbc.meta.strats.LobFieldStrategy.load(LobFieldStrategy.java:181)
        at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:912)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1015)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:967)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:628)
        at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
        at org.apache.openjpa.datacache.DataCacheStoreManager.load(DataCacheStoreManager.java:393)
        at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
        at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
        at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:2989)
        at org.apache.openjpa.kernel.StateManagerImpl.load(StateManagerImpl.java:405)
        at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:971)
        ... 32 more
","06/Jul/09 19:31;allee8285;After the latest patch, I am seeing the following exception:

Caused by: java.lang.ClassCastException: org.apache.openjpa.jdbc.schema.DynamicSchemaFactory$DynamicColumn incompatible with java.lang.Number
at org.apache.openjpa.jdbc.sql.ResultSetResult.getCharacterStreamInternal(ResultSetResult.java:305)
at org.apache.openjpa.jdbc.sql.ResultSetResult.getObjectInternal(ResultSetResult.java:423)
at org.apache.openjpa.jdbc.sql.AbstractResult.getObject(AbstractResult.java:694)
at org.apache.openjpa.jdbc.meta.strats.HandlerStrategies.loadDataStore(HandlerStrategies.java:220)
at org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy.load(HandlerFieldStrategy.java:186)
at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:912)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1015)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:967)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:391)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:290)
at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.initialize(WsJpaJDBCStoreManager.java:147)
at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1003)
at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:961)

Look further in the changes and found in:

ResultSetResult.java 

    protected Object translate(Object obj, Joins joins)
        throws SQLException {
        if (obj instanceof Number)
            return obj;
        // getStringInternal will take care the translation
        if (obj instanceof Column && ((Column) obj).getType() == Types.CLOB)
        	return obj;
        return Numbers.valueOf(findObject(obj, joins));
    }

The newly added code will always return object which is a Column type. However this method is expect a Number object to be returned.

        // getStringInternal will take care the translation
        if (obj instanceof Column && ((Column) obj).getType() == Types.CLOB)
        	return obj;

Albert Lee.
","07/Jul/09 03:37;allee8285;Attempt to fix the incompatible ClassCastException:

1) reverted the translate() method implementation
2) enhanced the AbstractResult.getStringInternal() to include a new parameter indicating if the String is a ClobString, such that the ResultSetResult.getStringInternal() can use it to determine if the _dict.getClobString() or _dict.getString() should be call.

After this patch is applied, OpenJPA trunk built and all tests ran successfully.

Amy and Milosz, can you please try this patch to verify it does solve the original and subsequent regression problems?

Thanks,
Albert Lee.","07/Jul/09 20:56;milosz;Hi Albert. I have tried the patch with MySQL and it resolved most of the LOB streaming errors. Unfortunately one LOB streaming test still fails and it looks like another one started failing:

  testQueryQualifiedId(org.apache.openjpa.persistence.jdbc.maps.spec_10_1_27_ex6.TestSpec10_1_27_Ex6)
  testUpdateWithNull(org.apache.openjpa.jdbc.meta.strats.TestReaderLob)

","07/Jul/09 21:46;allee8285;Milosz,

Thanks for trying the patch on MySQL.

I did not run into any problem in Derby and DB2. Probably it is some db specific feature.

How is the failure surfaced in the test? What is the symptoms looks like? Do you have any exception stack to look at ? Do you have any idea what may have gone wrong? Not sure how is the patch affect Oracle db?

Albert Lee.","08/Jul/09 15:55;allee8285;Milosz,

Did you make any progress on testing the MySQL db with the fixes? Are the failing tests passed before the original patch?

Do you have any objection if we commit the changes so that it reverts the original regression first. Then figure out what are the problems that you have encountered since the original fix had the observed regression? 

If I don't hear from you (or anyone) soon, I shall go ahead with the commit.

Thanks,
Albert Lee.","08/Jul/09 19:07;milosz;Albert,

You don't run into problems with Derby and DB2 because LOB streaming requires other databases (see AbstractLOBTest), otherwise it is basically a no-op.

Yes, the failing tests passed before the original patch although they were not executed by the default test suite because of incorrect names.

For me, you can go ahead with the commit. I have little time this week and then I start vacation. I will dig into this problem but probably no earlier than Jul 20.
","30/Jul/09 19:32;milosz;I started looking into this problem but no success so far. I will again be out of source for the first half of August, so if someone needs it earlier, grab it.
","15/Aug/09 10:54;milosz;Although Amy's patch caused more failures in streaming LOB functionality, that functionality does not work without the patch either. I have double checked this and even 1.2.0 and 1.1.0 releases do not pass all the tests. I will open a new issue for possible fix of streaming LOB.
","15/Aug/09 11:22;milosz;This issue is Oracle-specific.

To answer Amy's initial question (unfortunately that comment is visible only when you are logged in):

> We're using empty_lob() instead of ""null"" when the Lob field has no value even it is nullable. is there any historical reason to do so?

I think the reason is: if we set a LOB column to null we are not able to later update that column with a string longer that 4000 chars. Most probably it was needed in Oracle 8 times but looks like is not needed anymore (starting from Oracle 9 or 10). We should consider reworking our Oracle LOB support - there are chances that some Oracle-specific code can now be avoided and issues like this will disappear.

I will open a new issue for the idea of reworking Oracle LOB support.

","15/Aug/09 12:04;milosz;To clarify: OpenJPA persists an empty CLOB (Oracle-specific) when value to be persisted is null. Neither of the patches changes that. What the patches try to do is when the empty CLOB is read back, it is detected that the CLOB is empty and a null is returned. Without the patches, getString is called on the empty CLOB which gives an empty string to the user.

Amy's patch fixes the issue (TestSerializedLobs.testNullableClob passes with Oracle) but causes Albert's failure.
Albert's patch breaks the Oracle behaviour again (TestSerializedLobs.testNullableClob fails with Oracle) but fixes the error introduced by Amy's patch (so it is basically the state when no patch has been applied in terms of functionality).
","16/Aug/09 12:21;milosz;Albert, could you apply the attached OPENJPA-525.3.patch to trunk and see whether it works for you? With that patch TestSerializedLobs.testNullableClob passes with Oracle.

I have moved the call to translate method from AbstractResult.getObject to ResultSetResult.getObjectInternal. Now ResultSetResult.getObjectInternal receives a Column instead of a bare Number and can determine if the Coulmn is of type CLOB.
","24/Aug/09 09:56;amy;hi Milosz & Albert,
thank you very much for looking into this issue.
Milosz , I've tried OPENJPA-525.3.patch on oracle. TestSerializedLobs can pass with it.
I also run TestInputStreamLob on mysql with it and the case can pass too. Could you please check in the patch?


Thanks,
Amy",24/Aug/09 10:39;amy;patch for 1.1.x based on Milosz's patch,"24/Aug/09 20:25;dezzio;Applied Amy's patch OPENJPA-525-3-branch1.1.x.patch to branch 1.1.1 at revision 807362.  Includes merge from Milosz's change on trunk at 790666 that renamed misnamed test cases.

Amy, can you let us know the results of testing this change with MySQL and Oracle (identifying DB and driver versions), as well as let us know the results of testing Milosz's patch on trunk with the same setups?","25/Aug/09 04:01;amy;Oracle: Database 10g Enterprise Edition Release 11g
Driver: Oracle JDBC Driver version - ""11.1.0.7.0-Production""

MySQL: 5.1.37-community MySQL Community Server (GPL)

branch1.1.x: r807362
TestSerializedLobs passed on oracle and mysql.
TestInputStreamLob passed on mysql. on Oracle, it's result is ""Tests run: 13, Failures: 1, Errors: 12, Skipped: 0"". The failure isn't caused by the patch. It failed before r786218 too. I think it should be tracked by OPENJPA-1248.
TestReaderLob: on oracle, the result is similar with TestInputStreamLob. The failure isn't caused by the patch either. We should track it with OPENJPA-1248 too. I'll paste a stack trace to that issue. 
on mysql, even before r786218, testUpdateWithNull will fail. at r807362 it also failed. I.e. the OPENJPA-525-3-branch1.1.x.patch doesn't cause any regression. I'll create a new JIRA issue to track the failure.

trunk: r807465+OPENJPA-525.3.patch
TestSerializedLobs: same as 1.1.x branch
TestInputStreamLob: same as 1.1.x branch.
TestReaderLob: same as 1.1.x branch

So I think OPENJPA-525.3.patch does resolve the original problem of this issue and safe to be checked in.

Thanks,
Amy","25/Aug/09 14:19;dezzio;Milosz and Amy, thank you!

Applied Milosz's OPENJPA-525.3.patch to trunk at 807642.","26/Aug/09 18:03;milosz;I have ported OPENJPA-525.3.patch along with new tests in TestSerializedLobs to branch 1.3.x.

Mike, you can consider applying the fix to other branches or close this bug.
",27/Sep/09 07:01;milosz;Reopen if needs porting to other branches.,,,,,,,,,,,,,
NullPointerException when persisting a subclass and @Id field is declared in the abstract superclass.,OPENJPA-524,12389607,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,apatel@axway.com,apatel@axway.com,26/Feb/08 18:23,19/Jun/08 12:19,14/Mar/19 03:02,19/Jun/08 12:19,1.0.2,,,,,,,,,,,,,,jpa,,,,,,0,,"When persisting a subclass that has a superclass with an @Id annotation in it, OpenJPA throws the following NullPointerException:

Exception in thread ""main"" <openjpa-1.0.2-r420667:627158 fatal user error> org.apache.openjpa.persistence.ArgumentException: Errors encountered while resolving metadata.  See nested exceptions for details.
        at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:522)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:302)
        at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2372)
        at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2225)
        at org.apache.openjpa.kernel.DelegatingBroker.persist(DelegatingBroker.java:1005)
        at org.apache.openjpa.persistence.EntityManagerImpl.persist(EntityManagerImpl.java:541)
        at JpaTest.main(JpaTest.java:37)
Caused by: <openjpa-1.0.2-r420667:627158 fatal user error> org.apache.openjpa.persistence.ArgumentException: Attempt to map ""Person.id"" failed: the owning entity is not mapped.
        at org.apache.openjpa.jdbc.meta.MappingInfo.assertTable(MappingInfo.java:544)
        at org.apache.openjpa.jdbc.meta.MappingInfo.createColumns(MappingInfo.java:496)
        at org.apache.openjpa.jdbc.meta.ValueMappingInfo.getColumns(ValueMappingInfo.java:143)
        at org.apache.openjpa.jdbc.meta.strats.PrimitiveFieldStrategy.map(PrimitiveFieldStrategy.java:83)
        at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:120)
        at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:80)
        at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:438)
        at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:403)
        at org.apache.openjpa.jdbc.meta.ClassMapping.resolveNonRelationMappings(ClassMapping.java:841)
        at org.apache.openjpa.jdbc.meta.MappingRepository.prepareMapping(MappingRepository.java:322)
        at org.apache.openjpa.meta.MetaDataRepository.preMapping(MetaDataRepository.java:621)
        at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:508)
        ... 6 more
NestedThrowables:
java.lang.NullPointerException
        at org.apache.openjpa.jdbc.meta.MappingInfo.mergeJoinColumn(MappingInfo.java:1386)
        at org.apache.openjpa.jdbc.meta.MappingInfo.createJoins(MappingInfo.java:1192)
        at org.apache.openjpa.jdbc.meta.MappingInfo.createForeignKey(MappingInfo.java:954)
        at org.apache.openjpa.jdbc.meta.ValueMappingInfo.getTypeJoin(ValueMappingInfo.java:104)
        at org.apache.openjpa.jdbc.meta.strats.RelationToManyTableFieldStrategy.map(RelationToManyTableFieldStrategy.java:130)
        at org.apache.openjpa.jdbc.meta.strats.RelationCollectionTableFieldStrategy.map(RelationCollectionTableFieldStrategy.java:94)
        at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:120)
        at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:80)
        at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:438)
        at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:403)
        at org.apache.openjpa.jdbc.meta.ClassMapping.resolveMapping(ClassMapping.java:812)
        at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1618)
        at org.apache.openjpa.meta.MetaDataRepository.processBuffer(MetaDataRepository.java:675)
        at org.apache.openjpa.meta.MetaDataRepository.resolveMapping(MetaDataRepository.java:636)
        at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:514)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:302)
        at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2372)
        at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2225)
        at org.apache.openjpa.kernel.DelegatingBroker.persist(DelegatingBroker.java:1005)
        at org.apache.openjpa.persistence.EntityManagerImpl.persist(EntityManagerImpl.java:541)
        at JpaTest.main(JpaTest.java:37)
<openjpa-1.0.2-r420667:627158 fatal user error> org.apache.openjpa.persistence.ArgumentException: Attempt to map ""Contact.acquireDate"" failed: the owning entity is not mapped.
        at org.apache.openjpa.jdbc.meta.MappingInfo.assertTable(MappingInfo.java:544)
        at org.apache.openjpa.jdbc.meta.MappingInfo.createColumns(MappingInfo.java:496)
        at org.apache.openjpa.jdbc.meta.ValueMappingInfo.getColumns(ValueMappingInfo.java:143)
        at org.apache.openjpa.jdbc.meta.strats.PrimitiveFieldStrategy.map(PrimitiveFieldStrategy.java:83)
        at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:120)
        at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:80)
        at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:438)
        at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:403)
        at org.apache.openjpa.jdbc.meta.ClassMapping.resolveNonRelationMappings(ClassMapping.java:851)
        at org.apache.openjpa.jdbc.meta.ClassMapping.resolveMapping(ClassMapping.java:808)
        at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1618)
        at org.apache.openjpa.meta.MetaDataRepository.processBuffer(MetaDataRepository.java:675)
        at org.apache.openjpa.meta.MetaDataRepository.resolveMapping(MetaDataRepository.java:636)
        at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:514)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:302)
        at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2372)
        at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2225)
        at org.apache.openjpa.kernel.DelegatingBroker.persist(DelegatingBroker.java:1005)
        at org.apache.openjpa.persistence.EntityManagerImpl.persist(EntityManagerImpl.java:541)
        at JpaTest.main(JpaTest.java:37)

The attached test case can recreate this error.","Windows XP, JDK 1.5.0_14, Build time enhancement",,,,,,,,,,,,,,,,,,,,,26/Feb/08 18:24;apatel@axway.com;NPE.log;https://issues.apache.org/jira/secure/attachment/12376533/NPE.log,26/Feb/08 18:23;apatel@axway.com;OpenJPATest.zip;https://issues.apache.org/jira/secure/attachment/12376532/OpenJPATest.zip,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-06-19 12:19:28.219,,,no_permission,,,,,,,,,,,160841,,,Thu Jun 19 12:19:28 UTC 2008,,,,,,,0|i0z74f:,203456,,,,,,,,26/Feb/08 18:23;apatel@axway.com;Test case which reproduces the NullPointerException,26/Feb/08 18:24;apatel@axway.com;Log file showing the NullPointerException,"19/Jun/08 12:19;ppoddar@apache.org;Can not reproduce.
Please reopen with a JUnit test to show the failure if that is still the case.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
openJpa jar is being locked causing future deployments on an app server to fail,OPENJPA-518,12388826,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,atoback,atoback,15/Feb/08 23:05,09/Mar/10 18:32,14/Mar/19 03:02,20/Feb/08 15:02,1.0.1,,,,,,,,,1.0.3,1.1.0,,,,lib,,,,,,0,,"So when I deploy my war file on the application server the first time, everything works fine.  However, if I then try to undeploy or redeploy over the existing version the deployment will fail because the openjpa.jar in the WEB-INF/lib directory of my war file is locked.

I did track down the bug to:
    org.apache.openjpa.lib.util.Services


The addResources method is opening a URL Connection and not performing a setUseCaches(false).  I made the following changes, implemented the new jar in my webapp and it fixed the problem. 

    private static void addResources(URL url, Set set) throws IOException {
        InputStream in = null;
        BufferedReader reader = null;

        try {
            java.net.URLConnection ucon = url.openConnection();
            ucon.setUseCaches(false);
            in = ucon.getInputStream();
            reader = new BufferedReader(new InputStreamReader(in));
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.trim().startsWith(""#"")
                    || line.trim().length() == 0)
                    continue;

                StringTokenizer tok = new StringTokenizer(line, ""# \t"");
                if (tok.hasMoreTokens()) {
                    String next = tok.nextToken();
                    if (next != null) {
                        next = next.trim();
                        if (next.length() > 0 && !next.startsWith(""#""))
                            set.add(next);
                    }
                }
            }
        } 
        catch (Exception e) {
            throw new IOException(e.toString());
        }
        finally {
            try { reader.close(); } catch (IOException re) {}
            try { in.close(); } catch (IOException ioe) {}
        }
    }

Only the setUseCaches(false) should be necessary, but I was just making sure that anything that was opened was closed.

Thanks,
Adam","Windows XP, Sun PE Application Server 8.1, JDK 1.5.0_14-b03, Spring 2.5",600,600,,0%,600,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160835,,,2008-02-15 23:05:38.0,,,,,,,0|i1dq8f:,288347,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Exceptions when persisting Entities with fields map to NVARCHAR columns,OPENJPA-516,12388710,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ssegu,ssegu,ssegu,14/Feb/08 21:01,09/Mar/10 18:32,14/Mar/19 03:02,14/Feb/08 21:46,1.0.0,1.0.1,1.0.2,,,,,,,1.1.0,,,,,jdbc,,,,,,0,,"Attempting to persist the entity results in a SQLException. Appears that the value for the NVARCHAR column is not being set.

Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: Missing IN or OUT parameter at index:: 2 {prepstmnt 22481221 INSERT INTO Holder (id, STRING_FIELD) VALUES (?, ?) [params=(long) 51]} [code=17041, state=null]
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:192)
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$800(LoggingConnectionDecorator.java:57)
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:858)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1363)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:97)
",Test run on windows against Oracle,,,,,,,,,,,,,,,,,,,,,14/Feb/08 21:03;ssegu;testcase.zip;https://issues.apache.org/jira/secure/attachment/12375628/testcase.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160833,,,2008-02-14 21:01:12.0,,,,,,,0|i0zbmn:,204186,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maven build fails if -Dmaven.test.skip=true,OPENJPA-512,12388149,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,mikedd,mikedd,mikedd,08/Feb/08 00:43,19/Feb/08 18:07,14/Mar/19 03:02,19/Feb/08 18:07,0.9.0,0.9.6,0.9.7,1.0.0,1.0.1,,,,,1.0.3,1.1.0,,,,build / infrastructure,,,,,,0,,"Per Rahul Thakur's email to the dev mailing list the build fails if the maven.test.skip property is set to true. None of the source files in src/test/java are compiled when this flag is set, causing the PCEnhancer to fail, and the subsequent build to fail. 

Running mvn -Dtest=false clean test will still compile the testcases, but won't run any of the tests. This property can be used as a workaround for the problem. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160829,,,2008-02-08 00:43:47.0,,,,,,,0|i1dq9b:,288351,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unable to execute native queries which start with the WITH keyword. ,OPENJPA-511,12387935,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,06/Feb/08 05:12,07/Feb/08 16:17,14/Mar/19 03:02,07/Feb/08 16:17,1.0.1,,,,,,,,,1.0.2,1.1.0,,,,jdbc,,,,,,0,,"Some databases support using WITH ${var} AS (SELECT . . .) SELECT ${var}, . . . The variable may be used in a future select statement.

Currently OpenJPA checks whether a native query begins with ""select"" (case insensitive) and throws an exception if an application calls getSingleResult() or getResultList() if select isn't found.  As I understand it the WITH statement may only be used in conjunction with a SELECT statement, so it should be safe to treat the WITH statement as a select. 

I'm not sure how many databases support this syntax so it might be best to limit the support to specific databases. 

The only database to support the WITH statement that I know of is DB2, but this may apply to other databases too. Additional documentation can be found in the DB2 infocenter : http://publib.boulder.ibm.com/infocenter/db2luw/v8/index.jsp?topic=/com.ibm.datatools.sqlbuilder.doc/topics/ruisqlbldrwth.html. 
",DB2,,,,,,,,,,,,,,,,,,,,,06/Feb/08 05:14;mikedd;OPENJPA-511.patch.txt;https://issues.apache.org/jira/secure/attachment/12374844/OPENJPA-511.patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-02-07 15:55:16.603,,,no_permission,,,,,,,,,,,160828,,,Thu Feb 07 16:09:31 UTC 2008,,,,,,,0|i0z553:,203135,,,,,,,,"07/Feb/08 15:55;pcl;I would suggest putting a List<String> into DBDictionary that contains native SQL start words, and then putting WITH into the list in the DB2Dictionary constructor, and then change the logic to delegate to a new DBDictionary method to determine if a string is a SELECT-style statement or a callable statement.","07/Feb/08 16:09;mikedd;That's pretty much what the patch does, I used a Set instead of a List, and I didn't mess with the callable statement checking though. I'm running the tests on 1.0.x now and I'll commit when they're done. 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MappedSuperClass-Entity-Embedded domain model fails during insert ,OPENJPA-509,12387914,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,05/Feb/08 21:27,09/Mar/10 18:32,14/Mar/19 03:02,19/Jun/08 12:15,,,,,,,,,,1.1.0,,,,,,,,,,,0,,"OpenJPA User forum reported a problem with a domain model where entity X extends MappedSuperClass M and X embeds Y. M is using generated value as identity.
The problem appears on insertion of new instance of X.
   
                 http://www.nabble.com/Problem-with-MappedSuperclass-Entity-Embeddable-object-graph-to15298457.html#a15298457


The error has been confirmed and attached patch fixes it.
",,,,,,,,,,,,,,,,,,,,,,05/Feb/08 21:29;ppoddar@apache.org;patch-509.1.txt;https://issues.apache.org/jira/secure/attachment/12374820/patch-509.1.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160826,,,Thu Jun 19 12:15:55 UTC 2008,,,,,,,0|i0zbmf:,204185,,,,,,,,05/Feb/08 21:29;ppoddar@apache.org;Patch ignores primary key field of a Embedded field while inserting. ,19/Jun/08 12:15;ppoddar@apache.org;Revision 618739,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JPQL EXISTS clauses do not handle subclasses properly,OPENJPA-508,12387668,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,01/Feb/08 20:45,09/Mar/10 18:32,14/Mar/19 03:02,02/Feb/08 06:43,1.0.0,1.0.1,,,,,,,,1.0.2,1.1.0,,,,,,,,,,0,,"The following code does not properly add subclass indicators to the generated SQL query:

        StringRootEntity e = new StringRootEntity();
        e.setName(""foo"");
        em.persist(e);

        e = new StringRootEntity();
        e.setName(""foo"");
        em.persist(e);

        e = new StringRootEntity();
        e.setName(""bar"");
        em.persist(e);

        em.flush();

        Query q = em.createQuery(""select o from StringAbstractEntity o "" +
            ""where exists (select o2 from StringLeafEntity o2)"");
        List<StringAbstractEntity> list = q.getResultList();
        assertEquals(0, list.size());


The assertion at the end fails; 3 results are returned, even though there are no SingleLeafEntity instances in the store.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160825,,,Sat Feb 02 06:43:33 UTC 2008,,,,,,,0|i0zbhj:,204163,,,,,,,,02/Feb/08 06:43;pcl;Resolved for subqueries in general.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PreRemove method callback is never called; PreUpdate is always called,OPENJPA-506,12387565,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,miro,miro,31/Jan/08 18:41,09/Mar/10 18:32,14/Mar/19 03:02,01/Feb/08 16:08,1.1.0,,,,,,,,,1.0.2,1.1.0,,,,,,,,,,0,,"I am using EntityListeners to catch Insert, Update and Delete events. During my test case I notice that PreRemove method callback is never called. In the same time PreUpdate is always called whether  Delete (em.remove()) or Insert is called.

In my opinion Pre/Post Persist must be called on Insert operations. Pre/Post Update must be called on Update operations. Pre/Post Remove must be called on Delete operations.","Windows XP, JDK1.5, JDK6, PostgreSQL",,,,,,,,,,,,,,,OPENJPA-507,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-01-31 23:44:31.827,,,no_permission,,,,,,,,,,,160823,,,Fri Feb 01 16:08:40 UTC 2008,,,,,,,0|i0zbgv:,204160,,,,,,,,"31/Jan/08 23:44;pcl;Sure enough, things look a bit messed up (at least in 1.0.x). I've beefed up our existing test case, and have partially resolved the problem.

I believe that we should call Pre/PostUpdate for records that are persisted, flushed, and then modified. I do not believe that we should call Pre/PostUpdate for records that have been flushed, not modified, and then flushed again.",01/Feb/08 02:17;pcl;Resolved in 1.0.x; keeping open pending 1.1.0 resolution.,"01/Feb/08 16:08;pcl;OpenJPA is now in line with the JPA spec's defined behavior. Additionally, new instances that are persisted and then flushed and then modified, and existing instances that are modified, flushed, and then modified again will receive Pre/PostUpdate callbacks for the subsequent modifications.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CLONE -Incorrect Oracle DDL Generation for integer types since OPENJPA-455 ,OPENJPA-505,12387408,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,joe weinstein,joe weinstein,29/Jan/08 21:23,09/Mar/10 18:32,14/Mar/19 03:02,31/Jan/08 00:41,1.1.0,,,,,,,,,1.1.0,,,,,,,,,,,0,,"Since the fix for 455, I've found a problem. Oracle has a NUMBER 
column type, which may be specified with sizes, eg:  NUMBER(7),
or NUMBER(9,3), but may also be unsized,  eg: NUMBER. Since the
fix for 455, the new code is failing to  process the ""NUMBER{0}"" template
for non-sized  columns, so the DDL sent to the DBMS is like: 

CREATE TABLE ABSTRACTMAPPEDAPPIDSUPER ( ..., VERSN NUMBER{0}, ... 

which needless to say, dies. 

A change I made to DBDictionary, that fixed this for me is: 

    protected String insertSize(String typeName, String size) { 
        if(StringUtils.isEmpty(size)) { 

          int idx = typeName.indexOf(""{0}""); // remove the size token if not needed... 
          if (idx != -1) { 
            return typeName.substring(0,idx); 
          } 
          return typeName; 
        } 

        int idx = typeName.indexOf(""{0}""); 
... 


ie: 

Index: openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java 
=================================================================== 
--- openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java (revision 610999) 
+++ openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java (working copy) 
@@ -1648,8 +1648,13 @@ 
      */ 
     protected String insertSize(String typeName, String size) { 
        if(StringUtils.isEmpty(size)) { 
- return typeName; 
- } 
+ 
+ int idx = typeName.indexOf(""{0}""); 
+ if (idx != -1) { 
+ return typeName.substring(0,idx); 
+ } 
+ return typeName; 
+ } 

         int idx = typeName.indexOf(""{0}""); 
         if (idx != -1) { 

Please let me know what you think, and how to absorb this 
change, or it's purpose. thanks, 
Joe Weinstein at BEA Systems ",,,,,,,,,,,OPENJPA-455,,,,,,,,,,,29/Jan/08 21:29;joe weinstein;my-change.patch;https://issues.apache.org/jira/secure/attachment/12374295/my-change.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-01-31 00:39:59.38,,,no_permission,,,,,,,,,,,160822,,,Thu Jan 31 00:39:59 UTC 2008,,,,,,,0|i0z53z:,203130,,,,,,,,31/Jan/08 00:39;pcl;Changing affected version information since OPENJPA-455 was not in the 1.0.x line.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Duplicate order numbers in relationshiptable for the same List field,OPENJPA-504,12387171,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,christiaan,christiaan,25/Jan/08 16:00,09/Mar/10 18:32,14/Mar/19 03:02,13/May/08 12:48,,,,,,,,,,1.1.0,1.2.0,,,,,,,,,,0,,"I now and then encounter entries in the relationship tables for List fields (id, element, ordr) non-unique entries for id, ordr. (Two elements are placed on the same index in the same list). I am not sure how to reproduce this, but I do have a question regarding the code in StoreCollectionFieldStrategy.load(): 

ChangeTracker ct = null;
        if (field.getTypeCode() == JavaTypes.ARRAY)
            coll = new ArrayList();
        else {
            coll = sm.newProxy(field.getIndex());
            if (coll instanceof Proxy)
                ct = ((Proxy) coll).getChangeTracker();
        }

        // load values
        Result res = union.execute(store, fetch);
        try {
            int seq = 0;
            while (res.next()) {
                if (ct != null && field.getOrderColumn() != null)
                    seq = res.getInt(field.getOrderColumn());
                add(store, coll, loadElement(sm, store, fetch, res,
                    resJoins[res.indexOf()]));
            }
            if (ct != null && field.getOrderColumn() != null)
                ct.setNextSequence(seq + 1);
        } finally {
            res.close();
        }

If I am not mistaken, this initializes the changetracker for list fields for persistent objects loaded from the database with an empty list attribute (res.next() = false) with order number of ""1"", whereas objects with non-empty List fields which are persisted start with an order number of ""0"". Could this be the reason that I now and then encounter duplicate entries in the relationship table with ordernr ""1""? Actually this is also the reason why encounter duplicates for other numbers, since order number is zero based (next sequence number is initialized to size()), but as described, some lists start counting from ""1"".

kind regards,
Christiaan",Kodo 4.1.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160821,,,Tue May 13 12:48:08 UTC 2008,,,,,,,0|i0z25z:,202653,,,,,,,,"25/Jan/08 18:12;christiaan;The cause of the problem appears to be in different loading mechanisms. If the first time a collection is loaded using EAGER_NONE the sequence number is initialized to 1 instead of zero (see previous comment). When this is written to the datastore and loaded again the next time with EAGER_JOIN (resulting in StoreCollectionFieldStrategy.loadEagerJoin() which invokes CollectionChangeTrackerImpl.initialSequence()) the next sequence number will be initialized to the size of the collection => 1. So both element on index zero and one get the ordr value ""1""",13/May/08 12:48;christiaan;Fixed due to issue OPENJPA-567,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA 1.1.0-SNAPSHOT attempts to mutate unmodifiable map in Glassfish,OPENJPA-498,12386661,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,19/Jan/08 00:52,09/Mar/10 18:32,14/Mar/19 03:02,21/Jan/08 18:51,1.1.0,,,,,,,,,1.1.0,,,,,jpa,,,,,,0,,"Stack trace: 

.container.web|_ThreadID=10;_ThreadName=main;_RequestID=f69aacdb-3b39-4725-bde6-8ff100849358;|WEB0207: Error starting web context StandardEngine[ com.sun.appserv].StandardHost[server].StandardContext[/myctx] on virtual server server
java.lang.RuntimeException: java.lang.UnsupportedOperationException
        at com.sun.enterprise.web.WebModuleListener.loadPersistenceUnits (WebModuleListener.java:193)
        at com.sun.enterprise.web.WebModuleListener.lifecycleEvent(WebModuleListener.java:168)
        at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java :143)
        at org.apache.catalina.core.StandardContext.start(StandardContext.java:5086)
        at com.sun.enterprise.web.WebModule.start(WebModule.java:327)
        at com.sun.enterprise.web.LifecycleStarter.doRun (LifecycleStarter.java:58)
        at com.sun.appserv.management.util.misc.RunnableBase.runSync(RunnableBase.java:296)
        at com.sun.appserv.management.util.misc.RunnableBase._submit(RunnableBase.java:168)
        at com.sun.appserv.management.util.misc.RunnableBase.submit(RunnableBase.java:184)
        at com.sun.enterprise.web.VirtualServer.startChildren(VirtualServer.java:1672)
        at org.apache.catalina.core.ContainerBase.start (ContainerBase.java:1231)
        at org.apache.catalina.core.StandardHost.start(StandardHost.java:955)
        at com.sun.enterprise.web.LifecycleStarter.doRun(LifecycleStarter.java:58)
        at com.sun.appserv.management.util.misc.RunnableBase.runSync (RunnableBase.java:296)
        at com.sun.appserv.management.util.misc.RunnableBase._submit(RunnableBase.java:168)
        at com.sun.appserv.management.util.misc.RunnableBase.submit(RunnableBase.java:184)
        at com.sun.enterprise.web.EmbeddedWebContainer$WebEngine.startChildren(EmbeddedWebContainer.java:453)
        at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1231)
        at org.apache.catalina.core.StandardEngine.start (StandardEngine.java:533)
        at org.apache.catalina.startup.Embedded.start(Embedded.java:936)
        at com.sun.enterprise.web.WebContainer.start(WebContainer.java:873)
        at com.sun.enterprise.web.PEWebContainer.startInstance (PEWebContainer.java:790)
        at com.sun.enterprise.web.PEWebContainerLifecycle.onStartup(PEWebContainerLifecycle.java:84)
        at com.sun.enterprise.server.ApplicationServer.onStartup(ApplicationServer.java:442)
        at com.sun.enterprise.server.ondemand.OnDemandServer.onStartup(OnDemandServer.java:120)
        at com.sun.enterprise.server.PEMain.run(PEMain.java:411)
        at com.sun.enterprise.server.PEMain.main(PEMain.java :338)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at com.sun.enterprise.server.PELaunch.main(PELaunch.java:412)
Caused by: java.lang.UnsupportedOperationException
        at java.util.Collections$UnmodifiableMap.remove(Collections.java:1289)
        at org.apache.openjpa.lib.conf.Configurations.removeProperty(Configurations.java:659)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory (PersistenceProviderImpl.java:118)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:55)
        at com.sun.enterprise.server.PersistenceUnitLoaderImpl.load (PersistenceUnitLoaderImpl.java:149)
        at com.sun.enterprise.server.PersistenceUnitLoaderImpl.load(PersistenceUnitLoaderImpl.java:84)
        at com.sun.enterprise.web.WebModuleListener.loadPersistenceUnits(WebModuleListener.java :190)
        ... 31 more",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160815,,,2008-01-19 00:52:23.0,,,,,,,0|i0zblj:,204181,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorect handling of temporal parameters in queries,OPENJPA-497,12386583,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,likewise,likewise,18/Jan/08 08:11,22/Apr/10 20:32,14/Mar/19 03:02,02/Aug/08 14:00,1.0.1,,,,,,,,,1.3.0,,,,,,,,,,,0,,"The entity:
For an entity:
@Entity
class Log{
	protected Timestamp startTime;
}
given the query
SELECT al FROM Log al WHERE al.startTime BETWEEN :start AND :end ORDER BY al.id ASC
If the query is used as:
query.setParameter(""start"", start, TemporalType.TIMESTAMP);
query.setParameter(""end"", end, TemporalType.TIMESTAMP);
where start and end are of type java.util.Date, an exception will be thrown:

org.apache.openjpa.persistence.ArgumentException: The parameter
""start"" is of type ""java.util.Date"", but the declaration in the query
is for type ""java.sql.Timestamp"".
	at org.apache.openjpa.persistence.QueryImpl.validateParameter(QueryImpl.java:270)
	at org.apache.openjpa.persistence.QueryImpl.validateParameters(QueryImpl.java:257)

OpenJPA appears to ignore the temporal indications in setParameter because QueryImpl is as this:
public OpenJPAQuery setParameter(int position, Date value,
   TemporalType type) {
   return setParameter(position, value);
}
The Date parameter should be converted to Timestamp inside setParameter method.","Java 1.6
Glassfish v2
openjpa-1.0.1-r420667",,,,,,,,,,,,,,,OPENJPA-457,,,,,,21/Jan/08 20:14;clr;openjpa-497.patch;https://issues.apache.org/jira/secure/attachment/12373699/openjpa-497.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-01-18 15:27:40.669,,,no_permission,,,,,,,,,,,160814,,,Mon Jan 21 20:14:08 UTC 2008,,,,,,,0|i1dqan:,288357,,,,,,,,"18/Jan/08 15:27;allee8285;java.sql.Timestamp extends java.util.Date.  You can use a Timestamp as if it is a Date object but not the other way around because there are other attributes in Timestamp object that  Date object does not have.  Declare start and end as java.sql.Timestamp and try again.

Albert Lee.","19/Jan/08 06:51;likewise;The query works as is in other JPA providers(Reference implementation, Hibernate). If not for conversion, what would be the purpose of that TemporalType param then? The reason of this conversion is to not have the business code depending on java.sql but rather on java.util.Date .

Mircea","19/Jan/08 17:17;clr;Hi Mircea,

I agree with your interpretation of the purpose of that TemporalType param. OpenJPA should convert the parameter given to the appropriate TemporalType.

Of course, it would be nice if the specification were a bit more discursive on this topic. And if the TCK had a test.","19/Jan/08 22:19;clr;This patch doesn't fix the problem but reorganizes the code for a fix.

The method convertTemporalType probably belongs in a utility package, but which one? It uses the TemporalType class which is defined in JPA but the implementation will depend on the JDBC type package. There doesn't seem to be any good place for the utility method. :-(

So, should convertTemporalType be moved to the JPA JDBC project, or should the method refer to utility functions in the JPA JDBC project? Or something else?

Index: trunk/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java
===================================================================
--- trunk/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java	(revision 613460)
+++ trunk/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java	(working copy)
@@ -416,15 +416,19 @@
     }
 
     public OpenJPAQuery setParameter(int position, Calendar value,
-        TemporalType t) {
-        return setParameter(position, value);
+        TemporalType type) {
+        return setParameter(position, convertTemporalType(value, type));
     }
 
     public OpenJPAQuery setParameter(int position, Date value,
         TemporalType type) {
-        return setParameter(position, value);
+        return setParameter(position, convertTemporalType(value, type));
     }
 
+    protected Object convertTemporalType(Object parameter, TemporalType type) {
+        return parameter;
+    }
+
     public OpenJPAQuery setParameter(int position, Object value) {
         _query.assertOpen();
         _em.assertNotCloseInvoked();

","21/Jan/08 20:14;clr;Please review this patch.

I don't know if the conversion method belongs here or in a different utility class. 

The specification is unclear as to what the appropriate conversions should be, but what's done here seems to be consistent with what other implementations do.

I haven't written any tests to check for correctness. Where should the tests go?",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Merging multiple sorted results missing ordering clauses ,OPENJPA-495,12386431,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,16/Jan/08 21:40,09/Mar/10 18:35,14/Mar/19 03:02,19/Jun/08 12:05,,,,,,,,,,,,,,,query,,,,,,0,,"Came across following error while merging multiple sorted result sets:

OrderingMergedResultObjectProvider uses QuereyExpressions.orderingClauses for its logic to merge results in order. However,  QuereyExpressions.orderingClauses never gets populated while building the expression by parsing the JPQL query in JPQLExpressionBuilder. 

The problem became apparent while merging query results from multiple databases. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160812,,,Thu Jun 19 12:05:45 UTC 2008,,,,,,,0|i0yy6v:,202009,,,,,,,,19/Jun/08 12:05;ppoddar@apache.org;Revision 612583,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Single Table Inheritance Strategy causes errors when reading entities from the database (discriminator problem),OPENJPA-494,12386359,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,corp,corp,16/Jan/08 09:31,09/Mar/10 18:32,14/Mar/19 03:02,17/Jul/08 12:50,1.0.0,1.0.1,1.1.0,,,,,,,1.2.0,,,,,,,,,,,0,,"It appears that versions from 1.0 don't handle correctly discriminating objects received from the datastore when the inheritance strategy is set to SINGLE_TABLE.

Error I receive from test cases (attached):

<openjpa-1.0.1-r420667:592145 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Cannot load object with id ""2"".  Instance ""jpa.Admin-2"" with the same id already exists in the L1 cache.  This can occur when you assign an existing id to a new instance, and before flushing attempt to load the existing instance for that id.
FailedObject: jpa.Admin-2

This problem doesn't occur in OpenJPA version 0.9.7.

Trace:
<openjpa-1.0.1-r420667:592145 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Cannot load object with id ""2"".  Instance ""jpa.Admin-2"" with the same id already exists in the L1 cache.  This can occur when you assign an existing id to a new instance, and before flushing attempt to load the existing instance for that id.
FailedObject: jpa.Admin-2
	at org.apache.openjpa.kernel.BrokerImpl$ManagedCache.add(BrokerImpl.java:4444)
	at org.apache.openjpa.kernel.BrokerImpl.setStateManager(BrokerImpl.java:3779)
	at org.apache.openjpa.kernel.StateManagerImpl.initialize(StateManagerImpl.java:303)
	at org.apache.openjpa.kernel.StateManagerImpl.initialize(StateManagerImpl.java:264)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:330)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:255)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:843)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:801)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:723)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.find(JDBCStoreManager.java:748)
	at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.load(RelationFieldStrategy.java:570)
	at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:802)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:485)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:2867)
	at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:2945)
	at org.apache.openjpa.kernel.StateManagerImpl.beforeAccessField(StateManagerImpl.java:1449)
	at org.apache.openjpa.kernel.StateManagerImpl.accessingField(StateManagerImpl.java:1434)
	at jpa.RegularUser.pcGetadmin(RegularUser.java)
	at jpa.RegularUser.getAdmin(RegularUser.java:16)
	at TestCase.testL1ProductEasier(TestCase.java:38)","Windows XP, Java 5.0 IBM",,,,,,,,,,,,,,,,,,,,,16/Jan/08 09:33;corp;SingleTableDiscriminatorProblem.zip;https://issues.apache.org/jira/secure/attachment/12373253/SingleTableDiscriminatorProblem.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-02-01 19:20:35.227,,,no_permission,,,,,,,,,,,160811,,,Thu Jul 17 12:50:03 UTC 2008,,,,,,,0|i0z253:,202649,,,,,,,,"16/Jan/08 09:33;corp;This is an Eclipse project with JUnit test that fails on this issue.

In order to run the tests:
1. Add OpenJPA libraries to the build path.
2. Change the path in the build.properties file.
3. Run enchanceWorkspaceAndDeleteDB task from build.xml.
4. Run TestCase.","01/Feb/08 19:20;qeldroma;I'm not completely sure, as I don't pretend to understand all the code involved, but this seems to be caused by the patch for OPENJPA-313.  Specifically, in the block of code starting at line 202 in org.apache.openjpa.jdbc.meta.ClassMapping you can see what changed as part of that patch.  If you set a breakpoint while running the failing test case attached here, you can see where everything looks good until we hit line 213 of ClassMapping.  At that point, the type changes from jpa.Admin to jpa.RegularUser.  It appears to me that this causes the Admin object to get loaded into the L1 cache with an incorrect oid, which causes problems later on.

cls.getDescribedType() in this same block of code returns the correct ""jpa.Admin"".

Changing this block of code back to the way it was before OPENJPA-313 fixes the problem described by this issue.

However, as I don't claim to fully understand the patch in question, I'm not sure if that causes other problems or if there is some other way to solve OPENJPA-313 without causing the problem shown here.","19/Jun/08 20:33;ppoddar@apache.org;The test case passes on trunk with both runtime and build-time enhanced entities.
Please reopen if the error continues to appear on trunk.",17/Jul/08 09:55;corp;I have tested it on release 1.1.0 and on nightly build from 17th of July and the problem persists.,17/Jul/08 10:09;corp;I have tried Russell's solution and it works.,"17/Jul/08 12:50;corp;It is resolved for trunk (1.2.0), I didn't notice that nightly build on webpage is not updated.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
openjpa.jdbc.Schema property set causes wrong SQL queries when reading OPENJPA_SEQUENCE_TABLE,OPENJPA-493,12386357,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,corp,corp,16/Jan/08 09:01,09/Mar/10 18:32,14/Mar/19 03:02,30/Sep/08 17:50,1.0.0,1.0.1,,,,,,,,1.0.3,1.2.0,,,,jdbc,,,,,,1,,"When openjpa.jdbc.Schema is defined inserting object into the database causes exception because of wrong SQL query generation.

In the sample openjpa.jdbc.Schema=""KB"", generates  SQL: SELECT SEQUENCE_VALUE FROM KB.KB.OPENJPA_SEQUENCE_TABLE WHERE ID = ? FOR UPDATE WITH RR.

This problem doesn't occur in version 0.9.7.

Trace:
<openjpa-1.0.1-r420667:592145 fatal store error> org.apache.openjpa.persistence.RollbackException: Attempt to update the sequence table ""OPENJPA_SEQUENCE_TABLE"" failed.  The sequence table is typically created when you run the mappingtool's refresh action on any datastore identity class. If you have not run the mappingtool but want to create the sequence table, run:
java org.apache.openjpa.jdbc.kernel.TableJDBCSeq -action add
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:419)
	at TestCase.testL1ProductEasier(TestCase.java:30)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at org.junit.internal.runners.TestMethodRunner.executeMethodBody(TestMethodRunner.java:99)
	at org.junit.internal.runners.TestMethodRunner.runUnprotected(TestMethodRunner.java:81)
	at org.junit.internal.runners.BeforeAndAfterRunner.runProtected(BeforeAndAfterRunner.java:34)
	at org.junit.internal.runners.TestMethodRunner.runMethod(TestMethodRunner.java:75)
	at org.junit.internal.runners.TestMethodRunner.run(TestMethodRunner.java:45)
	at org.junit.internal.runners.TestClassMethodsRunner.invokeTestMethod(TestClassMethodsRunner.java:66)
	at org.junit.internal.runners.TestClassMethodsRunner.run(TestClassMethodsRunner.java:35)
	at org.junit.internal.runners.TestClassRunner$1.runUnprotected(TestClassRunner.java:42)
	at org.junit.internal.runners.BeforeAndAfterRunner.runProtected(BeforeAndAfterRunner.java:34)
	at org.junit.internal.runners.TestClassRunner.run(TestClassRunner.java:52)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:38)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
Caused by: <openjpa-1.0.1-r420667:592145 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: Attempt to update the sequence table ""OPENJPA_SEQUENCE_TABLE"" failed.  The sequence table is typically created when you run the mappingtool's refresh action on any datastore identity class. If you have not run the mappingtool but want to create the sequence table, run:
java org.apache.openjpa.jdbc.kernel.TableJDBCSeq -action add
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3938)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:97)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:75)
	at org.apache.openjpa.jdbc.kernel.TableJDBCSeq.allocateSequence(TableJDBCSeq.java:371)
	at org.apache.openjpa.jdbc.kernel.TableJDBCSeq.nextInternal(TableJDBCSeq.java:266)
	at org.apache.openjpa.jdbc.kernel.AbstractJDBCSeq.next(AbstractJDBCSeq.java:60)
	at org.apache.openjpa.util.ImplHelper.generateValue(ImplHelper.java:160)
	at org.apache.openjpa.util.ImplHelper.generateFieldValue(ImplHelper.java:144)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.assignField(JDBCStoreManager.java:557)
	at org.apache.openjpa.util.ApplicationIds.assign(ApplicationIds.java:450)
	at org.apache.openjpa.util.ApplicationIds.assign(ApplicationIds.java:426)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.assignObjectId(JDBCStoreManager.java:541)
	at org.apache.openjpa.kernel.DelegatingStoreManager.assignObjectId(DelegatingStoreManager.java:134)
	at org.apache.openjpa.kernel.StateManagerImpl.assignObjectId(StateManagerImpl.java:501)
	at org.apache.openjpa.kernel.StateManagerImpl.preFlush(StateManagerImpl.java:2770)
	at org.apache.openjpa.kernel.PNewState.beforeFlush(PNewState.java:39)
	at org.apache.openjpa.kernel.StateManagerImpl.beforeFlush(StateManagerImpl.java:940)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1892)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1852)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1770)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1292)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:861)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:408)
	... 21 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: Syntax error: Encountered ""."" at line 1, column 33. {SELECT SEQUENCE_VALUE FROM KB.KB.OPENJPA_SEQUENCE_TABLE WHERE ID = ? FOR UPDATE WITH RR} [code=20000, state=42X01]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:201)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$000(LoggingConnectionDecorator.java:57)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:228)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:163)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:140)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:152)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:475)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:455)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:444)
	at org.apache.openjpa.jdbc.kernel.TableJDBCSeq.getSequence(TableJDBCSeq.java:467)
	at org.apache.openjpa.jdbc.kernel.TableJDBCSeq.setSequence(TableJDBCSeq.java:511)
	at org.apache.openjpa.jdbc.kernel.TableJDBCSeq.allocateSequence(TableJDBCSeq.java:368)
	... 41 more
","Windows XP, Java 5.0 IBM.",,,,,,,,,,,,,,,,,,,,,16/Jan/08 09:09;corp;SchemaPropertyProblem.zip;https://issues.apache.org/jira/secure/attachment/12373251/SchemaPropertyProblem.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-06-23 13:20:05.952,,,no_permission,,,,,,,,,,,160810,,,Tue Sep 30 17:50:19 UTC 2008,,,,,,,0|i0z24n:,202647,,,,,,,,"16/Jan/08 09:09;corp;This is a small Eclipse project with JUnit test that fails on this issue.

In order to run the tests:
1. Add OpenJPA libraries to the build path.
2. Change the path in the build.properties file.
3. Run enchanceWorkspaceAndDeleteDB task from build.xml.
4. Run TestCase.","23/Jun/08 13:20;kwsutter;We just hit a similar problem with a slightly different scenario.  In this case, we had specified a schema name on the @TableGenerator annotation and it resulted in the double schema name.  Commenting out the schema name allowed this particular test to work okay.

	@Id
	@GeneratedValue(strategy=GenerationType.TABLE, generator=""OrderSeq"")
	@TableGenerator(name=""OrderSeq"", table=""IDGENERATOR"", /* schema=""APP"",*/ pkColumnName=""IDNAME"", 
			pkColumnValue=""ORDER"", valueColumnName=""IDVALUE"")
	private String orderID;

Kevin","23/Jun/08 19:26;kwsutter;Looks like you need to specify both the @Table and @TableGenerator annotations with a schema name element to reproduce the problem.  I just updated the Dog.java Entity and ran the TestTableGenerator to reproduce the problem with the following changes to Dog.java:

@Entity
@Table(name=""Dog"", schema=""MY"")
public class Dog {
    @Id
    @TableGenerator(name = ""Dog_Gen"", table = ""ID_Gen"", schema=""MY"",
            pkColumnName = ""GEN_NAME"", valueColumnName = ""GEN_VAL"", 
            pkColumnValue = ""ID2"", initialValue = 20, allocationSize = 10)
    @GeneratedValue(strategy = GenerationType.TABLE, generator = ""Dog_Gen"")

I did this with the 1.0.x release.  ","30/Jun/08 22:19;techhusky;This problem was corrected in the revision 610427 update made in the 1.1.x and later code streams.  I back-ported the fix to 1.0.x and tested with the attached code and Kevin's code.  However, I ran across another schema-name related problem during testing and opened issue/subtask OPENJPA-648.  A patch for 1.0.x is attached to that issue which includes the rev. 610427 fix and the fix for the problem documented by 648.",30/Sep/08 17:50;techhusky;Fixed as part of subtask OPENJPA-648.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DB2Dictionary casts string data to VARCHAR(1000) regardless of data length,OPENJPA-489,12386336,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,16/Jan/08 01:55,09/Mar/10 18:32,14/Mar/19 03:02,16/Jan/08 03:51,1.0.0,1.0.1,,,,,,,,1.1.0,,,,,sql,,,,,,0,,"DB2Dictionary performs CASTs on string data (among other types). When CASTing a string, the value is cast to a VARCHAR(1000), which seems like it could be problematic if the underlying data is actually longer than 1000 characters.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160806,,,2008-01-16 01:55:24.0,,,,,,,0|i0z72n:,203448,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Generates syntactically wrong SQL query for JPQL that uses ORDER BY on TABLE_PER_CLASS inheritance hierarchy,OPENJPA-485,12386206,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,14/Jan/08 18:06,09/Mar/10 18:32,14/Mar/19 03:02,01/Aug/08 19:31,,,,,,,,,,1.2.0,1.3.0,,,,query,,,,,,0,,"Symptom:
Generates wrong SQL query 
   ""SELECT t1.id, t1.name, t0.name FROM  ORDER BY t0.name ASC""
for a JPQL Query 
   ""SELECT p FROM Base p ORDER BY p.name""

Condition:
    where Base class uses TABLE_PER_CLASS inheritance strategy and has one or more known subclasses.

Cause:
   The routine that fails to handle aliasing and leaves the table in FROM clause empty is JDBCStoreManager.selectBaseMappings() line 1028-1031. 


Note:
  Queries that do not use ORDER BY on the same class hierarchy such as
  ""SELECT p FROM Base [WHERE <some condition>]"" 
  works.



 

   ",,,,,,,,,,,,,,,,OPENJPA-481,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160803,,,Fri Aug 01 19:31:08 UTC 2008,,,,,,,0|i0zbif:,204167,,,,,,,,"01/Aug/08 19:31;ppoddar@apache.org;Fixed on trunk with revision 681781.

Merged to 1.2.0 with revision 681788.

The change has unintended but positive impact on 
a) previously failed test  on org\apache\openjpa\persistence\managedinterface\TestManagedInterfaces.java (OPENJPA-481)
b) it now supports traversal through a collection valued path expression. 
     SELECT s FROM Student s WHERE s.departments.name = 'XYZ' 
     will return Students whose any of the departments in 'XYZ'
     This is not kosher as per JPA Spec but apparently convenient for the user.
     See org\apache\openjpa\persistence\jpql\clauses\TestEJBClauses.java 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"H2Dictionary has 'useGetObjectForBlobs' set to true, which should be false",OPENJPA-484,12386057,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,prashantbhat,prashantbhat,11/Jan/08 15:31,09/Mar/10 18:32,14/Mar/19 03:02,20/Feb/08 22:48,1.0.1,1.1.0,,,,,,,,1.1.0,,,,,jdbc,sql,,,,,0,,"From H2 Database forum http://groups.google.com/group/h2-database/browse_thread/thread/fab7dd4424445c9b

H2Dictionary has 'useGetObjectForBlobs' set to true, whereas the default in DBDictionary is false. So for an entity with a property of type byte[] which is mapped as blob,  loading fails because, the 'getBytes' method uses 'rs.getObject(column);' which fails with the following exception:

Caused by: java.lang.ClassCastException: java.io.ByteArrayInputStream cannot be cast to [B
        at org.apache.openjpa.jdbc.sql.DBDictionary.getBytes(DBDictionary.java:531)
        at org.apache.openjpa.jdbc.sql.ResultSetResult.getBytesInternal(ResultSetResult.java:278)
        at org.apache.openjpa.jdbc.sql.ResultSetResult.getObjectInternal(ResultSetResult.java:404)
        at org.apache.openjpa.jdbc.sql.AbstractResult.getObject(AbstractResult.java:662)
        at org.apache.openjpa.jdbc.meta.strats.HandlerStrategies.loadDataStore(HandlerStrategies.java:205)
        at org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy.load(HandlerFieldStrategy.java:172)
        at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:796)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:841)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:793)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:483)
        at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:116)
        at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
        at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:2893)
        at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:2971)
        at org.apache.openjpa.kernel.StateManagerImpl.beforeAccessField(StateManagerImpl.java:1476)
        at org.apache.openjpa.kernel.StateManagerImpl.accessingField(StateManagerImpl.java:1461) 

I've tried setting 'useGetObjectForBlobs' to false(by just commenting it!), it is working. So please change this to false.
Thanks,","H2 Database - v1.0.64, Java SE6",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-02-20 21:35:18.36,,,no_permission,,,,,,,,,,,160802,,,Wed Feb 20 21:35:18 UTC 2008,,,,,,,0|i0z4mv:,203053,,,,,,,,"20/Feb/08 21:35;pcl;This can be worked around with the following configuration setting:

    <property name=""openjpa.jdbc.DBDictionary"" value=""UseGetObjectForBlobs=false""/>",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Queries against managed interfaces do not work in ""mixed interface"" configuration",OPENJPA-481,12385941,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,pcl,pcl,10/Jan/08 02:35,09/Mar/10 18:35,14/Mar/19 03:02,01/Aug/08 19:33,1.1.0,,,,,,,,,,,,,,kernel,sql,,,,,0,,"When using managed interfaces (see OPENJPA-147), if a persistence unit has a managed interface and a managed implementation of that interface, queries against the managed interface entity name will fail. See TestManagedInterfaces.testMixedQuery to reproduce.",,,,,,,,,,,,,,,,OPENJPA-486,OPENJPA-147,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-08-01 19:33:03.06,,,no_permission,,,,,,,,,,,160799,,,Fri Aug 01 19:33:03 UTC 2008,,,,,,,0|i1dqbz:,288363,,,,,,,,"10/Jan/08 02:46;pcl;This came up while porting the Kodo managed interface test cases to OpenJPA. I decided to file an issue and establish a test case (which consumes the failure currently, and which will begin failing if the problem is independently resolved) instead of chasing down the issue. This is a corner case of managed interface support.",01/Aug/08 19:33;ppoddar@apache.org;Fixing OPENJPA-485 has the unintended but postive side-effect of fixing the failed test case related to this case.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Contradictory text in manual section 10.2.6. JPQL GROUP BY, HAVING",OPENJPA-478,12385784,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,milosz,hazen,hazen,08/Jan/08 16:24,02/Feb/12 16:23,14/Mar/19 03:02,19/Mar/11 19:40,1.2.2,2.1.0,,,,,,,,2.2.0,,,,,docs,,,,,,0,,"In section 10.2.6. JPQL GROUP BY, HAVING (http://openjpa.apache.org/docs/latest/manual/jpa_langref.html#jpa_langref_group) the last paragraph seems contradictory:

""""""
If there is no GROUP BY clause and the HAVING  clause is used, the result is treated as a single group, and the select list can only consist of aggregate functions. When a query declares a HAVING clause, it must always also declare a GROUP BY clause.
""""""

The first sentences seems to imply that a query may incorporate a HAVING clause without a GROUP BY clause, but the second sentence indicates otherwise.

Looking at section 10.2.12 JPQL BNF (http://openjpa.apache.org/docs/latest/manual/jpa_langref.html#jpa_langref_bnf), it seems as though the BNF contradicts the last sentence:

""""""
select_statement ::= select_clause from_clause [where_clause] [groupby_clause] [having_clause] [orderby_clause]
""""""

otherwise the BNF would be something like this:

select_statement ::= select_clause from_clause [where_clause] [groupby_clause [having_clause]] [orderby_clause]","linux, firefox, etc..",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-06-08 08:00:24.168,,,no_permission,,,,,,,,,,,160796,,,Thu Feb 02 16:23:21 UTC 2012,,,,,,,0|i1dqcn:,288366,,,,,,,,"08/Jun/08 08:00;milosz;The JPA spec says:

""If there is no GROUP BY clause and the HAVING clause is used, the result is treated as a single group,
and the select list can only consist of aggregate functions. The use of HAVING in the absence of
GROUP BY is not required to be supported by an implementation of this speciﬁcation. Portable appli-
cations should not rely on HAVING without the use of GROUP BY.""

If OpenJPA does not allow HAVING without GROUP BY, the paragraph in question could be changed to something like:

""OpenJPA requires that if a query declares a HAVING clause, it must also declare a GROUP BY clause.""
",19/Mar/11 19:40;milosz;OpenJPA supports HAVING without GROUP BY and assumes the database also allows such a construct. The manual is updated.,02/Feb/12 16:23;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
iSeries DB2 problem with using @GeneratedValue(strategy=GenerationType.SEQUENCE ...) ,OPENJPA-472,12384986,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,kenm,kenm,19/Dec/07 18:40,09/Mar/10 18:32,14/Mar/19 03:02,10/Jan/08 07:07,1.0.1,,,,,,,,,1.0.2,1.1.0,,,,sql,,,,,,0,,"I get the following error when I try to insert new row to a table that uses sequence object for identity. 

<openjpa-1.0.1-r420667:592145 fatal store error> org.apache.openjpa.persistence.RollbackException: [SQL0029] INTO clause missing from embedded statement. {VALUES NEXTVAL FOR SEC_FAPKDMC} [code=-29, state=42601]
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:419)
	at xxx.xxx.xxx.xxx..main(JPA_test_03.java:66)
Caused by: <openjpa-1.0.1-r420667:592145 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: [SQL0029] INTO clause missing from embedded statement. {VALUES NEXTVAL FOR SEC_FAPKDMC} [code=-29, state=42601]
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3938)
	at org.apache.openjpa.jdbc.sql.DB2Dictionary.newStoreException(DB2Dictionary.java:464)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:97)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:83)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:59)
	at org.apache.openjpa.jdbc.kernel.AbstractJDBCSeq.next(AbstractJDBCSeq.java:65)
	at org.apache.openjpa.util.ImplHelper.generateValue(ImplHelper.java:160)
	at org.apache.openjpa.util.ImplHelper.generateFieldValue(ImplHelper.java:144)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.assignField(JDBCStoreManager.java:557)
	at org.apache.openjpa.util.ApplicationIds.assign(ApplicationIds.java:450)
	at org.apache.openjpa.util.ApplicationIds.assign(ApplicationIds.java:426)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.assignObjectId(JDBCStoreManager.java:541)
	at org.apache.openjpa.kernel.DelegatingStoreManager.assignObjectId(DelegatingStoreManager.java:134)
	at org.apache.openjpa.kernel.StateManagerImpl.assignObjectId(StateManagerImpl.java:501)
	at org.apache.openjpa.kernel.StateManagerImpl.preFlush(StateManagerImpl.java:2770)
	at org.apache.openjpa.kernel.PNewState.beforeFlush(PNewState.java:39)
	at org.apache.openjpa.kernel.StateManagerImpl.beforeFlush(StateManagerImpl.java:940)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1892)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1852)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1770)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1292)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:861)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:408)
	... 1 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: [SQL0029] INTO clause missing from embedded statement. {VALUES NEXTVAL FOR SEC_FAPKDMC} [code=-29, state=42601]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:201)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$000(LoggingConnectionDecorator.java:57)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:228)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:163)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:140)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:152)
	at org.apache.openjpa.jdbc.kernel.NativeJDBCSeq.getSequence(NativeJDBCSeq.java:274)
	at org.apache.openjpa.jdbc.kernel.NativeJDBCSeq.nextInternal(NativeJDBCSeq.java:211)
	at org.apache.openjpa.jdbc.kernel.AbstractJDBCSeq.next(AbstractJDBCSeq.java:60)
	... 19 more

I have the following in persistence.xml 

<property name=""openjpa.jdbc.DBDictionary"" value=""db2""/> 
<property name=""openjpa.ConnectionDriverName"" value=""com.ibm.as400.access.AS400JDBCDriver""/> 

I was able to fix the problem by modifying the following code. 

I added: 
nextSequenceQuery = ""SELECT NEXTVAL FOR {0} FROM ""
            + ""SYSIBM.SYSDUMMY1""; 

to: 
package: org.apache.openjpa.jdbc.sql 
Class: DB2Dictionary
method: public void connectedConfiguration(Connection conn) throws SQLException 

right after the code: 
case db2ISeriesV5R4OrLater: 

iSeries that have earlier versions might have the same problem. 
If there is a problem, the same code should probably be added to ""case db2ISeriesV5R3OrEarlier: "" section. 

I'm new to OpenJPA, so it will be great if some one can verify that the fix was done appropriately. 

Thank you, 

Ken Maruyama 
","iSeries V5R4, DB2, jt400.jar ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-01-10 07:07:52.173,,,no_permission,,,,,,,,,,,160791,,,Thu Jan 10 07:07:52 UTC 2008,,,,,,,0|i0zbk7:,204175,,,,,,,,10/Jan/08 07:07;fancy;fixed under svn r610697,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
iSeries DB2 problem with using @GeneratedValue(strategy=GenerationType.IDENTITY),OPENJPA-471,12384980,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,kenm,kenm,19/Dec/07 18:04,09/Mar/10 18:32,14/Mar/19 03:02,10/Jan/08 07:06,1.0.1,,,,,,,,,1.0.2,1.1.0,,,,sql,,,,,,0,,"I get the following error when I try to insert new row to a table that has Identity Column.

Caused by: <openjpa-1.0.1-r420667:592145 fatal general error> org.apache.openjpa.persistence.PersistenceException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2107)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1954)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1852)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1770)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1292)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:861)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:408)
	... 1 more
Caused by: <openjpa-1.0.1-r420667:592145 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: [SQL0029] INTO clause missing from embedded statement. {VALUES(IDENTITY_VAL_LOCAL())} [code=-29, state=42601]
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3938)
	at org.apache.openjpa.jdbc.sql.DB2Dictionary.newStoreException(DB2Dictionary.java:464)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:97)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:83)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:59)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:75)
	at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:543)
	at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:105)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:89)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:514)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	... 8 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: [SQL0029] INTO clause missing from embedded statement. {VALUES(IDENTITY_VAL_LOCAL())} [code=-29, state=42601]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:201)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$000(LoggingConnectionDecorator.java:57)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:228)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:163)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:140)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:163)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1308)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:152)
	at org.apache.openjpa.jdbc.sql.DBDictionary.getGeneratedKey(DBDictionary.java:3770)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:120)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:73)
	... 14 more

I have the following in persistence.xml

<property name=""openjpa.jdbc.DBDictionary"" value=""db2""/>
<property name=""openjpa.ConnectionDriverName"" value=""com.ibm.as400.access.AS400JDBCDriver""/>

I was able to fix the problem by modifying the following code.

I added:
lastGeneratedKeyQuery = ""SELECT IDENTITY_VAL_LOCAL() FROM ""
            + ""SYSIBM.SYSDUMMY1"";

to:
package: org.apache.openjpa.jdbc.sql
Class: DB2Dictionary
method: public void connectedConfiguration(Connection conn) throws SQLException

right after the code:
case db2ISeriesV5R4OrLater:

iSeries that have earlier versions might have the same problem.
If there is a problem, the same code should probably be added to ""case db2ISeriesV5R3OrEarlier: "" section.

I'm new to OpenJPA, so it will be great if some one can verify that the fix was done appropriately.

Thank you,

Ken Maruyama
","iSeries V5R4, DB2, jt400.jar",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-01-10 07:06:37.112,,,no_permission,,,,,,,,,,,160790,,,Thu Jan 10 07:06:37 UTC 2008,,,,,,,0|i0zbj3:,204170,,,,,,,,10/Jan/08 07:06;fancy;fixed under svn r610697 ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Custom sequences specified via @SequenceGenerator must have parentheses at the end of the class name,OPENJPA-470,12384952,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,19/Dec/07 11:35,09/Mar/10 18:32,14/Mar/19 03:02,16/Jul/08 05:32,0.9.0,0.9.6,0.9.7,1.0.0,1.0.1,,,,,1.2.0,,,,,jpa,,,,,,0,,"When specifying a custom sequence to use via the @SequenceGenerator annotation, the class name specified in the sequenceName field must have open and close parentheses at the end of it. If no parentheses are present, OpenJPA assumes that the sequence name is the name of a sequence in the database, not a classname to use.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-07-16 05:32:09.687,,,no_permission,,,,,,,,,,,160789,,,Wed Jul 16 05:32:09 UTC 2008,,,,,,,0|i0zbbj:,204136,,,,,,,,16/Jul/08 05:32;ppoddar@apache.org;This was mentioned in the documentation (Section 6. Generators). Highlighted it using blockquotes.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Primary key constraint violated using (Oracle) sequence to generate ID in multithreaded app,OPENJPA-466,12384540,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,milosz,frankca,frankca,13/Dec/07 02:40,09/Mar/10 18:31,14/Mar/19 03:02,31/Oct/09 21:13,1.0.0,1.0.1,1.1.0,1.2.0,,,,,,1.0.4,1.2.2,1.3.0,2.0.0-M3,,,,,,,,5,,"Here's how I annotate the ID:
    @Id
    @SequenceGenerator(name = ""FooSeq"", sequenceName = ""seq_foo"", allocationSize = 20)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = ""FooSeq"")
    private Long id;

Here's how I create the (Oracle) sequence:
CREATE SEQUENCE seq_foo START WITH 1 INCREMENT BY 1;

I get a primary key unique constraint violated in a multithreaded app i.e. it doesn't happen in single-threaded!

You can simply reproduce this error by either create blocking queue or blocking thread pool say size 5 to insert 10000+ object.
","OpenJPA 1.0.0 (also tried 1.0.1 and 1.1.0-SNAPSHOT)
Oracle XE 10g (JDBC driver 10.2.0.3.0)
Windows XP Pro",,,,,,,,,,,,,,,,,,,,,19/Oct/09 17:15;ppoddar@apache.org;GeneratedIdObject.java;https://issues.apache.org/jira/secure/attachment/12422577/GeneratedIdObject.java,24/Aug/09 21:08;bjreed;OPENJPA-466-1.0.x.patch;https://issues.apache.org/jira/secure/attachment/12417527/OPENJPA-466-1.0.x.patch,24/Aug/09 21:08;bjreed;OPENJPA-466-1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12417528/OPENJPA-466-1.2.x.patch,12/Jul/09 15:14;mcconne;OPENJPA-466-SYNCRONIZED.patch;https://issues.apache.org/jira/secure/attachment/12413238/OPENJPA-466-SYNCRONIZED.patch,27/Apr/09 08:21;milosz;OPENJPA-466.patch;https://issues.apache.org/jira/secure/attachment/12406496/OPENJPA-466.patch,17/Feb/09 02:40;mcconne;OPENJPA-466.patch;https://issues.apache.org/jira/secure/attachment/12400305/OPENJPA-466.patch,19/Oct/09 17:15;ppoddar@apache.org;TestSequenceGenerationOnMT.java;https://issues.apache.org/jira/secure/attachment/12422576/TestSequenceGenerationOnMT.java,21/May/09 16:58;milosz;volatile.patch;https://issues.apache.org/jira/secure/attachment/12408717/volatile.patch,,,,,,,8.0,,,,,,,,,,,,,,,,,,,2008-02-25 22:33:00.086,,,no_permission,,,,,,,,,,,41868,,,Sat Oct 31 21:13:01 UTC 2009,,,Patch Available,,,,0|i0yvk7:,201583,,,,,,,,25/Feb/08 22:33;gmarkham;I've seen the same behavior using postgresql 8.2/8.3 and sequences and openjpa 1.0.1 and 1.0.2.,03/Feb/09 11:15;jpullen;is this issue resolved ? its pretty old and I am experiencing a similar error with version 1.2.0 and the priority is Blocker ?,"05/Feb/09 02:20;mcconne;Hi Joe, I'm trying to replicate the failure so that I can fix this problem. However, I'm still unable to reproduce it. Are you only seeing it fail in a multi-threaded application ?? And if so, are both threads connected to the same database and/or using the same sequence ?? Thanks for any additional information. ","09/Feb/09 11:42;jpullen;Hi Tim,

Definately get the issue in a WebLogic multithreaded enviroment with 11g (RAC). The version of  OpenJPA used is 1.2.0.
The issues comes with more load (25-100 TPS). The application has about 25 entities all using seqs on the primary key.
The error is always on the flush. The seq cache is set to 100.

The test cases are not mutilthreaded in our app, but maybe I try to get a working, or is that non working ;-) test.
Do you have ideas where the problem lies ?","10/Feb/09 21:22;mcconne;Hi Joe, I think I'm finally able to replicate this error !! I haven't run it yet on Oracle, but I'm consistently able to get this failure using postgresql. Does this look similar to the error you're getting in Oracle ?? 

Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:742775 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: ERROR: duplicate key value violates unique constraint ""entity_employee_pkey"" {prepstmnt 17832855 INSERT INTO ENTITY_EMPLOYEE (id, firstName, lastName, salary) VALUES (?, ?, ?, ?) [params=(int) 273350, (String) First_name_1628, (String) Last_name_1628, (float) 1628.0]} [code=0, state=23505]
",11/Feb/09 02:25;ppoddar@apache.org;Is openjpa.Multithreaded configuration property is set to 'true'? ,"11/Feb/09 04:39;mcconne;Hi Pinaki, in my postgresql testcase I'm setting the openjpa.Multithreaded property in the setup() mehtod as below. Does this look correct ??

    public void setUp() {
        setUp(EntityPerson.class, 
                EntityEmployee.class, 
        	CLEAR_TABLES, ""openjpa.Multithreaded"", ""true"");
    }

","11/Feb/09 11:45;joepullen;Hi Tim,

Looks similar to mine from oracle.

]]></stack><cause><stack><![CDATA[      <openjpa-1.2.0-r422266:683325 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: ORA-00001: unique constraint (P
OR.DSTA_PK) violated
 {prepstmnt 97 INSERT INTO DIA_STATUSES (DSTA_ID, APPLICATION_ID, COMPONENT_NAME, STATUS_LEVEL, REFERENCE_ID, SOFTWARE_VERSION, TIME_STAMP, VERSION, DATE_CREATED, CREATED_BY, DAT
E_MODIFIED, MODIFIED_BY, PPPC_ID, PPRC_ID) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) [params=(long) 230503, (String) JTX, (String) input, (short) 1, (null) null, (String)
 19-60-08, (Timestamp) 2009-02-10 17:15:05.49, (int) 1, (Timestamp) 2009-02-10 17:15:05.493, (String) weblogic, (Timestamp) 2009-02-10 17:15:05.493, (String) weblogic, (null) nul
l, (null) null]} [code=1, state=23000]
        at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4238)
        at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4203)
        at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
        at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:72)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:131)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:89)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:72)
        at org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager.flushPrimaryRow(OperationOrderUpdateManager.java:203)
        at org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:89)
        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:89)
        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:655)
    ",11/Feb/09 11:45;joepullen;tried with the openjpa.Multithreaded  as true for oracle and didnt help,"12/Feb/09 00:51;mcconne;Hi again Joe, I can now replicate the problem on both postgresql and oracle databases. Here is the error I get on oracle. Now, I will determine the cause for each. Thanks for your help.....

Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:743437M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: ORA-00001: unique constraint (SYSTEM.SYS_C004001) violated
 {prepstmnt 30673895 INSERT INTO ENTITY_PERSON (id, firstName, lastName) VALUES (?, ?, ?) [params=(int) 15662, (String) First_name_1011, (String) Last_name_1011]} [code=1, state=23000]
FailedObject: org.apache.openjpa.persistence.hightps.sequence.EntityPerson@114c8b6
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4244)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4209)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:72)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:127)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.batchOrExecuteRow(BatchingPreparedStatementManagerImpl.java:100)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushAndUpdate(BatchingPreparedStatementManagerImpl.java:84)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:93)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:81)
	at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:549)
	at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:106)
	at org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager.flush(BatchingConstraintUpdateManager.java:59)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:89)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:630)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	... 15 more
","16/Feb/09 15:17;mcconne;Failure for DB2 below. This was to demonstrate that it is not just a Oracle and PostgreSQL problem. There seems to be a thread-safe problem in OpenJPA for all databases that support native Sequences.

testMultiThreadedLoad(org.apache.openjpa.persistence.hightps.sequence.TestSequence)  Time elapsed: 178.797 sec  <<< ERROR!
org.apache.openjpa.persistence.hightps.sequence.TestSequence$ThreadingException: The 3 embedded errors occured in the execution of 8 iterations of 6 threads: [reflection invocation: (testMultiThreadedLoad)]
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence.mttest(TestSequence.java:466)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence.mttest(TestSequence.java:360)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence.mttest(TestSequence.java:310)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence.mttest(TestSequence.java:304)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence.testMultiThreadedLoad(TestSequence.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.PersistenceTestCase.runBare(PersistenceTestCase.java:443)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:173)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
	at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:334)
	at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:980)
Nested Throwable #1: org.apache.openjpa.persistence.hightps.sequence.TestSequence$ThreadingException: thread=Thread[reflection invocation: (testMultiThreadedLoad) [5 of 6],5,main];threadNum=5;maxThreads=6;iteration=1;maxIterations=8
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence$2.run(TestSequence.java:429)
Nested Throwable #1: java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence$1.run(TestSequence.java:363)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence$2.run(TestSequence.java:422)
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:743836M fatal store error> org.apache.openjpa.persistence.RollbackException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:530)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence.createManyPersonsInSeparateTransactions(TestSequence.java:134)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence.testMultiThreadedLoad(TestSequence.java:261)
	... 6 more
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:743836M fatal general error> org.apache.openjpa.persistence.PersistenceException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2264)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2111)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2009)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1927)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1451)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:895)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:519)
	... 8 more
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:743836M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: One or more values in the INSERT statement, UPDATE statement, or foreign key update caused by a DELETE statement are not valid because the primary key, unique constraint or unique index identified by ""1"" constrains table ""DB2ADMIN.ENTITY_PERSON"" from having duplicate rows for those columns.
FailedObject: prepstmnt 30057146 INSERT INTO ENTITY_PERSON (id, firstName, lastName) VALUES (?, ?, ?) [org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement]
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4244)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4209)
	at org.apache.openjpa.jdbc.sql.DB2Dictionary.newStoreException(DB2Dictionary.java:507)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:72)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushBatch(BatchingPreparedStatementManagerImpl.java:193)
	at org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager.flush(BatchingConstraintUpdateManager.java:63)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:89)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:630)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	... 15 more
Caused by: com.ibm.db2.jcc.b.SQLException: One or more values in the INSERT statement, UPDATE statement, or foreign key update caused by a DELETE statement are not valid because the primary key, unique constraint or unique index identified by ""1"" constrains table ""DB2ADMIN.ENTITY_PERSON"" from having duplicate rows for those columns.
	at com.ibm.db2.jcc.b.ce.d(ce.java:975)
	at com.ibm.db2.jcc.a.bd.k(bd.java:312)
	at com.ibm.db2.jcc.a.bd.a(bd.java:61)
	at com.ibm.db2.jcc.a.r.a(r.java:64)
	at com.ibm.db2.jcc.a.bq.c(bq.java:217)
	at com.ibm.db2.jcc.b.cf.C(cf.java:1109)
	at com.ibm.db2.jcc.b.cf.a(cf.java:1505)
	at com.ibm.db2.jcc.b.cf.executeUpdate(cf.java:322)
	at org.apache.commons.dbcp.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:101)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:981)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1501)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.executeUpdate(PreparedStatementManagerImpl.java:249)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushSingleRow(BatchingPreparedStatementManagerImpl.java:215)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushBatch(BatchingPreparedStatementManagerImpl.java:154)
	... 20 more
Nested Throwable #2: org.apache.openjpa.persistence.hightps.sequence.TestSequence$ThreadingException: thread=Thread[reflection invocation: (testMultiThreadedLoad) [2 of 6],5,main];threadNum=2;maxThreads=6;iteration=1;maxIterations=8
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence$2.run(TestSequence.java:429)
Nested Throwable #1: java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence$1.run(TestSequence.java:363)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence$2.run(TestSequence.java:422)
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:743836M fatal store error> org.apache.openjpa.persistence.RollbackException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:530)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence.createManyPersonsAndEmployeesInSeparateTransactions(TestSequence.java:179)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence.testMultiThreadedLoad(TestSequence.java:267)
	... 6 more
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:743836M fatal general error> org.apache.openjpa.persistence.PersistenceException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2264)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2111)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2009)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1927)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1451)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:895)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:519)
	... 8 more
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:743836M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: The current transaction has been rolled back because of a deadlock or timeout.  Reason code ""2"".
FailedObject: prepstmnt 5148820 INSERT INTO ENTITY_EMPLOYEE (id, firstName, lastName, salary) VALUES (?, ?, ?, ?) [org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement]
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4244)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4209)
	at org.apache.openjpa.jdbc.sql.DB2Dictionary.newStoreException(DB2Dictionary.java:507)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:72)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushBatch(BatchingPreparedStatementManagerImpl.java:193)
	at org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager.flush(BatchingConstraintUpdateManager.java:63)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:89)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:630)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	... 15 more
Caused by: com.ibm.db2.jcc.b.SQLException: The current transaction has been rolled back because of a deadlock or timeout.  Reason code ""2"".
	at com.ibm.db2.jcc.b.ce.e(ce.java:1093)
	at com.ibm.db2.jcc.a.bd.s(bd.java:678)
	at com.ibm.db2.jcc.a.bd.k(bd.java:335)
	at com.ibm.db2.jcc.a.bd.a(bd.java:61)
	at com.ibm.db2.jcc.a.r.a(r.java:64)
	at com.ibm.db2.jcc.a.bq.c(bq.java:217)
	at com.ibm.db2.jcc.b.cf.C(cf.java:1109)
	at com.ibm.db2.jcc.b.cf.a(cf.java:1505)
	at com.ibm.db2.jcc.b.cf.executeUpdate(cf.java:322)
	at org.apache.commons.dbcp.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:101)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:981)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1501)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.executeUpdate(PreparedStatementManagerImpl.java:249)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushSingleRow(BatchingPreparedStatementManagerImpl.java:215)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushBatch(BatchingPreparedStatementManagerImpl.java:154)
	... 20 more
Nested Throwable #3: org.apache.openjpa.persistence.hightps.sequence.TestSequence$ThreadingException: thread=Thread[reflection invocation: (testMultiThreadedLoad) [4 of 6],5,main];threadNum=4;maxThreads=6;iteration=1;maxIterations=8
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence$2.run(TestSequence.java:429)
Nested Throwable #1: java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence$1.run(TestSequence.java:363)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence$2.run(TestSequence.java:422)
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:743836M fatal store error> org.apache.openjpa.persistence.RollbackException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:530)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence.createManyPersonsAndEmployeesInSeparateTransactions(TestSequence.java:179)
	at org.apache.openjpa.persistence.hightps.sequence.TestSequence.testMultiThreadedLoad(TestSequence.java:267)
	... 6 more
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:743836M fatal general error> org.apache.openjpa.persistence.PersistenceException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2264)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2111)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2009)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1927)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1451)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:895)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:519)
	... 8 more
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:743836M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: The current transaction has been rolled back because of a deadlock or timeout.  Reason code ""2"".
FailedObject: prepstmnt 6639365 INSERT INTO ENTITY_EMPLOYEE (id, firstName, lastName, salary) VALUES (?, ?, ?, ?) [org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement]
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4244)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4209)
	at org.apache.openjpa.jdbc.sql.DB2Dictionary.newStoreException(DB2Dictionary.java:507)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:72)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushBatch(BatchingPreparedStatementManagerImpl.java:193)
	at org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager.flush(BatchingConstraintUpdateManager.java:63)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:89)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:630)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	... 15 more
Caused by: com.ibm.db2.jcc.b.SQLException: The current transaction has been rolled back because of a deadlock or timeout.  Reason code ""2"".
	at com.ibm.db2.jcc.b.ce.e(ce.java:1093)
	at com.ibm.db2.jcc.a.bd.s(bd.java:678)
	at com.ibm.db2.jcc.a.bd.k(bd.java:335)
	at com.ibm.db2.jcc.a.bd.a(bd.java:61)
	at com.ibm.db2.jcc.a.r.a(r.java:64)
	at com.ibm.db2.jcc.a.bq.c(bq.java:217)
	at com.ibm.db2.jcc.b.cf.C(cf.java:1109)
	at com.ibm.db2.jcc.b.cf.a(cf.java:1505)
	at com.ibm.db2.jcc.b.cf.executeUpdate(cf.java:322)
	at org.apache.commons.dbcp.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:101)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:981)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1501)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.executeUpdate(PreparedStatementManagerImpl.java:249)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushSingleRow(BatchingPreparedStatementManagerImpl.java:215)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushBatch(BatchingPreparedStatementManagerImpl.java:154)
	... 20 more","17/Feb/09 02:40;mcconne;The attached patch provides a testcase to demonstrate the failure on both PostgreSQL and Oracle, and likewise provides a fix for both PostgreSQL and Oracle. I would suggest that it be applied to both Trunk and the 1.2.x branch. Thanks","24/Feb/09 19:43;joepullen;Hi Tim, thanks for the patch I can guarantee to anyone who is using OpenJPA with a larger configuration (4 solaris machines with 24 core each) and oracle sequences that this patch is a MUST.
After testing with the patch our problems with duplicate pk from sequences have disappeared. Also the patch doesnt seem to have a major impact on performance.","26/Feb/09 15:27;mcconne;HI Joe, that's wonderful new !! Thanks much for verifying that it does it fact work for your configuration.....",28/Feb/09 03:04;mcconne;Closing since we now have verification that it fixes the problem.,"30/Mar/09 17:49;milosz;Although the patch applied (synchronization on PreparedStatement within NativeJDBCSeq.getSequence) does a good job on reducing the likelihood of crash, I am afraid we are still not free from multi-threading issue. On my one-core laptop I am not able to reproduce this issue (even when I remove the patch) but I find the problem still exists in the AbstractJDBCSeq.next method. I am able to reproduce the exception when I insert Thread.yield():

    public Object next(StoreContext ctx, ClassMetaData meta) {
        JDBCStore store = getStore(ctx);
        try {
            current = nextInternal(store, (ClassMapping) meta);
            Thread.yield();
            return current;
        } catch (OpenJPAException ke) {
            throw ke;
        } catch (SQLException se) {
            throw SQLExceptions.getStore(se, store.getDBDictionary());
        } catch (Exception e) {
            throw new StoreException(e);
        }
    }

This yield() simulates context switching in an real application. The context switch will actually seldom occur here but is possible to my knowledge. Also, I am able to reproduce the exception by adding some Thread.sleep calls instead of yield() but this is harder to reproduce.

My suggestion is to remove the synchronization from NativeJDBCSeq.getSequence and modify AbstractJDBCSeq.next to something like the following:

    public Object next(StoreContext ctx, ClassMetaData meta) {
        JDBCStore store = getStore(ctx);
        try {
                Object currentLocal = nextInternal(store, (ClassMapping) meta);
                current = currentLocal;
                return currentLocal;
        } catch (OpenJPAException ke) {
            throw ke;
        } catch (SQLException se) {
            throw SQLExceptions.getStore(se, store.getDBDictionary());
        } catch (Exception e) {
            throw new StoreException(e);
        }
    }
","27/Apr/09 08:21;milosz;The attached patch implements my suggestion. I think this is a better solution than we currently have because:
- the multi-threading problem will be completely avoided to my knowledge
- by removing synchronization from PreparedStatement execution we gain a bit of scalability.

I am going to commit it unless somebody has objection.
","12/May/09 18:04;milosz;I have applied the patch to trunk and 1.3.x branch.
","13/May/09 22:56;mcconne;Hi Milosz, It's a little unclear to me how these changes will prevent duplicate sequence values. And actually, I can easily create duplicates with these changes in trunk using the postgreSQL database (by altering the number of entities created in the TestSequence testcase). See the error/exception messages below and look for ""duplicate key value violates unique constraint"", which is indicative of duplicate sequences getting created. This appears to be a regression as these exceptions were eliminated using the previous patch.....

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running org.apache.openjpa.persistence.sequence.TestSequence
359  test  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.PostgresDictionary"" (PostgreSQL 8.3.6 ,PostgreSQL Native Driver PostgreSQL 8.3 JDBC3 with SSL (build 603)).
1406  test  INFO   [reflection invocation: (testMultiThreadedNativeSequences) [6 of 6]] openjpa.Runtime - Starting OpenJPA 2.0.0-SNAPSHOT
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 361.859 sec <<< FAILURE!
testMultiThreadedNativeSequences(org.apache.openjpa.persistence.sequence.TestSequence)  Time elapsed: 361.765 sec  <<< ERROR!
org.apache.openjpa.persistence.sequence.TestSequence$ThreadingException: The 1 embedded errors occured in the execution of 8 iterations of 6 threads: [reflection invocation: (testMultiThreadedNativeSequences)]
	at org.apache.openjpa.persistence.sequence.TestSequence.mttest(TestSequence.java:440)
	at org.apache.openjpa.persistence.sequence.TestSequence.mttest(TestSequence.java:334)
	at org.apache.openjpa.persistence.sequence.TestSequence.mttest(TestSequence.java:281)
	at org.apache.openjpa.persistence.sequence.TestSequence.mttest(TestSequence.java:275)
	at org.apache.openjpa.persistence.sequence.TestSequence.testMultiThreadedNativeSequences(TestSequence.java:66)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.PersistenceTestCase.runBare(PersistenceTestCase.java:465)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:181)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
	at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:345)
	at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009)
Nested Throwable #1: org.apache.openjpa.persistence.sequence.TestSequence$ThreadingException: thread=Thread[reflection invocation: (testMultiThreadedNativeSequences) [1 of 6],5,main];threadNum=1;maxThreads=6;iteration=2;maxIterations=8
	at org.apache.openjpa.persistence.sequence.TestSequence$2.run(TestSequence.java:405)
Nested Throwable #1: java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.openjpa.persistence.sequence.TestSequence$1.run(TestSequence.java:337)
	at org.apache.openjpa.persistence.sequence.TestSequence$2.run(TestSequence.java:398)
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:774393M fatal store error> org.apache.openjpa.persistence.RollbackException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:559)
	at org.apache.openjpa.persistence.sequence.TestSequence.createManyPersonsAndEmployeesInSeparateTransactions(TestSequence.java:191)
	at org.apache.openjpa.persistence.sequence.TestSequence.testMultiThreadedNativeSequences(TestSequence.java:78)
	... 6 more
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:774393M fatal general error> org.apache.openjpa.persistence.PersistenceException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2266)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2113)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2011)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1929)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1453)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:895)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:548)
	... 8 more
Caused by: <openjpa-2.0.0-SNAPSHOT-r422266:774393M fatal general error> org.apache.openjpa.persistence.PersistenceException: ERROR: duplicate key value violates unique constraint ""entity_employee_pkey"" {prepstmnt 24724157 INSERT INTO ENTITY_EMPLOYEE (id, firstName, lastName, salary) VALUES (?, ?, ?, ?) [params=(int) 256631, (String) 4_First_name_6912, (String) 4_Last_name_6912, (float) 6912.0]} [code=0, state=23505]
FailedObject: org.apache.openjpa.persistence.sequence.EntityEmployee@ff5a2b
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4383)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4342)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:102)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:72)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:141)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushAndUpdate(BatchingPreparedStatementManagerImpl.java:80)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:97)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:85)
	at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:550)
	at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:106)
	at org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager.flush(BatchingConstraintUpdateManager.java:59)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:103)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:76)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:672)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	... 15 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: ERROR: duplicate key value violates unique constraint ""entity_employee_pkey"" {prepstmnt 24724157 INSERT INTO ENTITY_EMPLOYEE (id, firstName, lastName, salary) VALUES (?, ?, ?, ?) [params=(int) 256631, (String) 4_First_name_6912, (String) 4_Last_name_6912, (float) 6912.0]} [code=0, state=23505]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:236)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$700(LoggingConnectionDecorator.java:69)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:1080)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:286)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:286)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1579)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.executeUpdate(PreparedStatementManagerImpl.java:246)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:116)
	... 25 more


Results :

Tests in error: 
  testMultiThreadedNativeSequences(org.apache.openjpa.persistence.sequence.TestSequence)

Tests run: 1, Failures: 0, Errors: 1, Skipped: 0

[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] There are test failures.
","14/May/09 14:48;kwsutter;Based on Tim's comments and test case failures, it doesn't look like this JIRA is completely resolved yet.  Milosz, please work with Tim to come to a common resolution.  Thanks.","14/May/09 18:47;milosz;Hi Tim, do you run the testcase on a multi-core CPU? What exactly is your change to the testcase?

I am looking into this and will let know about my findings next week. If I can't help, I will roll my patch back or merge the both patches.


","15/May/09 15:22;mcconne;Hi Milosz, what I did was change the number of Entities, and number of threads to try to emulate Joe's environment. Try these settings at these lines below. Also, make sure you're using a database that supports native sequences (i.e., nextSequenceQuery in the dictionary -- Derby for example, does not).

00042    private static final int NUMBER_ENTITIES = 30000;
00264    int iterations = 10;
00265    int threads = 12;
","21/May/09 16:58;milosz;Hi Tim, is it possible that you make the following tests?

1. Apply the volatile.patch, compile and run the test and see whether it changes anything.
2. If the above did not help, revert volatile.patch and try to reproduce the error on DB2 or Oracle, so we are sure it is not PostgreSQL fault.


","22/Jun/09 18:52;milosz;Maybe some volounteer could try reproducing this and if reproduced, try with volatile.patch. If not, I will restore the synchronization around PreparedStatement since I am not able to reproduce the issue with my system (Pentium M).
","08/Jul/09 18:37;mcconne;Hi Milosz, I'll apply your volatile patch later today and let you know what  happens. Note though that the failure can I can reproduce the problem on DB2, Oracle, and PostgreSQL -- it's certainly not isolated to PostgreSQL. Talk later....","12/Jul/09 16:05;mcconne;Hi Milosz, here is what I've done over the past couple days. I have two machines -- Windows XP, Windows 2003 -- each with MySQL (8.3 on one machine, 8.4 on the other machine), DB2 (8.2 and 9.5), and Oracle (10g on both) installed on them. To reproduce the original problem I use 25000 entities, 6 iterations, and 8 threads in the TestSequence test program. With these settings I can easily reproduce the failure on both machines on all three databases. Here are the results of the various patches attached to this JIRA. Note that I raised the number entities to 40000 to stress each patch (but still used 6 iterations and 8 threads):

1. Patch OPENJPA-466 (attached by you with the change to AbstractJDBCSeq.java): Failures on all three databases on both machines. Note that the failures manifest themselves differently on each database. For example the failures on PostgreSQL show up as 

ERROR: duplicate key value violates unique constraint 

on Oracle as: ORA-00001: unique constraint (SYSTEM.SYS_C008294) violated

and finally on DB2 as:  org.apache.openjpa.persistence.EntityExistsException: DB2 SQL error: SQLCODE: -803, SQLSTATE: 23505

2. Patch volite.patch only (i.e., no other patches used): Failures on all three databases on both machines

3. Patch OPENJPA-466-SYNCHRONIZED.patch only (which is a modified version of my original patch but is what was originally committed to trunk): Success on all three databases on both machines.

So here are my recommendations:

The OPENJPA-466-SYNCHRONIZED patch works in all scenarios that I've tested it in. More importantly, it fixed the original problem reported by the user, and has no adverse impact on performance. Please note as well that that user environment was an extremely large, high-volume, multi-threaded, multi-core installation. Not meaning to be overly brusque -- but it simply works in every scenario that it's been used it. Until or unless someone (other than me as I don't intend to spend any more time on this JIRA) can provide a scenario where it does not work it should be committed to trunk and retrofitted to all previous versions of OpenJPA, and any previously-committed patches should be reverted. Thanks much

","13/Jul/09 12:45;drwoods;Tim, not sure why you marked this as Resolved when your latest patch hasn't been committed yet.....","13/Jul/09 14:58;mikedd;I think we're up to date in trunk and 1.3.x now. Milosz, Frank  or Tim, if there are additional changes that need to be made please re-open the issue.

Thanks for the patches and the time you spend debugging this problem Tim. ","23/Jul/09 19:25;milosz;The volatile.patch was meant to be applied to what was on the trunk without any reverts so it is not a surprise that ""2. Patch volite.patch only (i.e., no other patches used): Failures on all three databases on both machines"".

I agree with applying the latest patch and resolving this. This is better that what we had before and it seems there is not enough interest in testing the patches.

I do state however we just hid a multi-threading bug that can bite us later.
",24/Aug/09 21:08;bjreed;Attached 2 patches to port necessary code back to 1.0.x and 1.2.x.,02/Sep/09 12:37;drwoods;add missing Fix versions of 1..0.4 and 1.2.2,"26/Sep/09 11:55;joepullen;Today came back to this issue get the patch and was surprised that after the first fix there was more discussion. Just wanted to say from my view the original patch from Tim did the job perfectly.

As Tim stated I can tell you that the original patch was def needed and helped solve a major issue with an application running on 4 T2000 Solaris machines (each with 64 cores, yes 256 cores !). This J2EE app has processed 10 millions of business transactions with throughput in peak of 100,000s business transactions (equals to 250,000 JTA and over a million SQL statements) per hour without a SINGLE duplicate primary key error related to sequences.
","19/Oct/09 17:12;ppoddar@apache.org;The issue of sequence value creation under multithreaded environment is still relevant. 
I ran a very simple tests that do the following 
1. A entity with @GeneratedValue primary key
2. 4 threads that persist() entities in separate persistence contexts

The test breaks with OPENJPA_SEQUENCE_TABLE being populated with duplicate key -- looks like a concurrency issue.",19/Oct/09 17:12;ppoddar@apache.org;The test was run onm MYSQL 5.3.,19/Oct/09 17:15;ppoddar@apache.org;A test and a entity to demonstrate the concurrency issue in sequence value generation.,"26/Oct/09 19:18;milosz;I confirm the issue although I had to modify the test to call em.persist in a loop and be a bit patient.

We are probably failing during OPENJPA_SEQUENCE_TABLE initialization, not during generating numbers from it.
","31/Oct/09 21:13;milosz;I will create a new issue for the sequence table problem as it is loosely coupled with the original issue. I guess the sequence table failure is the known problem where multiple threads access an uninitailized emf, it has been reported on the users mailing list.

"
Performance improvement with Statement Batching support,OPENJPA-464,12384438,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,tckan1,tckan1,11/Dec/07 22:03,09/Mar/10 18:32,14/Mar/19 03:02,07/Feb/08 22:53,1.1.0,,,,,,,,,1.1.0,,,,,kernel,,,,,,0,,"The current OpenJPA implementation did not provide the SQL statement batching. All SQL statements will be executed one statement at a time to the database. Consequently, the runtime performance was decreased due to lots of database flows. JDBC Specification provides the batch capability for insert, update and delete statements through the addBatch() and executeBatch() APIs. We should be able to take advantage of this capability to support SQL statement batching in OpenJPA.

According to the old version of the OpenJPA manual (i.e., Kodo), statement batching was part of the initial functions. Conscious decision by BEA that this function was not contributed back to OpenJPA. We can still use this info as the implementation base with some modifications. 

I have completed the work for this statement batching support and the patch has been tested by CTS against Derby and DB2, OPENJPA regression test as well as our internal FVT test bucket.  The following section describes the design and implementation info. I also attached the whole design documentation and the patch in this jira. Once the design and implementation are accepted, then I will update the OPENJPA manual to include this function. Thanks,

Design and implementation:
•	Configuration:
o	Batch Limit value: 
	0 - Disable batch support.
	-1 - Unlimited number of statements for a batch.
	Any positive number - Maximum number of statements for a batch.
o	By default, the batch support is based on each Dictionary to define the default batch limit. Currently only DB2 and Oracle dictionaries are set the default batch limit to 100. The default batch limit for rest of the dictionaries is set to zero (disabled).
o	To enable the batch support, user can specify the following property in the persistence.xml file:
<property name=""openjpa.jdbc.DBDictionary"" value=""BatchLimit=25""/>
or
<property name=""openjpa.jdbc.DBDictionary""
value=""db2(batchLimit=25)""/>


•	Basic design is to cache all the insert/update/delete statements during the execution of the PreparedStatementManagerImpl.flushInternal() method. There is a cache structure which uses the LinkHashMap to maintain the order of the SQL statements for execution:
o	_cacheSql - a LinkHashMap to store the rows that associate with one PrepareStatement. Key: SQL statement string; Value: array list of rows.

During the PreparedStatementManagerImpl.flush() process, it will go through the cache to prepare the SQL statement; add the statement to the batch; and execute the batch when the batch limit is reached or all the rows are processed for that statement. Validate the update count after the executeBatch() method.

•	If the batch limit =0 (disabled), execute the statement as the normal process; no need to use the batching process.  Same rule applies to the statement that only has one row, execute it as the normal process. 
•	The batch process will be disabled if the primary key generation is used the Identity strategy. When the GeneratedType=IDENTITY, we need to get the ID value right away for the in-memory entity to use. Therefore, we can't batch this kind of statement.
•	Batch exception process: a checkUpdateCount() is used to validate the batch process after the executeBatch(). According to the javadoc, there are three cases to consider:
o	Case of EXECUTE_FAILED: (-3): 
	This is a failure case. If the action is UPDATE or there is FailedObject, treats it as OptimisticException. Otherwise, throws the SQLException.
	This is the same process as current implementation.
o	Case of  SUCCESS_NO_INFO: (-2): 
	We treat this as successful case and log the info in the log.
o	Case of 0: 
	If there is a FailedObject or the action is INSERT, then throws the SQLException. Otherwise, treats it as successful case. 

",,,,,,,,,,,,,,,,,,,,,,13/Dec/07 22:13;tckan1;OPENJPA-464.patch;https://issues.apache.org/jira/secure/attachment/12371627/OPENJPA-464.patch,18/Jan/08 21:08;tckan1;OPENJPA-464.patch2;https://issues.apache.org/jira/secure/attachment/12373561/OPENJPA-464.patch2,29/Jan/08 17:59;tckan1;OPENJPA-464.patch3;https://issues.apache.org/jira/secure/attachment/12374276/OPENJPA-464.patch3,11/Dec/07 22:08;tckan1;statement batch design_1211.doc;https://issues.apache.org/jira/secure/attachment/12371461/statement+batch+design_1211.doc,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2007-12-18 19:05:12.433,,,no_permission,,,,,,,,,,,42089,,,Tue Apr 08 22:59:10 UTC 2008,,,,,,,0|i0z233:,202640,,,,,,,,"11/Dec/07 22:08;tckan1;Attach the design document and the patch. Basically changes are in :PreparedStatmentManagerImpl, DBDictionary, DB2Dictionary and OracleDictionary. 
Currenlty only DB2 and Oracle will take advantage of this support. If other databases which want to have this support, you can update the Dictionary to set batchLimit to some number. Follow the changes in the DB2 and Oracle Dictionaries.
",13/Dec/07 22:13;tckan1;Attach the patch including the OPENJPA documentation changes.,"18/Dec/07 19:05;mikedd;Hi Teresa,

A couple quick comments on the patch: 

1. The implementations of   getDefaultBatchLimit() for DB2Dictionary and OracleDictionary are slightly different. Further it looks like the DB2 dictionary doesn't allow the batchLimit to be set to UNLIMITED. Is that a known issue with DB2? If so we should add that to the documentation and possibly add a message indicating that we're overriding a user setting. 

On the other hand if this is not intended behavior then the dictionaries should be able to share a common method in DBDictionary. Ideally the subclass dictionaries would only need to set the default batch limit to some value, rather than re-implementing a method. 

2. Minor whitespace issue : 
+    }

+    

+

+    private void processSql(String sql, RowImpl row) throws SQLException {

+        ArrayList temprow;

3. Please add a comment to the empty catch block in the execute method : 
+            } catch (SQLException se) {

+            }

That's it for now. The only critical issue is the first one. ","09/Jan/08 16:43;tckan1;I redo the fix based on Pinaki's suggestion to use the UpdateManager plugin. Instead of extending from the AbstractUpdateManager, the BatchConstraintUpdateManager extends from the ConstraintUpdateManager:

public class BatchingConstraintUpdateManager
   extends ConstraintUpdateManager {

I also made this update manager as the default batch update manager. User can still plugin their own Batch mechanism through the property of  UpdateManager:

<property name=""openjpa.jdbc.UpdateManager"" 
     value=""org.apache.openjpa.jdbc.kernel.YourOperationOrderUpdateManager"" />  

","16/Jan/08 22:40;ppoddar@apache.org;Hello Teresa,
  Thank you for considering to separate batching logic in a separate UpdateManager.

  Comments on the patch
 1. Two separate methods on DBDictionary
    validateBatchProcess(...);
    validateDBSpecificBatchProcess(...)
    is not necessary.
    A single method validateBatchProcess(...) is sufficient.
    If specific database wants to augment or change the validation logic they should overwrite this method calling super.validateBatchProcess(...) if necessary. 
    
  2. A single 'batchLimit' should be able to account for different sitauations. Instead I see two separate varaibles and some logic that does not appear necessary. But I have not comb through it. May be you should elaborate what is the intention of BATCH_LIMIT_NOT_SET and defaultBatchLimit.

  3. As you are changing default UpdateManager, it may be worthwhile to mention in the document that alias 'constraint' will activate ConstraintUpdateManager","16/Jan/08 22:47;ppoddar@apache.org;I read your original posting again to see your usage of batch limit. 
Why not have a single batch limit bean-style property defined in DBDictionary?
Also in 
DBDictionary.validateBatchProcess() {
  if (getBatchLimit()<-1) return false;
  // other auto-assign logic
}

1. You will not require to define batch limit for individual database dictionaries
2. the concept of batch_limit_unset is not required. Just interpret any number less that -1 as an indication of switching off batching. Interpret -1 as maximum.","18/Jan/08 21:08;tckan1;Append the patch2 based on Pinaki's suggestion:
1) restructure the BatchingConstraintUpdateManager to extend ConstraintUpdateManager.
2) Default will be 0,but can be overriden by each DB Dictionary''s constructor. Currently only DB2Dictionary and OracleDictionary constructors have set the default limit to 100. The rest of the Dictionaries will be zero.

Thanks,
Teresa",29/Jan/08 17:59;tckan1;Provided the batching capability for the OperationOrderUpdateManager. Attach the patch for this support.,"08/Apr/08 22:59;yves.galante;On your document you write : 
""Batch exception process: a checkUpdateCount() is used to validate the batch process after the executeBatch().""
And after :
""Case of  SUCCESS_NO_INFO: (-2): We treat this as successful case and log the info in the log""

Oracle drivers return -2 :-((

We have 3 choices :
1)
Use bach update with Oracle only for Insert SQL command (if return -2 we can't having more than one insert all is rigth).
We need an others configuration parameter, one for update/delete and one for active insert batch mode.
2)
Use ""Oralce batching mode"", with special oracle class on the drivers ojdbc5.jar, this batching class return the correct number of rows updated. But we need oracle5.jar to building your projet :-((
3)
Execute an select for count the number of rows updated or deleted, with :
For update :
  select count(*) where id = XX and version = XX .
For delete
  select count(*) where id = XX

",,,,,,,,,,,,,,,,,,,,,,,,,,,,
OptimisticException is thrown instead of OptimisticLockException,OPENJPA-462,12384082,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ajay662,ajay662,06/Dec/07 14:56,02/Aug/08 14:02,14/Mar/19 03:02,16/Jul/08 02:37,0.9.7,,,,,,,,,1.2.0,,,,,,,,,,,0,,"In my application, i wanted to catch ""javax.persistence.OptimisticLockException"" and take appropriate action. However I am seeing that instead ""org.apache.openjpa.util.OptimisticException"" is being thrown. I don't want my code to become dependent on OpenJPA and would like to see OptimisticLockException thrown.

While discussing in the OpenJPA forums, Patrick suggested that I create a JIRA issue for this since its a bug.
You can see the discussion in the forum under title ""OptimisticException question"" few days ago.

Below is the stack trace from my application.

<Nov 30, 2007 9:50:53 AM EST> <Error> <EJB> <BEA-010026> <Exception occurred during commit of transaction Name=[EJB com.covergence.soa.covapi.sesscfg.SessionConfigBean.getSessionConfig(com.covergence.soa.utils.SerJavaSipMessageType)],Xid=BEA1-00001267875BE126CEB7(64273527),Status=Rolled back. [Reason=<2|false|0.9.7> org.apache.openjpa.util.OptimisticException: Optimistic locking errors were detected when flushing to the data store.  The following objects may have been concurrently modified in another transaction: [com.covergence.soa.covapi.userpolicy.User-com.covergence.soa.covapi.userpolicy.User-1]],numRepliesOwedMe=0,numRepliesOwedOthers=0,seconds since begin=2,seconds left=30,SCInfo[ajayProduction+AdminServer]=(state=rolledback),properties=({weblogic.transaction.name=[EJB com.covergence.soa.covapi.sesscfg.SessionConfigBean.getSessionConfig(com.covergence.soa.utils.SerJavaSipMessageType)]}),OwnerTransactionManager=ServerTM[ServerCoordinatorDescriptor=(CoordinatorURL=AdminServer+172.30.0.202:7001+ajayProduction+t3+admin+7001+,XAResources={WLStore_ajayProduction__WLS_AdminServer},NonXAResources={})],CoordinatorURL=AdminServer+172.30.0.202:7001+ajayProduction+t3+admin+7001+): weblogic.transaction.RollbackException: Optimistic locking errors were detected when flushing to the data store.  The following objects may have been concurrently modified in another transaction: [com.covergence.soa.covapi.userpolicy.User-com.covergence.soa.covapi.userpolicy.User-1]

        at weblogic.transaction.internal.TransactionImpl.throwRollbackException(TransactionImpl.java:1818)

        at weblogic.transaction.internal.ServerTransactionImpl.internalCommit(ServerTransactionImpl.java:333)

        at weblogic.transaction.internal.ServerTransactionImpl.commit(ServerTransactionImpl.java:227)

        at weblogic.ejb.container.internal.BaseRemoteObject.postInvoke1(BaseRemoteObject.java:606)

        at weblogic.ejb.container.internal.StatelessRemoteObject.postInvoke1(StatelessRemoteObject.java:57)

        at weblogic.ejb.container.internal.BaseRemoteObject.postInvokeTxRetry(BaseRemoteObject.java:426)

        at com.covergence.soa.covapi.sesscfg.SessionConfigBean_4w7egw_SessionConfigImpl.getSessionConfig(SessionConfigBean_4w7egw_SessionConfigImpl.java:76)

        at jrockit.reflect.VirtualNativeMethodInvoker.invoke(Ljava.lang.Object;[Ljava.lang.Object;)Ljava.lang.Object;(Unknown Source)

        at java.lang.reflect.Method.invoke(Ljava.lang.Object;[Ljava.lang.Object;I)Ljava.lang.Object;(Unknown Source)

        at weblogic.ejb.container.internal.RemoteBusinessIntfProxy.invoke(RemoteBusinessIntfProxy.java:63)

        at $Proxy67.getSessionConfig(Lcom.covergence.soa.utils.SerJavaSipMessageType;)Lcom.covergence.ws.callouts.SessionConfigType;(Unknown Source)

        at com.covergence.soa.ws.server.CallOutsImpl.getSessionConfigType(CallOutsImpl.java:46)

        at com.covergence.soa.ws.server.CallOutsImplBase.getSessionPolicy(CallOutsImplBase.java:238)

        at jrockit.reflect.VirtualNativeMethodInvoker.invoke(Ljava.lang.Object;[Ljava.lang.Object;)Ljava.lang.Object;(Unknown Source)

        at java.lang.reflect.Method.invoke(Ljava.lang.Object;[Ljava.lang.Object;I)Ljava.lang.Object;(Unknown Source)

        at weblogic.wsee.jaxws.WLSInvoker.invoke(WLSInvoker.java:50)

        at weblogic.wsee.jaxws.WLSInvoker.invoke(WLSInvoker.java:42)

        at com.sun.xml.ws.server.sei.EndpointMethodHandler.invoke(EndpointMethodHandler.java:247)

        at com.sun.xml.ws.server.sei.SEIInvokerPipe.process(SEIInvokerPipe.java:97)

        at weblogic.wsee.jaxws.MonitoringPipe.process(MonitoringPipe.java:98)

        at com.sun.xml.ws.protocol.soap.ServerMUPipe.process(ServerMUPipe.java:62)

        at com.sun.xml.ws.server.WSEndpointImpl$1.process(WSEndpointImpl.java:139)

        at com.sun.xml.ws.transport.http.HttpAdapter$HttpToolkit.handle(HttpAdapter.java:153)

        at com.sun.xml.ws.transport.http.HttpAdapter.handle(HttpAdapter.java:235)

        at com.sun.xml.ws.transport.http.servlet.ServletAdapter.handle(ServletAdapter.java:97)

        at weblogic.wsee.jaxws.HttpServletAdapter.post(HttpServletAdapter.java:36)

.>

javax.ejb.EJBException: nested exception is: <2|false|0.9.7> org.apache.openjpa.util.OptimisticException: Optimistic locking errors were detected when flushing

to the data store.  The following objects may have been concurrently modified in another transaction: [com.covergence.soa.covapi.userpolicy.User-com.covergence.

soa.covapi.userpolicy.User-1]<2|false|0.9.7> org.apache.openjpa.util.OptimisticException: Optimistic locking errors were detected when flushing to the data store.  The following objects may have been concurrently modified in another transaction: [com.covergence.soa.covapi.userpolicy.User-com.covergence.soa.covapi.userpolicy.User-1]

        at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2120)

        at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1970)

        at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1868)

        at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1786)

        at weblogic.transaction.internal.ServerSCInfo.doBeforeCompletion(ServerSCInfo.java:1212)

        at weblogic.transaction.internal.ServerSCInfo.callBeforeCompletions(ServerSCInfo.java:1190)

        at weblogic.transaction.internal.ServerSCInfo.startPrePrepareAndChain(ServerSCInfo.java:118)

        at weblogic.transaction.internal.ServerTransactionImpl.localPrePrepareAndChain(ServerTransactionImpl.java:1299)

        at weblogic.transaction.internal.ServerTransactionImpl.globalPrePrepare(ServerTransactionImpl.java:2111)

        at weblogic.transaction.internal.ServerTransactionImpl.internalCommit(ServerTransactionImpl.java:260)

        at weblogic.transaction.internal.ServerTransactionImpl.commit(ServerTransactionImpl.java:227)

        at weblogic.ejb.container.internal.BaseRemoteObject.postInvoke1(BaseRemoteObject.java:606)

        at weblogic.ejb.container.internal.StatelessRemoteObject.postInvoke1(StatelessRemoteObject.java:57)

        at weblogic.ejb.container.internal.BaseRemoteObject.postInvokeTxRetry(BaseRemoteObject.java:426)

        at com.covergence.soa.covapi.sesscfg.SessionConfigBean_4w7egw_SessionConfigImpl.getSessionConfig(SessionConfigBean_4w7egw_SessionConfigImpl.java:76)

        at jrockit.reflect.VirtualNativeMethodInvoker.invoke(Ljava.lang.Object;[Ljava.lang.Object;)Ljava.lang.Object;(Unknown Source)

        at java.lang.reflect.Method.invoke(Ljava.lang.Object;[Ljava.lang.Object;I)Ljava.lang.Object;(Unknown Source)

        at weblogic.ejb.container.internal.RemoteBusinessIntfProxy.invoke(RemoteBusinessIntfProxy.java:63)

        at $Proxy67.getSessionConfig(Lcom.covergence.soa.utils.SerJavaSipMessageType;)Lcom.covergence.ws.callouts.SessionConfigType;(Unknown Source)

        at com.covergence.soa.ws.server.CallOutsImpl.getSessionConfigType(CallOutsImpl.java:46)

Caused by: <2|false|0.9.7> org.apache.openjpa.util.OptimisticException: An optimistic lock violation was detected when flushing object instance ""com.covergence.soa.covapi.userpolicy.User-com.covergence.soa.covapi.userpolicy.User-1"" to the data store.  This indicates that the object was concurrently modified in anothertransaction.

FailedObject: com.covergence.soa.covapi.userpolicy.User-com.covergence.soa.covapi.userpolicy.User-1

        at kodo.jdbc.kernel.BatchingPreparedStatementManager.checkUpdate(BatchingPreparedStatementManager.java:354)

        at kodo.jdbc.kernel.BatchingPreparedStatementManager.flushInternal(BatchingPreparedStatementManager.java:208)

        at kodo.jdbc.kernel.BatchingPreparedStatementManager.flush(BatchingPreparedStatementManager.java:188)

        at kodo.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:90)

        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:86)

        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:69)

        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:511)

        at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:127)

        at org.apache.openjpa.datacache.DataCacheStoreManager.flush(DataCacheStoreManager.java:506)

        at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:127)

        at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1970)

        at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1868)

        at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1786)

        at weblogic.transaction.internal.ServerSCInfo.doBeforeCompletion(ServerSCInfo.java:1212)

        at weblogic.transaction.internal.ServerSCInfo.callBeforeCompletions(ServerSCInfo.java:1190)

        at weblogic.transaction.internal.ServerSCInfo.startPrePrepareAndChain(ServerSCInfo.java:118)

        at weblogic.transaction.internal.ServerTransactionImpl.localPrePrepareAndChain(ServerTransactionImpl.java:1299)

        at weblogic.transaction.internal.ServerTransactionImpl.globalPrePrepare(ServerTransactionImpl.java:2111)

        at weblogic.transaction.internal.ServerTransactionImpl.internalCommit(ServerTransactionImpl.java:260)

        at weblogic.transaction.internal.ServerTransactionImpl.commit(ServerTransactionImpl.java:227)

        at weblogic.ejb.container.internal.BaseRemoteObject.postInvoke1(BaseRemoteObject.java:606)

        at weblogic.ejb.container.internal.StatelessRemoteObject.postInvoke1(StatelessRemoteObject.java:57)

        at weblogic.ejb.container.internal.BaseRemoteObject.postInvokeTxRetry(BaseRemoteObject.java:426)

javax.ejb.EJBException: nested exception is: <2|false|0.9.7> org.apache.openjpa.util.OptimisticException: Optimistic locking errors were detected when flushing to the data store.  The following objects may have been concurrently modified in another transaction: [com.covergence.soa.covapi.userpolicy.User-com.covergence.soa.covapi.userpolicy.User-1]

        at weblogic.ejb.container.internal.RemoteBusinessIntfProxy.invoke(RemoteBusinessIntfProxy.java:78)

        at $Proxy67.getSessionConfig(Lcom.covergence.soa.utils.SerJavaSipMessageType;)Lcom.covergence.ws.callouts.SessionConfigType;(Unknown Source)

        at com.covergence.soa.ws.server.CallOutsImpl.getSessionConfigType(CallOutsImpl.java:46)

        at com.covergence.soa.ws.server.CallOutsImplBase.getSessionPolicy(CallOutsImplBase.java:238)

        at jrockit.reflect.VirtualNativeMethodInvoker.invoke(Ljava.lang.Object;[Ljava.lang.Object;)Ljava.lang.Object;(Unknown Source)

        at java.lang.reflect.Method.invoke(Ljava.lang.Object;[Ljava.lang.Object;I)Ljava.lang.Object;(Unknown Source)

        at weblogic.wsee.jaxws.WLSInvoker.invoke(WLSInvoker.java:50)

        at weblogic.wsee.jaxws.WLSInvoker.invoke(WLSInvoker.java:42)

        at com.sun.xml.ws.server.sei.EndpointMethodHandler.invoke(EndpointMethodHandler.java:247)

        at com.sun.xml.ws.server.sei.SEIInvokerPipe.process(SEIInvokerPipe.java:97)

        at weblogic.wsee.jaxws.MonitoringPipe.process(MonitoringPipe.java:98)

        at com.sun.xml.ws.protocol.soap.ServerMUPipe.process(ServerMUPipe.java:62)

        at com.sun.xml.ws.server.WSEndpointImpl$1.process(WSEndpointImpl.java:139)

        at com.sun.xml.ws.transport.http.HttpAdapter$HttpToolkit.handle(HttpAdapter.java:153)

        at com.sun.xml.ws.transport.http.HttpAdapter.handle(HttpAdapter.java:235)

        at com.sun.xml.ws.transport.http.servlet.ServletAdapter.handle(ServletAdapter.java:97)

        at weblogic.wsee.jaxws.HttpServletAdapter.post(HttpServletAdapter.java:36)

        at weblogic.wsee.jaxws.JAXWSServlet.doPost(JAXWSServlet.java:218)

        at javax.servlet.http.HttpServlet.service(HttpServlet.java:727)

        at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)

        at weblogic.servlet.internal.StubSecurityHelper$ServletServiceAction.run(StubSecurityHelper.java:226)

        at weblogic.servlet.internal.StubSecurityHelper.invokeServlet(StubSecurityHelper.java:124)

        at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:283)

        at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:175)

        at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:3370)

        at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)

        at weblogic.security.service.SecurityManager.runAs(Lweblogic.security.acl.internal.AuthenticatedSubject;Lweblogic.security.acl.internal.AuthenticatedSubject;Ljava.security.PrivilegedAction;)Ljava.lang.Object;(Unknown Source)

        at weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:2117)

        at weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:2023)

",BEA WebLogic Server 10,,,,,,,,,,,,,,,,,,,,,06/Dec/07 21:12;ppoddar@apache.org;PObject.java;https://issues.apache.org/jira/secure/attachment/12371181/PObject.java,06/Dec/07 21:12;ppoddar@apache.org;TestOptimisticException.java;https://issues.apache.org/jira/secure/attachment/12371180/TestOptimisticException.java,06/Dec/07 20:47;ppoddar@apache.org;jira462.patch.1.txt;https://issues.apache.org/jira/secure/attachment/12371177/jira462.patch.1.txt,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-12-06 20:45:39.089,,,no_permission,,,,,,,,,,,160783,,,Tue Dec 11 03:59:51 UTC 2007,,,,,,,0|i0z63j:,203290,,,,,,,,"06/Dec/07 20:45;ppoddar@apache.org;An optimistic violation often manifests as a SQLException during implicit or explicit flush/commit operation. 
As this SQL exception bubbles up the stack of OpenJPA layers, the exception gets translated with the original exception being nested within. 
The OpenJPA facade translates an exception to javax.persistence.OptimisticLockException for the user application *if* the lower layer 
(i.e. spec-agnostic OpenJPA kernel) raises or translates original SQLException to a org.apache.openjpa.util.OptimisticException.
If the context is not sufficient to translate the exception to  org.apache.openjpa.util.OptimisticException, it gets translated to 
org.apache.openjpa.util.StoreException which is the generic type from all exceptions raised by the underlying datastore (which is JDBC datastore in this case).

The attached patch addresses this issue by narrowing down the original SQLException to a specific subtype of  StoreException based on the SQLState carried by the original SQLException. 
As a result, the JPA-facade layer can translate the exception to a org.apache.opejpa.persistence.OptimisticLockException which is derived from intended javax.persistence.OptimisticLockException.
But this exception can get nested further up the exception translation chain before it reaches the user application.

So, if an application wants to detect whether the exception is caused by optimistic consistency violation, one way to do it is

	boolean isExpectedException(Throwable t, Class expected) {
		if (t == null) return false;
		if (expected.isAssignableFrom(t.getClass()))
				return true;
		if (t.getCause()==t) return false;
		return isExpectedException(t.getCause(), expected);
	}

     and call it from the application code as:

     try {
        // do some JPA stuff;
     } catch (Throwable t) {
           if (isExpectedException(t, javax.persistence.OptimisticLockException.class) {
                // do some smart thing to retry/recover
           else
             // rethrow
    }

Notes on the patch:
  1. The existing DBDictionary.newStoreException() method did detect referential integrity violations by analyzing java.sql.SQLException.getSQLState(). 
  2. This patch generalizes the same logic to other violations such as locking or duplicate key.
  3. The only context available to narrow down the cause is  java.sql.SQLException.getSQLState() -- which is ideally be same across JDBC drivers and different databases. 
But ideals are seldom met. So a new method
                   public String[] DBDictionary.getKnownErrorCodes(int storeExceptionType) 
is introduced, that can be overwritten by database-specific DBDictionary derivations.
  4. The patch only supplies two error codes for referential integrity and locking errors. 
===============================================================================================
If someone can point me to an enumeration of these (supposedly database-neutral) error codes returned by 
SQLException.getSQLState() that will be of great help.
===============================================================================================","06/Dec/07 20:47;ppoddar@apache.org;This patch narrows down StoreException by SQLException.getSQLState().
This narrowing down helps the upper layers to translate the exception to more specific errors for the user.

See the previous comment for further details.
","06/Dec/07 21:12;ppoddar@apache.org;a test case to verify exact type of exception being thrown for optimistic consistency violation.

","11/Dec/07 01:29;pcl;Based on the description, it sounds like this patch might still allow internal Exception types to make it out of the OpenJPA tier unwrapped. It would seem that we should always be re-wrapping with a facade-specific exception, even if the particular exception type is not being properly handled. Is that covered in the patches at this time?","11/Dec/07 03:59;ppoddar@apache.org;This patch only narrows down StoreException to more specific subtypes. So that the upper layers can translate/rewrap the exception in a more targeted exception for the user facacde.
This patch does not cover all internal exception types.  
The narrowing down is based on SQLState that the core SQLException carries with it. Hence only specific SQL errors can be narrowed within the available context/scope.
The user-visible exception translation will continue to happen through the layers above as The invocation context can only determine the correct translation. 

Specifically, a SQL lock time out exception is now being narrowed to a internal LockException as opposed to a generic StoreException. That helps JPA facade (PersistenceExceptions) to
translate it to OptimisticLockException rather than a more generic PersistenceException.    

SQLExceptions are being specialized further in JDBC 4.0 and SQLExceptions.narrow() that has been introduced in this patch can be a place for more improved logic. 

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Can't convert to: Time, InformixDictionary needs timeTypeName set to ""DATETIME HOUR TO SECOND""",OPENJPA-460,12384032,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,05/Dec/07 23:21,09/Mar/10 18:32,14/Mar/19 03:02,05/Dec/07 23:48,1.1.0,,,,,,,,,1.1.0,,,,,sql,,,,,,0,,"The default timeTypeName -- ""Time"" cause InformixDB reporting SQLException:

32747  mdd  TRACE  [main] openjpa.jdbc.SQL - <t 1090273532, conn 1260145436> executing stmnt 2021947524 CREATE TABLE EmpBean (empid INTEGER NOT NULL, bonus DOUBLE PRECISION, execLevel INTEGER, hireDate DATE, hireTime TIME, hireTimestamp DATE, isManager BOOLEAN, name VARCHAR(40), salary DOUBLE PRECISION, dept_deptno INTEGER, home_street VARCHAR(40), work_street VARCHAR(40), PRIMARY KEY (empid)) LOCK MODE ROW
32827  mdd  TRACE  [main] openjpa.jdbc.SQL - <t 1090273532, conn 1260145436> [80 ms] spent
Exception in thread ""main"" <openjpa-1.0.1-SNAPSHOT-runknown nonfatal general error> org.apache.openjpa.util.GeneralException: Type (time) not found. {stmnt 2021947524 CREATE TABLE EmpBean (empid INTEGER NOT NULL, bonus DOUBLE PRECISION, execLevel INTEGER, hireDate DATE, hireTime TIME, hireTimestamp DATE, isManager BOOLEAN, name VARCHAR(40), salary DOUBLE PRECISION, dept_deptno INTEGER, home_street VARCHAR(40), work_street VARCHAR(40), PRIMARY KEY (empid)) LOCK MODE ROW} [code=-9628, state=IX000]
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:549)
	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:1069)
	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:980)
	at org.apache.openjpa.jdbc.meta.MappingTool.main(MappingTool.java:921)
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: Type (time) not found. {stmnt 2021947524 CREATE TABLE EmpBean (empid INTEGER NOT NULL, bonus DOUBLE PRECISION, execLevel INTEGER, hireDate DATE, hireTime TIME, hireTimestamp DATE, isManager BOOLEAN, name VARCHAR(40), salary DOUBLE PRECISION, dept_deptno INTEGER, home_street VARCHAR(40), work_street VARCHAR(40), PRIMARY KEY (empid)) LOCK MODE ROW} [code=-9628, state=IX000]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:192)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$800(LoggingConnectionDecorator.java:57)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingStatement.executeUpdate(LoggingConnectionDecorator.java:754)
	at org.apache.openjpa.lib.jdbc.DelegatingStatement.executeUpdate(DelegatingStatement.java:114)
	at org.apache.openjpa.jdbc.schema.SchemaTool.executeSQL(SchemaTool.java:1185)
	at org.apache.openjpa.jdbc.schema.SchemaTool.createTable(SchemaTool.java:949)
	at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:526)
	at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:344)
	at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:321)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:497)
	... 3 more


when time has been created using a date type, at runtime we get time exception

<openjpa-1.0.1-SNAPSHOT-runknown nonfatal general error> org.apache.openjpa.persistence.PersistenceException: Can't convert to: Time
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3851)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:97)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:83)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:59)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:260)

...
Caused by: java.sql.SQLException: Can't convert to: Time
	at com.informix.util.IfxErrMsg.getSQLMinorException(IfxErrMsg.java:511)
	at com.informix.jdbc.IfxObject.toTime(IfxObject.java:590)
	at com.informix.jdbc.IfxResultSet.getTime(IfxResultSet.java:1281)
	at org.apache.commons.dbcp.DelegatingResultSet.getTime(DelegatingResultSet.java:208)
...
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160781,,,Wed Dec 05 23:48:40 UTC 2007,,,,,,,0|i0zbhb:,204162,,,,,,,,05/Dec/07 23:48;fancy;fixed under svn r601576,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem with bulk updates in mySQL,OPENJPA-459,12383999,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,zoch,zoch,05/Dec/07 16:38,09/Mar/10 18:31,14/Mar/19 03:02,12/Nov/09 06:39,1.0.0,,,,,,,,,2.0.0-beta,,,,,jdbc,,,,,,2,,"It's impossible to do bulk updates in mySQL. With subqueries enabled
(<property name=""openjpa.jdbc.DBDictionary""
value=""mysql(SupportsSubselect=true)"" /> in persistence.xml)
the updates generated are invalid, their execution ends with
exception. For example:

the jpql query is:
UPDATE Token t SET t.token = :tokenValue WHERE t.status = :status

the resulting exception is:

<1.0.0-SNAPSHOT-SNAPSHOT nonfatal general error>
org.apache.openjpa.persistence.PersistenceException: You can't specify
target table 'TOKENS' for update in FROM clause {prepstmnt 134
UPDATE TOKENS
SET TOKEN = ?
WHERE ID_TOKEN IN (SELECT DISTINCT t0.ID_TOKEN FROM TOKENS t0 WHERE
(t0.STATUS = ?))
[params=(String) token100, (long) 1]} [code=1093, state=HY000]
FailedObject: org.apache.openjpa.jdbc.kernel.exps.ExpContext@1d94799
at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3784)
at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:97)
at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:67)
at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeBulkOperation(JDBCStoreQuery.java:508)
at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeUpdate(JDBCStoreQuery.java:430)
at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeUpdate(ExpressionStoreQuery.java:690)
at org.apache.openjpa.datacache.QueryCacheStoreQuery$QueryCacheExecutor.executeUpdate(QueryCacheStoreQuery.java:351)
at org.apache.openjpa.kernel.QueryImpl.update(QueryImpl.java:1036)
at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:843)
at org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:879)
at kodo.kernel.KodoQuery.updateAll(KodoQuery.java:71)
at org.apache.openjpa.kernel.DelegatingQuery.updateAll(DelegatingQuery.java:581)
at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:313)
at sample.dao.jpa.TokenDaoImpl.updateByStatus(TokenDaoImpl.java:154)
... 16 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: You
can't specify target table 'TOKENS' for update in FROM clause
{prepstmnt 134
UPDATE TOKENS
SET TOKEN = ?
WHERE ID_TOKEN IN (SELECT DISTINCT t0.ID_TOKEN FROM TOKENS t0 WHERE
(t0.STATUS = ?))
[params=(String) token100, (long) 1]} [code=1093, state=HY000]
at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:191)
at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$800(LoggingConnectionDecorator.java:56)
at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:857)
at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1363)
at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeBulkOperation(JDBCStoreQuery.java:501)
... 26 more

We'd expect the generated sql would look more like:
UPDATE TOKENS
SET TOKEN = ?
WHERE STATUS = ?


For the following query:
UPDATE Token t SET t.token = :tokenValue WHERE t.user.login = :login

we get
<1.0.0-SNAPSHOT-SNAPSHOT nonfatal general error>
org.apache.openjpa.persistence.PersistenceException: You can't specify
target table 'TOKENS' for update in FROM clause {prepstmnt 137
UPDATE TOKENS
SET TOKEN = ?
WHERE ID_TOKEN IN (SELECT DISTINCT t0.ID_TOKEN FROM TOKENS t0 INNER
JOIN USERS t1 ON t0.ID_USER = t1.ID_USER WHERE (t1.LOGIN = ?))
[params=(String) token200, (String) noone]} [code=1093, state=HY000]
FailedObject: org.apache.openjpa.jdbc.kernel.exps.ExpContext@713bd2
at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3784)
at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:97)
at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:67)
at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeBulkOperation(JDBCStoreQuery.java:508)
at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeUpdate(JDBCStoreQuery.java:430)
at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeUpdate(ExpressionStoreQuery.java:690)
at org.apache.openjpa.datacache.QueryCacheStoreQuery$QueryCacheExecutor.executeUpdate(QueryCacheStoreQuery.java:351)
at org.apache.openjpa.kernel.QueryImpl.update(QueryImpl.java:1036)
at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:843)
at org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:879)
at kodo.kernel.KodoQuery.updateAll(KodoQuery.java:71)
at org.apache.openjpa.kernel.DelegatingQuery.updateAll(DelegatingQuery.java:581)
at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:313)
at sample.dao.jpa.TokenDaoImpl.updateByLogin(TokenDaoImpl.java:129)
... 16 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: You
can't specify target table 'TOKENS' for update in FROM clause
{prepstmnt 137
UPDATE TOKENS
SET TOKEN = ?
WHERE ID_TOKEN IN (SELECT DISTINCT t0.ID_TOKEN FROM TOKENS t0 INNER
JOIN USERS t1 ON t0.ID_USER = t1.ID_USER WHERE (t1.LOGIN = ?))
[params=(String) token200, (String) noone]} [code=1093, state=HY000]
at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:191)
at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$800(LoggingConnectionDecorator.java:56)
at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:857)
at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1363)
at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeBulkOperation(JDBCStoreQuery.java:501)
... 26 more


where we'd expect following sql:
UPDATE TOKENS t0
JOIN USERS t1 ON t0.ID_USER = t1.ID_USER
SET t0.TOKEN = ?
WHERE t1.LOGIN = ?


If we turn subqueries off
(<property name=""openjpa.jdbc.DBDictionary"" value=""mysql"" /> in persistence.xml)
instead of generating bulk update queries, openjpa generates a series
of single row updates like:
UPDATE TOKENS
SET TOKEN = ?, VERSION = ?
WHERE ID_TOKEN = ? AND VERSION = ?
[params=(String) token200, (int) 5, (long) 5, (int) 4]

UPDATE TOKENS
SET TOKEN = ?, VERSION = ?
WHERE ID_TOKEN = ? AND VERSION = ?
[params=(String) token200, (int) 5, (long) 6, (int) 4
",Weblogic 10.0 ; mySQL 5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-12-06 07:02:29.385,,,no_permission,,,,,,,,,,,160780,,,Thu Nov 12 06:37:47 UTC 2009,,,,,,,0|i0z22f:,202637,,,,,,,,"06/Dec/07 07:02;pcl;I believe that the first query (which only involves one table) is due to a fairly trivial-to-resolve limitation of DBDIctionary: currently, if SupportsSubselect is true and AllowsAliasInBulkClause is false, OpenJPA always uses a subselect, even when it would be valid to just omit the aliases.",07/Dec/07 11:34;zoch;Is there any workaround possible now ?,"11/Dec/07 12:08;bouzahri;can we consider this as a bug?
Workaround to turn off subquiries would not be an option when it concerns bulk updates.","12/Dec/07 15:57;zoch;I think, that turning off subqueries is not a good solution, because in this case we can`t use subqueries in any query in our application
As I am using Weblogic 10 I have reported this problem also to Bea support ( Case #: 760073 ).","13/Dec/07 09:50;ognjen;Just to confirm the bug, and to report that bulk DELETE statement is causing the same problems.
","30/Oct/09 13:04;kwsutter;Based on the conversation on the Users mailing list [1], this JIRA Issue does not seem to be resolved yet.  I've been in contact with Pinaki and Mike about the resolution status and we can't seem to come to any conclusion.  And, the customer is still claiming that this is not resolved.  So, I will re-open the Issue.  Initially, I will assign it to Pinaki since he resolved it in the first place.  Sorry for the confusion!

[1]  http://n2.nabble.com/Problem-with-bulk-updates-in-mySQL-td3871180.html#a3871180

Thanks,
Kevin",12/Nov/09 06:37;ppoddar@apache.org;Verify against commit  #835257 and report back.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA doesn't throw standard JPA exceptions,OPENJPA-458,12383824,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,onural@nortel.com,onural@nortel.com,03/Dec/07 21:47,09/Mar/10 18:32,14/Mar/19 03:02,16/Jul/08 02:37,1.0.1,,,,,,,,,1.2.0,,,,,jpa,,,,,,1,,"OpenJPA doesn't throw standard JPA exceptions in the case of failure to persist or commit. 

For example, the JPA spec states that the EntityExistsException is thrown by the persistence provider when EntityManager.persist(Object) is called and the entity already exists. 

However, the OpenJPA never raises the EntityExistsException, instead raises RollbackException.

In order to produce the issue, just take the hellojpa example comes with the OpenJPA distro. and modify Message.java to make 
variable message an ID (original Message class uses timestamp as ID, just change the ID to be message variable for the purpose of  reproducing the issue explained here) : 
   @Id
    private String message;

Then run the hellojpa after this very simple modification, twice. Second execution fails because of duplicate key. The stack trace is captured below and notice that there is no  EntityExistsException in the stack trace at all. 

Because of this, the caller of the jpa objects cannot differenciate EntityExistsException from any other exception and for example the GUI cleints cannot display meaningful error code to reflect exactly what happend. 

Here is the stack trace :

Buildfile: D:\apache-openjpa-1.0.0\examples\hellojpa\build.xml
pre-compile:
compile:
run:
     [java] 3063  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 26760685, conn 3238031> executing prepstmnt 28409161 INSERT INTO Message (message, created, id) VALUES (?, ?, ?) [params=(String) Hello Persistence!, (Timestamp) 2007-12-03 15:59:24.663, (long) 1196715564663]
     [java] 3157  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 26760685, conn 3238031> [94 ms] spent
     [java] Exception in thread ""main"" <openjpa-1.0.0-r420667:568756 fatal store error> org.apache.openjpa.persistence.RollbackException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
     [java] 	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:419)
     [java] 	at hellojpa.Main.main(Main.java:53)
     [java] Caused by: <openjpa-1.0.0-r420667:568756 fatal general error> org.apache.openjpa.persistence.PersistenceException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
     [java] 	at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2099)
     [java] 	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1946)
     [java] 	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1844)
     [java] 	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1762)
     [java] 	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
     [java] 	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1292)
     [java] 	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:861)
     [java] 	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:408)
     [java] 	... 1 more
     [java] Caused by: <openjpa-1.0.0-r420667:568756 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by 'SQL071203035857400' defined on 'MESSAGE'. {prepstmnt 28409161 INSERT INTO Message (message, created, id) VALUES (?, ?, ?) [params=(String) Hello Persistence!, (Timestamp) 2007-12-03 15:59:24.663, (long) 1196715564663]} [code=20000, state=23505]
     [java] FailedObject: hellojpa.Message@89e2f1
     [java] 	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3849)
     [java] 	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:97)
     [java] 	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:67)
     [java] 	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:108)
     [java] 	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:73)
     [java] 	at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:543)
     [java] 	at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:105)
     [java] 	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:89)
     [java] 	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
     [java] 	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:514)
     [java] 	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
     [java] 	... 8 more
     [java] Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by 'SQL071203035857400' defined on 'MESSAGE'. {prepstmnt 28409161 INSERT INTO Message (message, created, id) VALUES (?, ?, ?) [params=(String) Hello Persistence!, (Timestamp) 2007-12-03 15:59:24.663, (long) 1196715564663]} [code=20000, state=23505]
     [java] 	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:192)
     [java] 	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$800(LoggingConnectionDecorator.java:57)
     [java] 	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:858)
     [java] 	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
     [java] 	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1363)
     [java] 	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:97)
     [java] 	... 15 more

BUILD FAILED
D:\apache-openjpa-1.0.0\examples\build.xml:84: Java returned: 1

Total time: 6 seconds







","OpenJPA 1.0.0
Windows",,,,,,,,,,,,OPENJPA-462,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-06-17 19:59:54.35,,,no_permission,,,,,,,,,,,160779,,,Thu Jun 19 00:57:09 UTC 2008,,,,,,,0|i0yw1z:,201663,,,,,,,,"17/Jun/08 19:59;mikedd;Technically this is allowed in the JPA spec  :

/**
* Make an instance managed and persistent.
* @param entity
* @throws EntityExistsException if the entity already exists.
* (The EntityExistsException may be thrown when the persist
* operation is invoked, or the EntityExistsException or
* another PersistenceException may be thrown at flush or
* commit time.)
* @throws IllegalArgumentException if not an entity
* @throws TransactionRequiredException if invoked on a
* container-managed entity manager of type
* PersistenceContextType.TRANSACTION and there is
* no transaction.
*/
public void persist(Object entity);

Note that we have the option of throwing an EntityExistsException or another PersistenceException (RollbackException qualifies here) at commit / flush time. 

I agree that it isn't very friendly though. The trick is that there isn't a universal SQLState that indicates we've received a duplicate key exception. One way to detect this condition is to maintain a list of known dup key sqlstates for each DB. Keeping the list up to date is a bit of a hassle, but it would improve the user experience.

Since we're unlikely to get all the known dup key states it'd be nice to be able to update the list via the configuration. Ie : 
<property name=""openjpa.jdbc.DBDictionary"" value=""derby(dupKeyStates=23505,23504,23503...)""/> <!-- except the first one these aren't accurate -->
","19/Jun/08 00:56;ppoddar@apache.org;Introduced a file-based configuration ""sql-error-state-codes.xml"" to narrow down the SQL exceptions. Michael is right about each database/JDBC driver throwing their own error codes on the same/similar error (e.g. DuplicateKeyException). The content of ""sql-error-state-codes.xml"" is error codes for each database we support categorized into the same subtypes of StoreException. The error codes in this file is currently gleaned from a similar file supplied in Spring framework. 

Also because of *when* an exception is raised can be different than *when* user called a method (for example, an EntityExistsException can be raised at commit time and not when user called em.persist(new Entity()), the real exception is often wrapped in a javax.persistence.Rollback or generic javax.persistence.PersistenceException. 

","19/Jun/08 00:57;ppoddar@apache.org;It may be useful for people to take a look at ""sql-error-state-codes.xml"" and help to populate it with error codes of specific databases. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException in Filters.convert,OPENJPA-457,12383754,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,gangolli,gangolli,02/Dec/07 23:29,02/Aug/08 14:06,14/Mar/19 03:02,02/Aug/08 14:06,0.9.7,1.0.0,1.0.1,,,,,,,1.3.0,,,,,,,,,,,0,,"
I am seeing this problem in 0.9.7 but examination of trunk code suggests that the same bug is still present in current trunk.

The exception occurs when Filters.convert(o,type) is called with o of class String and type Long.class.

This leads to a ClassCastException at line 292 where o is cast to Number.  

The same path seems to be reached for any type assignable from Number, except Integer.class which is handled in a separate case at line 275.


Example stacktrace fragment:

Caused by: java.lang.ClassCastException: java.lang.String
        at org.apache.openjpa.kernel.Filters.convert(Filters.java:292)
        at org.apache.openjpa.jdbc.kernel.exps.UnaryOp.load(UnaryOp.java:110)
        at org.apache.openjpa.jdbc.kernel.ProjectionResultObjectProvider.getResultObject(ProjectionResultObjectProvider.java:76)
        at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:36)
        at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1219)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:987)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:796)









","openjpa 0.9.7, Sun JDK 1.5.0_12, MySQL 5.0.45, Ubuntu Linux 7.1",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-08-02 14:06:39.302,,,no_permission,,,,,,,,,,,160778,,,Sat Aug 02 14:06:39 UTC 2008,,,,,,,0|i0z4ov:,203062,,,,,,,,"02/Aug/08 14:06;ppoddar@apache.org;Query Parameter validation has been revamped. Similar parameter type mismatch is covered.
There is no definite test case given with this issue but OPENJPA-497 has a bunch of test case scenarios.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missed to validate the column name length for Join Column,OPENJPA-456,12383584,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,tckan1,tckan1,30/Nov/07 05:11,20/Apr/08 19:00,14/Mar/19 03:02,20/Apr/08 19:00,1.1.0,,,,,,,,,1.1.0,1.2.0,,,,jdbc,,,,,,0,,"In the PersistenceMappingDefault.populateJoinColumn() method, it missed the call to validate the column length. Consequencely the column length  that was longer than DB2's max column length resulted an invalid column length exception .

The fix wil be:

    public void populateJoinColumn(FieldMapping fm, Table local, Table foreign,
        Column col, Object target, int pos, int cols) {
        // only use spec defaults with column targets
        if (!(target instanceof Column))
            return;

        // if this is a bidi relation, prefix with inverse field name, else
        // prefix with owning entity name
        FieldMapping[] inverses = fm.getInverseMappings();
        String name;
        if (inverses.length > 0)
            name = inverses[0].getName();
        else
            name = fm.getDefiningMapping().getTypeAlias();

        // suffix with '_' + target column
        name += ""_"" + ((Column) target).getName();
        name = dict.getValidColumnName(name, foreign);  ===> add this call before set the name to the column.
        col.setName(name);
    }",,,,,,,,,,,,,,,,,,,,,,30/Nov/07 05:12;tckan1;OPENJPA-456.patch;https://issues.apache.org/jira/secure/attachment/12370609/OPENJPA-456.patch,07/Dec/07 19:01;tckan1;openjpa_456_2.patch;https://issues.apache.org/jira/secure/attachment/12371250/openjpa_456_2.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-04-20 19:00:07.853,,,no_permission,,,,,,,,,,,160777,,,Sun Apr 20 19:00:07 UTC 2008,,,,,,,0|i0z4o7:,203059,,,,,,,,30/Nov/07 05:12;tckan1;Attach the patch..,"07/Dec/07 19:01;tckan1;With my current fix(OPENJPA-456) which  put the getValidColumnName() in the PersistenctMappingDefault..populateJoinColumn(). The output will be like this:

===PersitendceMappingDefault.populateJoinColumn(), name before conversion=RelationToHandlerMapInstance_id
===PersitendceMappingDefault.populateJoinColumn(), name after conversion=RELATIONTOHANDLERMAPINSTANCE_I


If I modified the code to shorten the name first before append the targetName (""_ID""), then the output looks like this:

===PersitendceMappingDefault.populateJoinColumn(), tempname =RelationToHandlerMapInstanc
===PersitendceMappingDefault.populateJoinColumn(), name before conversion=RelationToHandlerMapInstanc_id
===PersitendceMappingDefault.populateJoinColumn(), name after conversion=RELATIONTOHANDLERMAPINSTANC_ID

I think the latest solution is better. It preserves the _ID at the end. For current solution will lost the _ID at the end if the max column name is much shorter than the initial name.
The attach patch provides the latest solution..
",20/Apr/08 19:00;mikedd;Closing old issue which was integrated with revision 603633 on 12-12-2008,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect MySQL DDL Generation for integer types,OPENJPA-455,12383365,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,pcl,mikedd,mikedd,27/Nov/07 23:44,30/Jul/09 14:04,14/Mar/19 03:02,30/Jan/08 06:30,1.0.0,1.0.1,,,,,,,,1.1.0,,,,,,,,,,,0,,"Opening a JIRA report on Tim's behalf. 

I turned the schema tool loose on a MySQL production database this
afternoon and it failed. The essence of the problem appears that DDL was
being generated with a type declaration of this form:

int unsigned(10)

In MySQL, the proper form is:

int(10) unsigned

viz:

ALTER TABLE fubar MODIFY col1 int(10) unsigned;

Checking other options indicates that similar constructs such as CREATE
TABLE are likewise defective.

I looked at the svn trunk head source code in
org.apache.openjpa.jdbc.sql.MySQLDictionary.java and the parent class
DBDictionary.java. The offending method appears to be:

1508:     public String getTypeName(Column col)

This method has no override in MySQLDictionary, but apparently needs
one. I think it's a minor mod, but I'm not currently set up to build and
test in the environment where the offending database exists.

This is a SEVERE error. It causes generation of defective SQL for
SQL-generating options and causes live updates to schemas to fail.

I don't have a Jira login at present, so if someone could log this, it
would be appreciated.

  Thanks,

   Tim Holloway",,,,,,,,,,,,,,,,,,,,,,28/Nov/07 21:00;mikedd;OPENJPA-455.patch.txt;https://issues.apache.org/jira/secure/attachment/12370450/OPENJPA-455.patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-01-29 16:36:34.827,,,no_permission,,,,,,,,,,,160776,,,Wed Jan 30 06:30:46 UTC 2008,,,,,,,0|i0z21z:,202635,,,,,,,,28/Nov/07 21:00;mikedd;Attaching potential patch. I'll commit this when I've had a chance to do a little more testing. ,"29/Jan/08 16:36;joe weinstein;Hi. I think I've found a problem here. Oracle has a NUMBER
column type, which may be specified with sizes, eg:
NUMBER(7), or NUMBER(9,3), but may also be unsized,
eg: NUMBER. Since this fix, the new code is failing to
process the ""NUMBER{0}"" template for non-sized
columns, so the DDL sent to the DBMS is like:

CREATE TABLE ABSTRACTMAPPEDAPPIDSUPER ( ..., VERSN NUMBER{0}, ...

which needless to say, dies.

The change I made that fixed this is:

    protected String insertSize(String typeName, String size) {
        if(StringUtils.isEmpty(size)) {

          int idx = typeName.indexOf(""{0}"");  // remove the size token if not needed...
          if (idx != -1) {
            return typeName.substring(0,idx);
          }
          return typeName;
        }

        int idx = typeName.indexOf(""{0}"");
...



ie:

Index: openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java
===================================================================
--- openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java    (revision 61099
9)
+++ openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java    (working copy)
@@ -1648,8 +1648,13 @@
      */
     protected String insertSize(String typeName, String size) {
        if(StringUtils.isEmpty(size)) {
-               return typeName;
-       }
+
+          int idx = typeName.indexOf(""{0}"");
+          if (idx != -1) {
+            return typeName.substring(0,idx);
+         }
+         return typeName;
+       }

         int idx = typeName.indexOf(""{0}"");
         if (idx != -1) {

Please let me know what you think, and how to absorb this
change, or it's purpose. thanks,
Joe Weinstein at BEA Systems
","30/Jan/08 06:30;pcl;Re-resolving, since Joe opened a new issue for the problem he found.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Error in the XML equivalent in the ""secondary table field mapping"" example",OPENJPA-452,12383213,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,clr,plunchete,plunchete,26/Nov/07 11:48,09/Mar/10 18:32,14/Mar/19 03:02,02/Jan/08 17:48,,,,,,,,,,1.0.2,1.1.0,,,,docs,,,,,,0,,A missing slash in the XML secondary table field mapping example. ,,,,,,,,,,,,,,,,,,,,,,26/Nov/07 11:57;plunchete;OPENJPA-452.patch;https://issues.apache.org/jira/secure/attachment/12370196/OPENJPA-452.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-01-02 17:48:46.844,,,no_permission,,,,,,,,,,,97290,,,Wed Jan 02 17:48:46 UTC 2008,,,,,,,0|i0zbjj:,204172,,,,,,,,26/Nov/07 11:57;plunchete;This patch solves the error.,01/Jan/08 06:27;plunchete;Anybody could to commit my patch?,"02/Jan/08 17:48;clr;Thanks for the patch. I've committed the change to the trunk (1.1.0) and branch (1.0.2)

 clr% svn commit -m ""OPENJPA-452 Fixed xml in secondary table mapping example. Patch contributed by Ignacio Andreu"" !$
svn commit -m ""OPENJPA-452 Fixed xml in secondary table mapping example. Patch contributed by Ignacio Andreu"" ./openjpa-project/src/doc/manual/jpa_overview_mapping.xml
Sending        openjpa-project/src/doc/manual/jpa_overview_mapping.xml
Transmitting file data .
Committed revision 608157.

 clr% svn commit -m ""OPENJPA-452 Fixed xml in secondary table mapping example. Patch contributed by Ignacio Andreu"" ./openjpa-project/src/doc/manual/jpa_overview_mapping.xml
Sending        openjpa-project/src/doc/manual/jpa_overview_mapping.xml
Transmitting file data .
Committed revision 608158.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Query pagination broken for non-DB2 databases,OPENJPA-447,12382839,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,20/Nov/07 03:04,09/Mar/10 18:32,14/Mar/19 03:02,07/Feb/08 01:44,1.1.0,,,,,,,,,1.0.2,1.1.0,,,,,,,,,,0,,"I don't know if this impacts 1.0.1.

A recent change to a DBDictionary signature resulted in the subclass overriding methods not being invoked for range configuration.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-04-14 09:44:24.648,,,no_permission,,,,,,,,,,,160769,,,Tue Apr 14 09:44:24 UTC 2009,,,,,,,0|i0zbjz:,204174,,,,,,,,20/Nov/07 13:41;pcl;This has been resolved in trunk. Keeping open until we determine if it impacts 1.0.1 also.,"14/Apr/09 09:44;jkronegg;Oops, I used the ""blocks"" link to OPENJPA-759 by error. The correct link type is ""is related to""",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem when setting String fields of detached objects,OPENJPA-446,12382814,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,jop,jop,19/Nov/07 19:50,09/Mar/10 18:32,14/Mar/19 03:02,20/Nov/07 16:35,1.0.1,,,,,,,,,1.0.2,1.1.0,,,,jpa,kernel,,,,,0,,"I would like to report some strange behavior with detach and merge. To me it looks like a bug.

I'm trying implement the following strategy:
 
persistence context A:
  1. get persistent object
  2. detach the object
no persistence context:
  3. modify the (detached) object
persistence context B:
  4. attach (merge) the object

This is quite simple and straight forward. It generally works except in one situation. When committing the merge() (step 4) an ""optimistic locking error"" is is thrown under the following condition: (step 3) a (String) field is set to the same text that it already contains but using a different String instance. In other words, when the following expressions are true:
    
    newString.equals(oldString)
    newString != oldString

I have written some test code that reproduces this effect (see Attachment).

The tests are using the same code except for one line:

Test 1 sets the String to a different one than the object contains:
    record.setContent(""a text different than the one in the record"");

Test 2 sets the String to the same instance the object contains:
  record.setContent(record.getContent());

Test 3 sets the String to the same text but as a different String instance:
  record.setContent(record.getContent()+"""");

 This is the result (output of the test run):
----------------------------------
Test 1: SUCCESS
Test 2: SUCCESS
Test 3: FAILED (Optimistic locking errors were detected when flushing 
                to the data store. The following objects may have been
                concurrently modified in another transaction: 
                [test.Record-1])
----------------------------------

While doing some debugging I noticed two things:

1. When setting the value:

Class: org.apache.openjpa.kernel.DetachedStateManager
Line: 555
Method: settingStringField()

        if (cur == next || !_loaded.get(idx))
          return;

Here the old and the new value (String) is compared with the == operator.
The expression can be false with the same text (but different instances). I find this interesting as it matches exacly the problematic condition. I think an .equals() would fix the issue I am having. But I suppose there is something going wrong at another place as well.

2. Here is the point where execution splits into different ways when calling commit().

Class: org.apache.openjpa.jdbc.kernel.AbstractUpdateManager
Line: 151
Method: populateRowManager()

    } else if ((dirty = ImplHelper.getUpdateFields(sm)) != null) {

In the tests that succeed ""ImplHelper.getUpdateFields(sm)"" will return a BitSet. So the condition is true.
In the tests that fail ""ImplHelper.getUpdateFields(sm)"" will return null. So the condition is false.

Note: the problem persist with OpenJPA 1.1.0-SNAPSHOT. When run without enhancing the Record class, all tests will succeed though (printing this message „INFO   [main] openjpa.Enhance - Creating subclass for ""[class test.Record]"". This means that your application will be less efficient and will consume more memory than it would if you ran the OpenJPA enhancer. Additionally, lazy loading will not be available for one-to-one and many-to-one persistent attributes in types using field access; they will be loaded eagerly instead."")

Regards
Jonas
","OpenJPA 1.0.1
Java 1.5.0_13
MySQL Server 5.0
MySQL Connector Java 5.0.6",,,,,,,,,,,,,,,,,,,,,20/Nov/07 23:25;jop;DetachAttachTest-updated.zip;https://issues.apache.org/jira/secure/attachment/12369932/DetachAttachTest-updated.zip,19/Nov/07 19:53;jop;DetachAttachTest.zip;https://issues.apache.org/jira/secure/attachment/12369812/DetachAttachTest.zip,20/Nov/07 10:11;jop;detach-attach-fix-proper.patch;https://issues.apache.org/jira/secure/attachment/12369860/detach-attach-fix-proper.patch,19/Nov/07 22:55;jop;detach-attach-fix.patch;https://issues.apache.org/jira/secure/attachment/12369829/detach-attach-fix.patch,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2007-11-20 16:35:20.829,,,no_permission,,,,,,,,,,,160768,,,Fri Jul 11 14:34:48 UTC 2008,,,,,,,0|i0z20v:,202630,,,,,,,,19/Nov/07 19:53;jop;Sourcecode to reproduce the issue.,"19/Nov/07 22:55;jop;I have fixed the DetachedStateManager so it correctly compares the strings (as described in ""1. When setting the value:"").

I have rebuilt OpenJPA and ran all maven tests successfully.

My DetachAttachTest runs all successfull as well now.

I'm attaching a patch.
","20/Nov/07 10:11;jop;I'm sorry, the patch that I posted (detach-attach-fix.patch) is bad. I'm posting a proper one: detach-attach-fix-proper.patch.

The problem was that it did not consider a String field set to null before setting it to another value.

Maybe a TestCase checking all the different situations would be a good idea.","20/Nov/07 16:35;mikedd;The attached patch looks good, thanks Jonas!","20/Nov/07 19:34;pcl;Thanks for the debugging work on this.

Is it ok for us to put the DetachAttachTest.zip test files into OpenJPA under the ASL license?",20/Nov/07 23:25;jop;Thanks for reviewing. It's fine for me if you put the DetachAttachTest.zip test files into OpenJPA under the ASL license. You may want to use the extended one that I just attached instead though. It also tests the null conditions and does some assertion for each test.,04/Dec/07 17:52;sdroscher;Any reason why the same change shouldn't be made to the settingObjectField() method of DetachedStateManager ?,06/Dec/07 07:04;pcl;I think that this patch should be applied for any non-primitive setting*Field() methods.,"11/Jul/08 09:35;nickcodefresh;Can someone definately confirm that this has been fixed in v1.0.2? I'm experiencing the same issue but am unable to upgrade to v1.1.0 due to an incompatability with BEA Kodo.

Nick","11/Jul/08 14:34;kwsutter;Nick,
Two things you can look at.  One is the ""fix versions"".  On this JIRA Issue, the 1.0.2 version is listed as being a ""fix version"".  The other thing you can look at is the specific SVN Commits.  The changes were put into the 1.0.x release via svn revision #596737.  The 1.0.2 release was tagged at revision #628944.  So, yes, this change has been put into the 1.0.2 release.

Kevin",,,,,,,,,,,,,,,,,,,,,,,,,,,
Calendar Objects are loaded with the current milliseconds,OPENJPA-443,12382601,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,tedman@sfu.ca,tedman@sfu.ca,15/Nov/07 18:18,09/Mar/10 18:35,14/Mar/19 03:02,18/Dec/07 23:40,1.1.0,,,,,,,,,,,,,,,,,,,,0,,"if you load an object which contains a Calendar object that has been persisted as date and time (in the case of mysql that's without milliseconds, just  : DATETIME of format	'0000-00-00 00:00:00') the milliseconds are not 0-ed out.

as an example I loaded the same identical object twice one right after the other and I did a Calendar. getTimeInMillis(). The results were 

1195149779501
1195149779540

I think 1195149779000 should have been the result. Right now it appears the millis were populated from the current time of the query, I did print a System.currentTimeMillis and it the millis seemed to match.","java full version ""1.6.0_03-b05"", fedora 7, OpenJPA 1.1.0 snapshot from Nov 14, 2007, mysql  Ver 14.12 Distrib 5.0.45, for pc-linux-gnu (i686) using readline 5.0",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160765,,,Thu Dec 20 18:48:24 UTC 2007,,,,,,,0|i0z7mf:,203537,,,,,,,,"18/Dec/07 23:40;tedman@sfu.ca;error in test case, not a problem.","20/Dec/07 18:48;tedman@sfu.ca;This was actually an artifact of a separate issue, where PrePersist is called on every commit even if the object has not changed.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JIRA-407 introduced backward compatibility problem in QueryImpl,OPENJPA-442,12382539,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,tckan1,tckan1,14/Nov/07 18:54,20/Apr/08 19:08,14/Mar/19 03:02,20/Apr/08 19:08,1.1.0,1.2.0,,,,,,,,1.2.0,,,,,query,,,,,,0,,"In the openjpa-407 patch, it changed the constructor to pass an extra parameter RuntimeExceptionTransaltor,

   public QueryImpl(EntityManagerImpl em, RuntimeExceptionTranslator ret,
        org.apache.openjpa.kernel.Query query) {
        _em = em;
        _query = new DelegatingQuery(query, ret);
    }

However, it did not keep the orginial constructor so the extension  of this QueryImpl from other vendor resulted in compiler error. We need to keep the backward compatibilty issue in mind when we change the public interface. 
The solution will be  to add the original constructor back and route it to the new constructor:

   public QueryImpl(EntityManagerImpl em, RuntimeExceptionTranslator ret,
        org.apache.openjpa.kernel.Query query) {
        _em = em;
        if (ret == null)
            ret = PersistenceExceptions.getRollbackTranslator(em);
        _query = new DelegatingQuery(query, ret);
    }

    /**
     * Constructor; supply factory and delegate.
     */
    public QueryImpl(EntityManagerImpl em, org.apache.openjpa.kernel.Query query) {        
        this(em, null, query);
    }

",,,,,,,,,,,,,,,,,,,,,,14/Nov/07 18:56;tckan1;OPENJPA-442.patch;https://issues.apache.org/jira/secure/attachment/12369542/OPENJPA-442.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-11-16 01:06:37.866,,,no_permission,,,,,,,,,,,160764,,,Fri Nov 16 01:06:37 UTC 2007,,,,,,,0|i0z4nj:,203056,,,,,,,,14/Nov/07 18:56;tckan1;attach the patch.,"16/Nov/07 01:06;pcl;So I guess it depends what we consider to be a ""public interface"". To date, we've defined that as just being things that are marked as @published. Significantly increasing this footprint will make OpenJPA much more brittle to refactorings.

We might want to think about a relatively high-speed deprecation route for things like this. This could help facilitate integration testing etc. while still allowing things to change as we perform useful refactorings by providing overlap in internal SPI compatibility.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Calendar instance doesn't appear to detach properly (or proxying of it is in error?),OPENJPA-440,12382247,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,tedman@sfu.ca,tedman@sfu.ca,10/Nov/07 01:28,09/Mar/10 18:32,14/Mar/19 03:02,18/Dec/07 23:42,1.0.0,1.1.0,,,,,,,,1.1.0,,,,,,,,,,,0,,"I have an @entity object which has a field 	

   @Temporal(TemporalType.DATE)
   private Calendar aquisitionDate = null;

I can set the Calendar field fine and it persists fine into the database.

If I start a new transaction and read the object back out of the database, 

when the transaction is still open everything works fine, I can call 
   getTimeInMillis() = 1153108800000
   get(Calendar.YEAR) = 2006
   get(Calendar.MONTH) 6
   get(Calendar.DAY_OF_MONTH) = 17
which is all correct

After I close the transaction, 
   getTimeInMillis() = 1153181684943 (why did it change? I didn't change the data)
   get(Calendar.YEAR) = ERROR 

<openjpa-1.1.0-SNAPSHOT-r420667:570593 fatal user error> org.apache.openjpa.persistence.InvalidStateException: The context has been closed.  The stack trace at which the context was closed is available if Runtime=TRACE logging is enabled.
	at org.apache.openjpa.kernel.BrokerImpl.assertOpen(BrokerImpl.java:4291)
	at org.apache.openjpa.kernel.BrokerImpl.beginOperation(BrokerImpl.java:1702)
	at org.apache.openjpa.kernel.BrokerImpl.isActive(BrokerImpl.java:1672)
	at org.apache.openjpa.kernel.StateManagerImpl.dirty(StateManagerImpl.java:1524)
	at org.apache.openjpa.kernel.StateManagerImpl.dirty(StateManagerImpl.java:1471)
	at org.apache.openjpa.util.Proxies.dirty(Proxies.java:66)
	at org.apache.openjpa.util.java$util$GregorianCalendar$proxy.computeFields(Unknown Source)
	at java.util.Calendar.complete(Calendar.java:1522)
	at java.util.Calendar.get(Calendar.java:1126)
	at com.XXXXX.dao.ItemTest.itemTest(ItemTest.java:46)
","fedora 7, java full version ""1.6.0_03-b05"", Spring 2.0.7, Mysql 5.0.45,  mysql connector 5.0.5",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160762,,,Tue Dec 18 23:42:24 UTC 2007,,,,,,,0|i0zbin:,204168,,,,,,,,15/Nov/07 18:08;tedman@sfu.ca;this appears to have been fixed in the latest 1.1.0 snapshot. (Nov 15 2007),18/Dec/07 23:42;tedman@sfu.ca;was resolved by some one else in the 1.1.0 snapshots is no longer a problem.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Performance degradation in multi-transaction operations,OPENJPA-439,12382245,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,10/Nov/07 00:43,09/Mar/10 18:32,14/Mar/19 03:02,12/Nov/07 17:58,0.9.0,0.9.6,0.9.7,1.0.0,1.0.1,1.0.2,1.1.0,,,1.1.0,,,,,kernel,,,,,,0,,"Reusing a Broker for multiple transactions / persistence contexts demonstrates a performance degradation, possibly due to explicit calls to clear sets and maps, rather than just dereferencing them.

Discussion: http://www.nabble.com/Performance-drop-in-AbstractHashedMap.clear%28%29-tf4769771.html#a13656730",,,,,,,,,,,,,,,,,,,,,,11/Nov/07 18:08;pcl;OPENJPA-439-patch.jar;https://issues.apache.org/jira/secure/attachment/12369329/OPENJPA-439-patch.jar,10/Nov/07 01:00;pcl;OPENJPA-439.patch;https://issues.apache.org/jira/secure/attachment/12369278/OPENJPA-439.patch,11/Nov/07 16:56;christiaan;performance testcase results.zip;https://issues.apache.org/jira/secure/attachment/12369327/performance+testcase+results.zip,11/Nov/07 16:55;christiaan;testcaseperformance.zip;https://issues.apache.org/jira/secure/attachment/12369326/testcaseperformance.zip,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2007-11-11 16:56:04.835,,,no_permission,,,,,,,,,,,160761,,,Tue Nov 13 10:04:50 UTC 2007,,,,,,,0|i0z1zr:,202625,,,,,,,,"10/Nov/07 01:00;pcl;Moving most of the BrokerImpl collections to recreate instead of clear sets and maps. I left a few probably-small collections as-is.

It'd be great to get some numbers about the impact of this patch.",11/Nov/07 16:56;christiaan;profiler screenshots,"11/Nov/07 17:00;christiaan;Attached you will find a testcase to reproduce the performance drop. Testcase should be run twice, once with generateLargeDataset set to true and once with false. The first run will generate the data, which takes about 15 minutes on my machine, the second run performs the actual test of the performance (with the generated data this can be executed 5 times). The test consists of collecting objects for deletion and next deleting them.

The output for the testcase:
Collecting 41371 objects took: 0:0:12:799 (12799.0 ms)
Deleting objects took: 0:0:6:267 (6267.0 ms)
duration 1st run: 0:0:19:66 (19066.0 ms)
Collecting 41371 objects took: 0:0:22:730 (22730.0 ms)
Deleting objects took: 0:0:5:569 (5569.0 ms)
duration 2nd run: 0:0:28:299 (28299.0 ms)

A couple of things I noticed:
1) The performance drop only occurs when a large amount of objects is involved (>20.000 objects). When it is small there is no performance drop. 
2) The factor of the performance drop is proportional to the amount of objects, eg. 40.000 objects have a performance drop of 2, 50.000 objects have a performance drop of a factor 4.
3) The performance drop is caused in traversing the object tree, not the actual delete (which is actually faster in the second run). 

Attached is also the profiler data for this test case. As you can see, the performance drop is caused AbstractHashedMap.clear(). Clear() iterates over all entries and sets them to null. Question is why is iterating so much slower in the second run when the same amount of objects is involved? I can imagine that leaving the data structure for the hashmap intact and adding objects with new identies will grow data structure and thus having impact on iterating over it, even if the number of entries stay the same. But this is just my assumption.

One other interesting thing to note is that after all objects have been collected and pm.deleteAll() + commit() is being called there is quite an increase in memory usage. After the collecting of the objects the memory usage is 40 mb, after committing of the deleteAll() the memory usage is 91 mb. So the memory usage is more than doubled even if all objects to delete have already been loaded into memory! This probably needs to be investigated in a separate issue. After the commit, the memory usage nicely drops back again to it's level when the transaction started. In the second run, the memory usage peaks at 105 mb, but this 15 mb increase might be related to the implementation of clear().

Btw, if you could send me the patched jar file I could run the test as well. 
","12/Nov/07 10:55;christiaan;I did a rerun of the testcase with the provided patch (I had to some changes to the query since Kodo 4.1.4 results in an exception with this openjpa version). The results are great:

Collecting 41371 objects took: 0:0:12:61 (12061.0 ms)
Deleting objects took: 0:0:6:356 (6356.0 ms)
duration 1st run: 0:0:18:417 (18417.0 ms)
Collecting 41371 objects took: 0:0:10:713 (10713.0 ms)
Deleting objects took: 0:0:5:751 (5751.0 ms)
duration 2nd run: 0:0:16:464 (16464.0 ms)

As you can see the collecting of objects in the second run has now been reduced from 22 seconds to 10 seconds (see output in previous comment), which is even faster than the first run! The hotspots for the first and second run are now the same and the top 10 hotspots are java. methods (the first openjpa hotspot is org.apache.openjpa.jdbc.sql.SelectImpl.getTableIndex which has only 0,3% self time). I also had a look at the memory usage since as mentioned the second run had a 15 mb increase of memory compared to the first run. This 15 mb increase of memory is now solved as well, so the second run has the same memory pattern has the first run. 

There is still one question pending. As mentioned, once all objects to be deleted into memory (40 mb) performing pm.deleteAll() increases the memory with another 45 mb. Is this as expected or should this be investigated as well?","12/Nov/07 17:57;pcl;Great! Thanks for running the numbers.

> There is still one question pending. As mentioned, once all objects to be
> deleted into memory (40 mb) performing pm.deleteAll() increases the
> memory with another 45 mb. Is this as expected or should this be
> investigated as well?

I think it's definitely worth investigating. I'm going to commit the changes to this issue and mark it as resolved, though; can you open a new issue for the potential memory leak?",13/Nov/07 10:04;christiaan;Created issue https://issues.apache.org/jira/browse/OPENJPA-441 for this,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The manual refers to FetchPlan (a JDO interface) while the OpenJPA interface is FetchConfiguration,OPENJPA-438,12382161,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,clr,clr,09/Nov/07 03:14,22/Apr/10 20:32,14/Mar/19 03:02,02/Aug/08 14:11,1.0.0,,,,,,,,,1.3.0,,,,,docs,,,,,,0,,We need to change the manual to refer to FetchConfiguration and remove references to FetchPlan if it is not implemented.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-08-02 14:11:34.862,,,no_permission,,,,,,,,,,,160760,,,Sat Aug 02 14:11:34 UTC 2008,,,,,,,0|i0z6wf:,203420,,,,,,,,"02/Aug/08 14:11;ppoddar@apache.org;org.apache.openjpa.persistence.FetchPlan is the the JPA facade level, user visible interface.
org.apache.openjpa.kernel.FetchConfiguration is the kernel level interface.

I think the doc is OK -- hence resolving it.

Please reopen if something is amiss.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
EntityManagerFactory is not thread-safe,OPENJPA-437,12382100,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,08/Nov/07 14:23,27/Mar/08 20:23,14/Mar/19 03:02,25/Jan/08 21:52,1.0.0,1.0.1,1.0.2,1.1.0,,,,,,1.0.2,1.1.0,,,,kernel,,,,,,0,,"Under certain conditions, we have discovered that the EntityManagerFactory is not thread safe when creating EntityManagers.  The problem is in the loadPersistentTypes method of the AbstractBrokerFactory.  There is an unprotected data structure (_pcClassNames) that can various problems (NullPointerException, IndexOutOfBoundsException, etc) when attempting to add new elements to the ArrayList.  Other similar datastructures in this part are properly synchronized (_pcClassLoaders for example), but somehow we missed this one.

A common scenario where this might be encountered is if your SLSB has an injected PersistenceUnit (EntityManagerFactory), but is attempting to create the EntityManager during a post-bean creation method (@PostConstruct).  In this case, the SLSB instances are probably using the same EMF instance (of course this would depend on your application server implementation).  If you have this type of environment, then hitting these SLSB's with multiple clients could get you into this situation.",,,,,,,,,,,,,,,,,,,,,,25/Jan/08 16:43;pcl;OPENJPA-437-nosync.patch;https://issues.apache.org/jira/secure/attachment/12374057/OPENJPA-437-nosync.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-11-21 03:43:00.621,,,no_permission,,,,,,,,,,,160759,,,Fri Jan 25 22:43:16 UTC 2008,,,,,,,0|i0z5pj:,203227,,,,,,,,21/Nov/07 03:43;pcl;A possible fix has been checked in for OPENJPA-449.,"21/Nov/07 03:44;pcl;Make that ""a partial fix"". OPENJPA-449 only deals with _pcClassLoaders.","16/Jan/08 16:30;kwsutter;Looking at just synchronizing the AbstractBrokerFactory.loadPersistentTypes method to resolve this problem.  As I continued to look at this problem, both _pcClassNames and _pcClassLoaders are not synchronized.  Patrick's fix for OPENJPA-449 to move the creation of the _pcClassLoaders structure to the constructor closed the window for the scenario described in OPENJPA-449, but it's still not protected from multiple client/thread access.  (Note, my previous comments in the Description about _pcClassLoaders being protected were not accurate.)

I could change both of these Collections to be synchronized, but the code was getting a bit ugly due to the still required synchronization for the iterators.  Since these two Collections are only modified in this method, an easy solution would be to make the method Synchronized.  Since this method is only used when creating new brokers, this shouldn't affect the through put.

Also, the logic for this method is based on the return value of the loadPersistentTypes on the MetaDataRepository instance.  This method is also synchronized, so we'd be following suit.

Any concerns about going the route of synchronizing the AbstractBrokerFactory.loadPersistentTypes method?

Kevin",23/Jan/08 20:05;kwsutter;Resolved in both 1.0.x and 1.1.0 branches (svn 612846 revision).,"25/Jan/08 16:43;pcl;I'm a bit concerned about adding the synchronization. While this addresses the thread safety issue, it also introduces a bottleneck for applications with a large number of concurrent threads creating new EntityManagers. This was not a bottleneck in the previous (unsafe) code since the synchronized repository call was only made once.

Attached is a patch that I believe is both thread-safe and unsynchronized. There might be a better datastructure other than a ConcurrentReferenceHashSet, but I think that it should do the job.",25/Jan/08 16:43;pcl;Reopening pending discussion of synchronization.,"25/Jan/08 21:18;kwsutter;Patrick,
Thanks for taking a look at this.

I went through the same type of concerns when I was coming up with the original patch.  But, it was my understanding that the ConcurrentReferenceHashSet still has an unprotected Iterator.  So, later on in this same loadPersistentTypes() method, the _pcClassNames structure is iterated through.  To make this iterator safe, then I would have to synchronize around this as well.  Also, the _pcClassLoaders should also be made thread-safe since we're updating that structure in this same method.  When I put in all of the necessary safeguards, it looked like it might be cleaner just by making the method synchronized.

But, if we're hitting a bottleneck by making that method synchronized, then we probably need to change it.  I had not discovered that bottleneck yet...

So, do we need to add the following items to your patch?

o  Initialize _pcClassLoaders with a ConcurrentReferenceHashSet.
o  Protect the _pcClassNames iterator usage with a synch block

Thanks,
Kevin",25/Jan/08 21:52;pcl;Good points. I resolved both with my most recent commit on this issue.,"25/Jan/08 22:43;pcl;In an offline discussion with Kevin, I realized that _pcClassNames is now read-only, so I think we should be able to replace it with a regular HashSet instead of a ConcurrentReferenceHashSet. Does that sound correct?",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Setting a null value for a primitive type field in a query results in hang,OPENJPA-434,12381890,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,spatula,spatula,06/Nov/07 06:28,22/Apr/10 20:32,14/Mar/19 03:02,02/Aug/08 14:27,1.0.0,,,,,,,,,1.3.0,,,,,,,,,,,0,,"I'm still working on a testcase to demonstrate this, but the basic steps are roughly like this:

1. Create a Query with a parameter for a primitive type field (e.g., long fooId)
2. Pass in a null for that parameter.
3. Execute the query.  OpenJPA correctly complains that a null has been passed for a primitive type field...

but once the EntityManager closes, it seems to hang forever.

If I can get a TestCase together that demonstrates this problem, I'll attach it.",,,,,,,,,,OPENJPA-497,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-08-02 14:25:54.484,,,no_permission,,,,,,,,,,,160756,,,Sat Aug 02 14:27:12 UTC 2008,,,,,,,0|i1dpvz:,288291,,,,,,,,"02/Aug/08 14:25;ppoddar@apache.org;OPENJPA-497 has tightened query parameter validation.
Related test cases have addressed similar isue.",02/Aug/08 14:27;ppoddar@apache.org;Attaching a release version,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Bad error message regarding ""openjpa.Id""",OPENJPA-428,12381637,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,vitorrodrigues,vitorrodrigues,01/Nov/07 17:39,06/Jun/18 17:10,14/Mar/19 03:02,08/Aug/12 18:04,1.0.0,,,,,,,,,,,,,,,,,,,,0,,"Hi all, this bug is to report a confusing and misplaced error message. Problem is described below. Feel free to request more info from me.

When running my project with OpenJPA, I get the following error message:

140  INFO   [http-0.0.0.0-8080-Processor23] openjpa.Runtime - Starting OpenJPA 1.0.0
380  INFO   [http-0.0.0.0-8080-Processor23] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.DB2Dictionary"".
20  WARN   [http-0.0.0.0-8080-Processor25] openjpa.Runtime - The property named ""openjpa.Id"" was not recognized and will be ignored, although the name closely matches a valid property called ""openjpa.Id"".
100  INFO   [http-0.0.0.0-8080-Processor25] openjpa.Runtime - Starting OpenJPA 1.0.0
300  INFO   [http-0.0.0.0-8080-Processor25] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.DB2Dictionary"".

As you can see, the two property names printed are the same, not different or similar. I retyped all my @Id annotations to make sure there was no special character in one of them coming from copy&paste.
Furthermore, I was able to identify that the error message was being printed only when I removed the @Id annotation from one of my classes (all the other classes still have @Id).

Here is a sample of my class without @Id annotation:
@Entity
@Table(name=""TAX"", schema=""JPA_SC"")
public class Tax  {
	
	// Class variables  
	protected double taxamount;
 
	public Tax(){
		
	}
	
	public Tax(double taxamount){
		this.taxamount = taxamount;
	}
//plus getter and setter for taxamount

}

Regards,
Vitor Rodrigues",,,,,,,,,,,,,,,,,,,,,,05/Nov/07 17:41;pcl;OPENJPA-428-test.jar;https://issues.apache.org/jira/secure/attachment/12368986/OPENJPA-428-test.jar,13/Jun/12 15:25;allee8285;OPENJPA-428.21x.patch;https://issues.apache.org/jira/secure/attachment/12531982/OPENJPA-428.21x.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-11-05 17:41:15.539,,,no_permission,,,,,,,,,,,160750,,,Wed Jun 06 17:10:12 UTC 2018,,,Patch Available,,,,0|i0yulz:,201429,,,,,,,,"05/Nov/07 17:41;pcl;Attached is a test case (source and compiled classes) that attempts to emulate this issue, but when run against OpenJPA 1.0.0, I don't see the error message.

Issue428Entity.class is enhanced in the attached jar; I also ran the test without the enhancer. I saw no errors in either environment.","16/Feb/10 18:24;faywang;There is another scenario to get the message of 'The property named ""openjpa.Id"" was not recognized and will be ignored, although the name closely matches a valid property called ""openjpa.Id"". ':

C:\was70\bin>set classpath=D:\db2jcc.jar;D:\db2jcc_license_cu.jar;D:\pdq.jar;D:\pdqmgmt.jar;D:\META-INF

C:\was70\bin>wsdb2gen -pu CustomerEJB3 -url jdbc:db2://localhost:50000/DEMODB -user user1 -pw password1
Start WsJpaDB2Gen for CustomerEJB3...
94  WARN   [main] openjpa.Runtime - The configuration property named ""openjpa.Id"" was not recognized and will be ignored, although the name closely matches a valid property called ""openjpa.Id"".
url from user is jdbc:db2://localhost:50000/DEMODB
URL from user is jdbc:db2://localhost:50000/DEMODB
ConnectionProperties: DriverType=4, DatabaseName=DEMODB, PortNumber=50000, ServerName=localhost
1203  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""com.ibm.ws.persistence.jdbc.sql.DB2Dictionary"".
1719  INFO   [main] openjpa.Runtime - Starting OpenJPA 2.0.0-M3
2047  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""com.ibm.ws.persistence.pdqstatic.jdbc.sql.StaticDB2Dictionary"".
Done!

Note that the persistence.xml is in D:\META-INF. However, the classpath is set to D:\META-INF. If the classpath is changed to D:\ , the project works fine. No more the message about openjpa.Id. 


","07/Sep/10 19:41;kwsutter;From Harold on our Users forum (http://openjpa.208410.n2.nabble.com/Confusing-warning-about-openjpa-jdbc-SynchronizeMappings-tc5495438.html#a5495438)...

Hi Kevin,

I can't offer a fix (yet), but I think I've pinpointed the problem. Here is
a little test case:

import static org.junit.Assert.assertEquals;
import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;
import org.junit.Test;

public class ConfigurationTest {

   @Test
   public void cloneTest() {
       JDBCConfigurationImpl config = new JDBCConfigurationImpl();
       JDBCConfigurationImpl newConfig = (JDBCConfigurationImpl)
config.clone();
       assertEquals(config, newConfig);
   }
}

The warning message about the configuration property
openjpa.jdbc.SynchronizeMappings is logged during config.clone().

clone() is implemented by invoking first toProperties(true) and then
fromProperties() on the resulting properties map.

fromProperties() removes all known properties from the map and then issues
warnings for all remaining ones - at least that seems to be the intention.

The problem is that SynchronizeMappings has no default value, or rather a
default value of null. Thus, the map generated by toProperties(true)
contains the key openjpa.jdbc.SynchronizeMappings with a value of null.

fromProperties() in fact only removes the known properties with a non-null
value,  so the key openjpa.jdbc.SynchronizeMappings remains in the map and
causes the warning.

The warning would not appear if clone() invoked toProperties(false), but I'm
not sure if this has any side effects.

Moreover, in my test case, the assertion

  assertEquals(config, newConfig);

fails - now the Javadoc of Object.clone() states that x.clone().equals(x) is
not an absolute requirement (without giving any good reasons), but in this
case I would definitely expect the clone of a configuration to be equal to
the original.

The assertion failure is caused by LockTimeout:0[int] != LockTimeout:0[int],
so it appears that for x of class IntValue the invariant

x.clone().equals(x)

does not hold either (why?).

Incidentally, the comment of ConfigurationImpl.toProperties() is outdated.
It references a non-existing parameter getAll and a non-existing method
getAllProperties().

Hopefully, this is enough input for someone familiar with the implementation
details to come up with a fix...

Best regards,

Harald","06/Jun/18 17:10;struberg;tickets are all resolved since at least 2012, so closing them finally",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"PostgresDictionary should set ""63"" as ""maxAutoAssignNameLength"".",OPENJPA-427,12381620,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,,isana,isana,01/Nov/07 13:58,09/Mar/10 18:32,14/Mar/19 03:02,15/Nov/07 18:16,1.0.0,1.1.0,,,,,,,,1.1.0,,,,,sql,,,,,,0,,"PostgresDictionary should set ""63"" (or something correct) as ""maxAutoAssignNameLength"", in order to let DBDictionary#getGeneratedKeySequenceName() generate correct names for IDENTITY sequences.

OpenJPA trims IDENTITY sequence names longer than 32 characters, while PostgreSQL uses longer names for BIGSERIAL sequences. So, persisting entities with @Id column with GenerationType.IDENTITY often results in a database error such as :
        org.apache.openjpa.lib.jdbc.ReportingSQLException: ERROR: relation ""x_school_membershi_entityid_seq"" does not exist {prepstmnt 2398193 SELECT CURRVAL(X_SCHOOL_TRANSFER_entityId_SEQ')} [code=0, state=42P01]

The followings are the examples. ""OK""s are the sequence names which PostgreSQL uses. ""NG""s are those which OpenJPA attempts to use.

Ex.1 -
        Table : X_SCHOOL_TRANSFER_EVENT
        BIGSERIAL Column : ENTITYID
   OK : X_SCHOOL_TRANSFER_EVENT_ENTITY_ID_SEQ
   NG : 'X_SCHOOL_TRANSFER__ENTITYID_SEQ

Ex.2 -
        Table : X_SCHOOL_MEMBERSHIP
        BIGSERIAL Column : ENTITYID
   OK : X_SCHOOL_MEMBERSHIP_ENTITYID_SEQ
   NG : X_SCHOOL_MEMBERSHI_ENTITYID_SEQ
",PostgreSQL 8.1.,,,,,,,,,,,,,,,,,,,,,04/Nov/07 10:35;isana;mychanges.patch;https://issues.apache.org/jira/secure/attachment/12368940/mychanges.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-11-06 15:54:53.684,,,no_permission,,,,,,,,,,,160749,,,Thu Nov 15 18:16:34 UTC 2007,,,,,,,0|i0yvif:,201575,,,,,,,,"04/Nov/07 10:35;isana;I created and attached below a patch to clarify what I'm thinking is to be done to fix this issue : it's simply add ""maxAutoAssignNameLength = 63;"" to the codes in the constructor of PostgresDictionary.

I've not tested the patch, because currently I don't have any environment to build OpenJPA.
I expect that my fix will work, because, according to the source comment,  PostgresDictionary uses getGeneratedKeySequenceName() which depends on the value of ""maxAutoAssignNameLength"" to obtain last generated key value.

And, I'm not sure if the value ""63"" is suitable for ""maxAutoAssignNameLength"".

I hope someone would fix if there's something wrong in my patch... m(_ _)m

Thank you.
","06/Nov/07 15:54;clr;This patch seems innocuous, and I'd like to check it in without testing.

Any objection to putting it into trunk? 

How about 1.0.x? 

How about 1.0.1? Do we think 1.0.1 is finished?","06/Nov/07 16:48;pcl;No objection to putting it into trunk.

I don't see any need to put it into 1.0.x or 1.0.1. Personally, I'm very conservative about putting any changes at all into maintenance releases, since there can always be unintended side-effects that we should be insulating our maintenance-release-consumers from.","06/Nov/07 22:05;mikedd;No objections to trunk or 1.0.x.

I don't think we need it in 1.0.1, but Albert's the judge, jury, etc. ","07/Nov/07 08:04;isana;I built OpenJPA with my patch and deployed my EAR with the private build.
Finally, @Entity objects with IDENTITY key generation no longer cause exceptions that I reported. IDENTITY sequence names seem to be handled correctly. And, for now, I don't see any side effects.

I hope that this patch is included as soon as possible, because our product needs IDENTITY key generation.

Thank you.
","07/Nov/07 19:45;pcl;Note that you should be able to do this without a patch by setting the following configuration option:

<property name=""openjpa.jdbc.DBDictionary"" value=""MaxAutoAssignNameLength=63""/>","08/Nov/07 10:14;isana;Thank you Patrick,

I'm sorry that I missed it in the manual.
","15/Nov/07 18:16;clr;Checked in the patch supplied by Ryosuke Iwata.

svn commit -m ""OPENJPA-427 Change maxAutoAssignNameLength to 63 for PostgreSQL""
Sending        sql/PostgresDictionary.java
Transmitting file data .
Committed revision 595383.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Mutation of compound ID values are not reflected in embedded ID instance in some circumstances,OPENJPA-425,12381492,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,30/Oct/07 21:32,22/Apr/10 20:32,14/Mar/19 03:02,02/Aug/08 14:17,1.0.0,,,,,,,,,1.3.0,,,,,,,,,,,0,,"I do not know what the impact of this issue on the broker or BrokerFactory cache is.

See the comment in org.apache.openjpa.persistence.jdbc.annotations.TestEmbeddedId.testMutateEmbeddedIdFieldValueOfNew() to reproduce.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-06-02 01:11:09.051,,,no_permission,,,,,,,,,,,160747,,,Sat Aug 02 14:17:31 UTC 2008,,,,,,,0|i0z7qf:,203555,,,,,,,,"02/Jun/08 01:11;amy;It seems a test case problem.
The object id should be immutable after the object id fields have been assigned.","30/Jul/08 16:33;mikedd;Is there still work to be done on this issue? There was a code drop back in October 2007, but no updates since then. ",31/Jul/08 15:39;mikedd;Tentatively deferring to next release.,"02/Aug/08 14:17;ppoddar@apache.org;The test cases TestEmbeddedId passes.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Since 29.10.2007 maven tests fails with OutOfMem,OPENJPA-424,12381369,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,,afilipchik,afilipchik,29/Oct/07 12:24,01/Aug/08 23:36,14/Mar/19 03:02,01/Aug/08 23:36,1.0.0,,,,,,,,,,,,,,jpa,,,,,,0,,"I use OpenJPA and Maven in my project. Up to 27.10.2007 all tests have worked fine.

Then something was changed (surefire or it's dependencies) - and now my simple CRUD test cause OutOfMemory exception!

For  enhancing i use ant call plugin:
<configuration>
                            <tasks>
                                <taskdef name=""openjpac"" classpathref=""maven.compile.classpath""
                                         classname=""org.apache.openjpa.ant.PCEnhancerTask""/>
                                <openjpac classpath=""${project.basedir}/target/classes"">
                                    <fileset dir=""${project.basedir}/target/classes"">
                                        <include name=""**/model/*.class""/>
                                    </fileset>
                                </openjpac>
                        </configuration>

Interesting, that now openjpa javaagent doesn't work (but it has worked in Friday)
  <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <configuration>
                    <forkMode>once</forkMode>
                    <argLine>-javaagent:${project.basedir}/../../openjpa_agent/openjpa-1.0.0.jar=jdoEnhance=true
                    <useSystemClassLoader>true</useSystemClassLoader>
                </configuration>
            </plugin>

Now it cause - 
[INFO] Surefire report directory: E:\java\LANIT\PUBSER\checkout\trunk\dev\modules\registry\target\surefire-rep
orts
[INFO] Building jar: C:\WINDOWS\TEMP\surefirebooter20526.jar
java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:141)
Caused by: java.lang.NoClassDefFoundError: org/apache/commons/lang/exception/NestableRuntimeException
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:56)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
FATAL ERROR in native method: processing of -javaagent failed
        at org.apache.openjpa.enhance.PCEnhancerAgent.premain(PCEnhancerAgent.java:61)
        ... 5 more

By the way - time of tests execution rises from one to another:
Running ru.lanit.ps.registry.service.radministrativelevel.RAdministrativeLevelServiceTe
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.671 sec
Running ru.lanit.ps.registry.service.appeal.AppealServiceTest
Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.749 sec
Running ru.lanit.ps.registry.service.address.AddressServiceTest
Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.155 sec
Running ru.lanit.ps.registry.model.jibx.rpaymenttype.RPaymentTypeBindingTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.093 sec
Running ru.lanit.ps.registry.service.addresstype.RAddressTypeServiceTest
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.64 sec
Running ru.lanit.ps.registry.service.pspassport.PsPassportTest
Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.795 sec
Running ru.lanit.ps.registry.service.functionary.FunctionaryTest
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 11.058 sec
Running ru.lanit.ps.registry.service.paymenttype.PaymentTypeServiceTest
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 10.995 sec
Running ru.lanit.ps.registry.model.jibx.roffdoctype.ROffDocTypeBindingTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 10.434 sec
Running ru.lanit.ps.registry.service.appealterm.AppealTermServiceTest
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 12.558 sec
Running ru.lanit.ps.registry.service.rplacesrequirements.RPlacesRequirementsServiceTest
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 21.835 sec
Running ru.lanit.ps.registry.service.ractivitydirection.RActivityDirectionServiceTest
Tests run: 4, Failures: 0, Errors: 4, Skipped: 0, Time elapsed: 25.942 sec <<< FAILURE! - OutOfMem

All tests is very simple CRUD tests ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160746,,,Mon Oct 29 12:29:30 UTC 2007,,,,,,,0|i0yvhj:,201571,,,,,,,,29/Oct/07 12:26;afilipchik;I use OpenJPA 1.0.0,"29/Oct/07 12:29;afilipchik;If i configure as following:

 <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <configuration>
                    <forkMode>once</forkMode>
                    <argLine>-javaagent:${project.basedir}/../../openjpa_agent/openjpa-1.0.0.jar=jdoEnhance=true</argLine>
                </configuration>
</plugin>

it cause:
java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:141)
Caused by: java.lang.NoClassDefFoundError: serp/util/Strings
        at org.apache.openjpa.lib.conf.Configurations.parseProperties(Configurations.java:517)
        at org.apache.openjpa.enhance.PCEnhancerAgent.premain(PCEnhancerAgent.java:61)
        ... 5 more
FATAL ERROR in native method: processing of -javaagent failed",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Deadlock victim exception getting sequence value with SQLServer,OPENJPA-423,12381324,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,28/Oct/07 13:58,29/Oct/07 15:48,14/Mar/19 03:02,29/Oct/07 15:48,0.9.6,0.9.7,1.0.0,,,,,,,1.0.1,1.1.0,,,,,,,,,,0,,"Opening a JIRA issue for the following problem, originally posted to openjpa-dev mailing list. 

I've run into tricky issue with Sequence tables on SQLServer.

After some time during a stress test I get this exception when trying to update the sequence table:
openjpa.jdbc.SQL: Trace: <t 25198719, conn 17636058> executing prepstmnt 4953425 SELECT SEQUENCE_VALUE FROM OPENJPA_SEQUENCE_TABLE WHERE ID = ? [params=(int) 0]
. . .
openjpa.jdbc.SQL: Trace: <t 25198719, conn 17636058> executing prepstmnt 19626156 UPDATE OPENJPA_SEQUENCE_TABLE SET SEQUENCE_VALUE = ? WHERE ID = ? AND SEQUENCE_VALUE = ? [params=(long) 48601, (int) 0, (long) 48551]
. . .
java.sql.SQLException: [IBM][SQLServer JDBC Driver][SQLServer]Transaction (Process ID 85) was deadlocked on lock resources with another process and has been chosen as the deadlock victim. Rerun the transaction.
    at com.ibm.websphere.jdbc.base.BaseExceptions.createException(Unknown Source)
    at com.ibm.websphere.jdbc.base.BaseExceptions.getException(Unknown Source)
 . . .
    at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate (DelegatingPreparedStatement.java:269)
    at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:856)

I believe I'm hitting the exception because SQLServer doesn't support the FOR UPDATE clause. Normally the first SQL statement shown above would have locked the row preventing the deadlock. SQLServer does support the WITH (UPDLOCK) hint, but I haven't found a convenient way to isolate the change so that it only affects TableSequences.",,,,,,,,,,,,,,,,,,,,,,28/Oct/07 13:58;mikedd;OPENJPA-423.patch.txt;https://issues.apache.org/jira/secure/attachment/12368559/OPENJPA-423.patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160745,,,2007-10-28 13:58:06.0,,,,,,,0|i0z4qn:,203070,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Calendar objects contained in a detached Entity still have a ""live"" StateManagerImpl",OPENJPA-422,12381307,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,27/Oct/07 19:51,09/Mar/10 18:32,14/Mar/19 03:02,27/Oct/07 20:20,1.0.0,,,,,,,,,1.0.1,1.1.0,,,,kernel,,,,,27/Oct/07 00:00,0,,"When Entities are detached, normally the StateManagerImpl instance associated with this Entity is replaced with a DetachedStateManager.  Not only with the Entity itself, but also with the proxied attributes (Date, Calendar, Collection, and Map types).  But, somehow the Calendar object type was forgotten in the code for this processing.  So, the Calendar proxy type was left with a ""live"" StateManagerImpl instance.  If the owning Broker (EntityManager) for this Entity was closed, then the use of this ""live"" StateManagerImpl would end up with an IllegalStateException.  And, even if the owning Broker (EntityManager) was still open, this ""live"" StateManagerImpl should not have been tracking the state since the enclosing Entity was detached.

A simple one-line update to DetachManager$DetachFieldManager.reproxy() method will now process the Calendar proxies as well as the other proxies it was already doing.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160744,,,Sat Oct 27 20:20:33 UTC 2007,,,,,,,0|i0z4pj:,203065,,,,,,,,27/Oct/07 20:20;kwsutter;Resolved for 1.0.1 and 1.1.0 via svn revision 589207.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA generates bad SQL before configuration fully populated,OPENJPA-421,12381285,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,dtlee,dtlee,dtlee,27/Oct/07 00:35,09/Mar/10 18:32,14/Mar/19 03:02,29/Oct/07 20:13,1.0.0,1.0.1,1.1.0,,,,,,,1.0.1,1.1.0,,,,jdbc,,,,,,0,,"When openjpa.jdbc.DBDictionary is set in persistence.xml file, OpenJPA creates a new DBDictionary instance by loading the class specified in the properties without trying to connect to database.   It leaves version related configuration unset until the first connection to the database and creates the window of referencing partial properties in the DBDictionary.  The problem happens when the first sql statement gets constructed within this window with lack of the knowledge of the version of the database.

For example, with the setting that described below, BIGINT was generated in the
SQL statement to be run on DB2 z/OS V8 and failed to execute because BIGINT was not supported on that version of z/OS DB2.

1. commenting out the setting of ""openjpa.jdbc.SynchronizeMappings"".
2. configure the connection properties to a z/OS database
3. issuing a statement similar to the following to generate SQL statement with
   ""CAST(? AS BIGINT)"".

Here is the testcase that I use to create the problem:
{
    EntityManagerFactory emf1 = 
        Persistence.createEntityManagerFactory(""demo"");
    EntityManager em1 = emf1.createEntityManager();
    em1.getTransaction().begin();
    Order o3 = (Order) em1.createQuery(
        ""select o from Order o where o.oid = 68"").getSingleResult();
    ...
}

==>
  SELECT t0.oid, t0.version, t0.amount, t0.delivered FROM Order t0
    WHERE (t0.oid = CAST(? AS BIGINT)) optimize for 1 row [params=(long) 68]
",,,,,,,,,,,,,,,,,,,,,,29/Oct/07 16:06;mikedd;OPENJPA-421.patch;https://issues.apache.org/jira/secure/attachment/12368609/OPENJPA-421.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-10-27 19:00:50.662,,,no_permission,,,,,,,,,,,160743,,,Mon Oct 29 20:13:42 UTC 2007,,,,,,,0|i0z4rb:,203073,,,,,,,,27/Oct/07 00:46;dtlee;This patch applies to both trunk and branch.,"27/Oct/07 19:00;clr;Minor formatting issue.
+                conn = ds.getConnection(conf.getConnectionUserName()
+                        , conf.getConnectionPassword());
+            else
+                conn = ds.getConnection(conf.getConnection2UserName()
+                        , conf.getConnection2Password());

should be
+                conn = ds.getConnection(conf.getConnectionUserName(),
+                        conf.getConnectionPassword());
+            else
+                conn = ds.getConnection(conf.getConnection2UserName(),
+                        conf.getConnection2Password());

I'd like to see a comment when swallowing a possible exception closing the connection. Since swallowing exceptions generally is bad practice, it would help to comment...
+                try {
+                    conn.close();
+                } catch (SQLException se) {
// ignore any exception since the connection is not going to be used anyway
+                }
","29/Oct/07 13:37;kwsutter;Something seems to be wrong with this patch...  Not sure how Craig can see it okay.  It's formatted funny.  And, when I attempt to apply it to my project, I get an ""invalid patch format"" error.",29/Oct/07 16:06;mikedd;I think I've fixed the patch (it works for me on Linux at least). Attaching the updated patch.,"29/Oct/07 16:19;kwsutter;Okay, I was able to cut-and-paste my way to happiness with this patch...  But, in the future, we need to ensure that patches posted to JIRA issues are readable and appliable.  Thanks.  I will be committing the changes soon...",29/Oct/07 16:54;dtlee;notepad reads it okay but not emacs.  emacs will be used in addition to verify the patch in the future.,29/Oct/07 16:55;dtlee;Thanks for the correction.,29/Oct/07 20:13;kwsutter;Resolved via SVN #589723 for 1.0.1 and 1.1.0 branches.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JPQL constructor query close the <SELECT DISTINCT> feature? ,OPENJPA-420,12381222,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,minewile,minewile,26/Oct/07 07:46,09/Mar/10 18:32,14/Mar/19 03:02,31/Jan/08 19:43,1.0.0,,,,,,,,,1.0.2,1.1.0,,,,kernel,,,,,,0,,"DISTINCT keyword,It can be supported in the simple query and subquery,but use  constructor query,example:select distinct new org.apache.A(a.id...),the distinct keyword is ignored .
I fixed as so:
java file:org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder
private Expression evalSelectClause(QueryExpressions exps) {
        if (exps.operation != QueryOperations.OP_SELECT)
            return null;

        JPQLNode selectNode = root();

        JPQLNode constructor = selectNode.findChildByID(JJTCONSTRUCTOR, true);
        if (constructor != null) {
           ...

            // add:now assign the distinct of the select clause
            JPQLNode selectClause = selectNode.findChildByID(JJTSELECTCLAUSE, false);
            if (selectClause != null && selectClause.hasChildID(JJTDISTINCT))
              exps.distinct = exps.DISTINCT_TRUE | exps.DISTINCT_AUTO;
            else
              exps.distinct = exps.DISTINCT_FALSE;
            
            return assignProjections(right(constructor), exps);
        } else {
            ..
        }
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-10-30 15:34:36.907,,,no_permission,,,,,,,,,,,160742,,,Thu Jan 31 17:26:27 UTC 2008,,,,,,,0|i0zbh3:,204161,,,,,,,,30/Oct/07 15:34;allee8285;Defer to next release.,31/Jan/08 17:23;pcl;Resolved in 1.0.x line. Thanks for the fix!,"31/Jan/08 17:26;pcl;BTW, the change will be available in the 1.0.2-SNAPSHOT in a few hours.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Merging graphs that include managed instances fails,OPENJPA-419,12381214,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,pcl,pcl,26/Oct/07 05:24,04/Feb/08 19:20,14/Mar/19 03:02,04/Feb/08 19:20,0.9.0,0.9.6,0.9.7,1.0.0,,,,,,1.0.2,1.1.0,,,,kernel,,,,,,0,,"Normally, em.merge() is invoked on graphs of detached or unmanaged instances. However, it is common to obtain a detached or unmanaged instance and add relations to managed instances.

It seems clear that these sorts of detached-and-managed graphs can be handled in a deterministic manner by OpenJPA. So, we should do so.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-02-01 14:24:31.335,,,no_permission,,,,,,,,,,,160741,,,Fri Feb 01 14:24:31 UTC 2008,,,,,,,0|i0z5uv:,203251,,,,,,,,01/Feb/08 14:24;kwsutter;Need to re-open to get this resolved for the 1.0.2 branch...,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unclear exception if an unknown external value is used,OPENJPA-416,12381084,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,24/Oct/07 18:07,24/Oct/07 18:09,14/Mar/19 03:02,24/Oct/07 18:09,0.9.6,0.9.7,1.0.0,,,,,,,1.0.1,1.1.0,,,,,,,,,,0,,"If you have specified ExternalValues for a field in an entity the transaction will be rolledback, but the root exception doesn't provide any information on what went wrong. 

Here's an example : 

<openjpa-1.1.0-SNAPSHOT-r420667:587896M fatal store error> org.apache.openjpa.persistence.RollbackException: null
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:469)
	at mdd.tests.TestExternalValues.testUnrecognizedExternalValue(TestExternalValues.java:40)
<snip>
Caused by: <openjpa-1.1.0-SNAPSHOT-r420667:587896M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: null
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1778)
<snip>
	... 19 more
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.kernel.StateManagerImpl.fetchInt(StateManagerImpl.java:2168)
	at org.apache.openjpa.jdbc.meta.strats.PrimitiveFieldStrategy.update(PrimitiveFieldStrategy.java:157)
<snip>
	... 23 more

The exception should be made more meaningful. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160738,,,2007-10-24 18:07:27.0,,,,,,,0|i1dpxj:,288298,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Garbage collection of AbstractResultList instance closes active connection,OPENJPA-415,12381075,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,24/Oct/07 15:58,30/Oct/07 14:36,14/Mar/19 03:02,26/Oct/07 13:55,1.0.1,1.1.0,,,,,,,,1.0.1,1.1.0,,,,jdbc,,,,,,0,,"While investigation a problem, I noticed that garbage collection kicks in on the AbstractResultList's finalize() method.
        ........
        at org.apache.openjpa.lib.jdbc.DelegatingConnection.close(DelegatingConnection.java:212)
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.close(LoggingConnectionDecorator.java:279)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.free(JDBCStoreManager.java:1288)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.close(JDBCStoreManager.java:1273)
        at org.apache.openjpa.jdbc.sql.ResultSetResult.close(ResultSetResult.java:182)
        at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.close(SelectResultObjectProvider.java:148)
        at org.apache.openjpa.lib.rop.WindowResultList.free(WindowResultList.java:158)
        at org.apache.openjpa.lib.rop.WindowResultList.close(WindowResultList.java:78)
        at org.apache.openjpa.lib.rop.AbstractResultList.finalize(AbstractResultList.java:89)
        at java.lang.J9VMInternals.runFinalize(J9VMInternals.java:406)

When traversing the call stack to the ResultSetResult.close() method, it is trying to close the result set unconditionally, and then close the associated statement and connection if they exists:

    public void close() {
        super.close();
        try {
            _rs.close();
        } catch (SQLException se) {
        }
        if (_stmnt != null)
            try {
                _stmnt.close();
            } catch (SQLException se) {
            }
        if (_closeConn)
            try {
                _conn.close();
            } catch (SQLException se) {
            }
    }

Would this be a undesired side-effect and a problem in the following scenario:

1)  appl / openjpa obtains a connection
2)  create a prepare statement 
3)  get a result set from the statement
4)  using the same statement and get another result set. The first result set is not being referenced by any code and ready for gc.
5)  the connection and statement is active for a long time and gc kicks in to gc the first result set instance
6)  eventually the ResultSetResult.close() gets call.
7)  The statement and connection gets closed while it is still being used by appl / openjpa.

Is this a possible scenario? 

According to the JCA architecture, connection that is scoped to a transaction will be closed by the connection manager and all associated statements and result set managed by the connection will be automatically closed. So is the AbstractResultList.finalize() ever be needed at all? 

Albert Lee.
",,,,,,,,,,,,,,,,,,,,,,24/Oct/07 20:02;allee8285;OPENJPA-415.patch;https://issues.apache.org/jira/secure/attachment/12368320/OPENJPA-415.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160737,,,Wed Oct 24 20:02:35 UTC 2007,,,,,,,0|i0z4sf:,203078,,,,,,,,"24/Oct/07 18:24;allee8285;Another finding is: the AbstractResultList.finalize() also causing some thread safety issues for some connection manager that does not support mutli-threaded access. I was told that in general JDBC driver, connection manager etc do not require to support multi-thread. This means closing connection from gc's finalize method, which is executed in a different thread, may cause problems. This is the original observed problem that I was trying to resolve.

By not doing explicit gc in AbstractResultList, both of the described problems were resolved. I have also looked at the heap dump snapshots taken during a 20 hours application run, I did not see any abnormal openjpa object (memory) leakage other than the normal heap growth by other application components.

Are there any reasons the AbstractResultList.finalize() can NOT be removed?

Albert Lee.",24/Oct/07 20:02;allee8285;This patch has been tested against a test application ran for 20+ hours without error and no undesirable heap growth.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Fix some message text in the localizer.properties files,OPENJPA-413,12380988,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,tckan1,tckan1,tckan1,23/Oct/07 15:31,09/Mar/10 18:32,14/Mar/19 03:02,30/Oct/07 15:29,1.0.0,,,,,,,,,1.0.1,1.1.0,,,,,,,,,,0,,Made some message text more readable and clearer.,,,,,,,,,,,,,,,,,,,,,,23/Oct/07 15:35;tckan1;OPENJPA-413.patch;https://issues.apache.org/jira/secure/attachment/12368223/OPENJPA-413.patch,24/Oct/07 20:07;tckan1;OPENJPA-413_2.patch;https://issues.apache.org/jira/secure/attachment/12368322/OPENJPA-413_2.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-10-23 17:25:01.728,,,no_permission,,,,,,,,,,,160735,,,Wed Oct 24 20:07:04 UTC 2007,,,,,,,0|i1dpxr:,288299,,,,,,,,23/Oct/07 15:35;tckan1;Attach the patch .. modified some messages for translation..,"23/Oct/07 17:25;allee8285;+++ openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties	(working copy)
@@ -314,7 +314,8 @@
 	generic put(Object,Object) method that can be used, nor does it have a \
 	public constructor that takes the types {2}.
 pack-err: There was an error packing the projection and/or aggregate results \
-	of the query into result type ""{0}"".  See the nested throwable for details.
+	of the query into result type ""{0}"".  See the nested Throwable exceptoin \
+	for details.

Typo:   Throwable exceptoin -> Throwable exception",24/Oct/07 20:07;tckan1;Found another message text that needs to be fixed.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Change ""connecting to dictionary"" message from Info to Trace",OPENJPA-410,12380777,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,kwsutter,kwsutter,kwsutter,19/Oct/07 13:25,09/Mar/10 18:32,14/Mar/19 03:02,29/Oct/07 20:14,1.0.0,1.0.1,1.1.0,,,,,,,1.0.1,1.1.0,,,,jdbc,,,,,,0,,"Discussed on our dev mailing list:  http://www.nabble.com/Change-%22connecting-to-dictionary%22-message-from-Info-to-Trace--tf4647416.html  :-)

Since nobody dissented, I'm going to go ahead with changing this message from an Info to a Trace entry.  Existing users of OpenJPA have already figured out how to ignore the message or change their configuration to avoid it, so it should be no problem with changing it.

Kevin",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160732,,,Mon Oct 29 20:14:30 UTC 2007,,,,,,,0|i1dpyf:,288302,,,,,,,,29/Oct/07 20:14;kwsutter;Resolved via svn   #586588.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Quick message updates,OPENJPA-409,12380652,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,18/Oct/07 01:28,09/Mar/10 18:32,14/Mar/19 03:02,18/Oct/07 01:46,1.0.0,1.0.1,1.1.0,,,,,,,1.0.1,1.1.0,,,,kernel,,,,,,0,,"Per the conversation on the dev mailing list:  http://www.nabble.com/error-message-for-native-sql-parameters-tf4641774.html

Updating message to indicate that only positional parameters are valid for native queries.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160731,,,Thu Oct 18 01:46:43 UTC 2007,,,,,,,0|i0z6pj:,203389,,,,,,,,18/Oct/07 01:46;kwsutter;Resolved via svn revision #585773 for 1.0.1 and 1.1.0.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
need extract space in the message text,OPENJPA-405,12380561,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,tckan1,tckan1,tckan1,16/Oct/07 20:48,09/Mar/10 18:32,14/Mar/19 03:02,16/Oct/07 21:55,,,,,,,,,,1.0.1,1.1.0,,,,kernel,,,,,,0,,"two words concat togther in the following message due to the space was missing in front of separator. Therefore, contract and detected became one word: contractdetected. 

subclasser-contract-violation-field: Possible violation of subclassing contract\
	detected while processing persistent field {1}, declared in {2}. \ 
	Are you sure you are obeying the OpenJPA requirements? Details: {0}

Fix will be :
subclasser-contract-violation-field: Possible violation of subclassing \
	contract detected while processing persistent field {1}, declared in {2}. \ 
	Are you sure you are obeying the OpenJPA requirements? Details: {0}",,,,,,,,,,,,,,,,,,,,,,16/Oct/07 20:53;tckan1;OPENJPA-405.patch;https://issues.apache.org/jira/secure/attachment/12367836/OPENJPA-405.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-10-16 21:55:55.772,,,no_permission,,,,,,,,,,,160727,,,Tue Oct 16 21:55:55 UTC 2007,,,,,,,0|i1dpz3:,288305,,,,,,,,16/Oct/07 20:53;tckan1;attach the patch,16/Oct/07 21:55;kwsutter;Resolved via revision 585269 for 1.0.x and 1.1.0.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
LoadFetchGroup patch (OPENJPA-370) introduces NPE,OPENJPA-403,12380475,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,pcl,pcl,pcl,15/Oct/07 19:48,09/Mar/10 18:32,14/Mar/19 03:02,18/Oct/07 15:33,1.0.1,1.1.0,,,,,,,,1.0.1,1.1.0,,,,,,,,,,0,,"From the patch:

            // post process for the fetchGroup: if there is a
            // fetchgroup field, then go to the FetchConfiguration
            // to get the required fetch fields.
            if (fgs != null) {
                if (fields == null)
                    fields = new BitSet(fmds.length);
                BitSet fgFields = fetch.requiresFetch(fgs, fmds);
                // merge the fetchgroup required fields to the original
                // fields only the fields are not already loaded and
                // are not in the original fields.
                for (int j = 0; j < fgFields.length(); j++) {
                    if (fgFields.get(j) && !fields.get(j) && !_loaded.get(j))
                        fields.set(j);
                }
            }

That code introduces an NPE if fetch is null. This is legal; see PNonTransState:108, for example.",,,,,,,,,,,,,,,,OPENJPA-370,,,,,,18/Oct/07 15:25;tckan1;OPENJPA-403.patch;https://issues.apache.org/jira/secure/attachment/12367952/OPENJPA-403.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-10-16 12:47:01.43,,,no_permission,,,,,,,,,,,160725,,,Thu Oct 18 15:33:58 UTC 2007,,,,,,,0|i0yvtb:,201624,,,,,,,,16/Oct/07 00:53;pcl;This has been fixed in the 1.1.0 branch (trunk).,"16/Oct/07 12:47;tckan1;Patrick,
Yes, your patch looks good. I did not catch this situation before..Thanks for fixing it.

Teresa
","18/Oct/07 15:25;tckan1;The 1.0.x branches need to be sync up with the 1.1.0 trunk..
","18/Oct/07 15:33;kwsutter;Now resolved for both 1.1.0 and 1.0.x branches.  Thanks, Patrick and Teresa.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unable to detect an valid Entity's meta data when the entity's .class file size is large.,OPENJPA-402,12380369,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,13/Oct/07 03:16,15/Oct/07 17:43,14/Mar/19 03:02,15/Oct/07 16:57,1.0.1,1.1.0,,,,,,,,1.0.1,1.1.0,,,,lib,,,,,,0,,"We ran into a scenario in which an application has all the correct configuration in the persistence.xml and orm.xml but the provider is still unabled to recognize an entity and establish its meta data. As a result, the following exception is thrown from openjpa.

    org.apache.openjpa.persistence.ArgumentException:No metadata was found for type ""class suite.r70.base.jpaspec.relationships.manyXmany.entities.containertype.annotated.MMContainerTypeEntityA"". The class does not appear in the list of persistent types:
[suite.r70.base.jpaspec.relationships.manyXmany.entities.uni.annotation.MMUniEntA, 
suite.r70.base.jpaspec.relationships.manyXmany.entities.bi.xml.XMLMMBiEntB_CA, 
  ..........
suite.r70.base.jpaspec.relationships.manyXmany.entities.bi.xml.XMLMMBiEntB_CRM]

	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:299)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2371)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2224)
	at org.apache.openjpa.kernel.DelegatingBroker.persist(DelegatingBroker.java:1005)
	at org.apache.openjpa.persistence.EntityManagerImpl.persist(EntityManagerImpl.java:541)
    
There are many entities defined in this application. A point of interest is there are 2 entities in the same package, in the same persistence archive but only one of these entity's meta data is found.

------------------------------------------

The cause of the problem is in ZipFileMetaDataIterator.getContent() method.
     
     public byte[] getContent() throws IOException {
        long size = _entry.getSize();
        if (size == 0)
            return new byte[0];

        InputStream in = _file.getInputStream(_entry);
        byte[] content;
        if (size < 0) {
            ByteArrayOutputStream bout = new ByteArrayOutputStream();
            byte[] buf = new byte[1024];
            for (int r; (r = in.read(buf)) != -1; bout.write(buf, 0, r)) ;
            content = bout.toByteArray();
        } else {
            content = new byte[(int) size];
            in.read(content);     <<<<<<<  cause of the problem here.
        }
        in.close();
        return content;
    }

What happened is if the entity class file is big enough, the in.read() only returns partial content of the .class file. Therefore during the ClassAnnotationMetaDataFilter.match() processing the annotation attribute count in the .class file is read to be zero and the entity is not detected as an Entity.

The solution is to replace

            in.read(content);     <<<<<<<  cause of the problem here.
 
 by
    
            int offset = 0;
            int read;
            while (offset < size
                && (read = in.read(content, offset, (int) size - offset)) != -1) {
                offset += read;
            }

",,,,,,,,,,,,,,,,,,,,,,13/Oct/07 03:23;allee8285;OPENJPA-402.patch;https://issues.apache.org/jira/secure/attachment/12367676/OPENJPA-402.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160724,,,Sat Oct 13 03:23:07 UTC 2007,,,,,,,0|i0z6xz:,203427,,,,,,,,13/Oct/07 03:23;allee8285;Patch attached.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
UnsatisfiedLinkError in MappingToolTask when using DB2 JDBC driver ,OPENJPA-401,12380246,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,12/Oct/07 15:35,05/Feb/08 19:08,14/Mar/19 03:02,05/Feb/08 19:08,1.0.0,,,,,,,,,1.0.1,1.0.2,1.1.0,,,,,,,,,0,,"The MappingToolTask's class resolver loads classes from a temporary classloader before loading them in the ""normal"" classloader. This can cause problems if the JDBC driver requires access to native libraries (which can only be loaded once). 

I've seen errors like this when using the DB2 JCC driver and the IBM JDK : 

  [mapping] 608  persistence-tests  INFO   [main] openjpa.Tool - Recording mapping and schema changes.
  [mapping] java.lang.UnsatisfiedLinkError: com/ibm/jvm/Trace.initTrace([Ljava/lang/String;[Ljava/lang/String;)V
  [mapping]     at com.ibm.jvm.Trace.initializeTrace(Trace.java:96)
  [mapping]     at com.ibm.jvm.Trace.<clinit>(Trace.java:61)
  [mapping]     at java.lang.J9VMInternals.initializeImpl(Native Method)
  [mapping]     at java.lang.J9VMInternals.initialize(J9VMInternals.java:192)
  [mapping]     at java.lang.Class.forNameImpl(Native Method)
  [mapping]     at java.lang.Class.forName(Class.java:130)
  [mapping]     at com.ibm.db2.jcc.c.o.q(o.java:550)
  [mapping]     at com.ibm.db2.jcc.c.o.<clinit>(o.java:319)
  [mapping]     at java.lang.J9VMInternals.initializeImpl(Native Method)
  [mapping]     at java.lang.J9VMInternals.initialize(J9VMInternals.java:192)
  [mapping]     at java.lang.Class.forNameImpl(Native Method)
  [mapping]     at java.lang.Class.forName(Class.java:130)
  [mapping]     at com.ibm.db2.jcc.DB2Driver.class$(DB2Driver.java:48)
  [mapping]     at com.ibm.db2.jcc.DB2Driver.<clinit>(DB2Driver.java:51)
  [mapping]     at java.lang.J9VMInternals.initializeImpl(Native Method)
  [mapping]     at java.lang.J9VMInternals.initialize(J9VMInternals.java:192)
  [mapping]     at java.lang.Class.forNameImpl(Native Method)
  [mapping]     at java.lang.Class.forName(Class.java:163)
  [mapping]     at org.apache.openjpa.jdbc.schema.DataSourceFactory.newDataSource(DataSourceFactory.java:82)

 <snip>

Note that this does not occur with the Sun JDK (or at least I haven't hit the problem.

A potential solution is to change the order of the classloaders used in MappingToolTask.",,,,,,,,,,,,,,,,,,,,,,29/Nov/07 17:16;mikedd;OPENJPA-401.patch.txt;https://issues.apache.org/jira/secure/attachment/12370559/OPENJPA-401.patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-11-28 22:53:38.279,,,no_permission,,,,,,,,,,,160723,,,Tue Feb 05 19:08:23 UTC 2008,,,,,,,0|i1dpzb:,288306,,,,,,,,"28/Nov/07 22:53;mprudhom;I'm reopening this because the fix was causing intermittent failures in loading metadata. E.g.:

[mappingtool] <openjpa-1.1.0-SNAPSHOT-r420667:598829 fatal user error> org.apache.openjpa.util.MetaDataException: Type ""class kodo.performance.PerfMultiA"" does not have persistence metadata.
[mappingtool] 	at org.apache.openjpa.jdbc.meta.MappingTool.getMapping(MappingTool.java:679)
[mappingtool] 	at org.apache.openjpa.jdbc.meta.MappingTool.refresh(MappingTool.java:716)
[mappingtool] 	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:641)
[mappingtool] 	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:1072)
[mappingtool] 	at org.apache.openjpa.jdbc.ant.MappingToolTask.executeOn(MappingToolTask.java:197)
[mappingtool] 	at org.apache.openjpa.lib.ant.AbstractTask.execute(AbstractTask.java:172)

I've committed revision #599178 which swaps the order in which the child loaders are added to the MultiLoaderClassResolver, which seems to fix the problem, but I don't know if it will re-introduce the original symptoms reported in the bug. Michael, can you check with this new revision to see if it still works with your DB2 native driver?","29/Nov/07 17:16;mikedd;Unfortunately I do still see the problem. I haven't re-verified that it only occurs with the IBM JDK though (I'll try that later). 

In the mean time I wrote a quick patch which adds a configuration option to disable the temporary classloader for the mappingToolTask - which might be a palatable interim solution. ",30/Jan/08 19:28;pcl;What's the status of this issue?,"05/Feb/08 19:08;mikedd;The MappingToolTask now includes a flag which can be used to disable the temporary classloader, similarly to the PCEnhancerTask. If the flag is not specified then we'll use the temporary classloader (original behavior). ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
openjpa did not handle multiple schema names with same table name,OPENJPA-399,12380120,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,tckan1,tckan1,tckan1,10/Oct/07 22:48,09/Mar/10 18:32,14/Mar/19 03:02,13/Dec/07 15:10,1.0.1,,,,,,,,,1.0.1,1.1.0,,,,jdbc,,,,,,0,,"Two entities have the same table name but with different schema, only one table is created. In addition, when two entities use the generatedType.AUTO for ID, only one OPENJPA_SEQUENCE-TABLE is created.

The problem due to the SchemaGroup.findTable() which only looked for a table name from all the schemas. Once the table was found in one of the schema then it exited and assumed that the table existed. Same problem in the TableJDBCSeq.addSchema().
","JDK1.5, OPENJPA verison 580425",,,,,,,,,,,,,,,,,,,,,17/Oct/07 20:57;tckan1;OPENJPA-399_2.patch;https://issues.apache.org/jira/secure/attachment/12367906/OPENJPA-399_2.patch,29/Oct/07 17:04;tckan1;OPENJPA-399_3.patch;https://issues.apache.org/jira/secure/attachment/12368612/OPENJPA-399_3.patch,12/Oct/07 23:05;tckan1;OPENJPA_399.patch;https://issues.apache.org/jira/secure/attachment/12367669/OPENJPA_399.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-10-11 14:41:08.861,,,no_permission,,,,,,,,,,,160721,,,Thu Dec 13 15:10:08 UTC 2007,,,,,,,0|i0zbhz:,204165,,,,,,,,"10/Oct/07 23:08;tckan1;Example of the problem:
@Entity(name=""Dog"")
@Table(name=""DOGTAB"")

@IdClass(DogId.class)
public class Dog implements Serializable
	
{
	@Id
                     @GeneratedValue(strategy=GenerationType.AUTO)
	private int id2;
..
)

@Entity(name=""Dog2"")
@Table(name=""DOGTAB"")

@IdClass(DogId.class)
public class Dog2 implements Serializable
	
{
	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	private int id2;
..
)

Although the datasource uses different schema name, openjpa only created one table for DOG but not DOG2.


The current architecture based on the following assumption: 
Each PU has one JDBCConfiguration, each JDBCConfiguration has only one SeqValue and one TableJDBCSeq instance. These are singletons. During the JDBCConfiguration instantate phase, the TableJDBCSeq was created and setup the default schema. At this point, there was no correlation between the actual schema with the table and with the entity class. Each entity class has the SchemaGroup which contains all the schemas within this PU, but you can tell which schema is used for this entity. 

The ultimate solution is to change the JDBCConfiguration to know the entity and its schema info at the instantiation phase. Then makes the seqValue and TableJDBCSeq as singleton for each schema. I tried to figure out how to make it work but failed. I can't find any correlation between entity, schema and table name at the configuration instantiation phase.. ..

My current solution is  based on the current architecture and fix it in the TableJDBCSeq and NativeJDBCSeq. Since the TableJDBCSeq /NativeJDBCSeq is a singleton, so I put the logic to add the seq table name for each schema for this SchemaGroup.. Then during the Insert and Update the seq table, the table name will be fully quality with the schema name, so we can insert to the correct seq table.. 

There are some restrictions for using multiple schemas for the same table name that we need to document:

1) If multiple entities have the same table name,  then they must be qualified with the schema name either thru the annotation or xml mapping. If one of entity does not have a schema and one entity has a schema, it still fails when the application executes again.
2) If multiple entities have the generatedType.AUTO, SEQUENCE, TABLE for ID and using the same table name, then each entity must have the schema name.
3) For those entities which have its unique table name within the PU, then the schema name is not required even though the entity using the generatedType of AUTO, SEQUENCE and TABLE. -- this is today's implementation.

For the generatedType.SEQUENCE, if multiple entities use different scehmas for the same table and the sequence generator are the same, then only one sequence  is created and is used for all the entities. However, if each entity has its own sequence generator, then each generator will have its own sequence. For example,
@Entity(name=""Dog"")
@Table(name=""DOGTAB"", schema=""DB2ADMIN"")

@IdClass(DogId.class)
public class Dog implements Serializable
	
{
	@Id
	@SequenceGenerator(name=""myseq"",sequenceName=""order_seq2"")
	@GeneratedValue(strategy=GenerationType.SEQUENCE,generator=""myseq"")
	private int id2;
..
)

@Entity(name=""Dog2"")
@Table(name=""DOGTAB"", schema=""TWC"")

@IdClass(DogId.class)
public class Dog2 implements Serializable
	
{
	@Id
	@SequenceGenerator(name=""mysequence"",sequenceName=""order_seq9"")
	@GeneratedValue(strategy=GenerationType.SEQUENCE,generator=""mysequence"")
	private int id2;
..
)
The output will be like this:
executing prepstmnt 538058770 VALUES NEXTVAL FOR order_seq2
executing prepstmnt 1078214724 VALUES NEXTVAL FOR order_seq9

the id values are :
after find, dog1 id2  = 425 and dog name =helloDog
after find, dog11 id2  = 426 and dog name =helloDog1a
after find, dog3 id2  = 5 and dog name =helloDog2
after find, dog31 id2  = 6 and dog name =helloDog2a



",10/Oct/07 23:10;tckan1;attach the patch..,"11/Oct/07 14:41;kwsutter;Teresa,
I haven't reviewed your patch yet, but I'd like to get some clarification on the problem first...

>  Although the datasource uses different schema name, openjpa only created one table for DOG but not DOG2.

It seems that your code example is dependent on another configuration somewhere.  Either a persistence.xml or orm.xml that would differentiate the schema name.  Is that correct?  Your text mentions a ""datasource uisng a different schema name"", but I'm not sure what you meant by that.  Basically, you are saying that attempting to use the same table with different schemas causes a problem because we are currently not differentiating between tables with different schemas.  Right?

>  2) If multiple entities have the generatedType.AUTO, SEQUENCE, TABLE for ID and using the same table name, then each entity must have the schema name.

Not sure I follow this.  Are you stating the use of different schemas is an absolute requirement for id generation?  Or, only if you are interested in keeping the id generations separate from each other?  I'm trying to figure out what limitations exist under what conditions.

And, your last example with multiple sequence generators...  Did you have to change something to allow this to work?  This sounds like normal, expected behavior.  Did you fix something in this area?

Finally, as part of the patch, it sounds like you are suggesting some documentation updates.  Are you going to include the necessary documentation updates to clarify these restrictions?  Since it sounds like we are totally broke with some of these scenarios, I'm okay with fixing the problem(s) with documentation updates.  But, I don't want to fix something without documenting how it's supposed to work for our customers.  Or, how we can make it work for our customers.

I'll take a look at your patch next, but I wanted to get started with these questions.

Thanks,
Kevin
","11/Oct/07 21:39;tckan1;attach 2nd patch and test case:
1) I removed the NativeJDBCSeq code since it worked as design.
2) Include the documentation changes in the OpenJPA manaual and Ref guide
3) inlcude the test case","12/Oct/07 03:29;kwsutter;Comments on the patches...  Overall, the concept and logic looks good.  I just have a few questions/comments about the proposed code changes.  Ping me if you have any questions on my abbreviated comments.  Thanks.

o  The restriction about requiring schema names for all tables if you use schema names for at least one of the entities using the same table name...  I'm okay with this restriction, but is there anyway that we could detect this condition?  That is, if we detect the use of a ""null"" schema with other existing schema names, couldn't we flag this a configuration error?

o  Any updated patches should be attached to the Issue with the same name.  JIRA keeps track of the older versions automatically, so you don't have to continually add a ""version number"" to your patch files.

o  The testcases should be provided as part of the patch file.  Makes it much easier to merge the new files into an existing project.  It also removes the confusion with different project names (ie. openjpa10x_2 doesn't match my project name).

o  The testcases need the Apache licensing...  :-)  Take a look, you'll understand.

o  In TableJDBCSeq, the getStatus method updates are interesting.  So, the previous implementation of this method didn't act on the input parameter at all?  That's strange.  Also, the javadoc for this method indicates that the input parameter (mapping) could be null.  Is it okay for your code to use ""null"" as a key for the HashMap?

o  In that same file, why not just initialize _stat to the new HashMap() (similar to the original ""new Status()"")?  And, the original declaration was final.  If you use an initializer, couldn't we go back to the ""final"" declaration?  Maybe I'm missing the reasons for your current _stat initialization.

o  In the addSchema() method, there's no longer a ""fast path"" return conditional at the beginning of the method.  Isn't there any means of bypassing all of the processing if the table/schema already exists?

o  I'm not following your code at the end of the addSchema() method with the ""Index idx"" processing.  It looks like this index processing is a side-effect of calling addSchema().  Is that your intent?  At a minimum, this requires additional comments, but maybe it requires some re-factoring to make this clearer.

o  The processing of generating the tableName is repeated in at least three areas of TableJDBCSeq.  Could a common utility method be used instead so as not to repeat the code?

o  I don't understand the comments for Column.resetTableName().  Doesn't ""reset"" mean to modify an existing set, yet the comment indicates that this can only be called on columns without a table set.

o  The cleanup in LocalConstraint.addColumn() looks good.

o  The logic in SchemaGroup.findTable and SchemaGroup.findSequence seems to be very close.  Can any of this code be shared in a private utility method?

That's it,
Kevin","12/Oct/07 21:17;tckan1;Kevin,
Thanks for the comments. I fixed the code based on your comments. However, I can't determine the configuration error because I can't tell whether the null schema is valid or not. 

For the question about HashMap, yes, HashMap can handle the null key . Here is the info from java doc:
""Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key""

For the last question about the logic in SchemaGroup.findTable and findSequence. It is not necessary to combine them together since they have different return object. Instead of adding more checking in a common method, the current way may be ok..

",12/Oct/07 21:22;tckan1;attach final patch,"17/Oct/07 04:01;tckan1;I discovered another problem in GeneratedType.Sequence. If the entity did not declare a schema name  and the table name was unique, the sequence was created successfully the first time. However, when I ran the test again, it can't find the sequence.  
Since the sequence name is unique within a system, therefore, we can let all sequences create in the default schema. IN this case, we can use the null schema name to search the sequences from the db. The fix will be :

Index: openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java
===================================================================
--- openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java	(revision 585254)
+++ openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java	(working copy)
@@ -819,8 +819,10 @@
         if (_log.isTraceEnabled())
             _log.trace(_loc.get(""gen-seqs"", schemaName, sequenceName));
 
+        // since all the sequences are generated under the default schema
+        // therefore, we can use the null schemaname to search
         Sequence[] seqs = _dict.getSequences(meta, conn.getCatalog(),
-            schemaName, sequenceName, conn);
+            null, sequenceName, conn);
 
         SchemaGroup group = getSchemaGroup();
         Schema schema;
Index: openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java
===================================================================
--- openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java	(revision 585254)
+++ openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java	(working copy)
@@ -94,7 +94,7 @@
             ""LONG VARCHAR FOR BIT DATA"", ""LONG VARCHAR"", ""LONG VARGRAPHIC"",
         }));
         systemSchemas = new String(
-                ""SYSCAT, SYSIBM, SYSSTAT, SYSIBMADM, SYSTOOLS"");
+                ""SYSCAT,SYSIBM,SYSSTAT,SYSIBMADM,SYSTOOLS"");
         maxConstraintNameLength = 18;
         maxIndexNameLength = 18;
         maxColumnNameLength = 30;
Index: openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java
===================================================================
--- openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java	(revision 585254)
+++ openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java	(working copy)
@@ -3341,7 +3341,7 @@
         try {
             int idx = 1;
             if (schemaName != null)
-                stmnt.setString(idx++, schemaName);
+                stmnt.setString(idx++, schemaName.toUpperCase());
             if (sequenceName != null)
                 stmnt.setString(idx++, sequenceName);
 
","17/Oct/07 20:57;tckan1;There was another problem occurred in SQLServer that the dict.getColumns() can't find the table names because openjpa alway convert the table name to upper case. The table name is case sensive on SQLServer, therefore, no tables are found. Openjpa created the tables again and failed with duplicate tables.

The fix will introduce a getSchemaCase() method on DBDictionary. SQLServerDictionary overrides this method to return the SCHEMA_CASE_PERSERVE.

Original code in  DBDictionary on the convertSchemaCase :
 protected String convertSchemaCase(String objectName) {
        if (objectName == null)
            return null;

        if (SCHEMA_CASE_LOWER.equals(schemaCase))
            return objectName.toLowerCase();
        if (SCHEMA_CASE_PRESERVE.equals(schemaCase))
            return objectName;
        return objectName.toUpperCase();
    }

Fix will be :

 protected String convertSchemaCase(String objectName) {
        if (objectName == null)
            return null;

        String scase = getSchemaCase();
        if (SCHEMA_CASE_LOWER.equals(scase))
            return objectName.toLowerCase();
        if (SCHEMA_CASE_PRESERVE.equals(scase))
            return objectName;
        return objectName.toUpperCase();
    }","29/Oct/07 16:28;tckan1;We only need to create the index for the OPENJPA_SEQUENCE_TABLE for DB2/ZOS only. Therefore, move the index creation code to the DB2Dictionary.",13/Dec/07 15:10;tckan1;Problem has been resolved,,,,,,,,,,,,,,,,,,,,,,,,,,
schematool ant task always requires files,OPENJPA-397,12379875,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,mikedd,mikedd,08/Oct/07 15:18,08/Oct/07 17:18,14/Mar/19 03:02,08/Oct/07 17:18,1.0.0,,,,,,,,,1.0.1,1.1.0,,,,,,,,,,0,,"The schema tool ant task requires files to be provided regardless of the schematool action.

It should only require files if you are importing from xml. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160719,,,2007-10-08 15:18:08.0,,,,,,,0|i1dpzr:,288308,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cloning Calendar proxies doesn't detach from StateManager,OPENJPA-396,12379870,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,08/Oct/07 14:14,09/Mar/10 18:32,14/Mar/19 03:02,09/Oct/07 14:29,1.0.0,1.0.1,1.1.0,,,,,,,1.0.1,1.1.0,,,,kernel,,,,,08/Oct/07 00:00,0,,"This problem was first discussed on our dev mailing list:  http://www.nabble.com/Cloning-Calendar-proxies-tf4571181.html

Per the discussion on that thread, I am proposing to modify the generated proxy code to override the clone() method.  This clone() method will do the necessary copying of data from the original object, but then also null out the sm (StateManager) and zero out the field attributes.  This action detaches the cloned object from the StateManager (and associated EntityManager).

Instead of limiting this action to the Calendar proxy, I am adding the clone() method implementation to all of our proxy objects that we generate.  Granted, some of the object types do not directly support the clone() method, but that will be detected when or if anybody attempts to use the clone() method on these types (compiler generated error message).

I'll be posting a patch shortly and I plan to commit the changes later today (unless there is opposition).

Thanks,
Kevin",,,,,,,,,,,,,,,,,,,,,,08/Oct/07 14:52;kwsutter;OPENJPA-396.patch;https://issues.apache.org/jira/secure/attachment/12367265/OPENJPA-396.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-10-08 17:25:05.705,,,no_permission,,,,,,,,,,,160718,,,Tue Oct 09 14:29:38 UTC 2007,,,,,,,0|i0zbfj:,204154,,,,,,,,"08/Oct/07 14:52;kwsutter;Proposed patch for OpenJPA-396.  It was built against the 1.0.x branch, but also seems to work with the trunk (1.1.0).

When testing this patch, I found that TestProxyManager had a couple of problems that needed correcting.  After these changes were made, I had to re-factor a few of the ""assert"" methods so that we were testing for proper equality when copying vs cloning.  That's why the patch for TestProxyManager looks larger than expected.

I plan to commit these changes later today unless concerns are raised with the patch.

Thanks,
Kevin","08/Oct/07 17:25;clr;Hi Kevin,

One question. In the generated clone method, after calling super.clone(), why do you not simply invoke stateManager = null; pcState = 0; instead of calling the setOwner(null, 0) method?

Seems like there is additional code in setOwner that you want to avoid because there is not yet any relationship between the owner and the sco. The effect of calling this method from the clone might be to disassociate the original sco.","08/Oct/07 17:52;kwsutter;[ Show » ]
Craig Russell - 08/Oct/07 10:25 AM Hi Kevin, One question. In the generated clone method, after calling super.clone(), why do you not simply invoke stateManager = null; pcState = 0; instead of calling the setOwner(null, 0) method? Seems like there is additional code in setOwner that you want to avoid because there is not yet any relationship between the owner and the sco. The effect of calling this method from the clone might be to disassociate the original sco.

Craig,
The original reason is that I couldn't figure out the proper serp invocations to just set those two fields.  :-)  Then, I found the setOwner method on the Proxy (also generated code) that did just what I was looking for.  So, it was more straight-forward to just call this method than to repeat the same code.

As far as I can tell, the setOwner has no other side effects.  I am calling setOwner on the Proxy, not the StateManager.  The code is generated in the ProxyManagerImpl class (addProxyMethods method).  And, the javadoc for this method is as follows:

    /**
     * Reset the state of the proxy, and set the owning instance of the
     * proxy and the name of the field it is assigned to. Set to null to
     * indicate that the proxy is no longer managed.
     */
    public void setOwner(OpenJPAStateManager sm, int field);

Kevin
","08/Oct/07 18:08;clr;> As far as I can tell, the setOwner has no other side effects.

I hope someone else can comment on this, as it doesn't seem right. You don't want to <allow> any code in the clone to access the StateManager, since the StateManager knows about the original and can't tell from the APIs which proxy is calling it.

I think we're asking for trouble, either now or in future if we call this method from the clone.","08/Oct/07 19:38;clr;One other comment:

In openjpa-kernel/src/test/java/org/apache/openjpa/util/TestProxyManager.java,

+    private static void assertSortedSetsEquals(SortedSet s1, SortedSet s2) {
...
+        assertTrue(s1.equals(s2));

I'm curious what this is testing, after you verified that the comparators are equivalent, the sizes are the same, and the contents are identical. What else is being tested here, except that the equals method is implemented correctly? Is that it? ","08/Oct/07 19:54;kwsutter;[ Show » ]
Craig Russell - 08/Oct/07 12:38 PM One other comment: In openjpa-kernel/src/test/java/org/apache/openjpa/util/TestProxyManager.java, + private static void assertSortedSetsEquals(SortedSet s1, SortedSet s2) { ... + assertTrue(s1.equals(s2)); I'm curious what this is testing, after you verified that the comparators are equivalent, the sizes are the same, and the contents are identical. What else is being tested here, except that the equals method is implemented correctly? Is that it?

Correct.  The original problem surfaced because of a .equals() invocation between two Calendar objects.  So, even though the Javadoc explains what attributes of a given Calendar, Date, Time, etc object are examined for .equals(), I just wanted to ensure that we didn't hit this problem again in the future because some JVM decided to change their implementation.",09/Oct/07 14:29;kwsutter;Resolved via svn revision #582974 for both the 1.0.1 and 1.1.0 branches.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Accessing short Foreign Key metadata fields as ints causes problems on iSeries,OPENJPA-395,12379868,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,08/Oct/07 14:03,09/Mar/10 18:32,14/Mar/19 03:02,08/Oct/07 14:53,1.0.0,1.0.1,1.1.0,,,,,,,1.0.1,1.1.0,,,,jdbc,,,,,08/Oct/07 00:00,0,,"Three of the fields in the JDBC Foreign Key metadata were being accessed incorrectly.  These three fields are actually documented as being ""shorts"", but we were accessing them as ""ints"".  Although most JDBC drivers will process this request correctly, we hit one problem with the JDBC driver on iSeries.  Instead of waiting for a patch for that platform, it's easier for us to make the change.

The three fields are ""KEY_SEQ"", ""DEFERRABILITY"", and ""DELETE_RULE"".  Field ""UPDATE_RULE"" is also a short, but we don't currently seem to be accessing that field.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160717,,,Mon Oct 08 14:53:14 UTC 2007,,,,,,,0|i0zbdz:,204147,,,,,,,,08/Oct/07 14:53;kwsutter;Resolved in 1.0.x branch and 1.1.0 trunk via svn revision 582838.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DB2 CAST VARCHAR type missing LENGTH,OPENJPA-394,12379819,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,07/Oct/07 00:41,09/Mar/10 18:32,14/Mar/19 03:02,07/Oct/07 05:48,1.0.1,,,,,,,,,1.0.1,,,,,sql,,,,,,0,," Should generate CAST (? AS VARCHA(<LENGTH>)) , this problem is in 1.0.x branch.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160716,,,Sun Oct 07 05:48:14 UTC 2007,,,,,,,0|i0zbef:,204149,,,,,,,,07/Oct/07 05:48;fancy;fixed under r582581.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Column(nullable=false) setting not taken into account for String field values,OPENJPA-393,12379817,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,gergely.kis,gergely.kis,06/Oct/07 23:09,09/Mar/10 18:32,14/Mar/19 03:02,29/Jul/08 18:42,1.0.0,,,,,,,,,1.2.0,,,,,,,,,,,1,,"The @Column(nullable=false) annotation is taken into account when creating the database schema, however it is not taken into account when inserting string values.

See the following test case:
@Entity
public class A {

   @Id
    private long id;

    @Column(nullable=false)
    private String name;

    public A() {}

    public A(String name) { this.name = name; }

[...accessor methods omitted...]
}

When trying to persist the instance A(null), the record will be created successfully with an empty string as the value of the name column, instead of returning an error.

According to my analysis the problem is the following. When the @Column annotations are parsed (see AnnotationPersistenceMappingParser) the FieldMapping.setNullValue() method is not called. As a result, when fetching the String field value for storing it in the database the default value for strings is returned (which is an empty string), instead of raising an exception. See StringFieldStrategy.toDataStoreValue() for reference.

The proposed solution would be to call this setNullValue method with the appropriate parameter while @Column annotations are parsed, but I don't know the OpenJPA source well enough to determine whether this is the proper fix or if there are other parameters that should be set in the FieldMapping. However, my local tests fixed the reported issue.
","Linux 2.6, Java JDK 1.5.0.11, Spring 2.0.7",,,,,,,,,,,OPENJPA-665,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160715,,,2007-10-06 23:09:41.0,,,,,,,0|i0z1xj:,202615,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Some columnDefinition annotation properties incorrectly used as column name instead of type,OPENJPA-392,12379672,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,04/Oct/07 14:40,09/Mar/10 18:32,14/Mar/19 03:02,01/May/08 13:54,0.9.0,0.9.6,0.9.7,1.0.0,,,,,,1.1.0,,,,,jdbc,jpa,,,,,1,,"When specified, the columnDefinition property settings of the @PrimaryKeyJoinColumn, @JoinColumn, @XJoinColumn, @ElementJoinColumn annotations are incorrectly stored as the column name instead of the column type.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160714,,,Thu May 01 13:54:27 UTC 2008,,,,,,,0|i0z1wv:,202612,,,,,,,,"01/May/08 13:54;pcl;This was left unresolved earlier. But, as it turns out, a new BEA contribution re-introduced a new manifestation of this; resolved.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
em.getTransaction().commit() is not issuing database commit for NativeQuery requesting updates,OPENJPA-389,12379432,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,01/Oct/07 19:49,09/Mar/10 18:32,14/Mar/19 03:02,01/Oct/07 23:21,1.0.0,1.0.1,1.1.0,,,,,,,1.0.1,1.1.0,,,,jdbc,,,,,,0,,"If update is requested by a native query and it is the only method run in the application, 
following query.executeUpdate(), 
em.getTransaction().commit(0 is not issuing database commit.
If after that, em.close() was not issued, any subsequent query againt the same table which involved in the previous 
native query update will get blocked.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160711,,,Mon Oct 01 23:21:58 UTC 2007,,,,,,,0|i0zax3:,204071,,,,,,,,01/Oct/07 23:21;fancy;fix committed under  revision 581088 (trunk) and 581083 (branch 1.0.x),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MappingToolTask can't find persistence meta data. ,OPENJPA-388,12379307,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,28/Sep/07 16:51,30/Oct/07 15:29,14/Mar/19 03:02,30/Oct/07 15:29,1.0.0,,,,,,,,,1.0.1,1.1.0,,,,jdbc,,,,,05/Oct/07 00:00,0,,"Running the MappingToolTask causes an error like this : 

Buildfile: build.xml

clean:
   [delete] Deleting directory /home/mikedd/workspaces/jpa/ant/target

compile:
    [mkdir] Created dir: /home/mikedd/workspaces/jpa/ant/target
    [javac] Compiling 1 source file to /home/mikedd/workspaces/jpa/ant/target
    [mkdir] Created dir: /home/mikedd/workspaces/jpa/ant/target/META-INF
     [copy] Copying 2 files to /home/mikedd/workspaces/jpa/ant/target/META-INF

enhance:

map:
  [mapping] 87  persistence-tests  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.DerbyDictionary"".
  [mapping] 169  persistence-tests  INFO   [main] openjpa.Tool - Mapping tool running on type ""class mdd.TestEntity"" with action ""buildSchema"".
  [mapping] <openjpa-1.1.0-SNAPSHOT-r420667:580087 fatal user error> org.apache.openjpa.util.MetaDataException: Type ""class mdd.TestEntity"" does not have persistence metadata.
  [mapping] 	at org.apache.openjpa.jdbc.meta.MappingTool.getMapping(MappingTool.java:679)
  [mapping] 	at org.apache.openjpa.jdbc.meta.MappingTool.buildSchema(MappingTool.java:745)
  [mapping] 	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:643)
  [mapping] 	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:1066)
  [mapping] 	at org.apache.openjpa.jdbc.ant.MappingToolTask.executeOn(MappingToolTask.java:194)
  [mapping] 	at org.apache.openjpa.lib.ant.AbstractTask.execute(AbstractTask.java:172)
  [mapping] 	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
  [mapping] 	at org.apache.tools.ant.Task.perform(Task.java:364)
  [mapping] 	at org.apache.tools.ant.Target.execute(Target.java:341)
  [mapping] 	at org.apache.tools.ant.Target.performTasks(Target.java:369)
  [mapping] 	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)
  [mapping] 	at org.apache.tools.ant.Project.executeTarget(Project.java:1185)
  [mapping] 	at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:40)
  [mapping] 	at org.apache.tools.ant.Project.executeTargets(Project.java:1068)
  [mapping] 	at org.apache.tools.ant.Main.runBuild(Main.java:668)
  [mapping] 	at org.apache.tools.ant.Main.startAnt(Main.java:187)
  [mapping] 	at org.apache.tools.ant.launch.Launcher.run(Launcher.java:246)
  [mapping] 	at org.apache.tools.ant.launch.Launcher.main(Launcher.java:67)

Running from the command line generates the expected result : 

52  persistence-tests  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.DerbyDictionary"".
59  persistence-tests  INFO   [main] openjpa.Tool - No targets were given.  Running on all classes listed in your configuration, or all persistent classes in the classpath if no classes are configured.  Use -help to display tool usage information.
130  persistence-tests  INFO   [main] openjpa.Tool - Mapping tool running on type ""class mdd.TestEntity"" with action ""buildSchema"".
343  persistence-tests  INFO   [main] openjpa.Tool - Recording mapping and schema changes.

The root problem here lies with the ant classloaders. The ant classloader appears to be unable to load the annotation classes unless they're found in ${ANT_HOME}/lib. 

Example : 
@Entity
public class MyEntity  {
   // . . .
}

MyEntity.class.isAnnotationPresent(Entity.class); 
// returns false with the ant classloader
// returns true with the ant classloader if you copy geronimo-jpa_3.0_spec-1.0.jar to ${ANT_HOME}/lib
// returns true if we create a temporary classloader - similar to the PCEnhancerTask. 


",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160710,,,2007-09-28 16:51:47.0,,,,,,,0|i1dq0f:,288311,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Getting ""java.lang.ClassNotFoundException"" when loading datacache plug-in which is a class outside of OpenJPA package.",OPENJPA-387,12379251,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,dtlee,dtlee,dtlee,28/Sep/07 01:24,09/Mar/10 18:32,14/Mar/19 03:02,01/Oct/07 21:46,1.0.0,,,,,,,,,1.0.1,1.1.0,,,,datacache,,,,,,0,,"Getting ""java.lang.ClassNotFoundException"" when loading datacache plug-in which is a class outside of OpenJPA package.

This happens when loading the class as DatCache plug-in but it can potentially happen to any plug-in classes that reside outside of OpenJPA package.  In order to load these classes, the fix is to get the class loader (by calling findDerivedLoader with no interface loader, loader = null) to load it again when the current class loading fails and the target class is not part of OpenJPA package.  The same exception is still thrown if the second attempt fail or the target class is actually part of OpenJPA.

Please see the patch for detail changes.",,,,,,,,,,,,,,,,,,,,,,30/Sep/07 00:52;dtlee;JIRA387.zip;https://issues.apache.org/jira/secure/attachment/12366808/JIRA387.zip,01/Oct/07 21:41;kwsutter;OPENJPA-387.patch;https://issues.apache.org/jira/secure/attachment/12366867/OPENJPA-387.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-09-28 13:11:13.299,,,no_permission,,,,,,,,,,,160709,,,Mon Oct 01 21:46:38 UTC 2007,,,,,,,0|i0z4tb:,203082,,,,,,,,28/Sep/07 01:27;dtlee;Patch for OpenJPA 1.0.0 Trunk.,28/Sep/07 01:28;dtlee;Patch for OpenJPA 1.0.x branch,"28/Sep/07 13:11;kwsutter;Daniel,
It looks like the patch resolves the immediate problem.  Thanks.  But, I have a couple of questions about the patch itself...

With this patch, could we be accidentally be corrupting the loaderCaches?  We first lookup the proper loaderCache based on the loader being
used on the first attempt.  Since the problem is surfacing with a non-null loader variable, then we have looked up an existing loaderCache (or just created one).  But, then if we drop into your new code (because the class wasn't cached yet), then we null out the loader variable and try again.  If this one succeeds, then we store the class into the loaderCache instance that was first accessed by the non-null loader instance.  Is that what we really want to do?  It seems that we may need the loaderCache lookup as part of the while loop as well.  Either that, or we need more explanation on the keys being used for the loaderCache lookups.

Second comment...  Why limit the retry to packages that don't start with ""org.apache.openjpa""?  Why not just re-try all class lookup failures with a null class loader and see if they work?  It's always possible that somebody may have named their plugin with ""org.apache.openjpa.*"", especially if they are just testing.

Thanks,
Kevin",30/Sep/07 00:52;dtlee;It was good catch.  The new fix is attahced.  Thanks for your commentc.,01/Oct/07 21:41;kwsutter;Talked this over with Daniel and we modified the patch slightly.  New patch is attached as OPENJPA-387.patch.  Will be committing soon...,01/Oct/07 21:46;kwsutter;Resolved 1.0.x Branch and 1.1.0 Trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
org.apache.openjpa.meta.ClassMetaData.validateAppIdClass() does not take @MappedSuperclass into account,OPENJPA-386,12379198,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,mschwickerath@ultramain.com,mschwickerath@ultramain.com,27/Sep/07 14:26,21/Sep/16 14:21,14/Mar/19 03:02,27/Aug/09 20:07,0.9.7,1.0.0,1.0.2,1.1.0,1.2.1,,,,,1.2.0,1.3.0,2.0.0-M3,,,kernel,,,,,,3,,"We have a @MappedSuperclass that is the base for all of our entity bean classes.  This class contains the @Version (and @Column for the version field) that all of our entity beans use.  But, in ClassMetaData.validateAppIdClass(), if an entity bean class has a superclass, and the entity bean has an @IdClass, it expects that superclass to have an @IdClass also.  All of our entity beans have an @IdClass (even if they only have a single part key), but our @MappedSuperclass does not have an @IdClass.  This scenario works under JBoss 4.2.0 and Sun AS 9, but produces a NullPointerException in OpenJPA at:

        if (_super != null) {
            // concrete superclass oids must match or be parent of ours
            ClassMetaData sup = getPCSuperclassMetaData();
            if (!sup.getObjectIdType().isAssignableFrom(_objectId))  // <--- NullPointerException here
",BEA WebLogic 10.0 under Windows XP SP1,,,,,,,,,,,,,,,,,,,,,21/Aug/09 22:06;fyrewyld;OPENJPA-386_1.0.x.patch;https://issues.apache.org/jira/secure/attachment/12417322/OPENJPA-386_1.0.x.patch,21/Aug/09 22:06;fyrewyld;OPENJPA-386_1.1.x.patch;https://issues.apache.org/jira/secure/attachment/12417323/OPENJPA-386_1.1.x.patch,21/Aug/09 22:06;fyrewyld;OPENJPA-386_1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12417324/OPENJPA-386_1.2.x.patch,21/Aug/09 22:06;fyrewyld;OPENJPA-386_1.3.x.patch;https://issues.apache.org/jira/secure/attachment/12417325/OPENJPA-386_1.3.x.patch,21/Aug/09 22:06;fyrewyld;OPENJPA-386_trunk.patch;https://issues.apache.org/jira/secure/attachment/12417326/OPENJPA-386_trunk.patch,,,,,,,,,,5.0,,,,,,,,,,,,,,,,,,,2008-02-13 22:09:04.455,,,no_permission,,,,,,,,,,,160708,,,Fri Dec 11 00:15:13 UTC 2009,,,Patch Available,,,,0|i0z1wf:,202610,,,,,,,,"13/Feb/08 22:09;chrisarnett;Any updates on this?  We're having the same problem.  These are legacy tables and we don't have the luxury of changing the schema.  We also can't use an EmbeddedId (which seems to work in this case) because one of the fields is generated while the other is not (an unsupported case for EmbeddedId).

Unless this is fixed in the Feb 15th release, we'll probably have to override WL10's JPA implementation with Hibernate (if that's even possible).","07/May/08 22:23;tsandor;Matthew,
We have the same problem (and situation for storing @Version). It's great that I found this entry.

Here's a workaround that worked for me:
@MappedSuperclass
@IdClass(Object.class)

This way PCEnhancer will enhance the superclassed entities with their special @IdClass().

However, normally it should work without this extra line (Hibernate does not need that).
Please vote for this bug to be solved in the next release.","21/Aug/09 22:05;fyrewyld;The problem was how ClassMetaData.hasConcretePCSuperclass() handled mapped superclasses.  Let's say we have the following classes:

@MappedSuperclass
public class MSC

@Entity
@IdClass(MyIdClass.class)
public class EntityA extends MSC

(Note that the @MappedSuperclass type ""MSC"" is not abstract, which is perfectly legal with the JPA Spec.)

Now, when an entity extending the MSC is annotated with @IdClass, the metadata processing notes that there are PC-enhanced superclasses, and needs to analyze them to check if they declare any identity elements, in order to ensure that the @IdClass specified will address them.  It uses this method in ClassMetaData to check if it has a PC superclass that is concrete (effectively, any entity class types that are further up the inheritance tree.:

    /**
     * Return true if this class has a concrete persistent superclass.
     */
    private boolean hasConcretePCSuperclass() {
        if (_super == null)
            return false;
        if (!Modifier.isAbstract(_super.getModifiers())))
            return true;
        return getPCSuperclassMetaData().hasConcretePCSuperclass();
    }

The line: if (!Modifier.isAbstract(_super.getModifiers()))) is responsible for detecting @MappedSuperclasses, however it relies exclusively on the class being abstract, something that, while recommended, is not required by the JPA Spec.  So it will incorrectly treat a @MappedSuperclass as a regular entity, resulting in this Exception:

org.apache.openjpa.util.MetaDataException: Field ""testcase.EntityA.id"" cannot be a primary key.  Primary key fields can only be declared in base persistent classes that also declare their identity type- to be ""application"".
     at org.apache.openjpa.meta.ClassMetaData.validateNoPKFields(ClassMetaData.java:2025)
     at org.apache.openjpa.meta.ClassMetaData.validateAppIdClass(ClassMetaData.java:1905)
     at org.apache.openjpa.meta.ClassMetaData.validateIdentity(ClassMetaData.java:1851)
     at org.apache.openjpa.meta.ClassMetaData.validateMeta(ClassMetaData.java:1768)
     at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1641)
...

The solution was to simply add another check for the @MappedSuperclass.  This is already done with the ClassMetaData.isAbstract() method in trunk (which is set true if a class type explicitly is annotated with @MappedSuperclass, or is defined as a mapped-superclass by ORM XML), which was brought down to 1.2.x and 1.3.x in OPENJPA-1061.  With the following change:

private boolean hasConcretePCSuperclass() {
        if (_super == null)
            return false;
        if (!Modifier.isAbstract(_super.getModifiers()) && 
        		(!getPCSuperclassMetaData().isAbstract()))
            return true;
        return getPCSuperclassMetaData().hasConcretePCSuperclass();
    }

With the above change, a @MappedSuperclass can now be identified whether or not its class type is actually a Java abstract class or not.","27/Aug/09 20:07;mikedd;Thanks for the patch Jody. Patch applied to 1.3.x, and trunk. ",11/Dec/09 00:15;dezzio;Applied Jody's patch to 1.1.x branch at rev 889476.  ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"IndexOutOfBounds exception when parsing "".class"" files",OPENJPA-385,12379111,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,26/Sep/07 14:04,09/Mar/10 18:32,14/Mar/19 03:02,27/Sep/07 19:20,1.0.0,1.0.1,1.1.0,,,,,,,1.0.1,1.1.0,,,,lib,,,,,,0,,"When finding and parsing files via the classpath, we're hitting a situation where an invalid .class file is in the classpath.  Although the files in question have the .class suffix, they do not have valid .class format.  Not only are we blowing up via the serp utilities, but neither jad nor javap can recognize the files either.  Here's the call stack that is produced:

Exception in thread ""main"" java.lang.ClassFormatError: COM/ibm/db2os390/sqlj/custom/DB2SQLJCustomizer.class
        at org.apache.openjpa.lib.meta.ClassAnnotationMetaDataFilter.matches(ClassAnnotationMetaDataFilter.java:89)
        at org.apache.openjpa.lib.meta.ZipFileMetaDataIterator.hasNext(ZipFileMetaDataIterator.java:79)
        at org.apache.openjpa.lib.meta.MetaDataIteratorChain.hasNext(MetaDataIteratorChain.java:76)
        at org.apache.openjpa.lib.meta.ClassArgParser.mapTypeNames(ClassArgParser.java:277)
        at org.apache.openjpa.meta.AbstractCFMetaDataFactory.scan(AbstractCFMetaDataFactory.java:713)
        at org.apache.openjpa.meta.AbstractCFMetaDataFactory.getPersistentTypeNames(AbstractCFMetaDataFactory.java:583)
        at org.apache.openjpa.meta.MetaDataRepository.getPersistentTypeNames(MetaDataRepository.java:1190)
        at org.apache.openjpa.meta.MetaDataRepository.loadPersistentTypes(MetaDataRepository.java:1207)
        at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:1002)
        at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:977)
        at org.apache.openjpa.jdbc.meta.MappingTool.main(MappingTool.java:918)
Caused by: java.lang.ArrayIndexOutOfBoundsException
        at serp.bytecode.lowlevel.ConstantPoolTable.readByte(ConstantPoolTable.java:106)
        at serp.bytecode.lowlevel.ConstantPoolTable.readUnsignedShort(ConstantPoolTable.java:114)
        at serp.bytecode.lowlevel.ConstantPoolTable.readUnsignedShort(ConstantPoolTable.java:184)
        at org.apache.openjpa.lib.meta.ClassAnnotationMetaDataFilter.matches(ClassAnnotationMetaDataFilter.java:67)
        ... 10 more

As you can see, the file in question is actually coming from the db2jcc.jar.  Although I could pursue why these files do not have the correct format, I'm proposing that we become more lenient in our ""matches"" logic.  Right now, we are throwing this IOOB exception.  This seems too harsh, especially since we just return ""false"" for any other indication that the resource is not an ""interesting"" class file with appropriate annotations.  In my mind, this invalid class file should just be treated as if it didn't have the .class suffix.

So, instead of the current exception throwing processing, I would like to change to just log a trace message.  We already log an Info message for all of the files that we do process.  And, logging an info message for a bad class format might just cause confusion (much like this exception throwing).  Thus, I would like to just log a trace message with the appropriate information and return ""false"" on this matches() invocation.

Any problems with this approach?  I've looked at the caller's of this method and nobody is expecting to get the ClassFormatException or IOOB exception (unexpected runtime exception), so just logging and eating the exception and returning false looks safe.

Kevin",,,,,,,,,,,,,,,,,,,,,,27/Sep/07 13:36;kwsutter;OPENJPA-385.patch;https://issues.apache.org/jira/secure/attachment/12366666/OPENJPA-385.patch,26/Sep/07 23:15;kwsutter;OPENJPA-385.patch;https://issues.apache.org/jira/secure/attachment/12366622/OPENJPA-385.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160707,,,Thu Sep 27 19:20:29 UTC 2007,,,,,,,0|i0zbgf:,204158,,,,,,,,"26/Sep/07 23:04;kwsutter;Ran into a little snag with my proposal...  All of this metadata processing code is in ""lib"" and ""lib"" doesn't have an associated configuration or logfactory, so I don't have a means to log the failing class name.  I looked at alternatives of setting a configuration object on the ClassAnnotationMetaDataFilter, but that gets ugly real fast.  And, for how much benefit?  Since a malformed .class file is no better than a file that does not have the .class suffix, why not treat them the same?  That is, just return ""false"" when we detect a malformed .class file?  I would still put a comment in the code block indicating why we're eating the exception.  I'll post a patch shortly so that you can see what I am referring to.

Kevin","27/Sep/07 13:31;kwsutter;Okay, so I didn't like the approach of just eating the exception and never logging the condition (just in case we have a problem with this area of the code).  So, I found an easy way to set a log into the ClassAnnotationMetaDataFilter object when it gets created.  Since this is a utility class, I didn't want to enforce a log file, so I will check for null before doing the logging.  Here's what the logged message will look like if TRACE is turned on:

812  MyBookJPA_annotation  TRACE  [main] openjpa.MetaData - Error extracting class information from ""COM/ibm/db2os390/sqlj/custom/DB2SQLJCustomizer.class"".
java.lang.ClassFormatError: COM/ibm/db2os390/sqlj/custom/DB2SQLJCustomizer.class
	at org.apache.openjpa.lib.meta.ClassAnnotationMetaDataFilter.matches(ClassAnnotationMetaDataFilter.java:107)
	at org.apache.openjpa.lib.meta.ZipFileMetaDataIterator.hasNext(ZipFileMetaDataIterator.java:88)
	at org.apache.openjpa.lib.meta.MetaDataIteratorChain.hasNext(MetaDataIteratorChain.java:76)
	at org.apache.openjpa.lib.meta.ClassArgParser.mapTypeNames(ClassArgParser.java:282)
	at org.apache.openjpa.meta.AbstractCFMetaDataFactory.scan(AbstractCFMetaDataFactory.java:785)
	at org.apache.openjpa.meta.AbstractCFMetaDataFactory.getPersistentTypeNames(AbstractCFMetaDataFactory.java:608)
	at org.apache.openjpa.meta.MetaDataRepository.getPersistentTypeNames(MetaDataRepository.java:1214)
	at org.apache.openjpa.meta.MetaDataRepository.loadPersistentTypes(MetaDataRepository.java:1231)
	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:1006)
	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:980)
	at org.apache.openjpa.jdbc.meta.MappingTool.main(MappingTool.java:921)
Caused by: java.lang.ArrayIndexOutOfBoundsException
	at serp.bytecode.lowlevel.ConstantPoolTable.readByte(ConstantPoolTable.java:81)
	at serp.bytecode.lowlevel.ConstantPoolTable.readUnsignedShort(ConstantPoolTable.java:88)
	at serp.bytecode.lowlevel.ConstantPoolTable.readUnsignedShort(ConstantPoolTable.java:153)
	at org.apache.openjpa.lib.meta.ClassAnnotationMetaDataFilter.matches(ClassAnnotationMetaDataFilter.java:79)
	... 10 more

I will post this new patch and plan to commit shortly...

Kevin",27/Sep/07 13:36;kwsutter;Updated version of the patch.,27/Sep/07 19:20;kwsutter;Resolved via r580087 for both 1.0.1 and 1.1.0 releases.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Overriding column names for Byte[] attributes causes exception.,OPENJPA-382,12378997,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,24/Sep/07 16:12,25/Feb/11 16:33,14/Mar/19 03:02,25/Feb/11 16:32,,,,,,,,,,1.0.1,1.1.0,,,,,,,,,,0,,"If an entity has an attribute of type Byte array and the column name is overridden in xml the following error will occur. 


<openjpa-1.0.0-SNAPSHOT-r420667:566855 fatal user error> 
org.apache.openjpa.persistence.ArgumentException: You have supplied columns for 
""org.apache.openjpa.persistence.xml.XmlOverrideEntity.picture<element:class java.lang.Byte>"", but this mapping cannot have columns in this context.

Code snippets follow :

public class XmlOverrideEntity {
<snip>
    @Column(name=""PICTURE"")
    @Lob
    private Byte[] picture;
<snip>
}

// orm.xml
    <entity name=""XmlOverride"" class=""XmlOverrideEntity"">
    	<attributes>
	    	<basic name=""name"" optional=""true""></basic>
	    	<basic name=""description"" optional=""false""></basic>
            <basic name=""picture"" fetch=""EAGER""> 
                <column name=""pic_xml""/>
                <lob/>
            </basic>
    	</attributes>
    </entity>",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160704,,,2007-09-24 16:12:04.0,,,,,,,0|i0z5wv:,203260,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Connecting to database when an unused emf is closed ,OPENJPA-380,12378883,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,21/Sep/07 18:48,24/Sep/07 15:58,14/Mar/19 03:02,21/Sep/07 21:54,0.9.0,0.9.6,0.9.7,1.0.0,,,,,,1.0.1,1.1.0,,,,kernel,,,,,,0,,"When an EMF is closed it attempts to get a MetaDataRepositoryInstance. If no instance has been created (the EMF hasn't been used) it will create a new one - which entails opening a connection to the database.

The MDR is only used to un-register itself as a class listener, so in this case it's rather pointless to create a new one. 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160702,,,2007-09-21 18:48:12.0,,,,,,,0|i1dq1b:,288315,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StoreException when using a third party connection pool against Sybase ,OPENJPA-379,12378834,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,ssegu,ssegu,21/Sep/07 05:18,09/Mar/10 18:32,14/Mar/19 03:02,21/Sep/07 05:57,0.9.0,0.9.6,0.9.7,1.0.0,,,,,,1.1.0,,,,,jdbc,,,,,,0,,"org.apache.openjpa.util.DataStoreException: Cursor 'jconnect_implicit_1' was declared with a FOR UPDATE clause. This cursor was found to be read only.

When running queries using third party connection pool and JConnect  drivers

","Sybase
JConnect drivers",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-09-21 15:07:05.001,,,no_permission,,,,,,,,,,,160701,,,Fri Sep 21 18:04:33 UTC 2007,,,,,,,0|i1dq1j:,288316,,,,,,,,"21/Sep/07 05:42;ssegu;When the statement is created if the resultSetType is not specified -  setFetchSize or setCursorName calls result in the ResultSet with TYPE_FORWARD_ONLY and CONCUR_UPDATABLE.

http://manuals.sybase.com/onlinebooks/group-jc/jcg0600e/prjdbc/@Generic__BookTextView/3956","21/Sep/07 15:07;mikedd;I'm not sure this was the right fix for the problem. The change affects all databases not just Sybase. 

It seems to me that the correct fix would be to delegate the resultSet type to the DBDictionary class, rather than changing the settings for all databases. 

","21/Sep/07 18:04;ssegu;Yes my initial thought too was to override the prepareStatement(...) behavior in SybaseDictionary$SybaseConnection. But later noticed that our connection pool implementation is setting the ResultSetType for all DBs, so to keep it consistent I went the route of setting it at the DelegatingConnection level. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"DB2 SQL incorrectly generating ""FETCH FIRST n ROWS ONLY"" in subselects",OPENJPA-378,12378786,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,20/Sep/07 19:07,09/Mar/10 18:32,14/Mar/19 03:02,21/Sep/07 22:43,1.0.0,1.0.1,1.1.0,,,,,,,1.0.1,1.1.0,,,,sql,,,,,,0,,"For select count(*) from (subselect), ""FETCH FIRST n ROWS ONLY"" clause was generated which is INVALID syntax in DB2.",,,,,,,,,,,,,,,,OPENJPA-447,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160700,,,Fri Sep 21 22:43:36 UTC 2007,,,,,,,0|i0z6sf:,203402,,,,,,,,"21/Sep/07 22:43;fancy;fixed in 1.0.x branch, revision r577972,  trunk revision r577973.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DB2 autoCommit(true) causes Result Set prematurely closed in WebContainer JEE environment.,OPENJPA-375,12378578,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,18/Sep/07 17:39,09/Mar/10 18:32,14/Mar/19 03:02,21/Sep/07 22:47,1.0.0,1.0.1,1.1.0,,,,,,,1.0.1,1.1.0,,,,jdbc,,,,,,0,,"Invalid operation: Result set is closed is reported from DB2, running in Web Container, non-jta-data-source, transaction local, JEE environment.
A workaround is to set the following property in persistence.xml for DB2:
<property name=""openjpa.jdbc.DBDictionary""
            value=""db2(supportsMultipleNontransactionalResultSets=false)""/>",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160697,,,Tue Oct 30 21:57:39 UTC 2007,,,,,,,0|i0zbcf:,204140,,,,,,,,21/Sep/07 22:47;fancy;Fixed in 1.0.x branch revision r577014  and in trunk revision r577015,"30/Oct/07 21:57;fancy;The fix for this problem has been undone under svn commit: r590481.
Here is the reason:
In WebSphere, there is a costom property that is configurable for DB2 datasources. This property is named ""resultSetHoldability"", the default value is 2; which means CLOSE_CURSOR_AT_COMMIT.
This property should be set to 1 if running with OpenJPA; 1 means HOLD_CURSORS_OVER_COMMIT.

Catalina
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AccessDeclaredMembers RuntimePermission requires by Solaris JDK with security enabled,OPENJPA-369,12378298,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,14/Sep/07 15:45,15/Oct/07 17:45,14/Mar/19 03:02,15/Oct/07 17:45,1.0.0,,,,,,,,,1.0.1,1.1.0,,,,jdbc,,,,,,0,,"On Solaris, its Java runtime AnnotatedElement.isAnnotationPresent() method implementation requires ""RuntimePermission accessDeclaredMembers"" permission, even though it is not documented.

This requirement does not applied to the JDK on (at least) Win32 and Linux.

-------------------------------------------------------------
Current Java 2 Security policy reported a potential violation of Java 2 Security Permission. Please refer to InfoCenter for further information.

Permission:
      accessDeclaredMembers : access denied (java.lang.RuntimePermission accessDeclaredMembers)

Code:
     suite.r70.base.jpaspec.entity.service.impl.AbstractDatatypeSupportTestEntityService  in  {file:/opt/WAS4/profiles/AppSrv01/installedApps/muonNode01Cell/EJB3JPAEntityBeanApp.ear/EJB3JPAEntityBean.jar}

Stack Trace:
java.security.AccessControlException: access denied (java.lang.RuntimePermission accessDeclaredMembers)
	at java.security.AccessControlContext.checkPermission(AccessControlContext.java:264)
	at java.security.AccessController.checkPermission(AccessController.java:427)
	at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)
	at com.ibm.ws.security.core.SecurityManager.checkPermission(SecurityManager.java:189)
	at java.lang.SecurityManager.checkMemberAccess(SecurityManager.java:1662)
	at java.lang.Class.checkMemberAccess(Class.java:2125)
	at java.lang.Class.getDeclaredMethods(Class.java:1762)
	at sun.reflect.annotation.AnnotationType.<init>(AnnotationType.java:81)
	at sun.reflect.annotation.AnnotationType.getInstance(AnnotationType.java:64)
	at sun.reflect.annotation.AnnotationParser.parseAnnotation(AnnotationParser.java:202)
	at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:69)
	at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:52)
	at java.lang.Class.initAnnotationsIfNecessary(Class.java:3031)
	at java.lang.Class.getAnnotation(Class.java:2989)
	at java.lang.Class.isAnnotationPresent(Class.java:3001)
	at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parseClassAnnotations(AnnotationPersistenceMetaDataParser.java:466)
	at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parse(AnnotationPersistenceMetaDataParser.java:349)
	at org.apache.openjpa.persistence.PersistenceMetaDataFactory.load(PersistenceMetaDataFactory.java:229)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:470)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:290)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2371)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2224)
	at org.apache.openjpa.kernel.DelegatingBroker.persist(DelegatingBroker.java:1005)
	at org.apache.openjpa.persistence.EntityManagerImpl.persist(EntityManagerImpl.java:541)
	at suite.r70.base.jpaspec.entity.service.impl.AbstractDatatypeSupportTestEntityService.doCreateIDatatypeSupportTestEntity(AbstractDatatypeSupportTestEntityService.java:47)

Albert Lee.",Solaris,,,,,,,,,,,,,,,,,,,,,02/Oct/07 16:06;allee8285;OPENJPA-369.10x.patch;https://issues.apache.org/jira/secure/attachment/12366932/OPENJPA-369.10x.patch,25/Sep/07 14:37;allee8285;OPENJPA-369.2.patch;https://issues.apache.org/jira/secure/attachment/12366533/OPENJPA-369.2.patch,17/Sep/07 19:26;allee8285;OPENJPA-369.patch;https://issues.apache.org/jira/secure/attachment/12366026/OPENJPA-369.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160692,,,Tue Oct 02 16:06:45 UTC 2007,,,,,,,0|i0z4tr:,203084,,,,,,,,"15/Sep/07 04:37;allee8285;Identify another related AnnotatedElement access required by Solaris JDK.

Caused by: java.security.AccessControlException: access denied (java.lang.RuntimePermission accessDeclaredMembers)
        at java.security.AccessControlContext.checkPermission(AccessControlContext.java:264)
        at java.security.AccessController.checkPermission(AccessController.java:427)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)
        at com.ibm.ws.security.core.SecurityManager.checkPermission(SecurityManager.java:189)
        at java.lang.SecurityManager.checkMemberAccess(SecurityManager.java:1662)
        at java.lang.Class.checkMemberAccess(Class.java:2125)
        at java.lang.Class.getDeclaredMethods(Class.java:1762)
        at sun.reflect.annotation.AnnotationType.<init>(AnnotationType.java:81)
        at sun.reflect.annotation.AnnotationType.getInstance(AnnotationType.java:64)
        at sun.reflect.annotation.AnnotationParser.parseAnnotation(AnnotationParser.java:202)
        at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:69)
        at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:52)
        at java.lang.reflect.Field.declaredAnnotations(Field.java:1002)
        at java.lang.reflect.Field.getDeclaredAnnotations(Field.java:995)
        at java.lang.reflect.AccessibleObject.getAnnotations(AccessibleObject.java:179)
        at org.apache.openjpa.persistence.PersistenceMetaDataDefaults.usesAccess(PersistenceMetaDataDefaults.java
","16/Sep/07 04:04;allee8285;Find 2 more instances that need doPriv:

--------------------------------
Caused by: java.security.AccessControlException: access denied (java.lang.RuntimePermission accessDeclaredMembers)
        at java.security.AccessControlContext.checkPermission(AccessControlContext.java:264)
        at java.security.AccessController.checkPermission(AccessController.java:427)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)
        at com.ibm.ws.security.core.SecurityManager.checkPermission(SecurityManager.java:189)
        at java.lang.SecurityManager.checkMemberAccess(SecurityManager.java:1662)
        at java.lang.Class.checkMemberAccess(Class.java:2125)
        at java.lang.Class.getDeclaredMethods(Class.java:1762)
        at sun.reflect.annotation.AnnotationType.<init>(AnnotationType.java:81)
        at sun.reflect.annotation.AnnotationType.getInstance(AnnotationType.java:64)
        at sun.reflect.annotation.AnnotationParser.parseAnnotation(AnnotationParser.java:202)
        at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:69)
        at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:52)
        at java.lang.reflect.Method.declaredAnnotations(Method.java:676)
        at java.lang.reflect.Method.getDeclaredAnnotations(Method.java:669)
        at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parseCallbackMethods(AnnotationPersistenceMetaDataParser.java:828)
        at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parseClassAnnotations(AnnotationPersistenceMetaDataParser.java:593)
        at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parse(AnnotationPersistenceMetaDataParser.java:351)
        at org.apache.openjpa.persistence.PersistenceMetaDataFactory.load(PersistenceMetaDataFactory.java:229)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:470)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:290)
        at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2372)
--------------------------------
Stack Dump = java.security.AccessControlException: Access denied (java.lang.RuntimePermission modifyThread)
	at java.security.AccessController.checkPermission(AccessController.java:104)
	at java.lang.SecurityManager.checkPermission(SecurityManager.java:547)
	at com.ibm.ws.security.core.SecurityManager.checkPermission(SecurityManager.java:189)
	at com.ibm.ws.security.core.SecurityManager.checkAccess(SecurityManager.java:299)
	at java.lang.Thread.checkAccess(Thread.java:397)
	at java.lang.Thread.setDaemon(Thread.java:839)
	at org.apache.openjpa.datacache.DataCacheScheduler.scheduleEviction(DataCacheScheduler.java:105)
	at org.apache.openjpa.datacache.AbstractDataCache.initialize(AbstractDataCache.java:89)
	at org.apache.openjpa.datacache.ConcurrentDataCache.initialize(ConcurrentDataCache.java:91)
	at org.apache.openjpa.datacache.DataCacheManagerImpl.initialize(DataCacheManagerImpl.java:51)
	at org.apache.openjpa.conf.OpenJPAConfigurationImpl.getDataCacheManagerInstance(OpenJPAConfigurationImpl.java:614)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:182)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:192)
	at com.ibm.ws.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:35)
	at com.ibm.ws.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:25)
	at com.ibm.ws.jpa.management.JPAEMFactory.createEntityManager(JPAEMFactory.java:100)
	at suite.r70.base.openjpa.datacache.tests.ejb.EJB_AMRLSF_DataCacheTestBean.createEntityManagers(EJB_AMRLSF_DataCacheTestBean.java:99)
--------------------------------",17/Sep/07 19:26;allee8285;Add doPriv(s) security access required by Solaris JDK.,"25/Sep/07 14:37;allee8285;Per discussion with Patrick and Kevin, add a new openjpa-lib-5 module to host the 1.5 specific doPriv actions, which allows the 1.4 modules compilation to succeed.

Apologize for this oversight in the original patch submission.

Albert Lee.",02/Oct/07 16:06;allee8285;Attached the same patch but for the 1.0.x branch.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Multithreaded client fails randomly on EntityManager.persist() with out transaction context.,OPENJPA-368,12378162,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,vbhatia,vbhatia,13/Sep/07 14:04,09/Mar/10 18:32,14/Mar/19 03:02,03/Oct/07 00:15,0.9.7,1.0.0,,,,,,,,1.0.1,1.1.0,,,,jdbc,,,,,,0,,"

This issue happens with the following scenario with JTA transaction.

Suppose there is Entity A which is related to table with two columns accountId and name. accountId is PK of the table whose value is generated using sequence in DB.

1. Thread A starts Transaction 1.
2. Thread B starts Transaction 2.
3. Thread A and Thread B both calls EntityManager.persist(o) where o is 
Entity object whose primary key is generated with a sequence in DB.
4. A call is made to o.getAccountId() concurrently.
5. Thread A suspends Transaction 1, and gets the value of accountId. It updates 
sequence value in DB with new Transaction 3. It saves Transaction 1.
6. Thread B suspends Transaction 2, and gets the value of accountId. It updates 
sequence value in DB with new Transaction 4. It saves Transaction 2.
7. Now, when both Thread A and Thread B resumes outer transaction 
concurrently, it updates Transaction Manager with Transaction 2.

The problem happens when JTA transaction is saved in AbstractJDBCSeq _outerTransaction variable. The variable gets overwritten if multiple threads load the value of accountId from sequence in DB, when it resumes the JTA transaction later it resumes the transaction 2 for both threads resulting in following exception.


javax.ejb.EJBException: nested exception is: javax.persistence.TransactionRequiredException: The method public abstract void javax.persistence.EntityManager.persist(java.lang.Object) must be called in the context of a transaction.
javax.persistence.TransactionRequiredException: The method public abstract void javax.persistence.EntityManager.persist(java.lang.Object) must be called in the context of a transaction.
	at weblogic.deployment.BasePersistenceContextProxyImpl.validateInvocation(BasePersistenceContextProxyImpl.java:121)
	at weblogic.deployment.BasePersistenceContextProxyImpl.invoke(BasePersistenceContextProxyImpl.java:86)
	at weblogic.deployment.TransactionalEntityManagerProxyImpl.invoke(TransactionalEntityManagerProxyImpl.java:90)
	at weblogic.deployment.BasePersistenceContextProxyImpl.invoke(BasePersistenceContextProxyImpl.java:80)
	at $Proxy63.persist(Unknown Source)

Please check README.txt of attached testcase.zip to see how to reproduce the issue.","WebLogic Server 10.0, Oracle DB",,,,,,,,,,,,,,,,,,,,,24/Sep/07 06:14;vbhatia;proposed-fix-v2.patch;https://issues.apache.org/jira/secure/attachment/12366436/proposed-fix-v2.patch,13/Sep/07 14:13;vbhatia;proposed-fix.patch;https://issues.apache.org/jira/secure/attachment/12365734/proposed-fix.patch,13/Sep/07 14:07;vbhatia;testcase.zip;https://issues.apache.org/jira/secure/attachment/12365733/testcase.zip,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-09-20 21:36:59.087,,,no_permission,,,,,,,,,,,160691,,,Wed Oct 03 00:15:33 UTC 2007,,,,,,,0|i0z4un:,203088,,,,,,,,13/Sep/07 14:13;vbhatia;Proposed Fix.,20/Sep/07 21:36;pcl;I believe that an easy workaround would be to specify a non-jta-data-source in persistence.xml.,"20/Sep/07 21:38;pcl;If the solution is going to be based on a thread-keyed map, why not use a ThreadLocal instead?

Another possible solution would be to obtain a lock on something so that only a single thread can obtain a seq value for a particular instance. Personally, I think that the proposed patch (potentially with a ThreadLocal mod) would be better, though.",24/Sep/07 06:14;vbhatia;Thanks Patrick.  Here is Version 2 of the patch using ThreadLocal. ,"03/Oct/07 00:15;pcl;Committing Vikram's patch. FTR, I don't love the fact that we're using a ThreadLocal; it feels wrong. However, given the current API design, I think it's unavoidable. Once we move to a system that provides a means to execute a Runnable or some analog in an out-of-band transaction via the ManagedRuntime interface, we'll be able to simplify this code.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PCEnhancer does not find meta data for entities using pure XML annotation,OPENJPA-367,12378065,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,12/Sep/07 16:30,15/Apr/08 18:10,14/Mar/19 03:02,30/Oct/07 16:04,1.0.0,,,,,,,,,1.0.1,1.0.2,1.1.0,,,kernel,,,,,,0,,"When an entity is defined using pure XML (i.e. no annotation in the entity class), the enhancer does not recognized the meta data and no enhancing will take place: E.g.

-----------------------------------------
C:\temp\test>runPcEnhancer.bat

C:\temp\test>java -cp C:\temp\test\;C:\temp\test\openjpa-1.1.0-SNAPSHOT.jar;C:\temp\test\utils.jar;C:\temp\test\geronimo-jpa_3.0_spec-1.0.jar;C:\temp\test\geronimo-jta_1.1_spec-1.1.jar org.apache.openjpa.enhance.PCEnhancer
15  EntityUnit_JSE  TRACE  [main] openjpa.Runtime - Setting the following properties from ""file:/C:/temp/test/META-INF/persistence.xml"" into configuration: {openjpa.Id=EntityUnit_JSE, openjpa.Log=DefaultLevel=TRACE, openjpa.MetaDataFactory=jpa(Resources=META-INF/jpamappings.xml, Types=test.XMLDatatypeSupportTestEntity)}
31  EntityUnit_JSE  TRACE  [main] openjpa.Runtime - No cache marshaller found for id org.apache.openjpa.conf.MetaDataCacheMaintenance.
47  EntityUnit_JSE  INFO   [main] openjpa.Tool - No targets were given.  Running on all classes in your persistent classes list, or all metadata files in classpath directories if you have not listed your persistent classes.  Use -help to display tool usage information.
62  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Scanning resource ""META-INF/jpamappings.xml"" for persistent types.
62  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Scan of ""META-INF/jpamappings.xml"" found persistent types [Ljava.lang.String;@3a183a18.
62  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Mapping resource location ""file:/C:/temp/test/META-INF/jpamappings.xml"" to persistent types ""[test.XMLDatatypeSupportTestEntity]"".
62  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Scanning resource ""META-INF/orm.xml"" for persistent types.
62  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - parsePersistentTypeNames() found [test.XMLDatatypeSupportTestEntity].
62  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Found 1 classes with metadata in 15 milliseconds.
62  EntityUnit_JSE  TRACE  [main] openjpa.Tool - Enhancer running on type ""test.XMLDatatypeSupportTestEntity"".
93  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Loading metadata for ""class test.XMLDatatypeSupportTestEntity"" under mode ""[META]"".
125  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Parsing resource ""file:/C:/temp/test/META-INF/jpamappings.xml"".
156  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Parsing class ""test.XMLDatatypeSupportTestEntity"".
172  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Generating default metadata for type ""test.XMLDatatypeSupportTestEntity"".
172  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Using reflection for metadata generation.
187  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Parsing class ""test.XMLDatatypeSupportTestEntity"".
187  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Parsing package ""test.XMLDatatypeSupportTestEntity"".
187  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Finished parsing metadata resource ""file:/C:/temp/test/META-INF/jpamappings.xml"".
187  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Parsing class ""test.XMLDatatypeSupportTestEntity"".
187  EntityUnit_JSE  TRACE  [main] openjpa.Enhance - Enhancing type ""class test.XMLDatatypeSupportTestEntity"".
203  EntityUnit_JSE  WARN   [main] openjpa.Enhance - Type ""class test.XMLDatatypeSupportTestEntity"" has no metadata; enhancing as persistence aware. If you intended for ""class test.XMLDatatypeSupportTestEntity"" to be persistence-capable, then this means that OpenJPA could not find any metadata for ""class test.XMLDatatypeSupportTestEntity"". This can happen if the directory containing your metadata is not in your CLASSPATH, or if your metadata files are not named properly. See the documentation on metadata placement for more information.
203  EntityUnit_JSE  TRACE  [main] openjpa.Tool - The class does not have metadata - enhanced as persistence-aware.
-----------------------------------------

However if the target is specified, the enhancement will occur, E.g.

-----------------------------------------
C:\temp\test>runPcEnhancer.bat test.XMLDatatypeSupportTestEntity

C:\temp\test>java -cp C:\temp\test\;C:\temp\test\openjpa-1.1.0-SNAPSHOT.jar;C:\temp\test\utils.jar;C:\temp\test\geronimo-jpa_3.0_spec-1.0.jar;C:\temp\test\geronimo-jta_1.1_spec-1.1.jar org.apache.openjpa.enhance.PCEnhancer test.XMLDatatypeSupportTestEntity
15  EntityUnit_JSE  TRACE  [main] openjpa.Runtime - Setting the following properties from ""file:/C:/temp/test/META-INF/persistence.xml"" into configuration: {openjpa.Id=EntityUnit_JSE, openjpa.Log=DefaultLevel=TRACE, openjpa.MetaDataFactory=jpa(Resources=META-INF/jpamappings.xml, Types=test.XMLDatatypeSupportTestEntity)}
47  EntityUnit_JSE  TRACE  [main] openjpa.Runtime - No cache marshaller found for id org.apache.openjpa.conf.MetaDataCacheMaintenance.
78  EntityUnit_JSE  TRACE  [main] openjpa.Runtime - No cache marshaller found for id org.apache.openjpa.conf.MetaDataCacheMaintenance.
94  EntityUnit_JSE  TRACE  [main] openjpa.Tool - Enhancer running on type ""class test.XMLDatatypeSupportTestEntity"".
125  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Loading metadata for ""class test.XMLDatatypeSupportTestEntity"" under mode ""[META]"".
125  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Scanning resource ""META-INF/jpamappings.xml"" for persistent types.
125  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Scan of ""META-INF/jpamappings.xml"" found persistent types [Ljava.lang.String;@20962096.
140  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Mapping resource location ""file:/C:/temp/test/META-INF/jpamappings.xml"" to persistent types ""[test.XMLDatatypeSupportTestEntity]"".
140  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Scanning resource ""META-INF/orm.xml"" for persistent types.
140  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - parsePersistentTypeNames() found [test.XMLDatatypeSupportTestEntity].
140  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Found 1 classes with metadata in 15 milliseconds.
156  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Parsing resource ""file:/C:/temp/test/META-INF/jpamappings.xml"".
187  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Parsing class ""test.XMLDatatypeSupportTestEntity"".
187  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Generating default metadata for type ""test.XMLDatatypeSupportTestEntity"".
187  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Using reflection for metadata generation.
203  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Parsing class ""test.XMLDatatypeSupportTestEntity"".
219  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Finished parsing metadata resource ""file:/C:/temp/test/META-INF/jpamappings.xml"".
219  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Set persistence-capable superclass of ""test.XMLDatatypeSupportTestEntity"" to ""null"".
219  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Resolving metadata for ""test.XMLDatatypeSupportTestEntity@1259490066"".
219  EntityUnit_JSE  TRACE  [main] openjpa.MetaData -   Resolving field ""test.XMLDatatypeSupportTestEntity@1259490066.byteAttrDefault"".
219  EntityUnit_JSE  TRACE  [main] openjpa.MetaData -   Resolving field ""test.XMLDatatypeSupportTestEntity@1259490066.id"".
250  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Preparing mapping for ""test.XMLDatatypeSupportTestEntity"".
250  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Resolving mapping for ""test.XMLDatatypeSupportTestEntity@1259490066"".
250  EntityUnit_JSE  TRACE  [main] openjpa.Enhance - Enhancing type ""class test.XMLDatatypeSupportTestEntity"".
312  EntityUnit_JSE  TRACE  [main] openjpa.MetaData - Clearing metadata repository ""org.apache.openjpa.meta.MetaDataRepository@518c518c"".
-----------------------------------------
",All platforms,,,,,,,,,,,,,,,,,,,,,13/Sep/07 16:54;allee8285;OPENJPA-367.patch;https://issues.apache.org/jira/secure/attachment/12365748/OPENJPA-367.patch,12/Sep/07 16:33;allee8285;OPENJPA-367.test.jar;https://issues.apache.org/jira/secure/attachment/12365647/OPENJPA-367.test.jar,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-09-12 17:17:16.676,,,no_permission,,,,,,,,,,,160690,,,Sun Dec 16 18:27:36 UTC 2007,,,,,,,0|i0z713:,203441,,,,,,,,"12/Sep/07 16:33;allee8285;Attached jar contains all the artifacts to reproduce the problem.
- unzip the jar to c:\temp
- run tests with
    runPcEnhancer.bat
       or
    runPcEnhancer.bat test.XMLDatatypeSupportTestEntity","12/Sep/07 16:48;allee8285;From initial investigation, here is the call stack that shows the call path to CFMetaDataParser.classForName()

  CFMetaDataParser.classForName(String, String, boolean, ClassLoader) line: 307
  XMLPersistenceMetaDataParser(CFMetaDataParser).classForName(String, boolean) line: 285	
  XMLPersistenceMetaDataParser.classForName(String) line: 1679	
  XMLPersistenceMetaDataParser.startClass(String, Attributes) line: 727	
  XMLPersistenceMetaDataParser(CFMetaDataParser).startElement(String, Attributes) line: 108	
  XMLPersistenceMetaDataParser(XMLMetaDataParser).startElement(String, String, String, Attributes) line: 432	
  SAXParserImpl$JAXPSAXParser(AbstractSAXParser).startElement(QName, XMLAttributes, Augmentations) line: not available	
  XMLSchemaValidator.startElement(QName, XMLAttributes, Augmentations) line: not available	
  XMLNSDocumentScannerImpl.scanStartElement() line: not available	
  XMLNSDocumentScannerImpl$NSContentDispatcher(XMLDocumentFragmentScannerImpl$FragmentContentDispatcher).dispatch(boolean) line: not available	
  XMLNSDocumentScannerImpl(XMLDocumentFragmentScannerImpl).scanDocument(boolean) line: not available	
  XIncludeAwareParserConfiguration(XML11Configuration).parse(boolean) line: not available	
  XIncludeAwareParserConfiguration(XML11Configuration).parse(XMLInputSource) line: not available	
  SAXParserImpl$JAXPSAXParser(XMLParser).parse(XMLInputSource) line: not available	
  SAXParserImpl$JAXPSAXParser(AbstractSAXParser).parse(InputSource) line: not available	
  SAXParserImpl.parse(InputSource, DefaultHandler) line: not available	
  XMLPersistenceMetaDataParser(XMLMetaDataParser).parseNewResource(Reader, String) line: 376	
  XMLPersistenceMetaDataParser(XMLMetaDataParser).parse(MetaDataIterator, boolean) line: 318	
  XMLPersistenceMetaDataParser(XMLMetaDataParser).parse(MetaDataIterator) line: 295	
  XMLPersistenceMetaDataParser(XMLMetaDataParser).parse(URL) line: 268	
  PersistenceMetaDataFactory.parseXML(URL, Class, int, ClassLoader) line: 247	
  PersistenceMetaDataFactory.load(Class, int, ClassLoader) line: 198	
  MetaDataRepository.getMetaDataInternal(Class, ClassLoader) line: 470	
  MetaDataRepository.getMetaData(Class, ClassLoader, boolean) line: 290	
  PCEnhancer.<init>(OpenJPAConfiguration, BCClass, MetaDataRepository, ClassLoader) line: 242	
  PCEnhancer.run(OpenJPAConfiguration, String[], PCEnhancer$Flags, MetaDataRepository, BytecodeWriter, ClassLoader) line: 4349	
  PCEnhancer.run(OpenJPAConfiguration, String[], Options) line: 4296	
  PCEnhancer.main(String[]) line: 4268	

In the failing case, serp.Strings.toClass() method returns a different Class object from the Class object used by the MetaDataRepository, as a result, the look up of the meta data from the MetaDataRepository._meta map will not find the meta data, even there is one in the _meta map with a different Class object key.

If a target is passed to the enhencer, serp.Strings.toClass() returns the same Class object, hence the look up in the MetaDataRepository succeeded. 

This implies serp returns a entity Class object using a different classloader.  From what I notice, both calls (pass & fail cases) to the serp.Strings.toClass() method uses the same TemporaryClassLoader.

Since I have no access to the Serp code, I don't know what Serp does and what is the difference that cause the failure.

I am looking for someone who can shred some light into this problem.

Thanks.
Albert Lee.","12/Sep/07 17:17;pcl;FTR, the serp source code is available at http://serp.sourceforge.net","12/Sep/07 19:46;allee8285;Patrick, thanks for the pointer to the serp code. It helps a lot.  This problem has nothing to do with Serp.

The scope of the problem is:

1) When pcEnhancer is invoked with a target (i.e. test.XMLDatatypeSupportTestEntity), the ClassArgParser.parseTypes() is called to process the arguments and indirectly the entity is loaded using the TemporaryClassLoader. Subsequently, when the orm.xml is parsed, the same TemporaryClassLoader is used as the key to the meta data repository map.

    TemporaryClassLoader.loadClass(String, boolean) line: 78	
    TemporaryClassLoader.loadClass(String) line: 44	
    ClassLoader.defineClassImpl(String, byte[], int, int, Object) line: not available [native method]	
    TemporaryClassLoader(ClassLoader).defineClass(String, byte[], int, int, ProtectionDomain) line: 224	
    TemporaryClassLoader(ClassLoader).defineClass(String, byte[], int, int) line: 163	
    TemporaryClassLoader.loadClass(String, boolean) line: 78	
    TemporaryClassLoader.loadClass(String) line: 44	
    Class<T>.forNameImpl(String, boolean, ClassLoader) line: not available [native method]	
    Class<T>.forName(String, boolean, ClassLoader) line: 164	
    Strings.toClass(String, boolean, ClassLoader) line: 162	
    Strings.toClass(String, ClassLoader) line: 108	
    ClassArgParser.parseTypes(String) line: 164	
    PCEnhancer.run(OpenJPAConfiguration, String[], PCEnhancer$Flags, MetaDataRepository, BytecodeWriter, ClassLoader) line: 4333	
    PCEnhancer.run(OpenJPAConfiguration, String[], Options) line: 4296	
    PCEnhancer.main(String[]) line: 4268	

2) When no target is specified, the argument process is skipped and proceed to meta-data processing. The first step to do is to load entity class using serp.Project.  Currently, the project's loadClass() method is called without a classloader, therefore Project uses a default, which is the application context classloader (Thread.currentThread().getContextClassLoader();)
However, the remaining meta-data processing follow the exactly the same path as the successfully scenario and use the TemporaryClassLoader to load the entity class. This later entity Class object is used as the key to the meta-data repository map.  When all the processing is finished, MetaDataRepository.getMetaDataInternal( entityClass_from_applCtxtClassLoader) is called to lookup the meta data and was not found.

--------------------------------
  PCEnhancer.java
        for (Iterator itr = classes.iterator(); itr.hasNext();) {
            Object o = itr.next();
            if (log.isTraceEnabled())
                log.trace(_loc.get(""enhance-running"", o));

            if (o instanceof String)
                bc = project.loadClass((String) o, loader); //<<<<  loader is added to resolve the observed problem
            else
                bc = project.loadClass((Class) o);
            enhancer = new PCEnhancer(conf, bc, repos, loader);
--------------------------------
  serp.Project.java
      public BCClass loadClass(String name) {
        return loadClass(name, null);
    }
--------------------------------
    public BCClass loadClass(String name, ClassLoader loader) {
        // convert to proper Class.forName() form
        name = _names.getExternalForm(name, false);

        BCClass cached = checkCache(name);
        if (cached != null)
            return cached;

        // check for existing type
        if (loader == null)
            loader = Thread.currentThread().getContextClassLoader();
        try {
            return loadClass(Strings.toClass(name, loader));
        } catch (Exception e) {
        }
--------------------------------

I modified PCEnhancer.run method and add the classloader parameter to the project.loadClass()  call to request Project to load the entity class using the TemporaryClassLoader. This seems to fix the problem.

            if (o instanceof String)
                bc = project.loadClass((String) o, loader); //<<<<  loader is added to resolve the observed problem

Is this the correct fix strategy for this problem?

Thanks,
Albert Lee","13/Sep/07 16:54;allee8285;Attached patch to add ""loader"" in PCEnhancer.run().

            if (o instanceof String)
                bc = project.loadClass((String) o, loader);
            else
                bc = project.loadClass((Class) o);",17/Sep/07 07:39;pcl;That sounds like a valid fix to me.,17/Sep/07 19:28;kwsutter;Resolved for 1.1.0 (r576552) and 1.0.1 (r576564).,30/Oct/07 15:44;pcl;The test case for this issue was not checked in.,30/Oct/07 16:04;allee8285;Problem fixed. Need to check in test.,"16/Dec/07 18:27;sebasouza;I have the same problem, and i am using openjpa 1.1. ",,,,,,,,,,,,,,,,,,,,,,,,,,,
InternalException thrown in BrokerImpl.endOperation,OPENJPA-366,12378057,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,12/Sep/07 14:27,27/Feb/08 20:30,14/Mar/19 03:02,31/Jan/08 00:45,1.0.0,,,,,,,,,1.0.2,1.1.0,,,,kernel,,,,,,0,,"Under heavy load during stress test, the following exception is observed:

<openjpa-1.0.0-SNAPSHOT-r420667:570288M fatal general error> org.apache.openjpa.persistence.PersistenceException: null
        at org.apache.openjpa.kernel.BrokerImpl.endOperation(BrokerImpl.java:1728)
        at org.apache.openjpa.kernel.BrokerImpl.isActive(BrokerImpl.java:1676)
        at org.apache.openjpa.kernel.DelegatingBroker.isActive(DelegatingBroker.java:420)
        at org.apache.openjpa.persistence.EntityManagerImpl.isActive(EntityManagerImpl.java:502)
        at org.apache.openjpa.persistence.PersistenceExceptions$2.translate(PersistenceExceptions.java:66)
        at org.apache.openjpa.kernel.DelegatingBroker.translate(DelegatingBroker.java:110)
        at org.apache.openjpa.kernel.DelegatingBroker.newObjectId(DelegatingBroker.java:262)
        at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:347)
        at com.ibm.svt.shoppingcartModule.stationstore.StationStoreSessionBean.getListOrders(StationStoreSessionBean.java:603)
        at com.ibm.svt.shoppingcartModule.stationstore.EJSRemoteStatelessStationStoreSession_5a5c538c.getListOrders(Unknown Source)
        at com.ibm.svt.shoppingcartModule.stationstore._EJSRemoteStatelessStationStoreSession_5a5c538c_Tie.getListOrders(_EJSRemoteStatelessStationStoreSession_5a5c538c_Tie.java:244)
        at com.ibm.svt.shoppingcartModule.stationstore._EJSRemoteStatelessStationStoreSession_5a5c538c_Tie._invoke(_EJSRemoteStatelessStationStoreSession_5a5c538c_Tie.java:100)
        at com.ibm.CORBA.iiop.ServerDelegate.dispatchInvokeHandler(ServerDelegate.java:613)
        at com.ibm.CORBA.iiop.ServerDelegate.dispatch(ServerDelegate.java:466)
        at com.ibm.rmi.iiop.ORB.process(ORB.java:503)
        at com.ibm.CORBA.iiop.ORB.process(ORB.java:1553)
        at com.ibm.rmi.iiop.Connection.respondTo(Connection.java:2680)
        at com.ibm.rmi.iiop.Connection.doWork(Connection.java:2554)
        at com.ibm.rmi.iiop.WorkUnitImpl.doWork(WorkUnitImpl.java:62)
        at com.ibm.ejs.oa.pool.PooledThread.run(ThreadPool.java:118)
        at com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1469)

[8/31/07 22:45:26:265 EDT] 000000c1 SystemOut     O   MDD Translating exception: <openjpa-0.0.0-r420667:570288 fatal internal error> org.apache.openjpa.util.InternalException: null
[8/31/07 22:45:26:265 EDT] 000000c1 SystemErr     R   <openjpa-0.0.0-r420667:570288 fatal internal error> org.apache.openjpa.util.InternalException: null
[8/31/07 22:45:26:265 EDT] 000000c1 SystemErr     R   	at org.apache.openjpa.kernel.BrokerImpl.endOperation(BrokerImpl.java:1728)

After some investigation, it was determined that the internal exception is caused by
             if (_operationCount < 1)
                throw new InternalException();
in BrokerImpl.endOperation();

We believe the cause of the problem is a lock() method call is missing in the endOperation()

    public boolean endOperation() {
        lock();   <<<<<  This is the missing lock() call since BrokerImpl.java was created
        try {
            if (_operationCount == 1 && (_autoDetach & DETACH_NONTXREAD) != 0
                && (_flags & FLAG_ACTIVE) == 0) {
                detachAllInternal(null);
            }
            if (_operationCount < 1)
                throw new InternalException();
            return _operationCount == 1;
        } catch (OpenJPAException ke) {
            throw ke;
        } catch (RuntimeException re) {
            throw new GeneralException(re);
        } finally {
            _operationCount--;
            if (_operationCount == 0)
                _operating.clear();
            unlock();
        }
    }

Once we have done more tests and verify the fix, I'll submit a patch for this problem.

If anyone doesn't think this is the solution. please response.

Albert Lee.",All platforms,,,,,,,,,,,,,,,,,,,,,02/Oct/07 22:02;allee8285;OPENJPA-366.patch;https://issues.apache.org/jira/secure/attachment/12366960/OPENJPA-366.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-01-31 00:45:29.956,,,no_permission,,,,,,,,,,,160689,,,Thu Jan 31 00:45:29 UTC 2008,,,,,,,0|i0z77j:,203470,,,,,,,,"13/Sep/07 17:10;allee8285;Add lock() in BrokerImpl.endOperation().

Stress test ran for 24 hours and still have not observed the reported problem. Continue to test with increasing workloads and clients for a 48 hours run.","15/Sep/07 01:23;allee8285;The hypothesis that the lock() is missing in endOperation() is incorrect. It was not there by design. Can some administrator remove the attached patch in this report.

We'll continue to investigate this issue and appreciate if anyone has any clues or ideas on where the problem is or how to attach the problem.

Thanks","21/Sep/07 15:42;allee8285;An update to this issue:

1) The test scenario is a simple Sale - 1toM - Order processing
2) A EJB 2.1 stateless session bean StationBean is used to drive the Sale. It uses JSE style access to JPA functions.

    public void ejbCreate() throws javax.ejb.CreateException {
        ut = (UserTransaction) getSessionContext().getUserTransaction();
        saleFactory = Persistence.createEntityManagerFactory(""StationSale"");
        saleManager = saleFactory.createEntityManager();
    }
  
3) This bean has a getListOrder() method returns Vector<Order>.

    public Vector getListOrders(int saleid) throws Exception {
        String methodName = ""getListOrders"";
        Vector v = new Vector();
        try {
            ut.begin();
            saleManager.joinTransaction();
            Sale sl = saleManager.find(Sale.class, saleid);
            if (sl != null) {
                saleManager.refresh(sl);
                Collection c = sl.getOrders();
                if (c != null) {
                    Iterator ids = c.iterator();
                    while (ids.hasNext()) {
                        Order o = (Order) ids.next();
                        if (o != null) {
                            v.add(o);
                        }
                    }
                }
                ut.commit();
            } else {
                throw new Exception(""getListOrders, Unable to find Sale , returned null for saleid = ""  + saleid);
            }
        } catch (Exception e1) {
            ut.rollback();
            throw e1;
        }
        return v;
    }
    
4) A test driver accesses the StationBean in multiple clients under heavy load. As a result, the observed exception as report in the original comment occurs.
5) Re-run the test with ""openjpa.Multithreaded=true"" property resolved the problem. It is due to the fact that this property installed a ReentrantLock in the BrokerImpl to synchronize multiple invocations to the same BrokerImpl.
6) After further analysis of the problem, the following stacks revealed the sources of the multiple invocations to the same broker:

   >>> Thread 1 : Thread[ORB.thread.pool : 3,5,main]
 java.lang.Exception: curThread=Thread[ORB.thread.pool : 3,5,main]:lock={noLock}:threadCnt=2:_operationCount=0
   at org.apache.openjpa.kernel.BrokerImpl.beginOperation(BrokerImpl.java:1723)
   at org.apache.openjpa.kernel.BrokerImpl.newObjectId(BrokerImpl.java:1060)
   at org.apache.openjpa.kernel.DelegatingBroker.newObjectId(DelegatingBroker.java:252)
   at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:347)
   at com.ibm.svt.shoppingcartModule.stationstore.StationStoreSessionBean.getListOrders(StationStoreSessionBean.java:603)
   at com.ibm.svt.shoppingcartModule.stationstore.EJSRemoteStatelessStationStoreSession_5a5c538c.getListOrders(Unknown Source)
   at com.ibm.svt.shoppingcartModule.stationstore._EJSRemoteStatelessStationStoreSession_5a5c538c_Tie.getListOrders(_EJSRemoteStatelessStationStoreSession_5a5c538c_Tie.java:244)
   at com.ibm.svt.shoppingcartModule.stationstore._EJSRemoteStatelessStationStoreSession_5a5c538c_Tie._invoke(_EJSRemoteStatelessStationStoreSession_5a5c538c_Tie.java:100)
   at com.ibm.CORBA.iiop.ServerDelegate.dispatchInvokeHandler(ServerDelegate.java:613)
   at com.ibm.CORBA.iiop.ServerDelegate.dispatch(ServerDelegate.java:466)
   at com.ibm.rmi.iiop.ORB.process(ORB.java:503)
   at com.ibm.CORBA.iiop.ORB.process(ORB.java:1553)
   at com.ibm.rmi.iiop.Connection.respondTo(Connection.java:2680)
   at com.ibm.rmi.iiop.Connection.doWork(Connection.java:2554)
   at com.ibm.rmi.iiop.WorkUnitImpl.doWork(WorkUnitImpl.java:62)
   at com.ibm.ejs.oa.pool.PooledThread.run(ThreadPool.java:118)
   at com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1469)

   >>> Thread 2 : Thread[ORB.thread.pool : 2,5,main]
 java.lang.Exception: curThread=Thread[ORB.thread.pool : 2,5,main]:lock={noLock}:threadCnt=1:_operationCount=0
   at org.apache.openjpa.kernel.BrokerImpl.beginOperation(BrokerImpl.java:1723)
   at org.apache.openjpa.kernel.BrokerImpl.isActive(BrokerImpl.java:1683)
   at org.apache.openjpa.kernel.StateManagerImpl.load(StateManagerImpl.java:352)
   at org.apache.openjpa.kernel.DetachManager.preDetach(DetachManager.java:156)
   at org.apache.openjpa.kernel.DetachManager.preSerialize(DetachManager.java:91)
   at org.apache.openjpa.kernel.StateManagerImpl.serializing(StateManagerImpl.java:1310)
   at com.ibm.svt.shoppingcartModule.storeEntities.Order.pcSerializing(Order.java)
   at com.ibm.svt.shoppingcartModule.storeEntities.Order.writeObject(Order.java)
   at sun.reflect.GeneratedMethodAccessor57.invoke(Unknown Source)
   at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
   at java.lang.reflect.Method.invoke(Method.java:615)
   at com.ibm.rmi.io.IIOPOutputStream.invokeObjectWriter(IIOPOutputStream.java:966)
   at com.ibm.rmi.io.IIOPOutputStream.outputObject(IIOPOutputStream.java:1002)
   at com.ibm.rmi.io.IIOPOutputStream.writeSerializable(IIOPOutputStream.java:1050)
   at com.ibm.rmi.io.IIOPOutputStream.simpleWriteObjectInternal(IIOPOutputStream.java:427)
   at com.ibm.rmi.io.IIOPOutputStream.simpleWriteObjectLoop(IIOPOutputStream.java:455)
   at com.ibm.rmi.io.IIOPOutputStream.defaultWriteObjectDelegate(IIOPOutputStream.java:566)
   at com.ibm.rmi.io.OutputStreamHook.defaultWriteObject(OutputStreamHook.java:132)
   at java.util.Vector.writeObject(Vector.java:869)
   at sun.reflect.GeneratedMethodAccessor10.invoke(Unknown Source)
   at java.util.Vector.writeObject(Vector.java:869)
   at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
   at sun.reflect.GeneratedMethodAccessor10.invoke(Unknown Source)
   at java.lang.reflect.Method.invoke(Method.java:615)
   at com.ibm.rmi.io.IIOPOutputStream.invokeObjectWriter(IIOPOutputStream.java:966)
   at com.ibm.rmi.io.IIOPOutputStream.outputObject(IIOPOutputStream.java:1002)
   at com.ibm.rmi.io.IIOPOutputStream.writeSerializable(IIOPOutputStream.java:1050)
   at com.ibm.rmi.io.IIOPOutputStream.simpleWriteObjectInternal(IIOPOutputStream.java:427)
   at com.ibm.rmi.io.IIOPOutputStream.simpleWriteObjectLoop(IIOPOutputStream.java:455)
   at com.ibm.rmi.io.IIOPOutputStream.simpleWriteObject(IIOPOutputStream.java:512)
   at com.ibm.rmi.io.ValueHandlerImpl.writeValue(ValueHandlerImpl.java:159)
   at com.ibm.rmi.iiop.CDROutputStream.write_value(CDROutputStream.java:1477)
   at com.ibm.rmi.iiop.CDROutputStream.write_value(CDROutputStream.java:1497)
   at com.ibm.rmi.iiop.CDROutputStream.write_value(CDROutputStream.java:1459)
   at com.ibm.svt.shoppingcartModule.stationstore._EJSRemoteStatelessStationStoreSession_5a5c538c_Tie.getListOrders(_EJSRemoteStatelessStationStoreSession_5a5c538c_Tie.java:256)
   at com.ibm.svt.shoppingcartModule.stationstore._EJSRemoteStatelessStationStoreSession_5a5c538c_Tie._invoke(_EJSRemoteStatelessStationStoreSession_5a5c538c_Tie.java:100)
   at com.ibm.CORBA.iiop.ServerDelegate.dispatchInvokeHandler(ServerDelegate.java:613)
   at com.ibm.CORBA.iiop.ServerDelegate.dispatch(ServerDelegate.java:466)
   at com.ibm.rmi.iiop.ORB.process(ORB.java:503)
   at com.ibm.CORBA.iiop.ORB.process(ORB.java:1553)
   at com.ibm.rmi.iiop.Connection.respondTo(Connection.java:2680)
   at com.ibm.rmi.iiop.Connection.doWork(Connection.java:2554)
   at com.ibm.rmi.iiop.WorkUnitImpl.doWork(WorkUnitImpl.java:62)
   at com.ibm.ejs.oa.pool.PooledThread.run(ThreadPool.java:118)
   at com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1469)

7) Thread #1 is doing the normal em.find processing and hits the BrokerImpl.beginOperation().
8) Thread #2 has completed the em.find processing and the Vector<Order> is collected properly in the getListOrder() method. ORB/CORBA is trying to serialize the return Vector<Order> back to the remote client.
9) During this processing, it is getting back to openjpa to serialize an Order in the returning collection:

   at org.apache.openjpa.kernel.StateManagerImpl.serializing(StateManagerImpl.java:1310)
   at com.ibm.svt.shoppingcartModule.storeEntities.Order.pcSerializing(Order.java)
   at com.ibm.svt.shoppingcartModule.storeEntities.Order.writeObject(Order.java)
   at sun.reflect.GeneratedMethodAccessor57.invoke(Unknown Source)

10) The EJB container guarantees a different StationBean instance is invoked from getListOrders() method call which initiated from different threads/clients, and since the em in each StationBean instance is obtained independently from Persistence class, we can concluded the em.find() in each bean invocation must use a different broker for the em.find() call.
11) Therefore we suspect somehow a incorrect broker (same broker used by Thread #1) is used during the pcSerializing invocation in Thread #2.
12) Another supporting fact for the hypothesis is we have observed scenario where there are up to 6 threads accessing the same BrokerImpl. Out of these call stacks, there is always only one thread exhibits the same stack pattern as in Thread #1 and the other threads have the Thread #2 call stack pattern.


Questions:
1) What is(are) the conditions (e.g. openjpa features/property) that trigger the Order.pcSerializing() processing? I wrote a simplier test that mimic the test case and was unable to drive the Order.pcSerializing() method call.
2) How is the Order.pcSerilizing() determine which BrokerImpl to use to perform the serialization?
3) Any suggestings or insight into how to identify the culprit of this problem?

Any help on this matter is greatly appreciated.
Albert Lee.","28/Sep/07 15:27;allee8285;After a lengthy investigation to this problem, it turns out there are a few problems in this application/ejb usage scenario:

1) Problem #1 - Application

The appl uses stateless session bean (SLSB) and JSE style JPA access, therefore the persistence context is extended. In each bean method call, the appl uses the persistence context to access JPA functions but did not clear the context upon method return. This leaves managed entities in the context propagates to the next client/thread who just happens to use the same session bean instance allocated by the EJB container from its slsb pool. 

2) Problem #2 - EJBContainer

Typically, an application server generates EJB deployment code (GenCode), either statically or at runtime, for an application(.ear) in order to implement EJB Container semantics in the application server. This generated code sits between the ORB/COBRA and the EJB Container. It redirects calls from the client to the EJB Container. Here is a brief sequence of events during this call path:

  a) ORB directs the client method call to the GenCode
  b) GenCode invokes the EJB Container to performs EJB semantics. E.g. start a transaction, CMP/BMP processing.  One of the function in this step is to allocate an user-defined bean instance.
  c) GenCode invokes the user define bean method.
  d) GenCode invokes the EJB Container to performs EJB clean up semantics. E.g. commit/rollback transaction, exception handling etc.  When this step is finished, the user-defined bean instance is returned back to the bean pool maintained by the EJB Container.
  e) GenCode returns the bean method returned object to ORB
   f) ORB serializes the returned object to an output stream which will be streamed back to the client.

In the reported problem scenario, the method being calls return a Vector<OrderEntity>. Everything functions normally until step d) to f). After step d), the SLSB instance is returned back to the EJB pool and is available for use by the next client while the current thread is still processing step f).  If the returned object contains a managed entity, the serialization process will eventually invocate its owning EntityManager/broker. Since step d) to f) are not synchronized, in a high load environment, EJB Container may allocate the same SLSB instance to a client in another thread. Now there are 2 threads using managed entities in the same persistence context. Since EntityManager is not thread-safe (per JPA spec), the reported exception is observed.

3) Problem #3 - OpenJPA

OpenJPA is doing whatever it can to detect the multiple access to the same thread/broker. However when this happens, only a InternalException() with a ""null"" message is thrown and this percolates back to the user with an PersistenceException with no meaningful message to isolate the problem. This is a critical usability issues.


Solutions for this Jira report:

1) Application must clear all Persistence Context upon return for each bean method call. There are explicit example in the JPA spec demonstrates these usage. (JPA spec 5.7.1.1 and 5.7.1.2)
2) Proposed to enhance the error message when this error condition occurs to explain the cause of the problem and suggested the following possible solutions:
      a) set ""openjpa.Multithreaded=true"", if the application requires and intent to support this particular usage. Application must fully responsible for the behavior of this undefined semantics.
      b) request application to make sure entity manager defines as attribute(s) in SLSB must be cleared upon each bean method invocation.

I'll use this Jira report to addess solution 2).

Albert Lee.","02/Oct/07 22:02;allee8285;Add a new message text for InternalException().

This patch is tested against both 1.1.0 trunk and 1.0.x branch.",30/Oct/07 15:44;allee8285;There are still other issues need to be resolved. Defer to next release.,"31/Jan/08 00:45;pcl;Marking as resolved, as I do not understand what additional issues remain for this issue. If there are any, please expand on them.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unexpected behavior on finding a Composite Key entity with a single value.,OPENJPA-365,12378020,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,mikecool,mikecool,12/Sep/07 01:58,09/Mar/10 18:32,14/Mar/19 03:02,16/Jul/08 03:59,,,,,,,,,,1.2.0,,,,,kernel,,,,,,0,,"Entity A has a composite key AId, thus User should look up A with an instance of AId.
Example: em.find(A.class, new AId());

In case of looking up A with a single value, for example: em.find(A.class, 12345). It will through an unexpected exception:
>>>The id type ""AId"" specfied by persistent type ""A"" does not have a  public string or class + string constructor.

>>>>> org.apache.openjpa.kernel.BrokerImpl.newObjectId 
>>>>> (BrokerImpl.java:1120)
>>>>> [WLServer TmsServer]    at  
>>>>> org.apache.openjpa.kernel.DelegatingBroker.newObjectId 
>>>>> (DelegatingBroker.java:254)
>>>>> [WLServer TmsServer]    at  
>>>>> org.apache.openjpa.persistence.EntityManagerImpl.find 
>>>>> (EntityManagerImpl.java:345)

I suppose to get an exception of error id type.
","Windows XP, JDK 1.5, OpenJPA 0.9.7",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160688,,,2007-09-12 01:58:22.0,,,,,,,0|i0zb53:,204107,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
maven build order is incorrect,OPENJPA-364,12377993,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,kwsutter,kwsutter,11/Sep/07 18:57,09/Mar/10 18:32,14/Mar/19 03:02,28/Apr/08 13:23,1.1.0,,,,,,,,,1.1.0,,,,,build / infrastructure,,,,,,0,,"From the dev mailing list. (http://www.nabble.com/order-of-build-modules-isn%27t-quite-right-tf4416976.html).

In short, we are building the aggregate jar before we have built the 1.5 modules.  Details follow...  BTW, this only seems to apply to the trunk (1.1.0 snapshot).  

============================================================

> Yes, that sounds about right.  This just recently started to happen...

Maybe if we create two profiles, one for 1.4 only and one for 5.0, and
just enable the appropriate one of them? This would increase
repetition (we could address that with XML entities, of course), but
might get things to run right.
- Hide quoted text -

-Patrick

On 9/10/07, Kevin Sutter <kwsutter@gmail.com> wrote:
> On 9/10/07, Patrick Linskey <plinskey@gmail.com> wrote:
> >
> > > So, I'm not sure what has to change in our pom.xml files to allow one to
> > > build, package, and install our aggregrate jar on the first try.  Any
> > maven
> > > experts that can help with this?
> >
> > Sadly, Marc probably knows the most, and he's on top of Mt Kilimanjaro
> > or thereabouts right now.
>
>
> Yep, and my resident build expert (Mike) is on vacation this week as well..
> :-)
>
> Might this have started happening with the recent move from how the
> > dependencies are set up, for the purposes of keeping our mvn
> > dependencies clean?
>
>
> Yes, that sounds about right.  This just recently started to happen...
>
> Kevin
>
> -Patrick
> >
> > On 9/10/07, Kevin Sutter <kwsutter@gmail.com> wrote:
> > > Hi,
> > > I'm the first to admit that I'm not a maven build expert, so I'm not
> > exactly
> > > sure what needs to be changed.  But, here's the problem...
> > >
> > > If I only want to build the artifacts and install them into my maven
> > > repository, I issue the following maven command.  (BTW, this only
> > happens on
> > > a truly clean environment.  Either just pull the contents from svn or do
> > a
> > > separate ""mvn clean"" first like I demonstrate below.)
> > >
> > > > mvn clean
> > > > mvn install
> > >
> > > But, when I do this, I get the following build report.  Although
> > everything
> > > builds okay, look at the order of the modules getting built.  We are
> > > building the aggregrate jar and distribution jars before we build kernel
> > 1.5,
> > > jpa, and jpa jdbc.  Thus, the aggregrate jar that we build does not have
> > all
> > > of the required contents (because I have a clean environment to start
> > with).
> > >
> > > [INFO]
> > > ------------------------------------------------------------------------
> > > [INFO] Reactor Summary:
> > > [INFO]
> > > ------------------------------------------------------------------------
> > > [INFO] OpenJPA ............................................... SUCCESS [
> > > 1.328s]
> > > [INFO] OpenJPA Utilities ..................................... SUCCESS [
> > > 12.265s]
> > >
> > > [INFO] OpenJPA Kernel ........................................ SUCCESS [
> > > 17.703s]
> > >
> > > [INFO] OpenJPA JDBC .......................................... SUCCESS [
> > > 10.063s]
> > >
> > > [INFO] OpenJPA XML Store ..................................... SUCCESS [
> > > 0.969s]
> > > [INFO] OpenJPA Aggregate Jar ................................. SUCCESS [
> > > 17.218s]
> > >
> > > [INFO] OpenJPA Distribution .................................. SUCCESS [
> > > 19.860s]
> > >
> > > [INFO] OpenJPA Integration Tests ............................. SUCCESS [
> > > 0.015s]
> > > [INFO] OpenJPA Examples Integration Tests .................... SUCCESS [
> > > 0.016s]
> > > [INFO] OpenJPA JPA TCK Integration Tests ..................... SUCCESS [
> > > 0.016s]
> > > [INFO] OpenJPA Kernel 1.5 .................................... SUCCESS [
> > > 0.718s]
> > > [INFO] OpenJPA JPA ........................................... SUCCESS [
> > > 4.719s]
> > > [INFO] OpenJPA JDBC 1.5 ...................................... SUCCESS [
> > > 0.625s]
> > > [INFO] OpenJPA JPA JDBC ...................................... SUCCESS [
> > > 17.437s]
> > >
> > > [INFO] OpenJPA Persistence Examples .......................... SUCCESS [
> > > 0.547s]
> > > [INFO]
> > > ------------------------------------------------------------------------
> > > [INFO]
> > > ------------------------------------------------------------------------
> > >
> > > I looked at our pom.xml at our root level of trunk and I see the
> > following
> > > <module> listing, which maps to the order of the build above:
> > >
> > >     <modules>
> > >         <module>openjpa-lib</module>
> > >         <module>openjpa-kernel</module>
> > >         <module>openjpa-jdbc</module>
> > >         <module>openjpa-xmlstore</module>
> > >         <module>openjpa-all</module>
> > >         <module>openjpa-project</module>
> > >         <module>openjpa-integration</module>
> > >     </modules>
> > >
> > > The rest of our modules are listed under the jdk1.5 profile and don't
> > get
> > > built until after these 1.4 modules are built.  If I re-run the exact
> > same
> > > invocation (without starting from scratch with the ""mvn clean""), then
> > > everything works since the 1.5 modules are all built and pulled into the
> > > aggregrate jar.
> > >
> > > So, I'm not sure what has to change in our pom.xml files to allow one to
> > > build, package, and install our aggregrate jar on the first try.  Any
> > maven
> > > experts that can help with this?
> > >
> > > Thanks,
> > > Kevin
> > >
> >
> >
> > --
> > Patrick Linskey
> > 202 669 5907
> >
>

",,,,,,,,,,,,,,,,,,,,,,17/Sep/07 04:22;djencks;OPENJPA-364-3.patch;https://issues.apache.org/jira/secure/attachment/12365973/OPENJPA-364-3.patch,12/Sep/07 20:36;kwsutter;OPENJPA-364.patch;https://issues.apache.org/jira/secure/attachment/12365671/OPENJPA-364.patch,11/Sep/07 19:23;fancy;OPENJPA-364.patch;https://issues.apache.org/jira/secure/attachment/12365585/OPENJPA-364.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-09-11 19:23:23.64,,,no_permission,,,,,,,,,,,160687,,,Mon Apr 28 13:23:47 UTC 2008,,,,,,,0|i0zb9j:,204127,,,,,,,,"11/Sep/07 19:23;fancy;my mvn knowledge is limited, but this patch seems to solve the build problem.","11/Sep/07 21:36;clr;IIRC, the reason we recently changed the build was to avoid having the aggregate jar declare dependencies at runtime on the other jars, which leads to the situation where a user downloads the aggregate jar which then causes all of the other jars to be downloaded and added to the path as well. 

So, can you verify that if you have a simple project that has a dependency on the aggregate jar, the only jar downloaded is the aggregate jar?","12/Sep/07 16:00;kwsutter;Catalina's suggested patch fixes the build order, but it basically re-instates the problem that was resolved by OPENJPA-345.  Actually, if you look at the patches for these two Issues, they cancel each other out.  So, we have more work to do...

Kevin","12/Sep/07 20:36;kwsutter;Question:  Why do we even have the ""jdk1.5"" profile in the trunk's pom file?  I think at one time, we were attempting to use this to force the compilation of some modules with jdk1.5 and others with jdk1.4.  But, now that each of the individual module's pom files have the jdk level configured, I don't see where we need the jdk1.5 profile any longer.

As a test, I removed the jdk 1.5 profile and moved those modules to the top-level module list in the trunk's pom file.  Like Catalina's previous patch, things are working better now, but is this the ""right solution""?

I've attached the patch in case anybody wants to check it out.

Kevin","17/Sep/07 04:22;djencks;I'm not sure what the previous patch that modifies the root pom is supposed to do but I can't see why it would affect this issue.  I think what you want is to use maven scopes.  The attached patch uses scope ""provided"" for all the dependencies which basically makes them non-transitive.  In addition to not wanting to have dependencies on openjpa ""mini-jars"" I really doubt you want dependencies on the geronimo spec implementation jars.  I don't know about serp.... in my patch I left it out also.","18/Sep/07 14:16;mikedd;Thanks for the patch David!

David's approach worked for me so I've gone ahead and committed it with one change. I didn't change the scope of serp to be provided. I think it makes sense for serp to be included since OpenJPA won't run without it. 

I'm a bit ambivalent regarding the geronimo specs. Its likely that users will have their own copy of these dependencies and they might prefer to pick up the version that matches their deploy environment. For JEE  this would be the app server's j2ee.jar. For JSE users will have to download a particular version. 

I'm leaving the JIRA open so we can discuss whether users should be expected to provide j2ee.jar (or the individual spec jars). ",18/Sep/07 16:25;kwsutter;This one doesn't apply to the 1.0.x stream...,"18/Sep/07 16:55;clr;When we remove the spec jars from explicit dependency, we expose the user to class not found exceptions unless the user's pom.xml references them. 

In an app server environment, this is absolutely not an issue, but in Java SE don't we need the user's pom to depend on them?

","18/Sep/07 21:26;mikedd;In a JSE environment they will need the spec jars, or a copy of j2ee.jar from an app server. 

The main reason I didn't include the spec jars as ""normal"" dependencies is that they're rather tough to remove. If another maven project depends on OpenJPA we would always add the Geronimo spec jars to the classpath. If for some reason that project didn't want the Geronimo implementation they'd have to manipulate maven so that a different version is loaded first. Theoretically this is as simple as listing the other dependency first, but that might depend on the maven dependency resolver. If the user wants to use the Geronimo spec jars then they don't have to do anything. 

The way it currently works the user has to provide their own version of the spec jars (or j2ee.jar). They can add whichever dependency(ies) they want into pom.xml and won't have to worry about the order on the classpath. The only reason I can think of for doing this is if you're running the app in JSE to test it prior to deploying on an app server and you want to use the same version of the spec jars that are part of the app server. This is probably a corner case, but I can be persuaded otherwise. 

All that being said I'd prefer to include the spec jars as ""normal"" dependencies. I think that the Geronimo implementation is TCK compliant and there shouldn't be any difference between vendors in the spec jars. Unless there are other reasons to leave them out I'll go ahead and put them back in. 
","19/Sep/07 20:51;clr;> The main reason I didn't include the spec jars as ""normal"" dependencies is that they're rather tough to remove. 
> ...
> The way it currently works the user has to provide their own version of the spec jars (or j2ee.jar). They can add whichever dependency(ies) they want into pom.xml and won't have to worry about the order on the classpath. 

Anyway, the pom.xml isn't used for deployment in a server, so this is *just* for Java SE environments.

1. The user does have a choice of where to get the API definitions (from Geronimo spec jars or javaee jar or persistence jar). 

2. OpenJPA doesn't have a hard dependency on any of them (all OpenJPA cares about is that the definitions of the APIs are the same, which in this case they are). 

3. Maven will put into the classpath whatever the user's pom.xml says to.

Therefore, I'd prefer to provide some good sample pom.xml dependencies but not to explicitly depend on Geronimo jars. I looked at our distributed pom.xml and they're pretty obscure. We should probably include the spec dependencies in the docs and see about adding some pom.xml examples that are really simple.",27/Apr/08 22:20;pcl;This is probably a non-issue now that we've gotten rid of the multiple-java-version support.,28/Apr/08 13:23;kwsutter;I agree.  This Issue can go away.,,,,,,,,,,,,,,,,,,,,,,,,,
NPE when enhancing with Maven 1.0.2,OPENJPA-363,12377850,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ssegu,ssegu,ssegu,09/Sep/07 20:43,09/Mar/10 18:35,14/Mar/19 03:02,09/Sep/07 21:14,0.9.0,0.9.6,0.9.7,1.0.0,,,,,,,,,,,lib,,,,,,0,,"java.lang.NullPointerException
at org.apache.openjpa.lib.util.MultiClassLoader.findResources(MultiClassLoader.java:241)
at java.lang.ClassLoader.getResources(ClassLoader.java:851)
at org.apache.openjpa.lib.meta.ClassMetaDataIterator.hasNext(ClassMetaDataIterator.java:148)
at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:305)
at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:283)
at org.apache.openjpa.meta.AbstractCFMetaDataFactory.parse(AbstractCFMetaDataFactory.java:441)
at kodo.jdo.JDOMetaDataFactory.load(JDOMetaDataFactory.java:116)
at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:417)
at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:275)
at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:216)
at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:3665)
at org.apache.openjpa.ant.PCEnhancerTask.executeOn(PCEnhancerTask.java:89)
at org.apache.openjpa.lib.ant.AbstractTask.execute(AbstractTask.java:169)
at org.apache.tools.ant.Task.perform(Task.java:341)
at org.apache.commons.jelly.tags.ant.AntTag.doTag(AntTag.java:185)
at org.apache.commons.jelly.impl.TagScript.run(TagScript.java:279)
at org.apache.commons.jelly.impl.ScriptBlock.run(ScriptBlock.java:135)
at org.apache.maven.jelly.tags.werkz.MavenGoalTag.runBodyTag(MavenGoalTag.java:79)
at org.apache.maven.jelly.tags.werkz.MavenGoalTag$MavenGoalAction.performAction(MavenGoalTag.java:110)
at com.werken.werkz.Goal.fire(Goal.java:639)
at com.werken.werkz.Goal.attain(Goal.java:575)
at org.apache.maven.plugin.PluginManager.attainGoals(PluginManager.java:671)
at org.apache.maven.MavenSession.attainGoals(MavenSession.java:263)
at org.apache.maven.cli.App.doMain(App.java:488)
at org.apache.maven.cli.App.main(App.java:1239)",Maven 1.0.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160686,,,2007-09-09 20:43:38.0,,,,,,,0|i1dq33:,288323,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect GREG_OFFSET offset or inconsistent usage in UUIDGenerator,OPENJPA-361,12377845,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,allee8285,allee8285,allee8285,09/Sep/07 14:06,30/Oct/07 14:43,14/Mar/19 03:02,11/Sep/07 13:30,1.0.0,,,,,,,,,1.0.1,1.1.0,,,,lib,,,,,,0,,"In UUIDGenerator, GREG_OFFSET is defined as

    // offset to move from 1/1/1970, which is 0-time for Java, to gregorian
    // 0-time 10/15/1582, and multiplier to go from 100nsec to msec units
    private static final long GREG_OFFSET = 0x01b21dd213814000L;

This constant is used as:

        // calculate time as current millis plus offset times 100 ns ticks
        long currentTime = (_currentMillis + GREG_OFFSET) * MILLI_MULT;

Based of the usage, GREG_OFFSET should be in msec unit and this value should be

    (1970-1582) * 365.25 * 24 * 3600 * 1000 (ms) = 12,219,292,800,000 (ms) = 0xB1D 069B 5400 (ms)

The defined constant value 0x1b21dd213814000L is the last value in 100ns unit not ms. 

This also offsets the currentTime calculation off by a factor of 10**4.

To correct the discrepency, either:

1) GREG_OFFSET should assign the value of 0xB1D 069B 5400L instead of 0x1b2 1dd2 1381 4000L, or
2) long currentTime = (_currentMillis * MILLI_MULT ) + GREG_OFFSET ;

Since UUID is an arbituary value, therefore I don't believe the current implementation is ""incorrect"" but just inconsistent in its implementation description. 

Please comment on if:
1) the suggested change will have any undesirable side-effect for UUID
2) there is any legacy/backward compatibility problem
3) this is worth to change at all.

If there is no objection, I'll correct the ""problem"" early next week.

Albert Lee.
",All platforms,,,,,,,,,,,,,,,,,,,,,10/Sep/07 16:02;allee8285;OPENJPA-361.patch;https://issues.apache.org/jira/secure/attachment/12365482/OPENJPA-361.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-09-10 20:09:07.953,,,no_permission,,,,,,,,,,,160684,,,Tue Sep 11 13:30:01 UTC 2007,,,,,,,0|i1dq3j:,288325,,,,,,,,10/Sep/07 16:02;allee8285;Change GREG_OFFSET value to match the description.,"10/Sep/07 20:09;kwsutter;Looks like a good catch, Albert.  I went back and looked at the Apache Sandbox code that this implementation was based off of and, sure enough, the constant for GREG_OFFSET should have been 12,219,292,800,000 (ms) or 0xB1D 069B 5400 (ms).  We should go ahead with this change.","10/Sep/07 20:16;pcl;I'm concerned about the backward-compat issue, but haven't done any analysis of it.","10/Sep/07 23:00;kwsutter;> I'm concerned about the backward-compat issue, but haven't done any analysis of it.

I don't think we have anything to worry about.  Looking at the incorrect value that was being used for the Gregorian Offset, we were basically adding somewhere around 380 years to the current time.  So, the possibility of someday matching up a new generated UUID (with the correct Gregorian offset) with an old one is next to nil.  Especially when you bring the other aspects of the UUID into play (IP, clock sequence, etc).

I'm going to go ahead with this commit.

Kevin","10/Sep/07 23:09;pcl;Ok. But in 380 years, I'm going to refer all bug reports about this to you.",11/Sep/07 13:30;kwsutter;Resolved in both trunk and the 1.0.x branch.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SQL FOR UPDATE OF incorrectly generated for DB2/NT SQL0816,OPENJPA-360,12377828,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,08/Sep/07 19:35,09/Mar/10 18:32,14/Mar/19 03:02,18/Sep/07 16:12,1.0.0,1.0.1,1.1.0,,,,,,,1.0.1,1.1.0,,,,sql,,,,,,0,,"""FOR UPDATE OF"" string incorrectly generated for DB2 UDB version 8.1 or earlier and DB2 ISeries V5R3 or earlier.
Should generate ""FOR UPDATE""",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-09-12 16:39:36.741,,,no_permission,,,,,,,,,,,160683,,,Tue Sep 18 16:12:47 UTC 2007,,,,,,,0|i0z6o7:,203383,,,,,,,,08/Sep/07 20:21;fancy;Fix UPDATE OF clause for DB2 UDB Version 8.1 or earlier and DB2 Iseries V5R3 or earlier.,11/Sep/07 18:10;fancy;This problem is fixed in svn commit: r574464 - in /openjpa/trunk: and svn commit: r574653 - in /openjpa/branches/1.0.x. ,"12/Sep/07 16:39;kwsutter;Temporarily re-opening this issue to clean up the testcases to remove the dependency on DB2 drivers...  Our unit tests need to run with Derby only.  If we want to run with DB2, then a different profile should be defined and specified.   I have made the changes and am currently testing them with Derby.  I'll commit the changes shortly.",12/Sep/07 16:48;kwsutter;Testcase updates resolved via SVN revision r575008 (both releases).,"12/Sep/07 19:42;fancy;As Patick pointed out that transient variable should not be used in DBDictionary, because dict is used by cuncurrent threads.
",12/Sep/07 19:44;fancy;Use ThreadLocal for concurrent threads.,"12/Sep/07 21:25;fancy;transient Select sel is removed.
fix committed under revision 575080.",18/Sep/07 16:12;kwsutter;Resolved in both 1.0.1 and 1.1.0 streams.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OptimisticLockException NOT thrown for entity using Timestamp Version when update from concurrent persistence contexts,OPENJPA-359,12377801,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,08/Sep/07 05:03,27/Feb/08 20:30,14/Mar/19 03:02,26/Feb/08 16:53,1.0.0,,,,,,,,,1.1.0,,,,,jdbc,,,,,,0,,"We ran a test using Timestamp as the version field in an entity, the following (pseudo) test failed when an OptimisticLockException is expected:

    em1.persist( e0(pk1) );

    e1 = em1.find(pk1);
    e2 = em2.find(pk1);

    e1.setAttr( ""new1"");
    e2.setAttr( ""new2"");

    em1.merge( e1 );
    em2.merge( e2 );    <<<< Expect an OptimisticLockException

The cause of this problem is because the TimestampVersionStrategy.nextVersion returns a java.sql.Timestamp(System.currentTimeMillis()); In the Wintel environment, the currentTimeMillis() only has approximately 15ms resolution. When 2 subsequent Timestamp version objects are requested within this 15ms interval, both has the same version value. Therefore the em2.merge does not detected the versions difference between o1 and o2, hence no exception is thrown.

Due to this behavior, the same test case may failed intermittenly depends on the currentTimeMillis() resolution and the time when a timestamp version is created.  From some preliminary tests, the resolution for  wintel, linux and z/os are about 15ms, 2ms and 2ms respectively.
    
",WIntel 32 ,,,,,,,,,,,,,,,,,,,,,24/Feb/08 04:05;allee8285;OPENJPA-359.1.patch;https://issues.apache.org/jira/secure/attachment/12376329/OPENJPA-359.1.patch,25/Feb/08 00:34;allee8285;OPENJPA-359.2.patch;https://issues.apache.org/jira/secure/attachment/12376380/OPENJPA-359.2.patch,08/Sep/07 05:21;allee8285;OPENJPA-359.patch;https://issues.apache.org/jira/secure/attachment/12365390/OPENJPA-359.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-09-08 18:02:39.832,,,no_permission,,,,,,,,,,,160682,,,Mon Feb 25 00:34:49 UTC 2008,,,,,,,0|i1dq3r:,288326,,,,,,,,08/Sep/07 05:21;allee8285;The solution is to create a java.sql.Timestamp based on the current time plus a unique counter within the same current time windows. Therefore the timestamp is not truely a time based timestamp but a unique timestamp for versioning purpose.,"08/Sep/07 18:02;pcl;We need to also consider clustered environments -- this patch doesn't do much for such environments. Of course, in a clustered environment, timestamp-based checks rely on clock synchronization, which is a hard problem.

I've always seen this as an insoluble problem with timestamp versioning, and have just worked around it by putting sleeps in test cases that test concurrency and timestamp versioning.

The proposed change adds a synchronized block, which seems like a potential bottleneck; if we decide that we care about this problem, I think I'd rather see us just put a Thread.currentThread().wait(<15 | 2>) call into the versioning code. Note, of course, that this still won't solve the problem in a clustered environment.","08/Sep/07 19:48;allee8285;>> We need to also consider clustered environments -- this patch doesn't do much for such environments. Of course, in a clustered environment, timestamp-based checks rely on clock synchronization, which is a hard problem. 

When you say clustered environment, do you mean multiple appl servers (in a cluster) accessing the same db server? This patch refines the time stamp granularity and improves version uniqueness. It does not degrade the current implementation and will exhibit the exact behavior as far as ""clustering"" is concern.  I agree with you that Versioning support in cluster environment is a hard problem and it is not only for Timestamp but any type. Until there is a central ""server"" that hands out unique version id, it will remain to be a insoluble problem.

>> The proposed change adds a synchronized block, which seems like a potential bottleneck; 
The synchronized block is required to make sure the counter is updated correctly in multi-thread scenario. This follows a similar pattern as implemented in the UUIDGenerator.  I have considered the bottleneck condition and scaled down the instructions absolutely needed in the synchronized block to improve concurrency.

>> I think I'd rather see us just put a Thread.currentThread().wait(<15 | 2>) call into the versioning code.
Do you mean ""Thread.currentThread().sleep(<15|2>)"" ?  
First, one has to determine the value to sleep. This value varies a lot and depends on the hardware platform and realistically should be determine at run-time.  Second, sleeping for 2ms per se is an artificial performance and concurrency inhibitors which I don't recommend.

We may be able to figure out other means to avoid the synchronized block but still get the same result.

>> Note, of course, that this still won't solve the problem in a clustered environment.
Distributed system synchronization is always a hard problem to solve.  The initial time stamp value is based on System.currentTimeMillis(), this means the first problem is to make sure this base value is synchronized between all servers in the cluster. The second problem is the increment value needs to be either synchronized and/or common between all servers.   

If we take a step back and say using Timestamp as version id is inherently problematic (the same argument as using float as primary key) in cluster environment, all we can do is to provide an implementation that can improve the possibility NOT to run into a problem condition, as we already have encountered in our test scenario.

Albert Lee.","10/Sep/07 05:41;pcl;> When you say clustered environment, do you mean multiple appl servers 
> (in a cluster) accessing the same db server? 

Yes.

> I agree with you that Versioning support in cluster environment is a hard 
> problem and it is not only for Timestamp but any type. Until there is a central
> ""server"" that hands out unique version id, it will remain to be a insoluble problem.

I don't understand. IMO, versioning in a clustered environment is a trivial problem 
when using the monotonically-incrementing number approach. The only ""problems""
arise when using timestamps, and arguably, these aren't problems, but rather just
limitations imposed by the timing needs of the application.

FTR, with a monotonically-incrementing version number, the database itself acts
as the central server.

> sleeping for 2ms per se is an artificial performance and concurrency inhibitors 
> which I don't recommend. 

By my definitions, sleeping for 2ms does incur a performance cost, but does not 
incur any concurrency problem at all. In fact, doing so avoids the concurrency 
problem introduced by the new synchronized block.","10/Sep/07 14:54;allee8285;> I don't understand. IMO, versioning in a clustered environment is a trivial problem
when using the monotonically-incrementing number approach. The only ""problems""
arise when using timestamps, and arguably, these aren't problems, but rather just
limitations imposed by the timing needs of the application.
>
> FTR, with a monotonically-incrementing version number, the database itself acts
as the central server. 

If the version is handed off from the db server, then I agree with you that is is a trivial problem. However in our implementation the version is handed off from an instance of the persistence provider of app server (in a cluster). E.g. 

NumberVersionStrategy.nextVersion() { .... return Numbers.valueOf(((Number) version).intValue() + 1); }
TimestampVersionStrategy.netxtVersion() { return TimestampHelper.getCurrentTimestamp(); }

TImestamp is always problematic, regardless of how accurate the value is used. It also depends on how precise (how many fractional digits) the column in the db are being stored. I ran into a scenario where the Timestamp version is precise to the 100ns but the test still failed. It is because the version column in the db only holds up to ms.

> By my definitions, sleeping for 2ms does incur a performance cost, but does not
incur any concurrency problem at all. In fact, doing so avoids the concurrency
problem introduced by the new synchronized block.

Sleeping in a thread to avoid duplicate time stamp only solve its own problem. What about if there are 2 threads coming in at the same time (within the 15ms time window) and asking for a new version. Without the synchronized block to hand out the next value, the time stamp version created in both threads will be same if sleep is used, which does not solve the initial problem. Even with the current suggested solution, it does not guarantee to solve the cluster scenario.","10/Sep/07 20:23;pcl;> If the version is handed off from the db server, then I agree with 
> you that is is a trivial problem. However in our implementation 
> the version is handed off from an instance of the persistence 
> provider of app server (in a cluster). E.g.
> 
> NumberVersionStrategy.nextVersion() {
>     ...
>     return Numbers.valueOf(((Number) version).intValue() + 1);
> } 

Yes, but then, the previous number is used in an UPDATE or DELETE statement. If the row being updated / deleted has been changed by a different VM, then the database will have a different version value at that time, and the update / delete statement will fail (modified row count of 0). So, while we don't fetch the number from the database, the database always contains the most-recent clean version number, and updates only get into the database when the reader had read that value.

Timestamps are more complicated, as has been discussed on this thread.

> Sleeping in a thread to avoid duplicate time stamp only solve its own problem.
> What about if there are 2 threads coming in at the same time (within the 15ms 
> time window) and asking for a new version. Without the synchronized block to 
> hand out the next value, the time stamp version created in both threads will be 
> same if sleep is used, which does not solve the initial problem. Even with the 
> current suggested solution, it does not guarantee to solve the cluster scenario.

I agree -- this entire domain is rife with problems when transactions are shorter than the resolution available. I just do not think that adding synchronization to attempt to partially fix the situation is really worth the cost in all the use cases where transactions are known to be longer than the resolution.

In any event, I understand that there is some value to what you're proposing; I just don't think that we should change our current behavior, because it's good enough for many users, and has characteristics (lack of synchronization) that is advantageous over the incremental improvement that you're suggesting. So, I could see room for a new versioning strategy or some sort of option to configure how the timestamp behavior works.","10/Sep/07 22:28;allee8285;Patrick,

I understand your concern of the proposed changed. 

I'll continue to find other implementation that does not require a synchronized block plus improving granularity of the version value (time-wise).

Thanks.","10/Sep/07 23:06;pcl;One approach might be to just create an implementation that uses System.nanoTime(). This would only work in 1.5 environments, but that might be good enough.

An easy way to do this would be to make a new abstract superclass of TimestampVersionStrategy, and two implementations for providing a timestamp: one that uses the nano calls, and one that uses the milli calls. For extra credit, you could even make the Configuration framework choose which to use by default based on the value of JavaVersions.VERSION.","24/Feb/08 04:03;allee8285;Attached is an alternative implementation of the nano precision timestamp versioning. This is based on the JRE 1.5 System.nanoTime() support. It does not use synchronization block and should be thread-safe.

A new NanoPrecisionTimestampVersionStrategy is created using alias ""nano-timestamp"". This is the default date/timestamp version strategy if Java version >= 5.

Due to the JRE 1.4 compilation requirement in the maven build process, the new TimestampHelper class in the openjpa-persistence module uses Reflection to invoke System.nanoTime() and TimeStamp.setNanos() methods.  If there is other alternative to get around the 1.4 maven compilation problem, I would prefer to call these methods directly but I don't have a good solution other than using Reflection. Suggestion is welcome.

I'll wait until EOD Monday to commit this change.

Thanks,
Albert Lee.",24/Feb/08 04:05;allee8285;Attached again and grant ASF license.,"24/Feb/08 08:12;pcl;We could get rid of at least some of the reflection, and push any remaining reflection to deploy-time only, by moving the new class to the openjpa-jdbc-5 module.","25/Feb/08 00:34;allee8285;Patrick,

Thanks for the hint... I am able to get around the 1.4 compile and Reflection ""problems"" by new'ing a single instance of  TimestampHelper with an override to Timestamp5elper at runtime if run in Java 5.

Please review the current solution.

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,
Recursion Depth for Field f should be calculated w.r.t active fetch groups and not all fetch groups,OPENJPA-358,12377792,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,07/Sep/07 23:01,09/Mar/10 18:32,14/Mar/19 03:02,20/Sep/07 18:41,0.9.7,1.0.0,,,,,,,,1.0.1,1.1.0,,,,,,,,,,0,,"A field f can have multiple recursion depth specified under different fetch groups.
Give:
 f is a member of three fetch groups A,B and C with d1, d2, d3 being its recursion depth in these groups respectively.

Assertion:
if A and B are active and C is inactive then effective recursion depth of f should be max(d1,d2) and not max(d1,d2,d3).

Currently recursion depth of f does not account for the active groups and is computed over all the groups f is a member of.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-09-18 19:59:21.161,,,no_permission,,,,,,,,,,,160681,,,Tue Sep 18 19:59:21 UTC 2007,,,,,,,0|i0zb9z:,204129,,,,,,,,07/Sep/07 23:03;ppoddar@apache.org;A ,18/Sep/07 19:59;mikedd;Is this fix complete in trunk? If so we should probably get the changes merged into 1.0.x. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Use case where FetchGroup A includes FecthGroup B is not honoured by fetch operations,OPENJPA-357,12377791,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,07/Sep/07 22:56,09/Mar/10 18:32,14/Mar/19 03:02,20/Sep/07 18:41,0.9.7,1.0.0,,,,,,,,1.0.1,1.1.0,,,,,,,,,,0,,"Given:
Fetch group A contains {x,y}
Fetch group B contains {z}.
Fetch group A includes Fetch group B

Assertions:
1. Any fetch operation with fetch group A should fetch {x,y,z}.
2. Any fetch operation with fetch group B should fetch {z}.

Currently, 
Assertion #2 fails. 
",,,,,,,,,,,,,,,,OPENJPA-358,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-09-18 19:58:37.857,,,no_permission,,,,,,,,,,,160680,,,Sat Nov 03 05:42:03 UTC 2007,,,,,,,0|i0z9z3:,203918,,,,,,,,"08/Sep/07 19:23;ppoddar@apache.org;First attempt to fix this and related OPENJPA-358 
is SVN revision 573750
http://svn.apache.org/viewvc?rev=573750&view=rev 

Verified against the current test corpus and Teresa Kan's test cases.

To Do: Write more test cases or integrate Teresa's cases.",18/Sep/07 19:58;mikedd;Is this fix complete in trunk? If so we should merge the changes into 1.0.x. ,"03/Nov/07 05:42;tckan; *private* *boolean* includes(FieldMetaData fmd) {
   String fmdName = fmd.getFullName(*false*);
*   if* ((fmd.isInDefaultFetchGroup() && hasFetchGroup(FetchGroup.*
NAME_DEFAULT*))|| hasFetchGroup(FetchGroup.*NAME_ALL*)


*return* *true*;

// check any LoadFetchGroup associates with this field. We need to

// include this LoadFetchGroup for fetch

String[] fgs = fmd.getCustomFetchGroups();

*for* (*int* i = 0; i < fgs.length; i++) {

*if* (hasFetchGroup(fgs[i])) {

String fg = fmd.getLoadFetchGroup(); //kan

*if* (fg != *null*) { //kan

*if* (!hasFetchGroup(fg)) { //kan

addFetchGroup(fg); //kan

}

}

*return* *true*;

}

}

*return* *false*;

}


On 9/8/07, Pinaki Poddar (JIRA) <jira@apache.org> wrote:
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DB2 requires CASTs when parameters appear in SELECT clause,OPENJPA-356,12377780,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,07/Sep/07 19:26,09/Mar/10 18:32,14/Mar/19 03:02,07/Sep/07 19:27,0.9.0,0.9.6,0.9.7,1.0.0,,,,,,1.0.1,1.1.0,,,,jdbc,,,,,,0,,"When executing a query that selects a literal value, OpenJPA converts the literal into a parameter in the SQL SELECT clause. In DB2, such parameters must be CAST to the appropriate type.

Note that this is not reproducible via OpenJPA's JPA bindings, as JPQL does not allow literals in the SELECT clause. However, the OpenJPA query parse trees do allow this syntax, and Kodo's JDO bindings allow such constructs.",Kodo JDO,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160679,,,2007-09-07 19:26:39.0,,,,,,,0|i0z6xj:,203425,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA Log4J factory incorrectly handles logging level,OPENJPA-355,12377735,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,clr,aco,aco,07/Sep/07 07:41,09/Mar/10 18:32,14/Mar/19 03:02,07/Sep/07 18:11,1.0.0,,,,,,,,,1.0.1,1.1.0,,,,logging,,,,,,0,,"Setting the log4j level to DEBUG, is unable to display INFO, WARN or higher level logging level.
",,,,,,,,,,,,,,,,,,,,,,07/Sep/07 07:43;aco;openjpa-355-trunk.patch;https://issues.apache.org/jira/secure/attachment/12365328/openjpa-355-trunk.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-09-07 18:11:17.27,,,no_permission,,,,,,,,,,,160678,,,Fri Sep 07 20:52:57 UTC 2007,,,,,,,0|i1dq3z:,288327,,,,,,,,"07/Sep/07 07:43;aco;Attach is a patch to fix the issue.

Either use _log.isEnabledFor(Level.FATAL) (in the patch)

or swap the comparison. (i.e. Level.WARN >= _log.getEffectiveLevel().toInt() )

Either one should work I think. :)","07/Sep/07 18:11;clr;svn commit 
Sending        openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log4JLogFactory.java
Transmitting file data .
Committed revision 573653.
",07/Sep/07 20:52;clr;Remove 1.1.0 as an affected version.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DB2 casts might not incorporate VARCHAR lengths often enough,OPENJPA-354,12377707,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,06/Sep/07 22:29,09/Mar/10 18:32,14/Mar/19 03:02,24/Mar/09 13:03,0.9.0,0.9.6,0.9.7,1.0.0,,,,,,1.1.0,,,,,,,,,,,0,,"Based on code inspection, it looks like OpenJPA might not be including VARCHAR lengths often enough.",,,,,,,,,,,,,,,,,,,,,,06/Sep/07 22:30;pcl;OPENJPA-354.patch;https://issues.apache.org/jira/secure/attachment/12365298/OPENJPA-354.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-03-24 13:03:09.591,,,no_permission,,,,,,,,,,,160677,,,Tue Mar 24 13:03:09 UTC 2009,,,,,,,0|i0z9lj:,203857,,,,,,,,"24/Mar/09 13:03;bjreed;I've looked through the patch and it looks like this code is currently included.  The best I can tell, half of the patch was included for 1.0.1 and the other half was included in 1.1.0.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Character discriminators are not converted correctly if storeCharsAsNumbers = true,OPENJPA-353,12377703,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,06/Sep/07 21:48,24/Sep/07 15:59,14/Mar/19 03:02,18/Sep/07 15:31,1.0.0,,,,,,,,,1.0.1,1.1.0,,,,,,,,,,0,,"If an application uses DiscriminatorType.CHAR and storeCharsAsNumbers is set to true in the DBDictionary they'll see an error similar to this one when the row is fetched from the database. 

Caused by: java.lang.ClassNotFoundException: Could not map disciminator value ""99"" to any known subclasses of the requested class ""org.apache.openjpa.persistence.discriminator.CharAbstractEntity"" (known discriminator values: [C, R, c]).
        at org.apache.openjpa.jdbc.meta.strats.ValueMapDiscriminatorStrategy.getClass(ValueMapDiscriminatorStrategy.java:98)
        at org.apache.openjpa.jdbc.meta.strats.InValueDiscriminatorStrategy.getClass(InValueDiscriminatorStrategy.java:117)
        at org.apache.openjpa.jdbc.meta.Discriminator.getClass(Discriminator.java:398)
        at org.apache.openjpa.jdbc.meta.strats.SuperclassDiscriminatorStrategy.getClass(SuperclassDiscriminatorStrategy.java:63)
        at org.apache.openjpa.jdbc.meta.Discriminator.getClass(Discriminator.java:398)
        at org.apache.openjpa.jdbc.meta.strats.SuperclassDiscriminatorStrategy.getClass(SuperclassDiscriminatorStrategy.java:63)
        at org.apache.openjpa.jdbc.meta.Discriminator.getClass(Discriminator.java:398)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:320)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:255)
        ... 34 more

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160676,,,Tue Sep 18 15:31:04 UTC 2007,,,,,,,0|i1dq47:,288328,,,,,,,,18/Sep/07 15:31;mikedd;Fixed in current dev streams. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
No object inserted if entity only contain ID attribute and set to IDENTITY,OPENJPA-349,12377533,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,supermaneddie,supermaneddie,05/Sep/07 09:09,09/Mar/10 18:32,14/Mar/19 03:02,16/Jul/08 03:57,1.0.0,,,,,,,,,1.2.0,,,,,kernel,,,,,,0,,"If the entity only contains the ID column and the generated strategy set to IDENTITY, then when saving this object, then will not insert record to database.

@Entity
@Table(name=""A"")
public class A {
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    public int id;
}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160672,,,2007-09-05 09:09:50.0,,,,,,,0|i0zbdb:,204144,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Performance Issue with Lazy Loaded Foreign Keys,OPENJPA-347,12377191,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,30/Aug/07 21:18,09/Mar/10 18:32,14/Mar/19 03:02,31/Aug/07 20:11,1.0.0,,,,,,,,,1.0.1,1.1.0,,,,kernel,,,,,,0,,"We're hitting a performance regression with the latest OpenJPA code when specifying LAZY fetch type with OneToOne and ManyToOne relationships.  It seems that we're loading more than just the foreign key (normal LAZY behavior) and processing them like an EAGER fetch type.  Here's some example SQL codes:

Previous version of OpenJPA generates the following:

SELECT t0.PROFILE_USERID, t0.BALANCE, t0.CREATIONDATE, t0.LASTLOGIN, t0.LOGINCOUNT, t0.LOGOUTCOUNT, t0.OPENBALANCE FROM ACCOUNTEJB t0 WHERE t0.ACCOUNTID = ?  optimize for 1 row

With latest OpenJPA, we see the following being generated:

SELECT t1.USERID, t2.ACCOUNTID, t2.BALANCE, t2.CREATIONDATE, t2.LASTLOGIN, t2.LOGINCOUNT, t2.LOGOUTCOUNT, t2.OPENBALANCE, t1.ADDRESS, t1.CREDITCARD, t1.EMAIL, t1.FULLNAME, t1.PASSWD, t0.BA
LANCE, t0.CREATIONDATE, t0.LASTLOGIN, t0.LOGINCOUNT, t0.LOGOUTCOUNT, t0.OPENBALANCE FROM ACCOUNTEJB t0 LEFT OUTER JOIN ACCOUNTPROFILEEJB t1 ON t0.PROFILE_USERID = t1.USERID LEFT OUTER JOIN ACCOUNTEJB t2 ON t1.USERID = t2.PROFI
LE_USERID WHERE t0.ACCOUNTID = ?  optimize for 1 row

It looks like the regression is due to the introduction of the fix I provided for OPENJPA-281 where the @Basic types were not eagerly being loaded by default.  In this test scenario, the field types used for the foreign keys were Serializable.  Thus, the test in isInDefaultFetchGroup() would incorrectly put the whole relationship in the default fetch group (making it eager).

As I was debugging this problem, I learned that OpenJPA loads the foreign key fields eagerly regardless of the setting of the LAZY fetch type.  Our customers would most likely expect this behavior and it doesn't cost anything (or next to nothing) to load these additional fields.  It just becomes a problem when we traverse the relationship when it's marked LAZY...

It looks like the problem can be easily resolved by just moving my check for Serializable in isInDefaultFetchGroup() to just the JavaTypes.OBJECT type and not the JavaTypes.PC type.  This makes more sense since the intent of the @Basic eager change was for basic simple attribute types, not relationships.  And, foreign key fields would fall into the JavaTypes.PC (Persistence Capable) type.

We're testing this theory with the performance run right now.  So far, it looks good.  And, I have modified the TestEagerBidiSQL test to test for this condition (the current versions of BidiChild and BidiParent were not Serializable and, thus, we didn't hit this problem when I did the fix for OPENJPA-281).

If anybody has any further thoughts on this problem, please post.  Thanks.

Kevin",,,,,,,,,,,,,,,,,,,,,,30/Aug/07 22:05;kwsutter;OPENJPA-347.patch;https://issues.apache.org/jira/secure/attachment/12364850/OPENJPA-347.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-10-04 14:26:43.68,,,no_permission,,,,,,,,,,,41875,,,Thu Oct 04 14:26:43 UTC 2007,,,,,,,0|i1dq5b:,288333,,,,,,,,30/Aug/07 22:05;kwsutter;Proposed patch and testcase update for this problem.,31/Aug/07 20:11;kwsutter;Resolved for both the 1.1.0 and 1.0.1 snapshot releases.,"04/Oct/07 14:26;pcl;> OpenJPA loads the foreign key fields eagerly regardless of the setting 
> of the LAZY fetch type. Our customers would most likely expect this 
> behavior and it doesn't cost anything (or next to nothing) to load these 
> additional fields. It just becomes a problem when we traverse the 
> relationship when it's marked LAZY

Does your patch preserve this described behavior?",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PCEnhancerAgent backwards-compatibility setting overly-enables enhancement,OPENJPA-346,12377181,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,30/Aug/07 18:38,09/Mar/10 18:32,14/Mar/19 03:02,30/Aug/07 18:48,1.0.0,,,,,,,,,1.0.1,1.1.0,,,,kernel,,,,,,0,,"In OpenJPA 1.0.0, we changed a javaagent flag for clarity. However, the logic is wrong. Currently, the only way to turn off runtime enhancement is to set both the RuntimeEnhancement and the ClassLoadEnhancement flags to false; setting just one is not sufficient.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160670,,,Thu Aug 30 18:48:59 UTC 2007,,,,,,,0|i0zben:,204150,,,,,,,,30/Aug/07 18:48;pcl;Resolved in 1.0.x and trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Do not call setRollbackOnly on inactive Transactions,OPENJPA-343,12377093,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,29/Aug/07 13:15,09/Mar/10 18:32,14/Mar/19 03:02,04/Sep/07 13:23,0.9.7,1.0.0,,,,,,,,1.0.1,1.1.0,,,,kernel,,,,,,0,,"While in the middle of processing an afterCompletion invocation in BrokerImpl, an unexpected RuntimeException (IndexOutOfBoundsException) occurred within some underlying WebSphere code.  While we (OpenJPA) were attempting to clean up after that exception, we attempted to call setRollbackOnly on the current transaction.  But, since we were in the process of completing the current transaction, it is invalid to be calling setRollbackOnly and we ended up getting an IllegalStateException from the WebSphere Transaction Manager.  Due this second exception, we ended up losing track of the original exception and this became a difficult problem to diagnose.

This issue will be used to correct a couple of issues (at least):

1)  We should ensure that the transaction is active before calling
setRollbackOnly().  When an exception happens during afterCompletion 
processing, the Transaction can no longer accept setRollbackOnly 
invocations.

2)  When an unexpected exception happens like this, we should log the
exception before attempting to process the exception.  In this particular
case, we lost the original exception when we ran into the IllegalStateException
from the Transaction service.  This forced us to re-run the scenario just to
get a trace of the exception.

3)  Or, if we don't want to log the exception immediately, we need to determine why we lost the first exception in the first place and ensure that doesn't happen again.

Kevin",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-08-31 01:15:10.118,,,no_permission,,,,,,,,,,,160667,,,Tue Sep 04 13:23:10 UTC 2007,,,,,,,0|i1dq5z:,288336,,,,,,,,"30/Aug/07 22:47;kwsutter;I should clarify a couple of statements.  I mixed Transaction and Synchronization concepts in the above description.  Since we are in the afterCompletion (Synchronization) processing, the Transaction is in a ""completed"" state and can no longer accept the setRollbackOnly invocation.  Although related, Transaction and Synchronization are two separate concepts and should treated as such.

I plan to resolve issue (1) by checking for a valid transaction status before calling setRollbackOnly.  If the transaction is not in a suitable state, I will log a trace message indicating that the setRollbackOnly can not be called, but processing will continue.

Re-looking at the code, I think we are already sufficiently addressing items (2) and (3), once issue (1) is resolved.  We already have the necessary trace logging for this unexpected exception.  Granted, we didn't expect this exception and it's a ""pain"" to turn on trace for long-running scenarios, the real exception that caused the problem in the first place will now get logged due to the fix for (1).  And, since OpenJPA doesn't have the concept of a first-failure-data-capture logging facility, it would get cumbersome to log every unexpected exception.

So, my plans at this point are to just resolve the first issue (1) with ensuring that we do not attempt to call setRollbackOnly when the transaction can not accept it.  Comments welcome.

Kevin","31/Aug/07 01:15;clr;I agree that 1) not calling setRollbackOnly during afterCompletion is correct.

But when 2) an unexpected exception occurs during afterCompletion, like a NullPointerException, it seems that we should log the exception. Even though it's during afterCompletion, we shouldn't just swallow it. Of course, fixing 1) means that 2) can't be reliably reproduced. 

I'm not clear on what 3) means. 

> I plan to resolve issue (1) by checking for a valid transaction status before calling setRollbackOnly. If the transaction is not in a suitable state, I will log a trace message indicating that the setRollbackOnly can not be called, but processing will continue. 

I guess the issue is whether this is a trace scenario or a more serious problem that should be reported back. We are still in commit as far as the application is concerned and it's not obvious to me that this is a successful transaction. I'd think we should cause the outer level transaction to fail with a SystemException because the application handling is not consistent (the cache, for example, might be in an inconsistent state). If the application thinks everything is aok, then I think we have a problem.

Craig","31/Aug/07 02:40;kwsutter;> I guess the issue is whether this is a trace scenario or a more serious problem that should be reported back. We are still in commit as far as the application is concerned and it's not obvious to me that this is a successful transaction. I'd think we should cause the outer level transaction to fail with a SystemException because the application handling is not consistent (the cache, for example, might be in an inconsistent state). If the application thinks everything is aok, then I think we have a problem. 

When we get to this spot, the Transaction is complete.  All of the prepares and commits and/or rollbacks have completed.  The afterCompletion call is just a convenience callback to let those resources that have registered for Synchronization that the transaction has completed.  The parameter on afterCompletion lets you know whether the transaction committed or rolled back.  So, there is nothing to ""fail"".  

And, actually, the IllegalStateException that I mentioned about we get when we attempt to call setRollbackOnly is only logged by the TM.  It is not thrown back to the caller since there is nothing to fail.  So, the application actually continues running without a problem.  The exception just gets logged so that we know that something isn't quite right, but everything still completed ""okay"".","31/Aug/07 03:40;clr;> When we get to this spot, the Transaction is complete. All of the prepares and commits and/or rollbacks have completed. The afterCompletion call is just a convenience callback to let those resources that have registered for Synchronization that the transaction has completed. The parameter on afterCompletion lets you know whether the transaction committed or rolled back. So, there is nothing to ""fail"". 

If there's nothing important for OpenJPA to do in afterCompletion, then it should simply return and there cannot be an exception. If there is something important to do, then it's important that it complete.

Is this not true?","31/Aug/07 03:50;pcl;I'm generally against the log-and-throw pattern, whenever it's possible to avoid it. When it is necessary, I think that it's important that the log only happen at the trace level, so that we aren't unnecessarily repeating exception printouts.

This conversation seems to have diverged a bit from suggesting a log-and-throw, but I figured it was worth mentioning anyways.","31/Aug/07 16:01;kwsutter;> If there's nothing important for OpenJPA to do in afterCompletion, then it should simply return and there cannot be an exception. If there is something important to do, then it's important that it complete.

> Is this not true?

Yes, that is true.  I was typing before thinking.  :-)  Our afterCompletion processing does do some ""real work"" with ending the transaction, detaching entities, etc.  So, when an exception happens in this code path, it could mean that some of our cleanup didn't complete.  We do log any exceptions that happen during this path via trace statements and the exception does get re-thrown.  It may get wrapped in a suitable PersistenceException, but it will get sent back.

But, to get back to what I was attempting to explain...  The transaction itself is already completed.  There is nothing we can do at this point to revert the state of that transaction.  It was already either committed or rolled back by the time the afterCompletion method is invoked.  The beforeCompletion and afterCompletion methods on the Synchronization interface are just convenient listener methods.  Any exceptions that may happen due to these calls will not affect the outcome of the Transaction (since it is already complete).  And, from my experience, the Synchronization implementation will not stop processing just because an exception happens.  They will log the condition (as we have seen) and then continue processing.

Hope this helps.
Kevin","02/Sep/07 17:39;clr;> So, when an exception happens in this code path, it could mean that some of our cleanup didn't complete. We do log any exceptions that happen during this path via trace statements and the exception does get re-thrown.

> There is nothing we can do at this point to revert the state of that transaction. It was already either committed or rolled back by the time the afterCompletion method is invoked.

I agree.

> The parameter on afterCompletion lets you know whether the transaction committed or rolled back. So, there is nothing to ""fail"". 

Here's where we might disagree. The user-level commit should fail so the user doesn't think everything is ok as far as the cache is concerned. I understand that the database transaction is complete and whatever changes have been made there are permanent. But the EntityManager is possibly corrupted.

Craig","04/Sep/07 13:21;kwsutter;> Here's where we might disagree. The user-level commit should fail so the user doesn't think everything is ok as far as the cache is concerned. I understand that the database transaction is complete and whatever changes have been made there are permanent. But the EntityManager is possibly corrupted.

I agree.  We are performing this ""afterCompletion"" processing as far as we can until we hit this unexpected exception.  This exception is now being logged (if trace is turned on) and the exception is returned to the caller.  Unless you are suggesting that we should possibly log-and-eat this exception and attempt to continue additional processing as if nothing has happened, I think we have done everything we can do.  If we went this log-and-eat route, it would require more more granular try-catch blocks in this path.  Not sure this is necessary processing for the unexpected (rare) case.

FYI, we are still flowing through the EntityManager with the setRollbackOnly invocation.  So, any processing in the EntityManager and/or Broker that would be triggered because of the setRollbackOnly call will still happen.  It's just the explicit setRollbackOnly call on the Transaction object itself that was conditionally skipped if the Transaction was not ""active"".  Just wanted to clarify that aspect of the change.

If there are still concerns about the general exception processing in the OpenJPA code base, then maybe we should open a separate JIRA issue or at least start a [DISCUSSION] topic on our dev mailing list.  The original intent of this Issue was to not call the setRollbackOnly method when the Transaction is not in a state to accept the invocation.  I think that issue has been resolved.  But, maybe there are still concerns about the general exception processing within OpenJPA...

Thanks,
Kevin",04/Sep/07 13:23;kwsutter;Resolved in trunk (1.1.0) via svn revision #571523.,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@UniqueConstraint and corresponding XML ignored,OPENJPA-340,12377008,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,28/Aug/07 15:40,09/Mar/10 18:32,14/Mar/19 03:02,16/Jul/08 02:47,,,,,,,,,,1.2.0,,,,,,,,,,,1,,"OpenJPA ignores @UniqueConstraint annotations (and the corresponding XML declaration) when generating database schemas. This should be rectified.

A workaround is to set the -ignoreErrors flag to true when running mappingtool, which will let schema creation continue despite the error.",,,,,,,,,,,,,,,,OPENJPA-1165,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-08-28 15:55:34.322,,,no_permission,,,,,,,,,,,97277,,,Mon Jun 02 03:37:07 UTC 2008,,,,,,,0|i0z1vz:,202608,,,,,,,,"28/Aug/07 15:55;ppoddar@apache.org;Currently partial support exists. Unique constraints can be specified at @Table annotation is processed.

For example, given 
  
@Entity
@Table(name=""Person"",uniqueConstraints=@UniqueConstraint(columnNames={""first"",""last""}))
public class Person {
	@Id
	private long id;
	private String first;
	private String last;
}

will generate following table schema
CREATE TABLE Person (id BIGINT NOT NULL, first VARCHAR(255), last VARCHAR(255), PRIMARY KEY (id), UNIQUE (first, last))
",31/Jan/08 21:55;hazen;looks like @JoinTable(uniqueConstraints=...) is not supported either.,"02/Jun/08 03:37;amy;looks like only @Table(uniqueConstraints=@UniqueConstraint(....)) is supported.
@SecondaryTable, @JoinTable, and @TableGenerator need be supported.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java 2 security Access denied in File.toURL() call,OPENJPA-339,12376942,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,27/Aug/07 17:21,30/Oct/07 14:44,14/Mar/19 03:02,17/Sep/07 22:25,0.9.7,,,,,,,,,1.0.1,1.1.0,,,,lib,,,,,,0,,"Encounter the following access denial exception when Java 2 security is enabled in application server environment.

File.toURL() is not documented which requires security check, however indirectly, the File.isDirectory() is invoked, which required security permission.

Exception = java.security.AccessControlException
Source = com.ibm.ws.security.core.SecurityManager
probeid = 180
Stack Dump = java.security.AccessControlException: Access denied (java.io.FilePermission C:\WAS3\profiles\AppSrv01\installedApps\javajoeNode01Cell\EJB3JPACallbackBeanApp.ear\EJB3JPACallbackWebApp.war\WEB-INF\classes\suite\r70\base\jpaspec\callback\entities\AbstractCallbackEntity.class read)
        at java.security.AccessController.checkPermission(AccessController.java:104)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:547)
        at com.ibm.ws.security.core.SecurityManager.checkPermission(SecurityManager.java:189)
        at java.lang.SecurityManager.checkRead(SecurityManager.java:886)
        at java.io.File.isDirectory(File.java:747)
        at java.io.File.toURL(File.java:620)
        at org.apache.openjpa.lib.meta.FileMetaDataIterator.next(FileMetaDataIterator.java:114)
        at org.apache.openjpa.lib.meta.ClassArgParser.mapTypeNames(ClassArgParser.java:283)
        at org.apache.openjpa.meta.AbstractCFMetaDataFactory.scan(AbstractCFMetaDataFactory.java:778)
        at org.apache.openjpa.meta.AbstractCFMetaDataFactory.parsePersistentTypeNames(AbstractCFMetaDataFactory.java:637)
        at org.apache.openjpa.meta.AbstractCFMetaDataFactory.getPersistentTypeNames(AbstractCFMetaDataFactory.java:605)
        at org.apache.openjpa.meta.MetaDataRepository.getPersistentTypeNames(MetaDataRepository.java:1214)
        at org.apache.openjpa.meta.MetaDataRepository.loadPersistentTypes(MetaDataRepository.java:1231)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.loadPersistentTypes(AbstractBrokerFactory.java:245)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:197)
        at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)
        at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:190)
        at com.ibm.ws.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:37)
        at com.ibm.ws.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:28)
",,,,,,,,,,,,,,,,,,,,,,31/Aug/07 14:45;allee8285;OPENJPA-339.1.patch;https://issues.apache.org/jira/secure/attachment/12364894/OPENJPA-339.1.patch,27/Aug/07 21:19;allee8285;OPENJPA-339.patch;https://issues.apache.org/jira/secure/attachment/12364641/OPENJPA-339.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-08-29 13:07:51.281,,,no_permission,,,,,,,,,,,160664,,,Mon Sep 17 22:25:31 UTC 2007,,,,,,,0|i1dq6n:,288339,,,,,,,,"27/Aug/07 21:04;allee8285;Find another failing security scenario that needs to fix:

Exception = java.security.AccessControlException
Source = com.ibm.ws.security.core.SecurityManager
probeid = 180
Stack Dump = java.security.AccessControlException: Access denied (java.lang.RuntimePermission getClassLoader)
        at java.security.AccessController.checkPermission(AccessController.java:104)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:547)
        at com.ibm.ws.security.core.SecurityManager.checkPermission(SecurityManager.java:189)
        at java.lang.Thread.getContextClassLoader(Thread.java:488)
        at serp.bytecode.Project.loadClass(Project.java:116)
        at serp.bytecode.Project.loadClass(Project.java:86)
        at org.apache.openjpa.util.ProxyManagerImpl.generateProxyBeanBytecode(ProxyManagerImpl.java:629)
        at org.apache.openjpa.util.ProxyManagerImpl.getFactoryProxyBean(ProxyManagerImpl.java:452)
        at org.apache.openjpa.util.ProxyManagerImpl.newCustomProxy(ProxyManagerImpl.java:311)
        at org.apache.openjpa.kernel.SingleFieldManager.proxy(SingleFieldManager.java:126)
        at org.apache.openjpa.kernel.StateManagerImpl.storeObjectField(StateManagerImpl.java:2413)
        at org.apache.openjpa.kernel.StateManagerImpl.storeField(StateManagerImpl.java:2510)
        at org.apache.openjpa.kernel.StateManagerImpl.storeField(StateManagerImpl.java:769)
        at org.apache.openjpa.kernel.StateManagerImpl.store(StateManagerImpl.java:765)
        at org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy.load(HandlerFieldStrategy.java:174)
        at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:789)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:833)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:785)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:336)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:255)
        at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
        at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
        at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:878)
        at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:836)
        at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:753)
        at org.apache.openjpa.kernel.DelegatingBroker.find(DelegatingBroker.java:172)
        at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:349)
        at suite.r70.acommon.servicesupport.AbstractServiceClass.findIEntity(AbstractServiceClass.java:111)
",27/Aug/07 21:19;allee8285;Add corrective doPriv() in appropriate call-outs.,29/Aug/07 13:07;kwsutter;Resolved via svn revision #570288.,29/Aug/07 23:12;allee8285;More testing discovers other paths in ProxyManagerImpl causes other access violations.,"30/Aug/07 22:28;allee8285;The other path which caused security violations are:

Stack Dump = java.security.AccessControlException: Access denied (java.lang.RuntimePermission getClassLoader)
        at java.security.AccessController.checkPermission(AccessController.java:104)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:547)
        at com.ibm.ws.security.core.SecurityManager.checkPermission(SecurityManager.java:189)
        at java.lang.Thread.getContextClassLoader(Thread.java:488)
        at serp.bytecode.BCClass.getClassLoader(BCClass.java:1670)
        at serp.bytecode.BCMember.getClassLoader(BCMember.java:326)
        at serp.bytecode.Attribute.getClassLoader(Attribute.java:85)
        at serp.bytecode.Instruction.getClassLoader(Instruction.java:141)
        at serp.bytecode.TypedInstruction.getType(TypedInstruction.java:76)
        at serp.bytecode.Code.calculateMaxLocals(Code.java:191)
        at org.apache.openjpa.util.ProxyManagerImpl.addProxyBeanMethods(ProxyManagerImpl.java:1173)
        at org.apache.openjpa.util.ProxyManagerImpl.generateProxyBeanBytecode(ProxyManagerImpl.java:640)
        at org.apache.openjpa.util.ProxyManagerImpl.getFactoryProxyBean(ProxyManagerImpl.java:452)
        at org.apache.openjpa.util.ProxyManagerImpl.newCustomProxy(ProxyManagerImpl.java:311)
        at org.apache.openjpa.kernel.SingleFieldManager.proxy(SingleFieldManager.java:129)
        at org.apache.openjpa.kernel.StateManagerImpl.proxyFields(StateManagerImpl.java:2721)
        at org.apache.openjpa.kernel.PNonTransState.initialize(PNonTransState.java:44)
        at org.apache.openjpa.kernel.StateManagerImpl.setPCState(StateManagerImpl.java:216)
        at org.apache.openjpa.kernel.StateManagerImpl.commit(StateManagerImpl.java:1005)
        at org.apache.openjpa.kernel.BrokerImpl.endTransaction(BrokerImpl.java:2177)
        at org.apache.openjpa.kernel.BrokerImpl.afterCompletion(BrokerImpl.java:1782)
        at com.ibm.ws.uow.ComponentContextSynchronizationWrapper.afterCompletion(ComponentContextSynchronizationWrapper.java:84)
        at com.ibm.ws.Transaction.JTA.RegisteredSyncs.distributeAfter(RegisteredSyncs.java:424)
        at com.ibm.ws.Transaction.JTA.TransactionImpl.distributeAfter(TransactionImpl.java:3883)
        at com.ibm.ws.Transaction.JTA.TransactionImpl.postCompletion(TransactionImpl.java:3862)
        at com.ibm.ws.Transaction.JTA.TransactionImpl.commitXAResources(TransactionImpl.java:2518)
        at com.ibm.ws.Transaction.JTA.TransactionImpl.stage1CommitProcessing(TransactionImpl.java:1635)
        at com.ibm.ws.Transaction.JTA.TransactionImpl.processCommit(TransactionImpl.java:1595)
        at com.ibm.ws.Transaction.JTA.TransactionImpl.commit(TransactionImpl.java:1530)
        at com.ibm.ws.Transaction.JTA.TranManagerImpl.commit(TranManagerImpl.java:237)
        at com.ibm.ws.Transaction.JTA.TranManagerSet.commit(TranManagerSet.java:162)
        at com.ibm.ws.Transaction.JTA.UserTransactionImpl.commit(UserTransactionImpl.java:292)
        at com.ibm.ejs.container.UserTransactionWrapper.commit(UserTransactionWrapper.java:264)
        at suite.r70.acommon.transactionservice.JTATransactionService.commitTransaction(JTATransactionService.java:39)

 and 

Caused by: java.security.AccessControlException: Access denied (java.lang.RuntimePermission modifyThreadGroup)
        at java.security.AccessController.checkPermission(AccessController.java:104)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:547)
        at com.ibm.ws.security.core.SecurityManager.checkPermission(SecurityManager.java:189)
        at com.ibm.ws.security.core.SecurityManager.checkAccess(SecurityManager.java:309)
        at java.lang.ThreadGroup.checkAccess(ThreadGroup.java:222)
        at java.lang.Thread.initialize(Thread.java:342)
        at java.lang.Thread.<init>(Thread.java:276)
        at java.lang.Thread.<init>(Thread.java:168)
        at org.apache.openjpa.datacache.DataCacheScheduler.scheduleEviction(DataCacheScheduler.java:100)
        at org.apache.openjpa.datacache.AbstractDataCache.initialize(AbstractDataCache.java:89)
        at org.apache.openjpa.datacache.ConcurrentDataCache.initialize(ConcurrentDataCache.java:91)
        at org.apache.openjpa.datacache.DataCacheManagerImpl.initialize(DataCacheManagerImpl.java:51)
        at org.apache.openjpa.conf.OpenJPAConfigurationImpl.getDataCacheManagerInstance(OpenJPAConfigurationImpl.java:602)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:181)

I have created a patch and am running more tests before posting it to this report.","31/Aug/07 14:45;allee8285;Attached patch for the 2 new permission denials.

The ""new Thread"" scenario is straight forward and needs no explaination.

For the ProxyManagerImpl case, I have in-line the new PrivilegeAction instead of putting them in J2DoPrivHelper because generateProxyBeanBytecode() is protected qualified, therefore it can not be call from an action in J2DoPrivHelper. There are also many methods being called to the Code instance in generateProxyBeanBytecode() that may potentially need the doPriv . So instead of putting many individual doPriv for Code, the doPriv is moved up to generateProxyBeanBytecode()  and this only needs one instead.
",17/Sep/07 22:25;kwsutter;Resolved in trunk (1.1.0).,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Logic in getters for entities with property access causes the PCEnhancer to hang,OPENJPA-335,12376846,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,mprudhom,mprudhom,24/Aug/07 20:58,09/Mar/10 18:32,14/Mar/19 03:02,13/Sep/07 23:24,1.0.0,,,,,,,,,1.0.1,1.1.0,,,,kernel,,,,,,0,,"If a getter had any logic in it (i.e., does not simply return the entity's member), the PCEnhancer will hang when trying to enhance it (both with build-time and run-time enhancement). This can be easily reproduced by changing /examples/hellojpa/Message.java in the OpenJPA distribution to using property access, and changing getMessage() to look like the following:

    @Basic
    public String getMessage() {
        if (Math.abs(1) == 1)
            return message;
        else
            return message;
    }

One thread dump of the hang looks like:

     [java] ""main"" prio=5 tid=0x00501830 nid=0x1804c00 runnable [0xb07fe000..0xb08000dc]
     [java]     at java.lang.Class.forName0(Native Method)
     [java]     at java.lang.Class.forName(Class.java:242)
     [java]     at serp.util.Strings.toClass(Strings.java:162)
     [java]     at serp.util.Strings.toClass(Strings.java:108)
     [java]     at serp.bytecode.TypedInstruction.getType(TypedInstruction.java:76)
     [java]     at serp.bytecode.LoadInstruction.isThis(LoadInstruction.java:164)
     [java]     at org.apache.openjpa.enhance.PCEnhancer.findField(PCEnhancer.java:718)
     [java]     at org.apache.openjpa.enhance.PCEnhancer.getReturnedField(PCEnhancer.java:665)
     [java]     at org.apache.openjpa.enhance.PCEnhancer.validateProperties(PCEnhancer.java:566)
     [java]     at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:444)
     [java]     at org.apache.openjpa.enhance.PCClassFileTransformer.transform(PCClassFileTransformer.java:134)
     [java]     at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
     [java]     at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
     [java]     at java.lang.ClassLoader.defineClass1(Native Method)
     [java]     at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
     [java]     at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
     [java]     at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
     [java]     at java.net.URLClassLoader.access$100(URLClassLoader.java:56)
     [java]     at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
     [java]     at java.security.AccessController.doPrivileged(Native Method)
     [java]     at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
     [java]     at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
     [java]     - locked <0x06a75a30> (a sun.misc.Launcher$AppClassLoader)
     [java]     at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)
     [java]     - locked <0x06a75a30> (a sun.misc.Launcher$AppClassLoader)
     [java]     at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
     [java]     at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
     [java]     - locked <0x06a75a30> (a sun.misc.Launcher$AppClassLoader)
     [java]     at java.lang.Class.forName0(Native Method)
     [java]     at java.lang.Class.forName(Class.java:242)
     [java]     at org.apache.openjpa.meta.MetaDataRepository.classForName(MetaDataRepository.java:1253)
     [java]     at org.apache.openjpa.meta.MetaDataRepository.loadPersistentTypes(MetaDataRepository.java:1241)
     [java]     - locked <0x06b14900> (a org.apache.openjpa.jdbc.meta.MappingRepository)
     [java]     at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:148)
     [java]     at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:130)
     [java]     at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:186)
     [java]     at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)
     [java]     at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:192)
     [java]     at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:145)
     [java]     at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:56)
     [java]     at hellojpa.Main.main(Main.java:43)

The bug appears to have been introduced in svn revision 560016 with the following change to PCEnhancer.findField:

-            code.next();
-            code.next();
-            code.next();
+            while (backupCount > 0) {
+                code.next();
+                backupCount--;
+            }

Reverting back to the three subsequent code.next() calls appears to fix the problem.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-09-13 23:24:23.938,,,no_permission,,,,,,,,,,,160660,,,Thu Sep 13 23:24:23 UTC 2007,,,,,,,0|i0zbg7:,204157,,,,,,,,13/Sep/07 23:24;pcl;Resolved in 1.0.x and trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Allow BigInteger and other Basic types as Primary Keys,OPENJPA-331,12376745,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,23/Aug/07 21:08,09/Mar/10 18:32,14/Mar/19 03:02,31/Jan/08 00:13,0.9.7,1.0.0,,,,,,,,1.0.2,1.1.0,,,,kernel,,,,,,0,,"Section 2.1.4 of the JPA spec outlines the requirements for a primary key (@Id):

Section 2.1.4:  A simple ( i.e., non-composite) primary key must correspond to a single persistent field or property of
the entity class. The Id annotation is used to denote a simple primary key. See section 9.1.8.

Also from Section 2.1.4 :  The primary key (or field or property of a composite primary key) should be one of the following types:
any Java primitive type; any primitive wrapper type; java.lang.String; java.util.Date;
java.sql.Date. In general, however, approximate numeric types (e.g., floating point types) should
never be used in primary keys. Entities whose primary keys use types other than these will not be portable.
If generated primary keys are used, only integral types will be portable. If java.util.Date is
used as a primary key field or property, the temporal type should be specified as DATE.

Right now, we are treating the ""should be"" statement above as ""must be"" and only allowing the specified types as primary keys.  But, the sentence in the middle of this paragraph (""Entities whose primary keys use types other than these will not be portable."") indicates that other types can also be allowed, but may not be portable.

It seems that Glassfish allows these additional Basic types as primary keys.  We should probably allow the same thing to keep up with the Jones'.

This was discussed on dev mailing list.  http://www.nabble.com/BigInteger-as-%40Id-tf4318071.html",,,,,,,,,,,,,,,,,,,,,,14/Dec/07 10:39;miro;fix-OpenJPA-331.patch;https://issues.apache.org/jira/secure/attachment/12371662/fix-OpenJPA-331.patch,20/Dec/07 07:41;miro;license-fix-OpenJPA-331-v110.patch;https://issues.apache.org/jira/secure/attachment/12372010/license-fix-OpenJPA-331-v110.patch,19/Dec/07 08:41;miro;license-fix-OpenJPA-331-v110.patch;https://issues.apache.org/jira/secure/attachment/12371933/license-fix-OpenJPA-331-v110.patch,19/Dec/07 08:40;miro;license-fix-OpenJPA-331-v110.patch;https://issues.apache.org/jira/secure/attachment/12371932/license-fix-OpenJPA-331-v110.patch,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2007-10-30 15:44:41.487,,,no_permission,,,,,,,,,,,160656,,,Thu Jan 31 00:13:48 UTC 2008,,,,,,,0|i0z1vj:,202606,,,,,,,,30/Oct/07 15:44;allee8285;Defer to next release.,"16/Dec/07 12:39;pcl;Resolved in trunk; keeping open since this probably deserves to be in 1.0.2, but I cannot apply patches to 1.0.2 on this machine due to a lame patch implementation.

The new files have a slightly different ASL license banner at the top. To the best of my non-legally-schooled knowledge, it looks right, and I'm reluctant to change someone else's license banner, but it seemed worth highlighting.","16/Dec/07 12:40;pcl;Oh, and thanks for the patch, Miro!

One more note: it looks like the automated build machine is currently offline, so this won't make it into a snapshot until it comes back online or someone manually creates a snapshot. I will not be able to debug the offline machine until late next week.","18/Dec/07 17:54;clr;Hi Miro,

Thanks for the patch! The copyright and license in the headers of the new files are an issue that I'd like you to fix and resubmit. Since the changes have already been checked in, an update to the headers and/or NOTICE.txt is all that's needed.

Please see http://cwiki.apache.org/confluence/display/openjpa/Found+a+Bug for details on the headers that are needed.

Thanks,

Craig","19/Dec/07 08:40;miro;Is that OK?
I am so sorry but I am not so friendly with License matter. If this is not OK, please fix it or exact tell me what to do.","19/Dec/07 08:41;miro;Is that OK?
I am so sorry but I am not so friendly with License matter. If this is not OK, please fix it or exact tell me what to do.","19/Dec/07 20:34;clr;Hi Miro,

Thanks, this is very close to what we need.

The license header is ok, but the copyright needs to be removed from the individual files and put into the openjpa-project/NOTICE.txt file. Something like this:

* OpenJPA includes the following software copyright 2007 Miroslav Nachev

openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java
openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java
openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigIntegerIdEntity.java
openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigDecimalIdEntity.java
openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigIntegerId.java
openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigDecimalId.java

Thanks,

Craig",20/Dec/07 07:41;miro;I hope that now everything is OK.,"29/Dec/07 22:23;clr;I've checked in the updated license information into trunk. 

I'll leave the issue open in case someone wants to apply the patch to the branch. I've got some ^M line ending issues when applying the patch to the branch.",31/Jan/08 00:13;pcl;Merged to 1.0.x line.,,,,,,,,,,,,,,,,,,,,,,,,,,,
Generic interface may cause the openjpa Reflection code to pickup the wrong getter method,OPENJPA-329,12376639,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,hlai,hlai,22/Aug/07 22:10,09/Mar/10 18:32,14/Mar/19 03:02,31/Jan/08 00:01,,,,,,,,,,1.0.2,1.1.0,,,,jpa,,,,,,0,,"The test case

	public void testFind(){
		PersistenceProviderImpl openJPA = new PersistenceProviderImpl();
		EntityManagerFactory factory = 
			openJPA.createEntityManagerFactory(""test"", ""ptp/test/issue6/persistence.xml"",
						System.getProperties() );
		
        EntityManager em = factory.createEntityManager();
        em.getTransaction().begin();
        
		String query=""select obj from T6Entity obj where obj.name=?1"";
        Query queryObject = em.createQuery(query);
        queryObject.setParameter(1, ""Mom"");
        List resultList = queryObject.getResultList();
        
        em.getTransaction().commit();
        em.close();
	}


produces the following exception

<1.0.0-SNAPSHOT-SNAPSHOT fatal user error> org.apache.openjpa.persistence.ArgumentException: Collection field ""ptp.test.issue6.T6Entity.children"" declares that it is mapped by ""ptp.test.issue6.T6Entity.parent"", but this is not a valid inverse relation.
	at org.apache.openjpa.jdbc.meta.MappingRepository.useInverseKeyMapping(MappingRepository.java:903)
	at org.apache.openjpa.jdbc.meta.MappingRepository.defaultTypeStrategy(MappingRepository.java:838)
	at org.apache.openjpa.jdbc.meta.MappingRepository.defaultStrategy(MappingRepository.java:771)
	at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:62)

public interface ITree <T extends ITree> {
	public List<T> getChildren();
	public T getParent();
}


public class T6Entity implements ITree {

	private Long id;
	T6Entity parent;
	List<T6Entity> children;

	public T6Entity getParent() {
		return parent;
	}
	public Long getId() {
		return id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public List<T6Entity> getChildren() {
		return children;
	}
	public void setChildren(List<T6Entity> children) {
		this.children = children;
	}
	public void setParent(T6Entity parent) {
		this.parent = parent;
	}
	public void addChild(T6Entity aChild) {
		if ( children == null ){
			children = new ArrayList<T6Entity>();
		}
		children.add( aChild );
		aChild.setParent(this);
	}

}


	<entity class=""T6Entity"">
		<table name=""T6Entity"" />
		<attributes>
			<id name=""id"">
				<column name=""S_ID"" />
				<generated-value strategy=""SEQUENCE"" generator=""seqGen1"" />
				<sequence-generator name=""seqGen1""	sequence-name=""SEQ_OBJECT_ID"" />
			</id>

			<many-to-one name=""parent"" fetch=""EAGER"">
				<join-column name=""PARENT_ID"" />
				<cascade>
					<cascade-persist />
					<cascade-merge />
				</cascade>
			</many-to-one>
			<one-to-many name=""children""
				target-entity=""T6Entity""
				mapped-by=""parent"" fetch=""LAZY"">
				<cascade>
					<cascade-persist />
					<cascade-merge />
				</cascade>
			</one-to-many>
		</attributes>
	</entity>



The java compiler generate the following 2 method for getParent()

public volatile ptp.test.issue6.ITree ptp.test.issue6.T6Entity.getParent()
public ptp.test.issue6.T6Entity ptp.test.issue6.T6Entity.getParent()

and depending on the order of the methods return from the reflection getDeclaredMethod(),  it cause the wrong return type to be infer as the inverse relationship. 

There is a  work around, by specifying the target-entity in the many-to-one mapping.

But may be something that should be fix.


",,,,,,,,,,,,,,,,OPENJPA-251,,,,,,22/Aug/07 22:12;hlai;ptpissue6.zip;https://issues.apache.org/jira/secure/attachment/12364363/ptpissue6.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-08-29 05:25:32.56,,,no_permission,,,,,,,,,,,160654,,,Thu Jan 31 00:01:38 UTC 2008,,,,,,,0|i0z1uv:,202603,,,,,,,,22/Aug/07 22:12;hlai;files to reproduce bug,29/Aug/07 05:25;mprudhom;Bumping to 1.0.1 since 1.0.0 is released.,30/Oct/07 16:02;allee8285;Defer to next release.,"31/Jan/08 00:01;pcl;I didn't run the reproducer directly, but created a unit test case that I believe accurately addresses the issue. The next snapshot 1.0.2 build will include this change.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"EntityListener that modify property value of a entity, causes invalid state exception",OPENJPA-327,12376633,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,hlai,hlai,22/Aug/07 21:04,09/Mar/10 18:35,14/Mar/19 03:02,21/Jul/09 03:22,1.0.0,,,,,,,,,,,,,,jpa,,,,,,3,,"entitylistener callback that modifies property value of the entity throws exception

The following test code produces the following exception

<1.0.0-SNAPSHOT-SNAPSHOT fatal user error> org.apache.openjpa.persistence.InvalidStateException: Attempt to set column ""T1ENTITY.VER_ID"" to two different values: (class java.lang.Integer)""2"", (class java.lang.Integer)""3"" This can occur when you fail to set both sides of a two-sided relation between objects, or when you map different fields to the same column, but you do not keep the values of these fields in synch.
	at org.apache.openjpa.jdbc.sql.PrimaryRow.setObject(PrimaryRow.java:338)
	at org.apache.openjpa.jdbc.sql.RowImpl.setObject(RowImpl.java:505)


	/**
	 * for entity with version field, and if the lifecycle listener such as
	 * pre-persist, post-persist handler modifies the entity
	 * then when flush is invoke, results in optimistic lock exception
	 * 
	 * this test failes in openjpa 0.9.6
	 * this test failes in openjpa 0.9.7
	 * this test failes in openjpa 1.0.0
	 * 
	 * This test case will past with either of following changes
	 * 1) comment out em.flush();
	 * 2) uncomment <post-update method-name=""postUpdate""/> in the orm.xml file 
	 *
	 */

	public void testMultipleInsertWithEntityListener(){
		
		PersistenceProviderImpl openJPA = new PersistenceProviderImpl();
		EntityManagerFactory factory = 
			openJPA.createEntityManagerFactory(""test"", ""ptp/test/issue1/persistence.xml"",
						System.getProperties() );
		
        EntityManager em = factory.createEntityManager();
        em.getTransaction().begin();
        T1Entity e1 = new T1Entity();		
        T1Entity e2 = new T1Entity();		
        e1.setName(""Mickey"");
        e2.setName(""Goofy"");
        
        em.persist(e1);
        em.flush();			// works if this line is commented out
        
        em.persist(e2);
        em.getTransaction().commit();
        em.close();
	}





package ptp.test.issue1;

import java.sql.Timestamp;

public class T1EntityListener {

  static int count;
  int instNum;

  public T1EntityListener() {
	 instNum = count++;
    System.out.println(""T1EntityListener="" + this + "", instance="" + instNum );
  }

  public void preUpdate(Object entity) {
    audit( ""preUpdate"", entity);
  }

  public void postUpdate(Object entity) {
    audit( ""postUpdate"", entity);
  }

  public void prePersist(Object entity) {
	    audit( ""prePersist"", entity);
	  }

	  public void postPersist(Object entity) {
	    audit( ""postPersist"", entity);
	  }

  public void audit(String eventName, Object entity) {
    if (entity instanceof IAudit) {
      IAudit auditEntity = (IAudit) entity;
      System.out.println(""****T1EntityListener inst="" + instNum + "", event="" + eventName + "", entity="" + auditEntity + "", ver="" + auditEntity.getVerId());

      try {
        auditEntity.setModifyDateTime(createTimeStamp());
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
  }
  
  private Timestamp createTimeStamp() {
	    return new Timestamp(System.currentTimeMillis());
	  }


","windows xp, jdk 5
code was build time enhanced",,,,,,,,,,,,,,,,,,,,,08/Jul/09 15:53;bjreed;OPENJPA327-1.0.patch;https://issues.apache.org/jira/secure/attachment/12412879/OPENJPA327-1.0.patch,08/Jul/09 15:53;bjreed;OPENJPA327-1.2.patch;https://issues.apache.org/jira/secure/attachment/12412878/OPENJPA327-1.2.patch,22/Aug/07 21:06;hlai;ptpissue1.zip;https://issues.apache.org/jira/secure/attachment/12364354/ptpissue1.zip,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2009-02-02 13:31:11.522,,,no_permission,,,,,,,,,,,160652,,,Tue Jul 21 03:22:27 UTC 2009,,,,,,,0|i0z1u7:,202600,,,,,,,,22/Aug/07 21:06;hlai;test case and mapping files to reproduce bug,"02/Feb/09 13:31;adam.hardy@cyberspaceroad.com;This bug completely disables auditing, or at least auditing based on a ""last_modified"" timestamp field with an entity listener. 

It prevents users from having pre-persist, pre-update, post-persist and post-update EntityListeners with versioning.

Very surprising that this issue is still outstanding in version 1.2.0 when to my untrained eye it seems as if it's not a difficult fix.

Here are a few of the threads discussing it, none of which give any hint of a fix in the pipeline:

http://n2.nabble.com/Does-anyone-meet-the-conflict-values-in-version-column--tt209013.html#none

http://n2.nabble.com/InvalidStateException%3A-Attempt-to-set-column-%22client.version%22-to-two-different-values-tt210609.html

http://n2.nabble.com/-jira--Created%3A-%28OPENJPA-327%29-EntityListener-that-modify-property-value-of-a-entity%2C-causes-invalid-state-exception-tt215677.html#a215679

","11/Feb/09 07:41;ppoddar@apache.org;This test case passes with Oracle on trunk version of OpenJPA.
","21/Feb/09 20:22;adam.hardy@cyberspaceroad.com;I see it with mySQL and Derby. 
",08/Jul/09 15:53;bjreed;This test case is working in trunk.  Looks like the fix for https://issues.apache.org/jira/browse/OPENJPA-732 will work for this.  The above is the change to BrokerImpl and the test case....slight changes in what worked on trunk and the patch for 1.0.x and 1.2.x.,"09/Jul/09 15:39;mikedd;Hi B.J. I'm going to reattach your patches to OPENJPA-732 and apply the fix under that JIRA. It's a shame that we didn't mark 732 as a duplicate of this one when we first fixed it but I don't want to have two separate issues which essentially fix the same problem (just different releases). It'll be a little easier to just track the single issue (at least for me). 

Thanks for the patches though!",09/Jul/09 15:44;mikedd;Linking to OPENJPA-732 which contains the fix for this issue. ,21/Jul/09 03:22;mikedd;Resolved under OPENJPA-732. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE if a discriminator column is specified without discriminator type in orm.xml,OPENJPA-326,12376559,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,22/Aug/07 03:58,24/Sep/07 15:56,14/Mar/19 03:02,24/Sep/07 15:56,0.9.7,,,,,,,,,1.0.1,1.1.0,,,,,,,,,,0,,XMLPersistenceMappingParser should initialize _discType to STRING to avoid a potential NPE. I'll provide an example shortly. ,,,,,,,,,,,,,,,,,,,,,,22/Aug/07 04:13;mikedd;OPENJPA-326.patch.txt;https://issues.apache.org/jira/secure/attachment/12364280/OPENJPA-326.patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160651,,,Wed Aug 22 04:13:00 UTC 2007,,,,,,,0|i0z65b:,203298,,,,,,,,"22/Aug/07 04:13;mikedd;Example exception: 

<openjpa-1.0.0-SNAPSHOT-r420667:568164 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: org.xml.sax.SAXException: file:/home/mikedd/workspaces/jpa/tests/target/test-classes/META-INF/orm.xml [Location: Line: 29, C: 14]: An error was encountered while parsing element ""entity"".  Make sure the metadata file is correctly formatted. [java.lang.NullPointerException]
	at org.apache.openjpa.persistence.PersistenceMetaDataFactory.parseXML(PersistenceMetaDataFactory.java:250)
	at org.apache.openjpa.persistence.PersistenceMetaDataFactory.load(PersistenceMetaDataFactory.java:199)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:433)

Patch attached so that I don't lose track of the changes. The fix is committed in trunk and we'll migrate to 1.0.1 when we're done with 1.0.0.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Uncommitted, flushed data can leak into data cache",OPENJPA-325,12376553,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,,pcl,pcl,22/Aug/07 00:03,09/Mar/10 18:32,14/Mar/19 03:02,22/Aug/07 02:16,0.9.0,0.9.6,0.9.7,,,,,,,1.0.0,,,,,datacache,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160650,,,2007-08-22 00:03:33.0,,,,,,,0|i0yvqv:,201613,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cleanup some message text,OPENJPA-323,12376423,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,tckan1,tckan1,tckan1,20/Aug/07 16:07,09/Mar/10 18:32,14/Mar/19 03:02,20/Aug/07 16:52,1.0.0,,,,,,,,,1.0.0,,,,,kernel,,,,,,0,,"Some words in the messages were confused or mis-spelled. In addition, some messages were not used by any openjpa components. The fpatch cleaned up some of the texts.","Window XP, JDK 1.5",,,,,,,,,,,,,,,,,,,,,20/Aug/07 16:11;tckan1;OPENJPA-323.patch;https://issues.apache.org/jira/secure/attachment/12364155/OPENJPA-323.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-08-20 16:52:29.39,,,no_permission,,,,,,,,,,,160648,,,Mon Aug 20 16:52:29 UTC 2007,,,,,,,0|i1dplz:,288246,,,,,,,,20/Aug/07 16:11;tckan1;Patch is attached..,20/Aug/07 16:52;kwsutter;Patch applied via revision 567748.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DB2 ABS Casting problem,OPENJPA-321,12376279,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,tckan1,kwsutter,kwsutter,17/Aug/07 22:00,09/Mar/10 18:32,14/Mar/19 03:02,21/Aug/07 03:26,0.9.7,,,,,,,,,1.0.0,,,,,jdbc,,,,,,0,,"Via the JPA TCK running against DB2, we found the following problem with casting and the ABS function:

Instead of generating:
..WHERE (CAST(t0.TOTALPRICE AS DOUBLE) > CAST(ABS(?) AS DOUBLE)) 

We need to generate:
..WHERE (CAST(t0.TOTALPRICE AS DOUBLE) > ABS(CAST(? AS DOUBLE)) 

While doing a bit more investigation we are finding similar problems with other function expressions such as MOD and TRIM.",,,,,,,,,,,,,,,,,,,,,,20/Aug/07 22:14;tckan1;OPENJPA-321.patch;https://issues.apache.org/jira/secure/attachment/12364192/OPENJPA-321.patch,17/Aug/07 22:13;fancy;OPENJPA-321.patch;https://issues.apache.org/jira/secure/attachment/12364066/OPENJPA-321.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-08-17 22:13:25.296,,,no_permission,,,,,,,,,,,160646,,,Tue Aug 21 03:26:29 UTC 2007,,,,,,,0|i0zbbb:,204135,,,,,,,,"17/Aug/07 22:13;fancy;Fix DB2 Casting problem for ABS, LENGTH, UPPER, LOWER, TRIM, SQRT.",20/Aug/07 22:14;tckan1;Move some codes from AbstractDB2Dictionary to DB2Dictionary to eliminate unnecessary changes for Derby.,21/Aug/07 03:26;kwsutter;Resolved via revision  #567928.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Do not use System Tables (SYS*) with DB2,OPENJPA-320,12376197,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,16/Aug/07 20:39,29/Aug/07 15:34,14/Mar/19 03:02,17/Aug/07 12:40,0.9.7,,,,,,,,,1.0.0,,,,,jdbc,,,,,,0,,"DB2's system tables (schemas beginning with SYS*) are causing problems with the JPA CTS bucket, if we're trying to use the SynchronizeMappings feature.

From our dev mailing list (http://www.nabble.com/Null-schema-name-when-generating-tables--tf4280146.html):

======================================================
We're running the CTS TCK against DB2 and we've hit a snag with the SynchronizeMappings feature (I know this is not a required aspect of the TCK, but that's what we have been using to create the tables for the testing).

One of the tests in the TCK requires a table called DATATYPES.  The problem is that DB2 has a system table by this name, so when OpenJPA attempts to look up any existing table information, we accidentally find the system table (SYSCAT) instead of the user's table (cts1).  The following trace snippet shows the problem.

1000  JPATCK  TRACE  [main] openjpa.jdbc.Schema - Reading table information for schema name ""null"", table name ""DATATYPES"".
1000  JPATCK  TRACE  [main] openjpa.jdbc.JDBC - <t 16515324, conn 1314410072> [0 ms] rollback
1000  JPATCK  TRACE  [main] openjpa.jdbc.JDBC - <t 16515324, conn 1314410072> getColumns: null, null, DATATYPES, null
1500  JPATCK  TRACE  [main] openjpa.jdbc.Schema - Reading column information for table "" SYSCAT.DATATYPES"".

Of course, this goes on thinking that we have found an appropriate DATATYPES table definition, but later when we attempt to alter it, we get an error:

1891  JPATCK  TRACE  [main] openjpa.jdbc.SQL - <t 16515324, conn 477240434> executing stmnt 854733554 ALTER TABLE DATATYPES ADD id INTEGER
1891  JPATCK  TRACE  [main] openjpa.jdbc.SQL - <t 16515324, conn 477240434> [0 ms] spent
1891  JPATCK  TRACE  [main] openjpa.jdbc.JDBC - <t 16515324, conn 477240434> [0 ms] close
<openjpa-0.0.0-r420667:563705M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: DB2 SQL error: SQLCODE: -204, SQLSTATE: 42704, SQLERRMC: CTS1.DATATYPES {stmnt 854733554 ALTER TABLE DATATYPES ADD id INTEGER} [code=-204, state=42704]
======================================================

By examining and experimenting with OpenJPA, it looks like we have a mechanism already in place to skip over these type of system tables.  By setting the variable systemSchemas with the names of these DB2-specific schema names, then we can bypass these tables and avoid the problem.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160645,,,Fri Aug 17 12:40:42 UTC 2007,,,,,,,0|i1dpmf:,288248,,,,,,,,17/Aug/07 12:40;kwsutter;Resolved via svn revision 566855.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unenhanced generated id field of a primitive wrapper type causes NPE,OPENJPA-315,12375994,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,,dain,dain,14/Aug/07 19:04,09/Mar/10 18:32,14/Mar/19 03:02,29/Aug/07 01:26,,,,,,,,,,1.0.0,,,,,UnenhancedClasses,,,,,,0,,"Unenhanced generated id field of a primitive wrapper type causes NPE because the field value is null.  This bug only occurs when the id field is an object type as primitive fields are automatically initialized to 0.  I believe this is a critical bug because when using a primitive field the system appears to work but the id field is always 0 which could cause data corruption.  The following stack trace shows the bug:

<openjpa-0.0.0-r420667:564688M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: null
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2437)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2251)
	at org.apache.openjpa.kernel.DelegatingBroker.persist(DelegatingBroker.java:1010)
	at org.apache.openjpa.persistence.EntityManagerImpl.persist(EntityManagerImpl.java:541)
	at org.apache.openjpa.enhance.AbstractUnenhancedClassTest.getObjectIdHelper(AbstractUnenhancedClassTest.java:134)
	at org.apache.openjpa.enhance.AbstractUnenhancedClassTest.testGetObjectIdOnOpenJPAType(AbstractUnenhancedClassTest.java:115)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:40)
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.util.ApplicationIds.fromPKValues(ApplicationIds.java:152)
	at org.apache.openjpa.enhance.ReflectingPersistenceCapable.pcNewObjectIdInstance(ReflectingPersistenceCapable.java:257)
	at org.apache.openjpa.util.ApplicationIds.create(ApplicationIds.java:384)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2405)
	... 23 more

The attached patch reproduces this bug.  The patch is a clone of TestUnenhancedFieldAccess that simply changes the id field to type Integer. 
",,,,,,,,,,OPENEJB-628,,,,,,,,,,,,14/Aug/07 19:07;dain;OPENJPA-315.patch;https://issues.apache.org/jira/secure/attachment/12363796/OPENJPA-315.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-08-20 23:14:35.031,,,no_permission,,,,,,,,,,,160641,,,Wed Aug 29 01:26:28 UTC 2007,,,,,,,0|i0yw1b:,201660,,,,,,,,14/Aug/07 19:07;dain;This patch has overrides for all the failing tests that do nothing.  These empty overrides must be removed to reproduce the bug.,"20/Aug/07 23:14;pcl;> I believe this is a critical bug because when using a primitive
> field the system appears to work but the id field is always 0
> which could cause data corruption.

I don't follow -- are you saying that you are seeing a data corruption problem?

Note that OpenJPA will not assign an ID field until it needs to, so you should call flush() or em.getObjectId() before checking to see if an ID field has been provided.",20/Aug/07 23:20;pcl;Marking as resolved under the assumption that the IDs are properly assigned as tested elsewhere.,"28/Aug/07 15:32;dain;> I don't follow -- are you saying that you are seeing a data corruption problem? 

No.  I said ""could cause data corruption"".   Any improperly loaded field in a bean could cause data corruption simply because the data isn't 100% normalized.  For example, someone could make a calculation using the primary key, which was improperly set to 0, and then store that calculation in another bean.

> Note that OpenJPA will not assign an ID field until it needs to, so you should call flush() or em.getObjectId() before checking to > see if an ID field has been provided.

Please review and apply this test.  You may have already fixed the bug when fixing the other issues I committed, but I believe this is the only test for this specific issue.   If you have already added another test for this bug, that is fine also but should be noted in this bug report for completeness.","28/Aug/07 17:26;pcl;> Please review and apply this test. 

What is ""this test""? Are you referring to the patch associated with this issue? If so, how do the changes in http://svn.apache.org/viewcvs?view=rev&rev=567875 not resolve this issue? Note that if you hit the 'subversion commits' tab (or the 'all' tab) in the comments section, you'll see all commits associated with a particular JIRA issue.

Also, from a process standpoint, it's fine to create test case patches that will cause the build to fail when they are applied; presumably, the person who grabs the patch and applies it expects to use the test case to validate that a fix works.","29/Aug/07 01:26;dain;Sorry.  I was responding to your comment ""Marking as resolved under the assumption that the IDs are properly assigned as tested elsewhere"", which to me implied that you assumed there was already a test for this bug so my patch wasn't necessary.  Again, sorry.",29/Aug/07 01:26;dain;Issue has been resolved and a test has been added,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unenhanced complex id in MappedSuperclass causes NPE,OPENJPA-314,12375989,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,dain,dain,14/Aug/07 17:34,09/Mar/10 18:32,14/Mar/19 03:02,20/Aug/07 23:19,,,,,,,,,,1.0.0,,,,,UnenhancedClasses,,,,,,0,,"When I have a complex id within an unenhanced MappedSuperClass, I get a NPE when calling persist.  The NPE appears to be caused because ClassMetaData.getField(int) does not take unenhanced MappedSuperclass fields into account.  Here is the stack trace:

<openjpa-0.0.0-r420667:564688M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: null
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2437)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2251)
	at org.apache.openjpa.kernel.DelegatingBroker.persist(DelegatingBroker.java:1010)
	at org.apache.openjpa.persistence.EntityManagerImpl.persist(EntityManagerImpl.java:541)
	at org.apache.openjpa.enhance.TestUnenhancedCompoundPKSubclass.compoundPKHelper(TestUnenhancedCompoundPKSubclass.java:46)
	at org.apache.openjpa.enhance.TestUnenhancedCompoundPKSubclass.testCompoundPKFieldAccessUserDefined(TestUnenhancedCompoundPKSubclass.java:35)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:40)
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.util.ApplicationIds$PrimaryKeyFieldManager.retrieve(ApplicationIds.java:568)
	at org.apache.openjpa.util.ApplicationIds$PrimaryKeyFieldManager.fetchIntField(ApplicationIds.java:537)
	at org.apache.openjpa.enhance.org$apache$openjpa$enhance$UnenhancedCompoundPKFieldAccessSubclass$pcsubclass.pcCopyKeyFieldsToObjectId(Unknown Source)
	at org.apache.openjpa.enhance.PCRegistry.copyKeyFieldsToObjectId(PCRegistry.java:160)
	at org.apache.openjpa.util.ApplicationIds.fromPKValues(ApplicationIds.java:185)
	at org.apache.openjpa.enhance.ReflectingPersistenceCapable.pcNewObjectIdInstance(ReflectingPersistenceCapable.java:257)
	at org.apache.openjpa.util.ApplicationIds.create(ApplicationIds.java:384)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2405)
	... 23 more

Attached is a test case that reproduces the NPE.  The test methods have been disabled as to not break the build.",,,,,,,,,,OPENEJB-628,,,,,,,,,,,,14/Aug/07 17:35;dain;OPENJPA-314.patch;https://issues.apache.org/jira/secure/attachment/12363791/OPENJPA-314.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160640,,,2007-08-14 17:34:24.0,,,,,,,0|i0z1sf:,202592,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
list of objects returned by query partially correct,OPENJPA-313,12375808,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,fancy,fancy,10/Aug/07 23:14,09/Mar/10 18:32,14/Mar/19 03:02,16/Aug/07 14:49,,,,,,,,,,1.0.0,,,,,jdbc,,,,,,0,,"We have an object inheritance hierarchy as follows.

    FixedAnnuity extends Annuity
    EquityAnnuity extends Annuity

Then we have following code:

    List<IAnnuity> annuities = getServerAdapter().findHolderAnnuities(holder);

from which we expect to have a list of ""Annuity"" (could be Annuity, FixedAnnuity or 
EquityAnnuity) from following code
	EntityManager em = null;
	try{		 						
		em = factory.createEntityManager();
		Query query = em.createNamedQuery(""GetHolderAnnuities"");
		query.setParameter(""holderId"", holder.getId());		
		return (List<IAnnuity>) query.getResultList();
	}

Here is the query
	<named-query name=""GetHolderAnnuities"">
	<query>SELECT a FROM Annuity AS a WHERE a.annuityHolderId = :holderId</query>
	</named-query>

In the end, the list returned only the first object with the correct Object, the 
rest of the objects all casted into the basic type ""Annuity""
e.g. we have following code:

	EntityManager em = null;
	try{		 						
		em = factory.createEntityManager();
		Query query = em.createNamedQuery(""GetHolderAnnuities"");
		query.setParameter(""holderId"", holder.getId());		
		return (List<IAnnuity>) query.getResultList();
	}
	
	FixedAnnuity fixed1 = new FixedAnnuity();
	fixed1.setHolder(holder);
	EquityAnnuity equity1 = new EquityAnnuity();
	equity1.setHolder(holder);
	FixedAnnuity fixed1 = new FixedAnnuity();
	fixed2.setHolder(holder);
	EquityAnnuity equity2 = new EquityAnnuity();
	equity2.setHolder(holder);
	
	List<IAnnuity> annuities = getServerAdapter().findHolderAnnuities(holder);
	
Only annuities.get(0) returns the correct object as FixedAnnuity, the other 3 
objects returned all returned as Annuity ",,,,,,,,,,,,,,,,,,,,,,15/Aug/07 02:23;fancy;OPENJPA-313.2.patch;https://issues.apache.org/jira/secure/attachment/12363817/OPENJPA-313.2.patch,14/Aug/07 04:27;fancy;OPENJPA-313.r564688.patch;https://issues.apache.org/jira/secure/attachment/12363754/OPENJPA-313.r564688.patch,11/Aug/07 02:53;fancy;OPENJPA-313.r564688.patch;https://issues.apache.org/jira/secure/attachment/12363646/OPENJPA-313.r564688.patch,10/Aug/07 23:34;fancy;jpa1.0.0.patch;https://issues.apache.org/jira/secure/attachment/12363639/jpa1.0.0.patch,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2007-08-13 16:10:15.154,,,no_permission,,,,,,,,,,,160639,,,Thu Aug 16 14:49:14 UTC 2007,,,,,,,0|i0zbcv:,204142,,,,,,,,"10/Aug/07 23:34;fancy;The attached patch seemed to have fixed the problem.
The testcase of the Annuity has FetchType EAGER set on both side of a OneToMany relation. An Annuity may have many Payouts.
I'd like to get some feedback from commiters before checking in this patch.
TCK verification is in process.","11/Aug/07 02:53;fancy;same patch as the last patch, but using the new naming convention as recommended by the community.","13/Aug/07 16:10;kwsutter;Catalina,
Thanks for the patch.  A couple of questions and/or comments though...

It looks like this updated code is only if we're working with an OpenJPAID oid and subs is true.  I can understand the oid part, but what exactly is the subs boolean used for?  I know this wasn't your original code, but a quick glance at the code shows a need for a javadoc update at least.  You must have spent some time figuring out how this parameter is used.  It would be helpful to put add to the javadoc for this method to explain what the subs parameter is used for (at least).  Thanks.

Also, I really dislike empty catch clauses.  I can't tell if this was on purpose or an oversight.  It also forces me to think through the logic whether this exception clause was necessary or not.  I think the empty clause is okay, but we should at least put a comment in the clause indicating why we can safely ignore this exception.

I also personally don't like the idea of comparing strings for the strategy type, but it looks like we're just following suit from the existing code.  We can only change so much at a time, I suppose...  :-)

Thanks again,
Kevin",14/Aug/07 04:27;fancy;add block comments to the code.,"15/Aug/07 02:23;fancy;attached revised patch.
mvn clean install ran successful.","16/Aug/07 14:49;kwsutter;Since Catalina doesn't quite have the necessary karma yet, I will resolve this Issue for her...  :-)  Thanks, Catalina, for the patch!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
derby fails with duplicate primary key(s) in group by list,OPENJPA-312,12375716,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,dtlee,dtlee,dtlee,10/Aug/07 01:43,09/Mar/10 18:32,14/Mar/19 03:02,16/Aug/07 13:59,1.0.0,,,,,,,,,1.0.0,,,,,sql,,,,,,0,,"derby fails with duplicate primary key(s) in group by list

With query ""select o.customer, avg(o.amount) from Order o group by o.customer"" the push-down query contains duplicate columns in the group by clause.  This is okay when DB2 and other DB that tolerate the duplicates but Derby returns error.

Of course, we can ask fix on Derby but we can also easy fix in OpenJPA to avoid duplicates in the group by list.  Please refer to the following for the error result and the attach patch for the fix.

Output from running the query that generate duplicate in the group by list:
6429  demo  TRACE  [main] openjpa.Query - Executing query: select o.customer, avg(o.amount) from Order o group by o.customer
6639  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1639735740> executing prepstmnt 1405375428 SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip, t1.creditRating, t1.name, AVG(t0.amount) FROM Order t0 INNER JOIN Customer t1 ON t0.customer_countryCode = t1.countryCode AND t0.customer_id = t1.id GROUP BY t1.countryCode, t1.id, t1.version, t1.countryCode, t1.id, t1.city, t1.state, t1.street, t1.zip, t1.countryCode, t1.id, t1.creditRating, t1.name 

",,,,,,,,,,,,,,,,,,,,,,15/Aug/07 19:15;dtlee;OPENJPA-312.patch;https://issues.apache.org/jira/secure/attachment/12363879/OPENJPA-312.patch,11/Aug/07 00:00;dtlee;OPENJPA-312.patch;https://issues.apache.org/jira/secure/attachment/12363642/OPENJPA-312.patch,10/Aug/07 01:45;dtlee;OPENJPA-312.patch;https://issues.apache.org/jira/secure/attachment/12363548/OPENJPA-312.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-08-10 16:57:58.762,,,no_permission,,,,,,,,,,,160638,,,Thu Aug 16 13:59:39 UTC 2007,,,,,,,0|i1dpnb:,288252,,,,,,,,10/Aug/07 01:45;dtlee;The fix for OpenJPA-312.,"10/Aug/07 16:57;kwsutter;Daniel,
The basic idea of the patch looks okay, but the code changes do not look consistent.  In some cases, you use ""sql"" and in others, you are using ""sql.getSQL()"".  I would prefer just using ""sql"".

Also, you check for an empty _grouping after you check if the desired group sub-string is already present in the _grouping.  This seems backwards.  I know it's only being used to determine whether to use a comma or not.  So, instead of doing these extra empty checks, could we do something along the following.  I think this accomplishes the same goal.

         getJoins(joins, true);
         if (_grouping == null) {
             _grouping = new SQLBuffer(_dict);
             _grouping.append(sql);
        }
        else if (_grouping.getSQL().indexOf(sql) < 0) 
             _grouping.append("", "" + sql);

Thanks,
Kevin

",11/Aug/07 00:00;dtlee;new fix,"13/Aug/07 16:20;kwsutter;Daniel,
The code is much cleaner now.  Thanks.  But, I don't think the performance of StringTokenizer is worth any advantages it might provide.  Is there some reason why the previous mechanism of just using indexOf() wasn't sufficient?  I like the idea of isolating this check to a single boolean method like you have, but I would like to see a better performing implementation.

Thanks,
Kevin","15/Aug/07 19:14;dtlee;Per discussion conclusion, attached here is the patch of fix using a ListArray to keep track of the columns in _grouping.  StringTokenizer has been removed.

Thanks,
Daniel","15/Aug/07 22:49;kwsutter;Daniel, Thanks for the updated patch.  Per our side discussion, I am making a couple of slight changes to your patch, but the intent is still there.  Thanks for resolving this issue.  I will be committing the changes shortly.

Kevin",16/Aug/07 13:59;kwsutter;Resolved via r566381.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem loading classes with OSGi classloaders,OPENJPA-311,12375701,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,09/Aug/07 19:51,10/Aug/07 17:34,14/Mar/19 03:02,10/Aug/07 17:34,0.9.0,0.9.6,0.9.7,1.0.0,,,,,,1.0.0,,,,,,,,,,20/Aug/07 00:00,0,,"The root of the problem appears to be in the GeneratedClasses.getMostDerivedLoader method. 

GetMostDerivedLoader takes two classes (class1 & class2) gets their respective classloaders (classloader1, & classloader2 respectively) and looks for a match. If the classloaders are not the same, and neither is null it calls getParent on classloader1 until classloader2 is found, or until there are no more parent loaders. If a match is found the mostDerivedLoader is considered to be classloader1, if no match is found we use classloader2. 

The problem comes in when you have an OSGI classloader involved. The specific scenario I ran into has classloader1 calling getParent and encountering an OSGI gateway classloader, but not classloader2 (which is behind the OSGI gateway). Conceptually classloader2 is a parent of classloader1, but the OSGI gateway classloader hides it and we aren't able to find it. 

I'm probably mangling the OSGI terminology a bit but I think this captures the essence of the problem. 

It seems to me that the intent of the getMostDerivedLoader is to ensure that we use a classloader that has the ""right"" version of class2, preferring classloader1. If that's the case then would it be possible to just try to load class2 from classloader1 and compare the result to the original class? I believe this approach would work for OSGI classloaders, but I have a nagging feeling that I'm missing something. 

",,,,,,,,,,,,,,,,,,,,,,09/Aug/07 21:49;mikedd;OPENJPA-311.diff.txt;https://issues.apache.org/jira/secure/attachment/12363531/OPENJPA-311.diff.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160637,,,2007-08-09 19:51:37.0,,,,,,,0|i0z6vj:,203416,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Postgres: bytea vs. oid handling in PreparedStatement.setNull() calls,OPENJPA-308,12375463,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,07/Aug/07 00:15,09/Mar/10 18:32,14/Mar/19 03:02,07/Aug/07 16:55,0.9.0,0.9.6,0.9.7,,,,,,,1.0.0,,,,,jdbc,,,,,,0,,"I'm seeing the following error when running against Postgres. This is solved by intercepting the DBDictionary.setNull() call and replacing Types.BLOB with Types.BINARY.


Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: ERROR: column ""image"" is of type bytea but expression is of type oid {prepstmnt 33517025 INSERT INTO LAZ_Product (id, image, name, price) VALUES (?, ?, ?, ?) [params=(long) 1186442009345, (null) null, (String) Browser Spiffer-Upper, (float) 31.5]} [code=0, state=42804]
at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:192)
at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$800(LoggingConnectionDecorator.java:57)
at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:858)
at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1363)
at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:95)
... 39 more","Postgres 8.1 driver, Postgres 8.2 database",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-03-20 21:01:10.165,,,no_permission,,,,,,,,,,,160634,,,Thu Mar 20 21:01:10 UTC 2008,,,,,,,0|i0z1t3:,202595,,,,,,,,"20/Mar/08 21:01;vastruc;I have this error with version 1.0.2 and Postgre 8.2 :

org.apache.openjpa.lib.jdbc.ReportingSQLException: ERROR: column ""administrateddata"" is of type bytea but expression is of type oid {prepstmnt 25070683 INSERT INTO USERS (OID, ADMINISTRATEDDATA, CLASSIFICATION, LOGIN, MODIFICATIONDATETIME, PASSWORD, PREFERENCES, PREFERENCESDATETIME, ROLE, JDOCLASS, JDOVERSION) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) [params=(long) 1002865354472414137, (null) null, (null) null, (String) test, (null) null, (null) null, (null) null, (null) null, (String) Default, (String) com.thalesgroup.isr.common.mdd.TypeUsersImpl, (int) 1]} [code=0, state=42804]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:191)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$800(LoggingConnectionDecorator.java:56)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:857)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1363)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problems with DepthFirstAnalysis and the IBM JDK,OPENJPA-304,12375048,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,31/Jul/07 15:33,31/Jul/07 19:04,14/Mar/19 03:02,31/Jul/07 16:02,0.9.7,,,,,,,,,1.0.0,,,,,lib,,,,,,0,,"TestDepthFirstAnalysis was reporting two errors when running with the IBM JDK.  The testcase ran just fine with the Sun JDK.  The error conditions were NPE's in testBackEdges and testForwardEdges:

testBackEdges(org.apache.openjpa.lib.graph.TestDepthFirstAnalysis)  Time elapsed: 0 sec  <<< ERROR!
java.lang.NullPointerException
        at org.apache.openjpa.lib.graph.DepthFirstAnalysis.visit(DepthFirstAnalysis.java:97)
        at org.apache.openjpa.lib.graph.DepthFirstAnalysis.<init>(DepthFirstAnalysis.java:74)
        at org.apache.openjpa.lib.graph.TestDepthFirstAnalysis.setUpGraph2 (TestDepthFirstAnalysis.java:78)
        at org.apache.openjpa.lib.graph.TestDepthFirstAnalysis.testBackEdges(TestDepthFirstAnalysis.java:105)
        :

testForwardEdges(org.apache.openjpa.lib.graph.TestDepthFirstAnalysis)  Time elapsed: 0 sec  <<< ERROR!
java.lang.NullPointerException
        at org.apache.openjpa.lib.graph.DepthFirstAnalysis.visit(DepthFirstAnalysis.java:97)
        at org.apache.openjpa.lib.graph.DepthFirstAnalysis.<init>(DepthFirstAnalysis.java :74)
        at org.apache.openjpa.lib.graph.TestDepthFirstAnalysis.setUpGraph2(TestDepthFirstAnalysis.java:78)
        at org.apache.openjpa.lib.graph.TestDepthFirstAnalysis.testForwardEdges(TestDepthFirstAnalysis.java :129)
        :

Some debugging with the IBM JDK turned up a couple of problems:

1)  The code in DepthFirstAnalysis.java and Edges.java was using == for equality testing instead of .equals().  It turns out that the IBM JDK has an optimization when using Integer instances as keys to HashMaps and new copies of the keys are created (vs using the input key objects directly).  Thus, the == check was not sufficient to do the comparison testing.

2)  After performing those updates, there was yet another problem with the order of the entries returned by the iterator() of the HashMap.  By definition, the
order is not guaranteed with a HashMap implementation.  In these particular failing testcases, the Sun JDK was starting with node 2 via the Iterator, while the IBM JDK was starting with node 5.  By changing the declaration of this Graph._nodes structure to use a LinkedHashMap (instead of HashMap), we can
reliably determine the order of the iterator.  And, now both the Sun and IBM JDK's produce the same results.

Thanks,
Kevin",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160630,,,2007-07-31 15:33:10.0,,,,,,,0|i1dpof:,288257,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MappingTools not honoring @Temporal for Date & Calender entity attributes,OPENJPA-303,12374998,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,allee8285,allee8285,30/Jul/07 20:51,12/Oct/07 15:59,14/Mar/19 03:02,31/Jul/07 20:10,0.9.7,1.0.0,,,,,,,,,,,,,jdbc,,,,,,0,,"I have a simple entity:

@Entity
@Table(name = ""JSEEmployee"")
public class Employee {
    @Id
    private int id;
    ......
    @Temporal(TemporalType.DATE)
    private java.util.Date date;
   .....
}

When I run the mapping tool to generated the sql as in below, the ""date"" column is still a TIMESTAMP type. Would it be of DATE type due to the @Temporal annotation ?

------------------------------------------------
C:\a.workspace\eclipse.workspace\wasx.jpa.jse.test\JPA.JSE>java org.apache.openjpa.jdbc.meta.MappingTool -sa build -sql create.sql
16  Employee  TRACE  [main] openjpa.Runtime - Setting the following properties from ""file:/C:/a.workspace/eclipse.workspace/wasx.jpa.jse.test/JPA.JSE/META-INF/persistence.xml"" into configuration: { openjpa.ConnectionURL=jdbc:db2:WSTest, openjpa.Id=Employee, openjpa.ConnectionUserName=leealber, openjpa.Log=DefaultLevel=TRACE, MetaData=TRACE, Runtime=TRACE, Enhance=TRACE, SQL=TRACE, openjpa.jdbc.DBDictionary=db2, openjpa.MetaDataFactory=jpa (Types=suite.r70.jse.Employee), javax.persistence.provider=com.ibm.websphere.persistence.PersistenceProviderImpl, openjpa.ConnectionDriverName=COM.ibm.db2.jdbc.app.DB2Driver,openjpa.ConnectionPassword=fth616dy, openjpa.jdbc.SynchronizeMappings=buildSchema }
63  Employee  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.DB2Dictionary"".
78  Employee  INFO   [main] openjpa.Tool - No targets were given.  Running on all classes listed in your configuration,or all persistent classes in the classpath if no classes are configured.  Use -help to display tool usage information.
125  Employee  TRACE  [main] openjpa.MetaData - Using metadata factory ""org.apache.openjpa.persistence.jdbc.PersistenceMappingFactory@2ea82ea8"".
125  Employee  TRACE  [main] openjpa.MetaData - Scanning resource ""META-INF/orm.xml"" for persistent types.
141  Employee  TRACE  [main] openjpa.MetaData - parsePersistentTypeNames() found [suite.r70.jse.Employee].
141  Employee  TRACE  [main] openjpa.MetaData - Found 1 classes with metadata in 16 milliseconds.
141  Employee  INFO   [main] openjpa.Tool - Mapping tool running on type ""class suite.r70.jse.Employee"" with action ""buildSchema"".
141  Employee  TRACE  [main] openjpa.MetaData - Using metadata factory ""org.apache.openjpa.persistence.jdbc.PersistenceMappingFactory@19621962 "".
141  Employee  TRACE  [main] openjpa.MetaData - Loading metadata for ""class suite.r70.jse.Employee"" under mode ""[META][QUERY]"".
141  Employee  TRACE  [main] openjpa.MetaData - Scanning resource ""META-INF/orm.xml"" for persistent types.
141  Employee  TRACE  [main] openjpa.MetaData - parsePersistentTypeNames() found [suite.r70.jse.Employee].
141  Employee  TRACE  [main] openjpa.MetaData - Found 1 classes with metadata in 0 milliseconds.
172  Employee  TRACE  [main] openjpa.MetaData - Parsing class ""suite.r70.jse.Employee"".
172  Employee  TRACE  [main] openjpa.MetaData - Parsing package ""suite.r70.jse.Employee"".
203  Employee  TRACE  [main] openjpa.MetaData - Generating default metadata for type "" suite.r70.jse.Employee"".
234  Employee  TRACE  [main] openjpa.MetaData - Set persistence-capable superclass of ""suite.r70.jse.Employee"" to ""null"".
234  Employee  TRACE  [main] openjpa.MetaData - Resolving metadata for ""suite.r70.jse.Employee@1018576054"".
234  Employee  TRACE  [main] openjpa.MetaData -         Resolving field ""suite.r70.jse.Employee@1018576054.date "".
250  Employee  TRACE  [main] openjpa.MetaData -         Resolving field ""suite.r70.jse.Employee@1018576054.id"".
250  Employee  TRACE  [main] openjpa.MetaData -         Resolving field ""suite.r70.jse.Employee@1018576054.name"".
250  Employee  TRACE  [main] openjpa.MetaData -         Resolving field "" suite.r70.jse.Employee@1018576054.salary"".
250  Employee  TRACE  [main] openjpa.MetaData - Preparing mapping for ""suite.r70.jse.Employee"".
250  Employee  TRACE  [main] openjpa.MetaData -         Resolving field ""suite.r70.jse.Employee@1018576054.id"".
266  Employee  TRACE  [main] openjpa.MetaData -         ""id"" has mapping strategy ""org.apache.openjpa.jdbc.meta.strats.PrimitiveFieldStrategy"".
266  Employee  TRACE  [main] openjpa.MetaData -         Resolving field "" suite.r70.jse.Employee@1018576054.date"".
266  Employee  TRACE  [main] openjpa.MetaData -         ""date"" has mapping strategy ""org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy"".
266  Employee  TRACE  [main] openjpa.MetaData -         Resolving field ""suite.r70.jse.Employee@1018576054.name"".
266  Employee  TRACE  [main] openjpa.MetaData -         ""name"" has mapping strategy "" org.apache.openjpa.jdbc.meta.strats.StringFieldStrategy"".
266  Employee  TRACE  [main] openjpa.MetaData -         Resolving field ""suite.r70.jse.Employee@1018576054.salary "".
266  Employee  TRACE  [main] openjpa.MetaData -         ""salary"" has mapping strategy ""org.apache.openjpa.jdbc.meta.strats.PrimitiveFieldStrategy"".
266  Employee  TRACE  [main] openjpa.MetaData - ""suite.r70.jse.Employee<discriminator>"" has mapping strategy ""none"".
266  Employee  TRACE  [main] openjpa.MetaData - ""suite.r70.jse.Employee<version>"" has mapping strategy ""none"".
266  Employee  TRACE  [main] openjpa.MetaData - Resolving mapping for ""suite.r70.jse.Employee@1018576054"".
266  Employee  TRACE  [main] openjpa.MetaData - ""suite.r70.jse.Employee"" has mapping strategy ""full"".
266  Employee  INFO   [main] openjpa.Tool - Recording mapping and schema changes.
391  Employee  TRACE  [main] openjpa.MetaData - Clearing metadata repository ""org.apache.openjpa.jdbc.meta.MappingRepository@54685468 "".

C:\a.workspace\eclipse.workspace\wasx.jpa.jse.test\JPA.JSE>type create.sql
CREATE TABLE JSEEmployee (id INTEGER NOT NULL, date TIMESTAMP, name VARCHAR(254), salary BIGINT, PRIMARY KEY (id));
------------------------------------------------ 

",All OS & platforms,,,,,,,,,,,,,,,,,,,,,30/Jul/07 21:00;allee8285;OPENJPA-303.patch;https://issues.apache.org/jira/secure/attachment/12362807/OPENJPA-303.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160629,,,Mon Jul 30 21:00:55 UTC 2007,,,,,,,0|i0z6tr:,203408,,,,,,,,"30/Jul/07 21:00;allee8285;The solution is to add the new'ed cols List in AnnotationPersistenceMappingParser.parseTemporal() back to the fm.valueInfo.

    /**
     * Parse @Temporal.
     */
    private void parseTemporal(FieldMapping fm, Temporal anno) {
        List cols = fm.getValueInfo().getColumns();
        if (!cols.isEmpty() && cols.size() != 1)
            throw new MetaDataException(_loc.get(""num-cols-mismatch"", fm,
                String.valueOf(cols.size()), ""1""));
        if (cols.isEmpty()) {
            cols = Arrays.asList(new Column[]{ new Column() });
            fm.getValueInfo().setColumns(cols);    // <<<<<<<< add this line to use the new cols List.
        }

I have also added a test case to validate all combinations of @Temporal generated the correct column type.

Please review the patch and test case.

Thanks.
Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
UUID algorithm generating non-unique values sometimes,OPENJPA-296,12374571,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,25/Jul/07 17:59,09/Mar/10 18:32,14/Mar/19 03:02,25/Jul/07 18:01,0.9.0,0.9.6,0.9.7,,,,,,,1.0.0,,,,,sql,,,,,,0,,"From the dev list:


@Entity
public class Foo {

 @Id
 @GeneratedValue(strategy=GenerationType.AUTO, generator=""uuid-string"")
 private String id;

}

CREATE TABLE Foo (
 id VARCHAR(16) NOT NULL
}

If I do one em.persist() it works just fine. However, if I do a a whole
list of them, I get exceptions (duplicate). If I enable logging I can
see they are all using the same id during INSERT. I stepped a bit
through the code and noticed that uuid-string doesn't get generated
while em.persist(), but much later while committing/flushing. I then
looked a bit (just a bit) at the UUID generator code and noticed that
the bytes are not changing much (maybe only the first two), but again,
that was while debugging, so I'm assuming I have a supa-fast machine.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160622,,,Wed Jul 25 18:01:12 UTC 2007,,,,,,,0|i0zba7:,204130,,,,,,,,25/Jul/07 18:01;pcl;Resolved with r559540.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ArrayIndexOutofBoundsException when under load and within a managed Transaction,OPENJPA-295,12374560,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,rob.wisniewski,rob.wisniewski,25/Jul/07 16:15,12/Oct/07 15:59,14/Mar/19 03:02,08/Aug/07 17:50,0.9.6,,,,,,,,,1.0.1,1.1.0,,,,jpa,,,,,,0,,"Recent development builds of our WAS products as well as the Geronimo project are seeing exceptions when running under load.  An example of the exception is below:

Caused by: 
java.lang.ArrayIndexOutOfBoundsException
	at java.util.ArrayList.add(ArrayList.java:378)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.syncWithManagedTransaction(AbstractBrokerFactory.java:684)
	... 39 more

This is the deepest trace I can get with the actual exception, but the wrappering exception shows this stack trace for geronimo:

<1.0.0-SNAPSHOT-SNAPSHOT nonfatal general error> org.apache.openjpa.persistence.PersistenceException: null
	at org.apache.openjpa.kernel.AbstractBrokerFactory.syncWithManagedTransaction(AbstractBrokerFactory.java:690)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:304)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:182)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:190)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:55)
	at org.apache.geronimo.persistence.CMPEntityManagerTxScoped.createEntityManager(CMPEntityManagerTxScoped.java:74)
	at org.apache.geronimo.persistence.CMPEntityManagerTxScoped.getEntityManager(CMPEntityManagerTxScoped.java:55)
	at org.apache.geronimo.persistence.CMPEntityManagerTxScoped.createNamedQuery(CMPEntityManagerTxScoped.java:259)
	at org.apache.geronimo.samples.daytrader.ejb3.TradeSLSBBean.getClosedOrders(TradeSLSBBean.java:335)

This is happening in two separate products with two different JTA implementations, and also both of these products were working at one point.

Any ideas?
","openjpa running under WebSphere development builds, as well as Geronimo development builds",,,,,,,,,,,,,,,OPENJPA-310,,,,,,03/Aug/07 16:48;mikedd;OPENJPA-295.diff.txt;https://issues.apache.org/jira/secure/attachment/12363140/OPENJPA-295.diff.txt,02/Aug/07 17:51;mprudhom;OPENJPA295.patch;https://issues.apache.org/jira/secure/attachment/12363077/OPENJPA295.patch,03/Aug/07 04:32;clr;openjpa-295.patch;https://issues.apache.org/jira/secure/attachment/12363101/openjpa-295.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-07-25 16:40:52.618,,,no_permission,,,,,,,,,,,160621,,,Tue Sep 18 18:14:56 UTC 2007,,,,,,,0|i0z6z3:,203432,,,,,,,,25/Jul/07 16:40;pcl;We should be creating a concurrent data structure instead of an ArrayList a couple of lines above where you're getting the exception. I can't create a patch easily right now as I've made significant uncommitted changes to that file.,"25/Jul/07 17:21;mprudhom;Could the application somehow be using the same JTA transaction from different threads? The reason we don't synchronize at AbstractBrokerFactory:684 is that we don't expect to ever be able to have multiple threads accessing the list of brokers, since it is keyed off of the JTA transaction (which is supposed to be thread-bound).",25/Jul/07 19:15;rob.wisniewski;It's a long shot that both of these products would be having the same problem..  we're trying to switch out jpa implementations and see if the problem goes away.  earlier builds of the products built on 0.9.7 work fine while the 1.0.0 based builds fail.. trying to retrofit 0.9.7 into the newer builds.  Also synchonizing the set locally here to see if that gets rid of the problem.,"25/Jul/07 21:43;mikedd;Attaching a simple patch based on Patrick's comments. The patch uses a ConcurrentSet (arbitrarily chosen) instead of an ArrayList. 

I also sent a jar containing this change to Rob earlier today and it looks like it resolved the problem. 

I'm hesitating to commit the fix until we understand what else changed between 0.9.7 and now. A quick diff shows no changes to the AbstractBrokerFactory.syncWithManagedTransaction method and only a few in AbstractBrokerFactory as a whole. 

I believe the current builds are faster than 0.9.7 (at least for Rob's application) so it's possible that we're just hitting a timing window that we couldn't before.","02/Aug/07 15:23;mikedd;Getting back to Marc's comment. I think the difference in this case is that WebSphere Application Server (and I'm guessing Geronimo) use the TransactionSynchronizationRegistry. 

When we use the TSR to get a TransactionManager it returns a TransactionManagerFacade (a singleton), calling getTransaction() on the facade returns a singleton (itself) as well. If I haven't misread the code, we'll hit this problem fairly quickly with any Application Server that uses the TSR.

I can think of two potential fixes (assuming I've identified the problem correctly) : 

1. Use a concurrent set (similar to the patch I attached earlier). 

2. The TSR API provides a getTransactionKey() method. The TransactionManagerFacade could be modified to return a new ""TransactionFacade"" Object when getTransaction is called. The TransactionFacade could use the transactionKey's hashcode (which should be unique to each transaction), and we'll avoid the collision. 

Does anyone see a problem with either approach (or something I've missed) ? 
","02/Aug/07 17:51;mprudhom;I bet you're right. Good catch!

Another solution might be to use the following patch: it changes RegistryManagedRuntime.java to use a ThreadLocal to hold its Transaction facades, rather than just having a single global one, which should mean that multiple threads never get the same Transaction facade. I would be interested in hearing if the patch works for you.
","02/Aug/07 21:14;clr;Hi Marc,

There should not be any issue using the identical instance of TSR for the registerSynchronization, get/setRollbackOnly, and getStatus methods. The issue is the assumption that the Transaction instance is different for each transaction.

I think that Michael Dick's #2 solution is needed. The _transactional is already a concurrent map but all the keys are identical so the basic premise doesn't work.

More basic, the AbstractBrokerFactory method findTransactionalBroker should have a different implementation for TSR, which has direct support for this functionality via the getResource and putResource methods. I think I'd rather delegate the ""findTransactionalBroker"" to the ManagedRuntime, which could do the current behavior in other than TSR environments but delegate to the TSR behavior in the app server.

Back to the current problem how about adding Object getTransactionKey() to ManagedRuntime which in non-TSR implementations returns ""this"" and in TSR returns ""this.getTransactionKey()"".","02/Aug/07 21:40;mprudhom;My patch doesn't use a different TSR per thread, it just put a different instance of the javax.transaction.Transaction into the ThreadLocal, so that a different Transaction is used per thread (as per the JTA spec). 

That being said, there are plenty of other solutions to this problem. The advantage I see to my solution is that it doesn't introduce additional unnecessary synchronizatin into the findTransactionalBroker() method. However, even if a different solution is desired, my patch should probably be applied anyway, since having the same Transaction instance being used from multiple threads might break other assumptions elsewhere.","02/Aug/07 22:11;clr;The attached patch adds a new method getTransactionKey to ManagedRuntime and uses this key to manage the Map<Transaction, Broker> map. ","02/Aug/07 22:27;mikedd;I agree with Marc and Craig that some variation of solution 2 is the best option (I see Marc's patch as one of these variations).

That being said I think there are cases where we will need to return a separate TransactionFacade instance if the transaction key is different. 

If the container has suspended that current transaction and started a new one (a bean method with TX_REQUIRES_NEW calls another bean method with TX_REQUIRES_NEW) we'll need a separate key to the _transactions collection. If they used the same key then we'd run into problems the first time an AfterCompletion event is fired. 

Between Marc and Craig's patches I think we're pretty close, I just haven't had a change to play with it much (yet) today. ","02/Aug/07 22:30;clr;> My patch doesn't use a different TSR per thread, it just put a different instance of the javax.transaction.Transaction into the ThreadLocal, so that a different Transaction is used per thread (as per the JTA spec). 

Well, we are only using the Transaction interface to do a small number of things, and while it may seem attractive to use a ThreadLocal for this, it's a bit bizarre because the same ThreadLocal is permanently assigned to the thread so the Transaction never changes. This is not per the JTA spec ;-)

> That being said, there are plenty of other solutions to this problem. The advantage I see to my solution is that it doesn't introduce additional unnecessary synchronizatin into the findTransactionalBroker() method. However, even if a different solution is desired, my patch should probably be applied anyway, since having the same Transaction instance being used from multiple threads might break other assumptions elsewhere.

I think in the case of TSR, there is a much more elegant solution to findTransactionalBroker, by using the getResource and setResource methods. These methods should be much more efficient than our own synchronized _transactional.get(key). Then the only use for _transactional is to make sure that there are no outstanding transactions in progress when we try to close the EntityManagerFactory.

So I'd like to extend ManagedRuntime with a findTransactionalBroker method that would allow the RegistryManagedRuntime to be more efficient, and put the current AbstractBrokerFactory's implementation into AbstractManagedRuntime.","03/Aug/07 01:13;pcl;> So I'd like to extend ManagedRuntime with a findTransactionalBroker method 
> that would allow the RegistryManagedRuntime to be more efficient, and put the 
> current AbstractBrokerFactory's implementation into AbstractManagedRuntime.

+1","03/Aug/07 02:16;clr;Michael said:
>That being said I think there are cases where we will need to return a separate TransactionFacade instance if the transaction key is different. 

TSR was designed so this is not needed. Getting the transaction key is supposed to be a trivial operation so there's no need to remember (cache) it.

>If the container has suspended that current transaction and started a new one (a bean method with TX_REQUIRES_NEW calls another bean method with TX_REQUIRES_NEW) we'll need a separate key to the _transactions collection. If they used the same key then we'd run into problems the first time an AfterCompletion event is fired. 

As long as we never cache the transaction key, but look it up each time we need it, we're good. That is, any time you need to do anything with the transaction key, get it from the ManagedRuntime. It's guaranteed to give you the *current* transaction key. 

The usage of the cached key in RemoveTransactionSync is ok because it's called after the transaction which was registered has completed. And the broker you want to remove from _transactional has that key.

I've attached a new patch that makes the internally cached transaction key an Object instead of a Transaction.","03/Aug/07 03:22;mikedd;I deleted the original bad patch. 

+1 to Craig's approach (now that I see what he meant). AbstractManagedRuntime seems to be missing from the patch. I'm guessing LocalManagedRuntime will also extend AbstractManagedRuntime. 

I'll run a sniff test with WebSphere Application Server in the morning. ","03/Aug/07 04:32;clr;Sorry, forgot to svn add the new abstract class before svn diff. The new patch includes the new class.

I still have not put the findBroker method into the ManagedRuntime pending a bit more discussion.","03/Aug/07 15:01;mikedd;The attached patch is very similar to Craig's last one. I changed the type of
RegistryManagedRuntime._tm to TransactionManagerRegistryFacade, and made LocalManagedRuntime extend AbstractManagedRuntime. 

Of course there could be better solutions, but this worked for me. A very simple test with WebSphere Application Server proved that we aren't missing anything terribly obvious, but it'd be nice to get validation that this did resolve the issue (I've never reproduced the problem).","03/Aug/07 16:48;mikedd;Previous patch had a bug in AutomaticManagedRuntime - it wasn't delegating to the real ManagedRuntime's getTransactionKey method. 
",03/Aug/07 17:27;mikedd;I sent the OPENJPA-295.diff.txt patch to Rob and he confirmed that it does resolve the problem. I'll commit those changes but leave the JIRA open in case we want to discus the findBroker change here too. ,"04/Aug/07 00:52;clr;Looking at how to use the TSR map of object->object instead of the _transactional, we would need to make a change to the AbstractBrokerFactory method BrokerImpl findTransactionalBroker(String user, String pass). The change would delegate to the ManagedRuntime which might have a better way to look up the Broker in the context of the current transaction.

The _transactional map is a map of TransactionKey to Broker. This is needed for a completely different purpose (keeping track of whether there are any Brokers with open transactions). 

The issue is separation of concerns. Currently the ManagedRuntime doesn't really know anything about Brokers or transaction maps. To implement the findTransactionalBroker entirely in ManagedRuntime would introduce a lot of broker-aware code. We could simply have ManagedRuntime know about a Map of Transaction to Object, and do the rest of the processing in AbstractBrokerFactory. This would separate functionality but not completely.

With this separation, the ManagedRuntime would have a new method Object getByTransactionKey(Object brokerFactory, Map transactional) that returns the entry associated with the current transaction (which it knows how to get) in the Map parameter (Abstract implementation) or the entry associated with the TSR Map using the brokerFactory as the key. This is not completely abstract but pretty close.

But if we do all that, we should probably look at delegating most of the syncWithManagedTransaction to the ManagedRuntime as well...","08/Aug/07 17:21;pcl;It looks like the main feature is resolved here, and the issue is open for follow-on work. I'm going to remove the 1.0.0 designation and downgrade the issue to ""Major"" from ""Blocking"".",08/Aug/07 17:50;clr;This issue is resolved. See OPENJPA-310 for more discussion on possible refactoring of the implementation.,18/Sep/07 18:14;mikedd;Already fixed in 1.0.1. ,,,,,,,,,,,,,,,
Change the _exception variblae in the PreparedStatementManagerImpl from private to protected,OPENJPA-288,12374259,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,tckan1,tckan1,20/Jul/07 14:01,09/Mar/10 18:35,14/Mar/19 03:02,20/Jul/07 18:18,1.0.0,,,,,,,,,,,,,,jdbc,,,,,,0,,"In order to utilize the same exception collections in the  PreparedStatementManagerImpl in the subclass, I need to change the _exception variable from private to protected. Since most of the variables in the openjpa PreparedStatementManagerImpl were changed from private to protected recently. This is the one that may be missed.","Window XP, JDK 1.5",,,,,,,,,,,,,,,,,,,,,20/Jul/07 14:01;tckan1;openjpa.patch;https://issues.apache.org/jira/secure/attachment/12362221/openjpa.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160614,,,Fri Jul 20 14:01:28 UTC 2007,,,,,,,0|i1dpqf:,288266,,,,,,,,20/Jul/07 14:01;tckan1;Attach the patch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Generated methods on superclasses are not visible to subclasses,OPENJPA-287,12374203,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,19/Jul/07 20:23,19/Jul/07 20:56,14/Mar/19 03:02,19/Jul/07 20:56,0.9.7,,,,,,,,,1.0.0,,,,,kernel,,,,,,0,,"The pcgetField() and pcsetField() methods are created as Private instead of Protected. 

This becomes a problem if you use Property access in an entity hierarchy and use a DetachStateField. In this scenario the PCEnhancer will generate writeExternal and readExternal methods on the Entity classes. Those methods expect to be able to call pcgetField() and pcsetField() respectively. A child entity won't have access to those methods and will throw an exception when it is serialized, or deserialized. 

To resolve the problem I've modified the PCEnhancer so that the generated methods are protected (fix forthcoming). ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160613,,,2007-07-19 20:23:13.0,,,,,,,0|i1dpqn:,288267,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Can't merge detached One-To-Many child instance. The entities were implement by an internal Hash container.,OPENJPA-286,12374144,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,mikecool,mikecool,19/Jul/07 10:11,09/Mar/10 18:32,14/Mar/19 03:02,16/Jul/08 04:50,0.9.7,1.0.0,1.1.0,,,,,,,1.2.0,,,,,jdbc,,,,,,0,,"Maybe you know, one of the entity implementation is composite of a hash set, which stores key-value pairs.

It's a common design of Entity Bean in EJB2.x ages. Does any one use it in OpenJPA? I am using it right now, and encounter an issue in entity cascade manipulate. Here is the issue description.

Base.java : the super class of entities.
        protected final Object getAttributeValue(String attributeName) {

                return _values.get(attributeName);
        }

        protected final void setAttributeValue(String attributeName, Object value) {

                _values.put(attributeName, value);
        }

        // To hold the {attributeName, value} pair of the value object.
        private HashMap<String, Object> _values = new HashMap<String, Object>();

C.java extends Base.java : Entity C has a set of Entity D.
        public void setDs(Set<D> ds) {

                setCollection(""Ds"", ds);
        }

        @OneToMany(mappedBy = ""c"", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
        public Set<D> getDs() {

                return (Set<D>)getAttributeValue(""Ds"");
        }

D.java extends Base.java as well.

The relationship between C and D is one-to-many. I use following code to reproduce the issue.

                C c = em.find(C.class, 1);
                logger.debug(c.getDs().size());
                D d = new D();
                d.setC(c);
                c.getDs().add(d);
                em.merge(c);

After commit the transaction, you will find the new D instance was not inserted into the database(there is no insert sql log as well). After you add, em.persist(c). That new instance will be added!

Meanwhile, I wrote a couple of classes, which do not use a HashSet. I got the expected result after merge is done. ","java version ""1.5.0_10""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_10-b03)
Java HotSpot(TM) Client VM (build 1.5.0_10-b03, mixed mode, sharing)",,,,,,,,,,,,,,,,,,,,,19/Jul/07 10:24;mikecool;hashpojo.zip;https://issues.apache.org/jira/secure/attachment/12362119/hashpojo.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-07-16 04:50:43.659,,,no_permission,,,,,,,,,,,160612,,,Wed Jul 16 04:50:43 UTC 2008,,,,,,,0|i0z5pz:,203229,,,,,,,,"19/Jul/07 10:24;mikecool;I prepared a test case to reproduce the issue.

The package path will be ""openjpa-persistence-jdbc\src\test\java\org\apache\openjpa\persistence\hashpojo"".

You can feel free to modify them.

Gene","16/Jul/08 04:50;ppoddar@apache.org;This style of modeling persistent states as a name-value pair does not notify OpenJPA which field has been dirtied and hence the observed behavior.
Inform OpenJPA when a field has been dirtied and things should work.
The added lines in TestMargeHashEntity (around Line 79) are marked with + and additional comments
 
		em = emf.createEntityManager();
		em.getTransaction().begin();
+		parent = em.merge(parent);                                                  // merge the detached entity to the current context
+		OpenJPAPersistence.cast(em).dirty(parent, ""children""); // mark it dirty because OpenJPA did not understand that the name-value pair has been updated
                                                                                                                    // now proceed as usual by merging it again so that it can detect the new child added in detached state 
		parent = em.merge(parent);
		em.getTransaction().commit();
		em.close();
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Multiple deploy/undeploy leaks memory in PCRegistry,OPENJPA-285,12373956,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,ppoddar@apache.org,ppoddar@apache.org,17/Jul/07 06:29,09/Mar/10 18:32,14/Mar/19 03:02,01/Aug/07 22:03,1.0.0,,,,,,,,,1.0.0,,,,,kernel,,,,,,1,,"Kevin Miller reported:
Geronimo is running out of PermGen space in some simple deploy/ undeploy scenarios involving OpenJPA. The cause of the problem seems to be the _metas table in PCRegistry. _metas is a ConcurrentReferenceHashMap with WEAK reference keys and HARD reference values. The keys are the PersistenceCapable classes. While the values are the metadata for these classes which are maintained by the internal Meta class.

The cause of the ClassLoader memory leak is simple -- if any of the objects/classes held by the Meta class (e.g. fieldTypes) have also been loaded by the same ClassLoader used to load the PersistenceCapable class, the PersistenceCapable class (the weak key) will never be GCed. The value of the HashMap entry will always maintain a hard reference to the ClassLoader. Since the ClassLoader will never be GC'ed, the the the pcClass Class object will never be GC'able...

The problem can be easily recreated using current Geronimo trunk and the Geronimo Daytrader application.

Patrick Linskey suggested:
Change PCRegistry.fieldTypes to be String[] instead of Class[], and dematerialize them as needed.

Robert Burrell Donkin/Marc Prud'hommeaux  both pointed out that alternatives such as to
listen for the death of a ClassLoader and manually unregistering metadata would be more costly in terms of complexity.

This patch follows Patrick's suggestion.
1. Changes the Meta.fieldTypes to String[] from Class[]
2. Adapts the enhanced bytecode accordingly to the modified method signatures
3. PCRegistry getFieldTypes() load the fields' declared type using the same loader that loaded the owner pc class. 

Note: For a class C and its field f,  CL(c) == CL(f) is not always true. (Kevin Miller)
          But CL(c) will be able to load declared type of f  either directly or via one of its parent (Craig Russel)
",Geronimo 2.0,,,,,,,,,,,,,,,,,,,,,28/Jul/07 20:38;kevan;ImplHelperClassLoaderMemoryLeak.patch;https://issues.apache.org/jira/secure/attachment/12362727/ImplHelperClassLoaderMemoryLeak.patch,17/Jul/07 17:45;ppoddar@apache.org;JIRA-285.patch.2.txt;https://issues.apache.org/jira/secure/attachment/12361993/JIRA-285.patch.2.txt,17/Jul/07 06:35;ppoddar@apache.org;JIRA-285.patch.txt;https://issues.apache.org/jira/secure/attachment/12361957/JIRA-285.patch.txt,28/Jul/07 20:30;kevan;PCRegistryClassLoaderMemoryLeak.patch;https://issues.apache.org/jira/secure/attachment/12362726/PCRegistryClassLoaderMemoryLeak.patch,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2007-07-28 20:30:26.197,,,no_permission,,,,,,,,,,,42051,,,Wed Aug 01 22:05:41 UTC 2007,,,,,,,0|i0z1rr:,202589,,,,,,,,"17/Jul/07 06:35;ppoddar@apache.org;This patch 
1. Changes Meta.fieldTypes from Class[] to String[]
2. Adjusts PCEnhancer to the modified method signature
3. Loads each field's type in PCRegistry.getFieldTypes() using the classloader of pc class 
 
Tested for regression against OpenJPA testcases.
Performance hit is a concern.

","17/Jul/07 17:45;ppoddar@apache.org;Would it be possible to run this patch in Geronimo environment?

This patch 
1. changes all field types of Class to String in PCRegistry$Meta
2. Retains all method signature the same. The constructor of Meta translates all input Class arguments to their stringfied form 
3. Reverts all changes of the earlier patch in PCEnhancer
4. The class names held in PCRegistry$Meta are converted to Classes in PCRegistry. The classloader used to load these classes is always the same classloader that loaded the user-defined persistence capable class.  


","28/Jul/07 20:30;kevan;I'm attaching a potential fix for this problem. It adds a PCRegistry.deRegister(ClassLoader) method. It allows Geronimo to inform OpenJPA when a ClassLoader is no longer valid. deRegister() simply iterates through all entries in the _metas map and removes all entries whose keys were loaded by the associated ClassLoader. If you don't like iterating though all of the _metas tables, it's a simple matter to maintain a set of Classes associated with each ClassLoader. I like the simplicity of it iterating. ClassLoaders are removed on an infrequent basis.

I've tested this change along with associated Geronimo changes in https://issues.apache.org/jira/browse/GERONIMO-3326. I've been through 100's of deploy/undeploy cycles without a problem...

The problem with other solutions (WeakReferences or Stringified Class names) is that PCRegistry$Meta.pc must be a hard reference. It is your only reference to the PersistenceCapable object. If it is a WeakReference, the PersistenceCapable object will be GC'ed and bad things start to happen... ;-)

There's one other solution, which could be considered: Allow embedders to be notified when you've created PersistenceCapable objects. Embedders could maintain the strong references to these objects and delete the references when a ClassLoader has been deleted. PCRegistry references could then be WeakReferences.

","28/Jul/07 20:38;kevan;Found another ClassLoader memory leak caused by ImplHelper. This one is pretty straight forward.

Will be doing a bit more testing...","01/Aug/07 05:08;drwoods;Is there any chance we can get this into the 1.0.0 stream before 8/3, which is when we will start the final TCK runs for Geronimo 2.0?","01/Aug/07 22:00;kwsutter;Don and Kevan,
I just went ahead with the integration of Kevan's patches into OpenJPA.  Per the e-mail conversation that we had about these changes, I am still a little hesitant with the new PCRegistry.deRegister() method.  But, as you have pointed out, there haven't been any other solutions suggested that resolve the problem.  Although this solution puts the responsibility on the embedder of OpenJPA, it does provide the necessary communication between the Embedder and OpenJPA that this particular class loader is no longer required.

I have no concerns with Kevan's other patch for the ImplHelper to use a ConcurrentReferenceHashMap.

Thanks for digging into these problems and providing these patches.

Kevin",01/Aug/07 22:03;kwsutter;Resolved per the discussion on the dev mailing list (http://www.nabble.com/PCRegistry-ClassLoader-memory-leak-tf4091308.html) and this Issue.,"01/Aug/07 22:05;kwsutter;Also, the two other patches attached to this Issue (JIRA-285.patch.txt and JIRA-285.patch.2.txt) are not being included in this commit processing.  Neither of these were deemed to resolve the problem as originally reported.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TableJDBCSeq for GeneratedValue.TABLE did not handle initialValue correctly,OPENJPA-284,12373898,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,tckan1,tckan1,16/Jul/07 14:11,07/Aug/07 17:39,14/Mar/19 03:02,07/Aug/07 17:00,1.0.0,,,,,,,,,1.0.0,,,,,jdbc,,,,,,0,,"When I tested the GeneratedValue strategy on TABLE, and I found a bug in the TableJDBCSeq that did not set the InitalValue. Therefore, the sequence always start from 1.  
Here are the bugs in the TableJDBCSeq:
1) InsertSequence method:
       SQLBuffer insert = new SQLBuffer(dict).append(""INSERT INTO "").
            append(_pkColumn.getTable()).append("" ("").
            append(_pkColumn).append("", "").append(_seqColumn).
            append("") VALUES ("").
            appendValue(pk, _pkColumn).append("", "").
            appendValue(Numbers.valueOf(1), _seqColumn).append("")"");  --> Always set the initial value to 1.
2) no getter and setter on the InitialValue.

Here is the annotation:
@TableGenerator(name=""Dog_Gen"", table =""ID_Gen"", pkColumnName=""GEN_NAME"", valueColumnName=""GEN_VAL"",pkColumnValue=""ID2"",initialValue=20,allocationSize=10)
@GeneratedValue(strategy=GenerationType.TABLE, generator=""Dog_Gen"")
private int id2;

The initial value always started from 1 with the current openjpa implementation. 
The fix will be like this:
1) add getter and setter of InitialValue in TableJDBCSeq .
2) add int _initValue variable.
3) Change the  InsertSequence method:
       SQLBuffer insert = new SQLBuffer(dict).append(""INSERT INTO "").
            append(_pkColumn.getTable()).append("" ("").
            append(_pkColumn).append("", "").append(_seqColumn).
            append("") VALUES ("").
            appendValue(pk, _pkColumn).append("", "").
            appendValue(_intValue, _seqColumn).append("")""); ---> change to use the initValue instead of 1.

","Window XP, JDK 1.5",,,,,,,,,,,,,,,,,,,,,16/Jul/07 18:36;tckan1;OPENJPA-284.patch;https://issues.apache.org/jira/secure/attachment/12361905/OPENJPA-284.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160611,,,Mon Jul 16 18:36:12 UTC 2007,,,,,,,0|i0z5of:,203222,,,,,,,,16/Jul/07 18:36;tckan1;The patch is provided for this jiar report,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Build not successful executing mvn package,OPENJPA-283,12373559,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,plunchete,plunchete,11/Jul/07 23:02,09/Mar/10 18:35,14/Mar/19 03:02,12/Jul/07 16:54,,,,,,,,,,,,,,,build / infrastructure,,,,,,0,,"Running the ""mvn package"" into the Apache OpenJPA project I found an error, the stack error is the next:

Tests run: 3, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.491 sec <<< FAILURE!
testEMClose(org.apache.openjpa.persistence.relations.TestLRS)  Time elapsed: 0.083 sec  <<< FAILURE!
junit.framework.AssertionFailedError: expected:<3> but was:<6>
        at junit.framework.Assert.fail(Assert.java:47)
        at junit.framework.Assert.failNotEquals(Assert.java:282)
        at junit.framework.Assert.assertEquals(Assert.java:64)
        at junit.framework.Assert.assertEquals(Assert.java:201)
        at junit.framework.Assert.assertEquals(Assert.java:207)
        at org.apache.openjpa.persistence.relations.TestLRS.assertLRS(TestLRS.java:92)
        at org.apache.openjpa.persistence.relations.TestLRS.testEMClose(TestLRS.java:72)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
0  test  INFO   [main] openjpa.Runtime - Starting OpenJPA 0.0.0
0  test  INFO   [main] openjpa.jdbc.JDBC - OpenJPA will now connect to the database to attempt to determine what type of database dictionary to use.  To prevent this connection in the future, set your openjpa.jdbc.DBDictionary configuration property to the appropriate value for your database (see the documentation for available values).
2  test  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.DerbyDictionary"" (Apache Derby 10.2.2.0 - (485682) ,Apache Derby Embedded JDBC Driver 10.2.2.0 - (485682)).
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:210)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:135)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:122)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:129)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:225)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:747)

Running org.apache.openjpa.conf.TestBadAutoDetachProperty
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.069 sec, Cle,,,, ","Mac OS X 10.4.9, Java 1.5.0_06-64, Maven 2.0.6",,,,,,,,,,,,,,,,,,,,,11/Jul/07 23:04;plunchete;OpenJPA-283.patch;https://issues.apache.org/jira/secure/attachment/12361624/OpenJPA-283.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160610,,,Wed Jul 11 23:04:21 UTC 2007,,,,,,,0|i0z7mv:,203539,,,,,,,,11/Jul/07 23:04;plunchete;I add the patch to solve the problem,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Postgresql does not support deferred unique constraints.,OPENJPA-282,12373321,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,dmigowski,dmigowski,09/Jul/07 15:59,09/Mar/10 18:32,14/Mar/19 03:02,28/Aug/07 21:51,,,,,,,,,,1.0.1,1.1.0,,,,jdbc,,,,,,0,,"PostgreSQL does not support deferred unique constraints. Since the dictionary states deferred constraints capabilities, this results in an error on automatic database generation for unique fields.

Oh, and identifiers can be 63 chars long... not 31(since at least postgres 7.3, which has last be updated 2005, and is outdated by 7.4 since 2000).

Please use the attached patch to fix this. (Or try something else... ;). Maybe one could better define a variable to describe this capability.

With best regards,
Daniel Migowski

--------------------- PATCH BEGINS BELOW THIS LINE --------------------------
Index: C:/IKOfficeRoot/Projekte/OpenJPA/openjpa/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java
===================================================================
--- C:/IKOfficeRoot/Projekte/OpenJPA/openjpa/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java	(revision 554663)
+++ C:/IKOfficeRoot/Projekte/OpenJPA/openjpa/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java	(working copy)
@@ -32,6 +32,7 @@
 import org.apache.openjpa.jdbc.schema.Column;
 import org.apache.openjpa.jdbc.schema.Sequence;
 import org.apache.openjpa.jdbc.schema.Table;
+import org.apache.openjpa.jdbc.schema.Unique;
 import org.apache.openjpa.lib.jdbc.DelegatingConnection;
 import org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement;
 import org.apache.openjpa.lib.util.Localizer;
@@ -36,6 +37,8 @@
 import org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement;
 import org.apache.openjpa.lib.util.Localizer;
 
+import serp.util.Strings;
+
 /**
  * Dictionary for Postgres.
  */
@@ -93,10 +96,10 @@
         // PostgreSQL requires double-escape for strings
         searchStringEscape = ""\\\\"";
 
-        maxTableNameLength = 31;
-        maxColumnNameLength = 31;
-        maxIndexNameLength = 31;
-        maxConstraintNameLength = 31;
+        maxTableNameLength = 63;
+        maxColumnNameLength = 63;
+        maxIndexNameLength = 63;
+        maxConstraintNameLength = 63;
         schemaCase = SCHEMA_CASE_LOWER;
         rangePosition = RANGE_POST_LOCK;
         requiresAliasForSubselect = true;
@@ -301,6 +304,31 @@
         throws SQLException {
         return new PostgresConnection(super.decorate(conn), this);
     }
+    
+	/**
+     * Return the declaration SQL for the given unique constraint. This
+     * method is used from within {@link #getCreateTableSQL}.
+     * Returns	<code>CONSTRAINT &lt;name&gt; UNIQUE (&lt;col list&gt;)</code>
+     * by default. Only foreign key constraints can be deferred in PostgreSQL
+     * so we have to override the function in DbDictionary.
+     */
+    protected String getUniqueConstraintSQL(Unique unq) {
+        if (unq.isDeferred()) return null;
+
+        StringBuffer buf = new StringBuffer();
+        if (unq.getName() != null
+            && CONS_NAME_BEFORE.equals(constraintNameMode))
+            buf.append(""CONSTRAINT "").append(unq.getName()).append("" "");
+        buf.append(""UNIQUE "");
+        if (unq.getName() != null && CONS_NAME_MID.equals(constraintNameMode))
+            buf.append(unq.getName()).append("" "");
+        buf.append(""("").append(Strings.join(unq.getColumns(), "", "")).
+            append("")"");
+        if (unq.getName() != null
+            && CONS_NAME_AFTER.equals(constraintNameMode))
+            buf.append("" CONSTRAINT "").append(unq.getName());
+        return buf.toString();
+    }    
 
     /**
      * Connection wrapper to work around the postgres empty result set bug.
",PostgreSQL,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-08-28 21:51:16.905,,,no_permission,,,,,,,,,,,160609,,,Tue Aug 28 21:51:16 UTC 2007,,,,,,,0|i1dpqv:,288268,,,,,,,,"28/Aug/07 21:51;pcl;I think that I resolved this, although I did not test it.

To work around this issue in older versions of OpenJPA, you can set the supportsDeferredConstraint DBDictionary property to 'false':

    openjpa.DBDictionary: SupportsDeferredConstraints=false",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
EAGER not the default fetch type without the @Basic annotation,OPENJPA-281,12373309,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,09/Jul/07 14:09,09/Mar/10 18:32,14/Mar/19 03:02,05/Aug/07 23:51,0.9.7,,,,,,,,,1.0.0,,,,,jpa,,,,,,0,,"There's an on-going discussion on the dev mailing list concerning this problem (http://www.nabble.com/Eager-fetching-not-working-with-enums-and-lobs-tf4037105.html).  Since I've gotten agreement on at least one aspect of the problem, I decided to open this JIRA Issue to document the problem.

Here's a summary of the problem:

I am finding that the supposed default action of Eager fetching is not happening with @Enumerated and @Lob fields.  If I explicitly specify the @Basic annotation, then the fields are eagerly fetched.  But, without this extraneous @Basic, these fields are lazily loaded.  This action does not seem to be consistent with the spec.  Nor, can I find any mention of this alternate behavior in our OpenJPA manual.  Sounds like a bug to me.  Any other insights?

This works (eager loading kicks in):

    @Basic @Enumerated(EnumType.STRING)
    private Gender gender;

This does not work (lazy loading kicks in):

    @Enumerated(EnumType.STRING)
    private Gender gender;

I have also tried to use defaults (without any annotations), and lazy loading still kicks in:

    private Gender gender;

The JPA spec attempts to address this situation in section 9.1.18...  Section 9.1.8 of the JPA spec indicates that @Basic is optional and applies to the following types: 

""..Java primitive types, wrappers of the primitive types, java.lang.String, java.math.BigInteger,
java.math.BigDecimal, java.util.Date, java.util.Calendar, java.sql.Date,
java.sql.Time, java.sql.Timestamp, byte[], Byte[], char[], Character[],
enums, and any other type that implements Serializable.""

And, since the default fetch type for @Basic is EAGER, it looks like we need to do eager fetching for both @Enumerated and @Lob fields unless otherwise overridden by a LAZY fetch type (ie. @Basic(fetch=LAZY)).  Agree?

We're still working on the agreement...  :-)

Thanks,
Kevin",,,,,,,,,,,,,,,,,,,,,,02/Aug/07 13:12;kwsutter;openjpa-281.patch;https://issues.apache.org/jira/secure/attachment/12363049/openjpa-281.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160608,,,Sun Aug 05 23:51:23 UTC 2007,,,,,,,0|i0zban:,204132,,,,,,,,"09/Jul/07 18:29;kwsutter;After a bit more discussion on the mail thread, I decided to ping Mike Keith (co-lead of the JPA spec) on his interpretation of the 9.1.18 and 2.1.6 sections of the spec.  Here's his response:

""You are correct. Lobs are to be treated like other Basic attributes and should default to EAGER. Your colleague is somewhat justified in that lobs can be costly to load, however, once we put lobs under the category of basic mappings we needed to be consistent and have them use the same defaults. If they are expected to be both large and not referenced often then @Basic(fetch=LAZY) should be used. Note that if one of these is not true then you probably do want them to be eagerly loaded.

-Mike""

That should decide it.  This Issue will be used to change the behavior be consistent with the @Basic annotation and make all listed types as EAGER fetch type by default.","02/Aug/07 13:12;kwsutter;I decided to post a patch for this Issue before committing it in order to get feedback first...  Take a look at FieldMetaData and see how I am determining whether to include a given type in the default fetch group.  Although it looks a little strange to be doing all of this testing for Serializable, Enums, and Lobs, it actually limited the changes to this single part.  Other alternatives started to ripple through out the code base and I didn't see where it was buying anything.  If I don't hear anything negative, I'll commit these changes later today.

I also updated AllFieldTypes and created a new TestBasicAnnotation testcase so that we don't accidentally re-introduce this problem.

The other change to FieldMapping.java was to avoid an obscure NPE when parsing some orm.xml.

Thanks,
Kevin","05/Aug/07 23:47;kwsutter;I just committed the changes posted in my patch from last week.  No additional comments were received, so I am taking that as general agreement.

Just a bit more historical background on these changes in case we have to revisit this in the future.  My first thought on making Eager work for Enums was to introduce a new ENUM type code in org.apache.openjpa.meta.JavaTypes.  Although this change started off simple and elegant, it quickly rippled to many more changes through out the code that really didn't add any value.  So, I decided to just test for Enums in FieldMetaData instead.  This change was isolated and didn't have the ripple effect.

On the chance that we need more specialized processing for the Enum type, then we might have to revert to my original thought.  But, for this immediate problem, a new type code seemed like overkill.

Kevin",05/Aug/07 23:51;kwsutter;Resolved via revision 562986.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Enhancement failure for inherited fields introduced with change 532137,OPENJPA-280,12373206,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,dezzio,dezzio,06/Jul/07 20:49,09/Mar/10 18:32,14/Mar/19 03:02,13/Jul/07 20:03,1.0.0,,,,,,,,,1.0.0,,,,,kernel,,,,,,0,,"When the PCEnhancer.getPersistenceCapableOwner method was altered, the side effect on the ""owner"" parameter with the old code was removed with the change in 532137.  The patch does the right thing by using f.getDeclaringClass() instead of ""owner"" when looking up the metadata.",The failure shows up when running the JDO 2. TCK on Kodo.  Four test cases fail without the supplied patch.,,,,,,,,,,,,,,,,,,,,,06/Jul/07 20:50;dezzio;PatchPCEnhancer;https://issues.apache.org/jira/secure/attachment/12361326/PatchPCEnhancer,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160607,,,Fri Jul 13 20:03:34 UTC 2007,,,,,,,0|i0zb9b:,204126,,,,,,,,06/Jul/07 20:50;dezzio;SVN patch for the bug.  (A one-line change.),"07/Jul/07 01:27;dezzio;The patch applied (svn 554083) is not the patch submitted here.  I found that the tests (for mvn package) fail with the applied patch, but not with the submitted patch.",13/Jul/07 20:03;dezzio;Fixed by patch applied at 554111,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPAQuery.getDataStoreActions() returns an empty String array,OPENJPA-278,12373103,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,pcl,pcl,pcl,05/Jul/07 20:49,09/Mar/10 18:32,14/Mar/19 03:02,05/Jul/07 20:51,0.9.0,0.9.6,0.9.7,,,,,,,1.0.0,,,,,diagnostics,query,,,,,0,,"OpenJPAQuery.getDataStoreActions() should return the SQL statements that will be executed to satisfy a query. For JPQL queries, it currently always returns an empty String array.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160605,,,2007-07-05 20:49:46.0,,,,,,,0|i0z5mv:,203215,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"JPQL queries cannot access version fields, including bulk updates",OPENJPA-274,12372784,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,pcl,pcl,pcl,01/Jul/07 20:25,09/Mar/10 18:32,14/Mar/19 03:02,06/Jul/07 14:51,0.9.0,0.9.6,0.9.7,,,,,,,1.0.0,,,,,jdbc,query,,,,,0,,"OpenJPA throws an exception if a query uses a field mapped as a @Version. This happens because FieldMappings for fields that are @Version do not have any columns, since the columns are managed separately by the owning ClassMapping's version indicator.",,,,,,,,,,,,,,,,,,,,,,01/Jul/07 21:24;pcl;bulk-updates.patch;https://issues.apache.org/jira/secure/attachment/12360895/bulk-updates.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160601,,,Sun Jul 01 21:24:16 UTC 2007,,,,,,,0|i0z5rr:,203237,,,,,,,,01/Jul/07 21:24;pcl;This patch resolves this bug and also OPENJPA-275. It is possible to decouple this from OPENJPA-275 if it is deemed that OPENJPA-275 is not desirable. Thoughts?,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@GenerateValue (AUTO) doesn't work with Property level access,OPENJPA-272,12372712,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,29/Jun/07 18:53,09/Mar/10 18:32,14/Mar/19 03:02,06/Aug/07 00:00,0.9.7,,,,,,,,,1.0.0,,,,,kernel,,,,,,0,,"The @GenerateValue annotation doesn't work correctly when applied to via the Property level access (getter method) when using the wrapper classes for the primitive types.  Something like this:

    private Long id;

    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

With this type of Entity definition, we hit a problem when checking for the ""default value"":

    public boolean isDefaultValue() {
        return dblval == 0 && longval == 0
            && (objval == null || """".equals(objval));
    }

For this scenario, objval is not null and it's not of type String, so we fail this test and return false.  Upon returning the value of false, the calling code skips the call that would have assigned the generated value to the field (in ApplicationIds):

    private static boolean assign(OpenJPAStateManager sm, StoreManager store,
        FieldMetaData[] pks, boolean preFlush) {
        for (int i = 0; i < pks.length; i++)
            if (pks[i].getValueStrategy() != ValueStrategies.NONE
                && sm.isDefaultValue(pks[i].getIndex())
                && !store.assignField(sm, pks[i].getIndex(), preFlush))
                return false;
        return true;
    }

I haven't figured out the exact fix yet, but there are two workarounds available:

1.  Use field level annotations instead of property, or...
2.  Don't use the primitive wrapper types (use long instead of Long).

In either of these cases, objval is left as null and we are eventually allowed to call store.assignField() which gets the generated value assigned to the field in question (id in this case).

I will keep digging, but if anyone knows the history of the isDefaultValue() method, it would help with getting a quick answer to this Issue.  Since we're dealing with generated values, I'm not clear why we care if values are already assigned to this field or not.  It would seem that we would want to just override what's there.  But, like I said, I need to dive into this a bit.  I just wanted to get the Issue on the books with the information I discovered thus far.

Kevin",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-07-05 18:04:57.963,,,no_permission,,,,,,,,,,,18545,,,Mon Aug 06 00:00:08 UTC 2007,,,,,,,0|i0z5rb:,203235,,,,,,,,"29/Jun/07 19:02;kwsutter;The result of this type of scenario is that you get duplicate key exceptions because the id generation never takes place.  Thus, you end up with attempting to store multiple rows with the same key of 0:

Caused by: <0.0.0 nonfatal store error> org.apache.openjpa.util.StoreException: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by 'SQL070629094257460' defined on 'GASPURCHASE'. {prepstmnt 429791646 INSERT INTO GASPURCHASE (id, DAYNUMBER, GRADENUMBER, PUMPNUMBER, QUANTITY) VALUES (?, ?, ?, ?, ?) [params=(long) 0, (int) 5, (int) 6, (int) 7, (int) 8]} [code=20000, state=23505]
FailedObject: com.ibm.ws.jpa.entities.GasPurchaseProperty@4e144e14

","29/Jun/07 19:22;kwsutter;New information...

My original posting wasn't quite accurate.  You need to mix the use of primitive and wrapper types to get this to fail:

    private long id;

    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    public Long getId() {
        return id;
    } 

    public void setId(Long id) {
        this.id = id;
    }

In this case, it seems that the autoboxing feature of Java 5 kicks in and when getId() gets called, the default value of ""long id"" (0) is returned as an autoboxed Long.  This returned Long object then throws off the conditional code mentioned above and we don't set the generated value appropriately.

So, now I go back to my question of why the invocation of sm.isDefaultValue() necessary?  Do we care there's a default value when we're generating one anyway?

Kevin
","05/Jul/07 18:04;pcl;Man. Another place where property access rules are annoying.

It seems like one possible solution would be to just expand what is considered a default value to include auto-boxed values, when running in a JDK1.5 or higher environment.","05/Jul/07 19:18;kwsutter;It's turning out that this is more than just autoboxing.  The setting of initial values for fields annotated with @GeneratedValue is causing several problems.

For example, even if I have the same types through the Entity definition (where autoboxing does not come into play)...

    private Long id = new Long(5);

    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }


.. I still get the duplicate key exceptions because our runtime logic doesn't know the difference between the initial value and somebody setting a value.  As I pointed out in a separate mail thread, the invocation of the setter method was also being allowed to override the @GeneratedValue annotation.  And, once you have set your own id, how do you tell OpenJPA ""okay, I'm done now... go ahead and generate the rest of the ids now...""?

It just seems like we're opening a can of worms attempting to support both ways.  I think the @GeneratedValue annotation should take precedence.

Kevin","05/Aug/07 23:59;kwsutter;I just committed the changes to resolve this issue.  Per the discussion on our dev mailing list (http://www.nabble.com/Allow-overrides-of-%40GeneratedValue--tf4031013.html#a11450606), I decided to go with the more direct response as Patrick and others suggested.  That is, if somebody has @GeneratedValue on a field (id or otherwise) and then attempts to set a value either via an initializer or a setter method, then an InvalidStateException will be thrown.  This will immediately let the user know that something isn't quite right.  At first, I thought this was too drastic and was leaning towards a warning or error message.  But, due to data integrity concerns, I decided to go with an exception to signal the problem.  This will force the user to do something about the situation instead of blindly running with it until s/he notices the error message.

The exception thrown has a localizer message that indicates the problem and suggested actions to resolve it.

I also provided a new testcase to test for this new condition and the exception processing.

I also had to update the TestSharedMappedSuperclassIdValue testcase since it was incorrectly relying on this ""incorrect"" behavior.

Kevin",06/Aug/07 00:00;kwsutter;Resolved via revision 562987.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DB2 missing JDBC driver 2 support,OPENJPA-271,12372693,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,fancy,fancy,29/Jun/07 15:18,09/Mar/10 18:32,14/Mar/19 03:02,07/Aug/07 17:02,1.0.0,,,,,,,,,1.0.0,,,,,jdbc,,,,,,0,,DB2 platform specific fix needed to support JDBC driver version 2.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160599,,,2007-06-29 15:18:40.0,,,,,,,0|i0zbav:,204133,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Informix doesn't support subselects or using table aliases in a delete statement. ,OPENJPA-269,12372533,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,27/Jun/07 18:26,24/Sep/07 15:59,14/Mar/19 03:02,27/Jun/07 18:39,,,,,,,,,,1.0.0,,,,,,,,,,,0,,"Informix doesn't support using table aliases in a delete statement if you have an index on the table.  For example if we issue the SQL statement : 
""delete from quoteejb t0"" a Syntax error will be thrown by the Informix JDBC driver. Whereas ""delete from quoteejb"" would work. 

This problem seems to be fixed by setting allowAliasInBulkClause to false in InformixDBDictionary. Another possibility is to check whether there is an index on the table, if no index is present we should be able to use the alias. I haven't verified whether that approach works though. 

A second problem occurred when we tried to issue the following statement : 
DELETE FROM holdingejb WHERE holdingID IN (SELECT DISTINCT t0.holdingID FROM holdingejb t0 WHERE (t0.ACCOUNT_ACCOUNTID IS NULL))

The second problem was resolved by setting supportsSubselect to false in InformixDBDictionary. 

In the current implementation when supportsSubselect is false we never check allowAliasInBulkClause so the first change might not be necessary. If the implementation changes we might run into the problem again, so I'd prefer to change both variables.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160597,,,2007-06-27 18:26:33.0,,,,,,,0|i0z5qf:,203231,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
UnsupportedOperationException occurred in BrokerImpl.java,OPENJPA-261,12371987,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,,tckan1,tckan1,19/Jun/07 22:02,20/Jul/07 16:26,14/Mar/19 03:02,20/Jul/07 16:26,0.9.7,,,,,,,,,,,,,,kernel,,,,,,0,,"While I was testing against the openjpa code, I got an UnsupportedOperationException in the BrokerImpl.endtransaction() method. The method set the transState to an empty Collection if there is no cache for transactions. Later the code got an UnsupportedOperationException.

Original code:

Collection transStates = _transCache;
        if (transStates == null)
            transStates = Collections.EMPTY_LIST;
.....
for (Iterator itr = transStates.iterator(); itr.hasNext();) {
            sm = (StateManagerImpl) itr.next();
            try {
                if (rollback) {
                    // tell objects that may have been derefed then flushed
                    // (and therefore deleted) to un-deref
                    sm.setDereferencedDependent(false, false);
                    sm.rollback();
                } else
                    sm.commit();
            } catch (RuntimeException re) {
                exceps = add(exceps, re);
            }
         }

I put a check before this ""for"" loop then the UnsupportedOperationException
disappeared.
if (!transStates.isEmpty()) {   
        	for (Iterator itr = transStates.iterator(); itr.hasNext();) {
            sm = (StateManagerImpl) itr.next();
            try {
                if (rollback) {
                    // tell objects that may have been derefed then flushed
                    // (and therefore deleted) to un-deref
                    sm.setDereferencedDependent(false, false);
                    sm.rollback();
                } else
                    sm.commit();
            } catch (RuntimeException re) {
                exceps = add(exceps, re);
            }
         }
        }
The NPE.patch is attached to this JIRA. ",Window XP,,,,,,,,,,,,,,,,,,,,,21/Jun/07 15:38;tckan1;JIAR261_test.zip;https://issues.apache.org/jira/secure/attachment/12360293/JIAR261_test.zip,19/Jun/07 22:04;tckan1;NPE.patch;https://issues.apache.org/jira/secure/attachment/12360145/NPE.patch,20/Jun/07 05:52;pcl;OPENJPA-261-Java5.jar;https://issues.apache.org/jira/secure/attachment/12360175/OPENJPA-261-Java5.jar,20/Jun/07 05:52;pcl;OPENJPA-261.patch;https://issues.apache.org/jira/secure/attachment/12360174/OPENJPA-261.patch,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2007-06-19 22:08:38.015,,,no_permission,,,,,,,,,,,160589,,,Fri Jul 20 16:26:01 UTC 2007,,,,,,,0|i0yw8v:,201694,,,,,,,,19/Jun/07 22:04;tckan1;Patch for OPENJPA-261,19/Jun/07 22:08;pcl;So you're saying that Collections.EMPTY_LIST.iterator() is returning null? That seems surprising. What version of Java are you using? Can you check if your Java version is returning null from Collecitons.EMPTY_LIST.iterator()?,"20/Jun/07 02:50;clr;There is still something fishy about the reported symptoms. With an empty collection, the itr.hasNext() will return false, and the for loop will never be executed. So the problem must be further down where the transStates empty collection is being used.","20/Jun/07 05:40;pcl;Update from Teresa's email:

Sorry it was not NPE, it was UnsupportedOperationException. I had the NPE
before and somehow mixed up with two. Anyway, it caused by :
java.lang.UnsupportedOperationException: IteratorChains must contain at
least one Iterator

The Collecitons.EMPTY_LIST.iterator() does not return null.
Here is the exception stack:

4781 emptest TRACE [main] openjpa.Runtime - An exception occurred while
ending the transaction. This exception will be re-thrown.

<0.0.0 nonfatal user error> org.apache.openjpa.util.NoTransactionException:
Can only perform operation while a transaction is active.

at org.apache.openjpa.kernel.BrokerImpl.assertActiveTransaction(
BrokerImpl.java:4307)

at org.apache.openjpa.kernel.BrokerImpl.afterCompletion(BrokerImpl.java
:1806)

at org.apache.openjpa.kernel.LocalManagedRuntime.rollback(
LocalManagedRuntime.java:123)

at org.apache.openjpa.kernel.LocalManagedRuntime.commit(
LocalManagedRuntime.java:104)

at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1319)

at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java
:869)

at org.apache.openjpa.persistence.EntityManagerImpl.commit(
EntityManagerImpl.java:409)

at tutorial.ejb.TestEmpsPerClass.main(TestEmpsPerClass.java:135)

4781 emptest TRACE [main] openjpa.Runtime - An exception occurred while
ending the transaction. This exception will be re-thrown.

<0.0.0 nonfatal store error> org.apache.openjpa.util.StoreException:
IteratorChains must contain at least one Iterator

at org.apache.openjpa.kernel.BrokerImpl.afterCompletion(BrokerImpl.java
:1833)

at org.apache.openjpa.kernel.LocalManagedRuntime.commit(
LocalManagedRuntime.java:93)

at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1319)

at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java
:869)

at org.apache.openjpa.persistence.EntityManagerImpl.commit(
EntityManagerImpl.java:409)

at tutorial.ejb.TestEmpsPerClass.main(TestEmpsPerClass.java:135)

Caused by: java.lang.UnsupportedOperationException: IteratorChains must
contain at least one Iterator

at
org.apache.commons.collections.iterators.IteratorChain.checkChainIntegrity(Unknown
Source)

at org.apache.commons.collections.iterators.IteratorChain.lockChain(Unknown
Source)

at org.apache.commons.collections.iterators.IteratorChain.hasNext(Unknown
Source)

at org.apache.openjpa.kernel.BrokerImpl.endTransaction(BrokerImpl.java:2196)

at org.apache.openjpa.kernel.BrokerImpl.afterCompletion(BrokerImpl.java
:1809)

... 5 more

<0.0.0 fatal store error> org.apache.openjpa.persistence.RollbackException:
IteratorChains must contain at least one Iterator

at org.apache.openjpa.persistence.EntityManagerImpl.commit(
EntityManagerImpl.java:420)

at tutorial.ejb.TestEmpsPerClass.main(TestEmpsPerClass.java:135)

Caused by: <0.0.0 nonfatal general error>
org.apache.openjpa.persistence.PersistenceException: IteratorChains must
contain at least one Iterator

at org.apache.openjpa.kernel.BrokerImpl.afterCompletion(BrokerImpl.java
:1833)

at org.apache.openjpa.kernel.LocalManagedRuntime.commit(
LocalManagedRuntime.java:93)

at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1319)

at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java
:869)

at org.apache.openjpa.persistence.EntityManagerImpl.commit(
EntityManagerImpl.java:409)

... 1 more

Caused by: java.lang.UnsupportedOperationException: IteratorChains must
contain at least one Iterator

at
org.apache.commons.collections.iterators.IteratorChain.checkChainIntegrity(Unknown
Source)

at org.apache.commons.collections.iterators.IteratorChain.lockChain(Unknown
Source)

at org.apache.commons.collections.iterators.IteratorChain.hasNext(Unknown
Source)update different fields

at org.apache.openjpa.kernel.BrokerImpl.endTransaction(BrokerImpl.java:2196)

at org.apache.openjpa.kernel.BrokerImpl.afterCompletion(BrokerImpl.java
:1809)

... 5 more
","20/Jun/07 05:52;pcl;So I saw exactly this problem a few days ago, and fixed the code that was leading to the IteratorChain problem. Upon doing so, I just ended up uncovering a new problem.

Attached is a patch that gets past this exception; I expect that you will just get a new exception, probably about the managed cache being corrupt. Can you try it out?

The jar contains a a compiled version of the patch; because of some other changes that I'm working on in my environment, the jar has a dependency on Java 5; if you are still using JDK1.4, you'll need to manually apply the patch (or convince another OpenJPA developer to do so, and post the jar). If you are using Java 5, just put the jar in the front of your classpath, or update the contents of openjpa.jar with the classes listed in the jar.

Also, can you describe what your test case is doing, or better yet, attach your test case to this issue?","21/Jun/07 15:38;tckan1;Patrick,
After I applied your changes and I got the NPE in your changes:

if ((_dirty == null || _dirty.isEmpty() 
&& 
_clean == null || _clean .isEmpty())) 


Exception in thread ""main"" <0.0.0 fatal store error> 

org.apache.openjpa.persistence.RollbackException : null 
at org.apache.openjpa.persistence.EntityManagerImpl.commit(

EntityManagerImpl.java:420) 
at tutorial.ejb.TestEmpsPerClass.main(

TestEmpsPerClass.java:56) 
Caused by: <0.0.0 nonfatal general error> 

org.apache.openjpa.persistence.PersistenceException: null 
at org.apache.openjpa.kernel.BrokerImpl.afterCompletion(

BrokerImpl.java:1834) 
at org.apache.openjpa.kernel.LocalManagedRuntime.commit(

LocalManagedRuntime.java:93) 
at org.apache.openjpa.kernel.BrokerImpl.commit(

BrokerImpl.java:1320) 
at org.apache.openjpa.kernel.DelegatingBroker.commit(

DelegatingBroker.java:869) 
at org.apache.openjpa.persistence.EntityManagerImpl.commit(

EntityManagerImpl.java:409) 
... 1 more

Caused by: 

java.lang.NullPointerException 
at org.apache.openjpa.kernel.BrokerImpl$TransactionalCache.iterator(

BrokerImpl.java:4691) 
at org.apache.openjpa.kernel.BrokerImpl.endTransaction(

BrokerImpl.java:2194) 
at org.apache.openjpa.kernel.BrokerImpl.afterCompletion(

BrokerImpl.java:1810) 
- Show quoted text -

I attached the testcase JIAR261_test.zip file here.
 
",20/Jul/07 16:26;tckan1;It seems to me that the bug was fixed in the recent OPENJPA build. So close this issue.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MetaDataInheritanceComparator is not transitive; C > B > A > C leads to out-of-memory crash in PCEnhancer,OPENJPA-258,12371491,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,,jdf@us.ibm.com,jdf@us.ibm.com,12/Jun/07 18:21,09/Mar/10 18:32,14/Mar/19 03:02,31/Jan/08 08:04,0.9.6,,,,,,,,,1.0.2,1.1.0,,,,jpa,,,,,,0,,"Comparisons done by MetaDataInheritanceComparator are not transitive. It is possible to have classes A, B, and C such that the comparator simultaneously reports that A > B, B > C, and C > A. Under certain unlucky conditions, this causes the SortedTree holding the metadata resolution buffer to become confused during Red-Black fix, such that it can retrieve a certain element, but not delete it. The ""processed"" list then grows until heap is exhausted.

In the enclosed sample project, 

A < B by name
B < C by assignable primary key field
C < A by ""levels"" from base class (Object)

If you import the enclosed eclipse project into an AspectJ-enabled eclipse, and refer the AspectJ compiler to an OpenJPA jar file, you'll get the following output:

  bug.B > bug.A
  bug.C > bug.B
  bug.A > bug.C
  Cycle detected: 
  bug.A > bug.C > bug.B > bug.A

The project will work outside of AspectJ, and will exhibit the out of memory condition described above.

I acknowledge that the enclosed persistence.xml file is not kosher, in that it doesn't list all classes to be instrumented. My own project, affected by this bug, has a correct persistence.xml file. I had to work hard to contrive a simple example, as the order in which classes are buffered affects the appearance of the bug.

There is no work-around that I know of. I don't believe that the comparator's semantics are well-defined.","Sun JDK 5, Sun JDK 6",,,,,,,,,,,,,,,,,,,,,12/Jun/07 18:23;jdf@us.ibm.com;jpa-comparator-bug.zip;https://issues.apache.org/jira/secure/attachment/12359534/jpa-comparator-bug.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-08-21 14:57:08.673,,,no_permission,,,,,,,,,,,160586,,,Tue Oct 30 16:08:58 UTC 2007,,,,,,,0|i0yvfz:,201564,,,,,,,,"12/Jun/07 18:23;jdf@us.ibm.com;Attached: An eclipse/AJDT project. When built and run with AspectJ, will instrument the defective comparator and fail fast on detection of cycle. Without AJDT, will run out of memory and die.",21/Aug/07 14:57;mprudhom;Bumping to release 1.0.1 since 1.0.0 is being released.,30/Oct/07 16:08;allee8285;Defer to next release.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Getter/Setter type inconsistency in Entity IdClass,OPENJPA-257,12371488,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,jdf@us.ibm.com,jdf@us.ibm.com,12/Jun/07 17:27,09/Mar/10 18:32,14/Mar/19 03:02,19/Jul/07 21:06,1.0.0,,,,,,,,,1.0.0,,,,,jpa,,,,,,0,,"In this excerpt from ClassMetaData, we are seeking getter and setter in an identity class. We should be seeking getter and setter with type of Entity class's *key*, not type of Entity class per se. The getter code refers to ""c"", which was earlier set to the correct object id field type. But the setter-seeking code refers incorrectly to ""fmds[i].getDeclaredType()"". This is a show-stopper, as it makes OpenJPA manual section 3.2 un-implementable.

if (m == null || !m.getReturnType().isAssignableFrom(c))
                    throw new MetaDataException(_loc.get(""invalid-id"",
                        _type, fmds[i].getName()));
                m = Reflection.findSetter(oid, fmds[i].getName(),
                    fmds[i].getDeclaredType(), false);
                if (m == null || m.getReturnType() != void.class)
                    throw new MetaDataException(_loc.get(""invalid-id"",
                        _type, fmds[i].getName()));",,,,,,,,,,,,,,,,,,,,,,12/Jun/07 19:31;ppoddar@apache.org;jira257.patch;https://issues.apache.org/jira/secure/attachment/12359544/jira257.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-06-12 19:31:59.091,,,no_permission,,,,,,,,,,,160585,,,Thu Jul 19 21:06:32 UTC 2007,,,,,,,0|i0z1qn:,202584,,,,,,,,"12/Jun/07 18:07;jdf@us.ibm.com;I can work around it by declaring both

void setFoo(String fooKey) { foo = fooKey; }

void setFoo(Foo foo) { foo = foo.getId() }

In the identity class, but this is cheesy.",12/Jun/07 19:31;ppoddar@apache.org;Attached patch to find  Application Identity class' setter method with correct parameter type.  ,"19/Jul/07 21:06;mikedd;Looks like this has already been fixed, or at any rate Pinaki's change is already committed. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.ClassNotFoundException: org.apache.openjpa.util.CacheMap in a jetty spring environment,OPENJPA-256,12371316,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,bommel,bommel,09/Jun/07 12:08,09/Mar/10 18:32,14/Mar/19 03:02,21/Aug/07 15:22,,,,,,,,,,1.0.0,,,,,,,,,,,0,,"Get a ClassNotFoundException: org.apache.openjpa.util.CacheMap.

I think the java.util.Map in Line 1405 

queryCompilationCachePlugin.instantiate(Map.class, this); 

of OpenJPAConfigurationImpl cause the error.

The classloader in this enviroment is a sun.misc.Launcher$AppClassLoader for java.util.Map not a WebAppClassLoader.

Changing the Map.class to CacheMap.class solves the problem (the right ClassLoader is used)",jetty 6.1.3 jdk 1.5 spring 2.0.5 openjpa 1.0.0-SNAPSHOT maven 2.0.5 ,,,,,,,,,,,,,,,,,,,,,09/Jun/07 12:10;bommel;OPENJPA-256.error.log;https://issues.apache.org/jira/secure/attachment/12359326/OPENJPA-256.error.log,13/Aug/07 20:40;bommel;OPENJPA256.patch;https://issues.apache.org/jira/secure/attachment/12363719/OPENJPA256.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-06-09 16:12:48.786,,,no_permission,,,,,,,,,,,160584,,,Tue Aug 21 15:46:25 UTC 2007,,,,,,,0|i0z1pr:,202580,,,,,,,,09/Jun/07 16:12;pcl;How is OpenJPA configured in your environment? How are you bootstrapping it?,"10/Jun/07 08:02;bommel;OpenJPA is configured by spring and part of the webapp.
The classes are enhanced at build time.

You can see the complete example at:

http://svn.apache.org/repos/asf/myfaces/tobago/trunk/example/addressbook/

the 9.6-incubating version works but any newer version shows this error.

If you want to play with it you can use this version 

http://svn.apache.org/repos/asf/myfaces/tobago/tags/tobago-1.0.11/example/addressbook/

this is using a released version of tobago. You don't need to build the whole project :-).

Please change the property openjpa.version to a newer version in the pom and start the application with

mvn jetty:run-exploded and open a browser with the url http://localhost:8080

","02/Aug/07 03:53;mprudhom;The QueryCompilationCacheValue class differs from most plugins in that th
e plugin type is the standard java interface Map.class (rather than an openjpa-s
pecific interface), which means that the ClassLoader used to load the implementa
tion will be the system class loader; this presents a problem if OpenJPA is not
in the system classpath, so work around the problem by catching the IllegalArgum
entException (which is what we wrap the ClassNotFoundException in) and try again.

This is fixed as of revision 562011. The only workaround of earlier versions of OpenJPA is to set the ""openjpa.QueryCompilationCache"" property to ""none"" (thereby disabling the query compilation cache).","13/Aug/07 20:37;bommel;In my case 

Configurations.newInstance  wraps the Exception with a ParseException.

I will attach a patch with also catch the ParseException.",13/Aug/07 20:40;bommel;patch attached,21/Aug/07 14:57;mprudhom;Bumping to release 1.0.1 since 1.0.0 is being released.,"21/Aug/07 15:22;pcl;Applied the patch, but sadly not until after the 1.0.0 deadline.","21/Aug/07 15:46;pcl;Looks like we're doing another 1.0.0 retry, so this is now in.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inconsistent behavior during merge with cascade=none,OPENJPA-255,12371293,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,gergul,gergul,08/Jun/07 22:39,09/Mar/10 18:32,14/Mar/19 03:02,12/May/08 05:43,0.9.7,1.0.0,,,,,,,,1.1.0,,,,,kernel,,,,,,0,,"Suppose you have 2 entities, A and B, with a unidirectional one-to-one relation from A to B and cascade=none. Persist A, B1 and B2, where A.b == B1. Later change A.b to B2 and merge, the operation may or may not succeed, depending on the following conditions:

- If both A and B2 is detached, merge succeeds.
- If both A and B2 is attached, iow managed in the same entity manager, merge succeeds.
- If A is detached and B2 is managed as above, merge fails with 'encountered new object ...' exception.

(It doesn't matter if the objects are versioned or not.) 

The latter case is a rather typical usecase involving a detached context, where the server application unmarshalls a user-modified domain object, creates an entity manager and further modifies that object before invoking merge (such as setting A.b depending on values of other fields). There are two workarounds for the issue: merge twice (merge/set server managed fields/merge), or explicitly detach all such relation objects before calling merge, but obviously neither is desirable.

Looking at the code, it all boils down to AttachStrategy.getReference(...) method. This method is invoked whenever a relation with cascade=none is encountered during merge operation (and only for that case). Yet this method assumes that the object *must* be detached or it will throw the mentioned exception --I don't see the logic behind that assumption.

Attached a testcase demonstrating that behaviour, and a possible fix for it --based on the premise that the above assumption is not correct. If that's not the case, I'd appreciate if someone can point me in the right direction as to why cascade=none on any type of relation field requires a detached object. 
",,,,,,,,,,,,,,,,OPENJPA-231,,,,,,05/May/08 23:47;xiaoqinfeng2000;openjpa-jira-231-255-new.patch;https://issues.apache.org/jira/secure/attachment/12381462/openjpa-jira-231-255-new.patch,08/Jun/07 22:41;gergul;openjpa-jira-255.patch;https://issues.apache.org/jira/secure/attachment/12359302/openjpa-jira-255.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-10-22 17:51:16.516,,,no_permission,,,,,,,,,,,160583,,,Fri May 09 23:36:16 UTC 2008,,,,,,,0|i1dptb:,288279,,,,,,,,08/Jun/07 22:41;gergul;Testcase and fix attached.,22/Oct/07 17:51;addy999;How do i use the patched attached here? I am trying to build OpenJPA with the patched code but getting maven Build error.Can some one send me or let me know where i can get an openJpa jar with the patched code ?,"05/May/08 23:47;xiaoqinfeng2000;I added TestNoCascadeOneToOneMerge.java based on the test case provided in this bug.
The attached patch includes both tests and fixes for open-231 and open-255.","06/May/08 18:39;pcl;Hi,

The recent patch is somewhat corrupted; can you recreate and re-post?","09/May/08 23:36;xiaoqinfeng2000;openjpa-255 is already fixed by openjpa-419 on openjpa1.1.x branch. I think my recent added openjpa-jira-231-255-new.patch is not needed for this issue.
But fix for openjpa-231 on openjpa1.1.x and openjpa head will be different. I will attach patch to openjpa-231.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"org.apache.openjpa.enhance.Reflection.getDeclaredMethod() has undefined behavior, leading to VM-dependent crashes",OPENJPA-251,12371051,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,jdf@us.ibm.com,jdf@us.ibm.com,06/Jun/07 16:29,09/Mar/10 18:32,14/Mar/19 03:02,31/Jan/08 00:02,0.9.7,,,,,,,,,1.0.2,1.1.0,,,,jpa,,,,,,0,,"Given 

public interface A { Object getId(); }

@Entity
public class B implements A { 
    @Id
    public String getId() { return ""foo""; } 
}

B.class.getDeclaredMethods() will include both ""public java.lang.String B.getId()"" and ""public java.lang.Object B.getId()"". The order in which these two methods appear is NOT DEFINED! Because org.apache.openjpa.enhance.Reflection.getDeclaredMethod()  returns the first matching method, and because that method might well be the abstract one retuning Object, OpenJPA will complain that it cannot persist an ID with a non-explicit strategy, and throw up.

Class.getDeclaredMethod() (note singular, not plural) is defined to return the method with the most specific return type under these circumstances, and should therefore be used. Here's my implementation of Reflection.getDeclaredMethod:

	private static Method getDeclaredMethod(Class cls, String name, Class param)
	{
		Class[] params = param == null ? new Class[0] : new Class[] { param };
		try
		{
			return cls.getDeclaredMethod(name, params);
		}
		catch (Exception e)
		{
			return null;
		}
	}
",Sun JDK 6.01,,,,,,,,,,,,,,,,,,,,,06/Jun/07 16:30;jdf@us.ibm.com;weirdness.zip;https://issues.apache.org/jira/secure/attachment/12359090/weirdness.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-06-06 17:04:01.431,,,no_permission,,,,,,,,,,,160579,,,Thu Jan 31 00:02:24 UTC 2008,,,,,,,0|i0z1ov:,202576,,,,,,,,"06/Jun/07 16:30;jdf@us.ibm.com;The enclosed demonstration program gives the output

  public java.lang.String weirdness.TheImplementation.getIt()
  public java.lang.Object weirdness.TheImplementation.getIt()

on my machine, but gives the output

  public java.lang.String weirdness.TheImplementation.getIt()
  public java.lang.String weirdness.TheImplementation.getIt()

on a seemingly identical machine belonging to my colleague.

","06/Jun/07 17:04;clr;Thanks for the info, Jonathan. Seems like a good analysis and an easy fix.

Would you be able to provide a patch, and run the build script to verify it doesn't break anything?

","06/Jun/07 17:09;pcl;From a fix standpoint, it'd be nice to come up with a helper method that replaces the functionality of getDeclaredMethods(), but only lists the most-specific of duplicate covariant signatures (getMostSpecificDeclaredMethods() or something) so that we can use it throughout the codebase without duplication of the looping logic.","06/Jun/07 18:18;awhite;The original implementation used Class.getDeclaredMethod.  It was changed because this is significantly slower than using getDeclaredMethods() and searching through them, and this method is used a lot during deployment. ","09/Jun/07 16:51;jdf@us.ibm.com;Abe, I'd rather have the right answer slowly. :)

Out of curiosity, how much time does it add to deployment?","10/Jun/07 01:15;pcl;It was significant, due to the additional exceptions that were raised by getDeclaredMethod(), which throws when it fails.

We should aim to have a solution that is both correct and fast, IMO. It shouldn't be that hard to implement such a solution with appropriate use of a bit of caching. As ever, it's unfortunate to need to add a cache, since that's one more memory resource to manage and synchronization area to care about.

In fact, IIRC, a caching solution was marginally faster than the non-caching solution that we ended up using.",21/Aug/07 14:57;mprudhom;Bumping to release 1.0.1 since 1.0.0 is being released.,30/Oct/07 16:11;allee8285;Defer to next release.,30/Jan/08 22:06;pcl;These seem like they might be related.,"31/Jan/08 00:02;pcl;I was unable to reproduce this on my machine (presumably my VM uses the ""expected"" ordering), but I believe that I resolved the issue with changes to getDeclaredMethod().",,,,,,,,,,,,,,,,,,,,,,,,,,,
ForeignKey cascade delete action not working,OPENJPA-248,12370634,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,31/May/07 19:29,31/Jul/07 19:03,14/Mar/19 03:02,31/May/07 21:26,0.9.7,,,,,,,,,1.0.0,,,,,jdbc,,,,,,0,,The code in parseForeignKey is not correct.  It is accidentally using the deleteAction setting for both the delete and update action settings.  This results in invalid SQL being generated (at least for DB2 since it doesn't like cascading updates).  This report will be used to correct these settings.  It looks like a simple case of cut-and-paste error.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160576,,,Thu May 31 21:26:56 UTC 2007,,,,,,,0|i0z6af:,203321,,,,,,,,31/May/07 21:26;kwsutter;Fixed via svn revision 543265.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Attach NEW and auto-increment identity,OPENJPA-245,12370345,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,alikic,alikic,27/May/07 14:03,09/Mar/10 18:32,14/Mar/19 03:02,29/Jan/08 06:44,0.9.6,0.9.7,,,,,,,,1.0.3,1.1.0,,,,jpa,,,,,,1,,"According to documentation (1.2 Attach Behavior), when an entity instance is NEW (never detached):

    * If neither of the above cases apply, OpenJPA will check to see if an instance with the same primary key values exists in the database. If so, the object is considered detached. Otherwise, it is considered new.

This doesn't work for me - a new record in database is created on commit instead of updating the existing one. The ""regular"" case - detach/modify/attach works fine - the existing record is updated.

It is very easy to reproduce - just create a new instance of an entity, assign an already existing primary key, call em.merge() and commit. A new record will be created in database, with new, auto-generated primary key.

I stumbled on this trying to implement a web service that uses OpenJPA-based backend. When servicing an ""update"" request, the web service instantiates a NEW object (by performing XML de-serialization) and calls em.merge to update the entity. A new record gets created instead of updating an existing one.

------------ Entity class (START) ------------------------------

package exaple;

public class Consumer implements java.io.Serializable {

  private long id;

  public long getId() {
    return this.id;
  }

  public void setId(long id) {
    this.id = id;
  }

  private java.lang.String firstName;

  public java.lang.String getFirstName() {
    return this.firstName;
  }

  public void setFirstName(java.lang.String firstName) {
    this.firstName = firstName;
  }

  private java.lang.String lastName;

  public java.lang.String getLastName() {
    return this.lastName;
  }

  public void setLastName(java.lang.String lastName) {
    this.lastName = lastName;
  }

------------ Entity class (END) ------------------------------
------------ persistence.xml (START) ------------------------------
<?xml version=""1.0"" encoding=""UTF-8""?>
<persistence xmlns=""http://java.sun.com/xml/ns/persistence"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" version=""1.0"">

    <persistence-unit name=""example"" transaction-type=""RESOURCE_LOCAL"">
    
        <provider>org.apache.openjpa.persistence.PersistenceProviderImpl</provider>

        <!-- We must enumerate each entity in the persistence unit -->
        <class>example.Consumer</class>

        <properties>

            <property name=""openjpa.jdbc.DBDictionary"" value=""postgres""/>
            <property name=""openjpa.ConnectionDriverName"" value=""org.postgresql.Driver""/>
            <property name=""openjpa.ConnectionUserName"" value=""app_user""/>
            <property name=""openjpa.ConnectionPassword"" value=""app_user""/>
            <property name=""openjpa.ConnectionURL"" value=""jdbc:postgresql://localhost/alikic""/>
            <property name=""openjpa.Log"" value=""DefaultLevel=WARN,SQL=TRACE""/>
            
        </properties>
    </persistence-unit>
    
</persistence>
------------ persistence.xml (END) ------------------------------
------------ orm.xml (START) ------------------------------
<entity-mappings xmlns=""http://java.sun.com/xml/ns/persistence/orm"" 
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" 
    xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence/orm orm_1_0.xsd""
    version=""1.0"">
    <entity class=""example.Consumer"">
        <attributes>
            <id name=""id"">
                <generated-value strategy=""IDENTITY""/>
            </id>
            <basic name=""firstName"">
                <column name=""first_name""/>
            </basic>
            <basic name=""lastName"">
                <column name=""last_name""/>
            </basic>
        </attributes>
    </entity>
</entity-mappings>
------------ orm.xml (END) ------------------------------
","jdk1.5.0_11, Win XP, Fedora Core 6, Postgres 8.1 (on Fedora)",,,,,,,,,,,,,,,,,,,,,25/Jan/08 17:13;pcl;OPENJPA-245.patch;https://issues.apache.org/jira/secure/attachment/12374063/OPENJPA-245.patch,22/Jan/08 22:45;mikedd;OPENJPA-245.patch.txt;https://issues.apache.org/jira/secure/attachment/12373786/OPENJPA-245.patch.txt,29/May/07 18:00;ppoddar@apache.org;TestMerge.zip;https://issues.apache.org/jira/secure/attachment/12358445/TestMerge.zip,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-05-29 17:19:52.593,,,no_permission,,,,,,,,,,,18529,,,Tue Jan 29 06:44:06 UTC 2008,,,,,,,0|i0z1lz:,202563,,,,,,,,"29/May/07 17:19;ppoddar@apache.org;
merge() to identify that the the merged entity instance is not *truely* new but a version of a instance that is already persistent, the entity requires a version field.
If the merged instance was a clone created out of serialization and desrialization, then OpenJPA will maintain the required bits to identify the difference between a truly new instance and an instance that has been detached.

","29/May/07 18:00;ppoddar@apache.org;Attached a test case that demonstates merge() behaviour of entities with or without a version field and when the merged instance is a clone or a copy. A clone is created by serialization+deserialization of the original persistent instance. A copy is created by Java new() operator and then fields values are set equal to the original persistent instance (including the primary key field). 

Thus we have four scenarios:
1. Unversioned + Copy
2. Unversioned + Clone
3. Versioned + Copy
4. Versioned + Clone

The  first case originated this issue (at least that's what I gathered from the description). The first case behaves 'rationally but non-intutively'. It creates a new database record rather than updating the existing one. The merge() operation does not see a versioned field, treats the argument instance as a new instance, assigns a new identity (ignoring what the application has set).
If the entity were using application identity, one would have encountered a DuplicateKeyException of some sort, I presume but not tested here.

The rest three cases update the existing record. In the third case, the user application has to copy the version field for merge() to treat the merged instance 'correctly' i.e. as a update rather than an insert of a new record. This seems to be the solution to the original use cse -- add a version field and copy the version field to the merged instance.      
 ","29/May/07 22:43;ppoddar@apache.org;From openjpa documentation (ref: 1.2.  Attach Behavior)

""  * If the instance was detached and detached state is enabled, OpenJPA will use the detached state to determine the object's version and primary key values. In addition, this state will tell OpenJPA which fields were loaded at the time of detach, and in turn where to expect changes. Loaded detached fields with null values will set the attached instance's corresponding fields to null.

    * If the instance has a Version field, OpenJPA will consider the object detached if the version field has a non-default value, and new otherwise.
   * If neither of the above cases apply, OpenJPA will check to see if an instance with the same primary key values exists in the database. If so, the object is considered detached. Otherwise, it is considered new.""

The implementaion does not seem to adhere to the last statement above. This is observed by the original scenario described in this issue as well as the attached testcase testMergeUnversionedNewObjectCreatesNewRecord(). 

AttachStrategy implementaion is responsible for merge().  For a newly created entity instance even if it carries id of a persistent record -- the  attach strategy selected (by AttachManager.getStrategy() method) is VersionAttachStrategy. Now, VersionAttachStrategy determines whether the instance to be attached is new by the following logic:

boolean isNew = !broker.isDetached(pc); // VersionAttachStrategy.java:70

which turns out to be true in this case. 

With the current implementation, VersionAttachStrategy does not detect that a) the instance to be attached is carrying a primary key equal to a pre-existing data record and b) hence it should be an update and not an insert. However, it passes the instance as PNEW further downstream to be flushed (the instance is still carrying a primary key value same as the one set by the application and a record with the same key exists). However, as the identity field is annotated with GenerateValue.IDENTITY -- the PNEW instance gets stored without a duplicate key exception and its primary key in the database is auto incremented. That the primary key value assigned by the user application is ignored and a new value is assigned can also be verified (see the testcase).     

This is the flow for a new instance being merged in a context which is not managing another instance with the same primary key. If the new instance carrying an existing key was merged to a EntityManager that already is managing another instance, because the attach strategy still considered the to be merged instance as PNEW -- a EntityExistsException is raised by the object management kernel even before attampting a flush to the database.","30/May/07 20:58;ppoddar@apache.org;An entity instance x which has been created by new() operator and carrying a existing id (say idx) set by the user application is treated as detached by merge() when the entity class is annotated with @DetachState(enabled=false). Then merge() updates the existing database record with current state of x. If it is not annotated with @DetachState(enabled=false), the instance x is trated as a new instance, and if the entity is using auto-generated identity, a new database record is created, ignoring the id set by the application. However, if the entitymanager doing the merge() is already managing an instance with the same identity idx then an EntityExists exception is raised. 

The generated enhanced code differs based on @DetachedState setting. 
So if the application has changed this setting, the entity must be enhanced again.   


","22/Jan/08 22:45;mikedd;I'm still seeing this problem on 1.0.x, and trunk. Attaching a patch for 1.0.1. I believe this resolves the problem. I'll commit to trunk and 1.0.x shortly. ","25/Jan/08 17:13;pcl;I believe that the changes made for this issue will circumvent some of the more intelligent behavior in more-sophisticated attach strategies, which are used when the instance being attached is an enhanced type that was previously detached (vs. a newly-created instance).

The attached patch moves the changes to VersionAttachManager, which is invoked when other strategies can't be found.

We should probably come up with some more complex test scenarios involving graphs of newly-created instances and mixed graphs.",29/Jan/08 06:44;pcl;Resolved with r615317.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java 2 Security enablement,OPENJPA-244,12370109,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,kwsutter,kwsutter,24/May/07 02:48,15/Apr/08 18:16,14/Mar/19 03:02,10/Aug/07 13:05,1.0.0,,,,,,,,,1.0.0,,,,,,,,,,,0,,"Via some testing with the WebSphere Application Server, it's been discovered that we're missing some doPriv blocks through out the OpenJPA code base.  This JIRA report will be used to resolve these issues.  More specific examples will be posted later.",,,,,,,,,,,,,,,,,,,,,,03/Jul/07 19:13;allee8285;OPENJPA-244.patch;https://issues.apache.org/jira/secure/attachment/12361078/OPENJPA-244.patch,08/Aug/07 23:55;allee8285;OPENJPA.244-2.patch;https://issues.apache.org/jira/secure/attachment/12363452/OPENJPA.244-2.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-06-03 15:41:39.488,,,no_permission,,,,,,,,,,,42029,,,Fri Aug 10 13:05:33 UTC 2007,,,,,,,0|i0z1n3:,202568,,,,,,,,"03/Jun/07 15:41;allee8285;After looking into this Java 2 security issue, here is a proposal to correct the problem in openjpa.

The goals of the enhancements are:

1) non-intrusive changes.
2) easy readability and future usages
3) sensitive to downstream security exposure
4) maintanence of the additional code.

Approach to the solution:
1) Create a static helper class J2DoPrivHelper.java in openjpa-lib\src\main\java\org\apache\openjpa\lib\util. See attachment for the content. The purpose of this class is isolate Java 2 security related code in one place for control and maintenance.
2) Each JDK functions that required doPrivileged encasement associated to a static method in the helper class. The name of the method is closely related to the JDK function. If it is an instance method, the first argument is the instance object. So far I have identified 24 JDK helper methods.
3) Where there is a usage of the security sensitive method call, it can be translated to one of the helper method.
    E.g.
    a) From
            return _url.openStream();
         To
            return J2DoPrivHelper.openStream(_url);
    b) From
           ClassLoader loader = cls.getClassLoader();
         To
           ClassLoader loader = J2DoPrivHelper.getClassLoader(cls);
    c) From
            loader = ClassLoader.getSystemClassLoader();
         To
            loader = J2DoPrivHelper.getSystemClassLoader();

         To
4) These method call translations will be to the closest place where the doPriv is needed. This will eliminate the possible security ""leak"" in the down stream code. E.g. callback to unsecured code inside the doPriv encasement.
5) There are approximately 71 files affected, excluding test cases that use the same security sensitive methods.
6) Document the permissions required by Java 2 security used in openjpa.
    E.g.
      permission java.lang.RuntimePermission  ""getClassLoader"";
      permission java.io.FilePermission       ""<<ALL FILES>>"",        ""read""; 

I have a prototype of these changes and it is working in the WebSphere environment.

I am open for suggestions and ideas. I continue to work on this path unless I hear there is any objection otherwise.

Thanks.
Albert Lee","03/Jun/07 16:12;djencks;Would it make any sense to, rather than having a class with static methods, having an interface/abstract class and a static INSTANCE?  Then some initialization (static) code could decide which implementation is appropriate for the environment: e.g. if no security manager is installed we wouldn't need the doPrivileged code?  I don't know if going through the doPrivileged code when it isn't doing anything incurs enough expense to make this worthwhile.","03/Jun/07 23:53;clr;If you choose not to have an interface and two classes selected by whether the security manager is active or not, I'd suggest adding a 
static final boolean isSecure = System.getSecurityManager() != null; 

and then testing it for each method, e.g. 

    public static final ClassLoader getClassLoader (final Class clazz)
    {
if(isSecure) {
        return (ClassLoader) AccessController
                .doPrivileged(new PrivilegedAction()
                {
                    public Object run ()
                    {
                        return clazz.getClassLoader();
                    }
                });
} else {
return clazz.getClassLoader();
}
    }

If the variable isSecure is static final we need to be sure that the class is never loaded before the security manager is activated, otherwise we will get the wrong answer.

As the patch is written as of June 3, each call will at minimum create a new object on the heap that needs to be garbage collected, and calling doPriv when there is no security manager is a waste.

In any case, it's good to isolate the calls to this class so I'm +1 on making the rest of the changes and we can worry about the implementation details when we see if there is any performance impact one way or the other.

","04/Jun/07 21:23;mitesh;Including a class like J2DoPrivHelper as part of trusted code might be dangerous from security point of view.  For example. some malicious code  that otherwise does not enough privileges can now call J2DoPrivHelper.getDeclaredFields() to get access to fields of a class. AFAIK, there is no easy way to completely factor out doPrivileged blocks without compromising secuity :(","05/Jun/07 15:15;allee8285;Mitesh, You bring up a very good point.

I need to investigate more and see if there are alternatives other than in-lining doPrivileged in the openjpa code base.

Thanks for you insight into this matter.
Albert Lee","05/Jun/07 16:05;clr;What is possible is to hide the nasty mechanical construction of a new instance of the anonymous inner class by a wrapper method. 

Perhaps Mitesh can post examples (used in CDDL-licensed TopLink Essentials) that preserve the doPrivileged method call in the correct place but delegates the construction of the instance to a wrapper. The resulting code is much more readable than the usual inline doPrivileged and avoids the security hole.
","05/Jun/07 17:07;allee8285;I noticed that there are many openjpa classes have a static final caching the line.separator (or something similiar) from the system properties. This kind of general resource that required doPriv can be customized in the helper without any security exposure and still make the code readable.

private static final String SEP = J2DoPrivHelper.getLineSeparator();

public static final String J2DoPrivHelper.getLineSeparator()
{
        if (System.getSecurityManager() != null)
        {
            return (Properties) AccessController
                    .doPrivileged(new PrivilegedAction()
                    {
                        public Object run ()
                        {
                            return System.getProperty(""line.separator"");
                        }
                    });
        } else
        {
            return System.getProperty(""line.separator"");
        }
}

These type of functions can also be cached in the helper for performance too.

Albert Lee.
","05/Jun/07 17:28;clr;What the example code does is to allow any untrusted code with access to the J2DoPrivHelper class to get the value for the line separator. 

While this doesn't sound like a big deal, it's still violating the security model.

A solution is to code this in the trusted code:
private static final String SEP = (Properties) AccessController.doPrivileged(
    J2DoPrivHelper.getLineSeparatorAction());

And then the helper class is responsible for:
public static PrivilegedAction getLineSeparatorAction() {
    return new PrivilegedAction() {
                       public Object run () 
                        { 
                            return System.getProperty(""line.separator""); 
                        } 
                    }); 
}
","05/Jun/07 18:02;mitesh;>What is possible is to hide the nasty mechanical construction of a new instance of the anonymous inner class by a wrapper method.

Here is an example for invoking a method reflectively 

                try {
                    AccessController.doPrivileged(new PrivilegedMethodInvoker(method, null, args));
                } catch (PrivilegedActionException exception) {
                    Exception throwableException = exception.getException();
                }

where PrivilegedMethodInvoker is as follows

public class PrivilegedMethodInvoker implements PrivilegedExceptionAction {

    private Method method;
    private Object target;
    private Object[] args;
    
    public PrivilegedMethodInvoker(Method method, Object target, Object[] args){
        this.method = method;
        this.target = target;
        this.args = args;
    }
    
    public Object run() throws IllegalAccessException, InvocationTargetException {
        return PrivilegedAccessHelper.invokeMethod(method, target, args);
    }
    
}
","07/Jun/07 15:15;allee8285;Having specific function(s) in J2DoPrivHelp that required doPriv is to isolate common access function without security exposure and hopefully improve performance. Since there is no user parameters allowed by the helpers, even the getLineSeparator() is public, user is only allowed to get the lineSeparator string and no other resources security leak.

The wrapper method approach is to provide means to create the Privilege(Exception)Action object but the doPrivileged will still be in-lined in the openjpa code to avoid undesirable security exposure. 

Here is a new proposal:

1) The J2DoPrivHelper defines the common security safe functions and PrivilegedAction getters (example):
        
       public static final String getLineSeparator();
       public static final Object getOtherSpecificSecuritySafeResource();
       .......
 
       public static final PrivilegedAction getClassLoaderAction(final ClassLoader loader);
       public static final PrivilegedExceptionAction getDeclaredMethodAction(final Class clazz, final String name, final Class[] parameterTypes);
       .......

2)  J2DoPrivHelper usage:

       private static final String SEP = J2DoPrivHelper.getLineSeparator(); 

       ClassLoader loader = (ClassLoader) AccessController.doPrivileged( J2DoPrivHelper.getClassLoaderAction( clazz ) );

        try {
              AccessController.doPrivileged(J2DoPrivHelper.getDeclaredMethodAction( clazz, name, args));
        } catch (PrivilegedActionException exception) {
               NoSuchMethodException ex = (NoSuchMethodException)exception.getException();
        } 

3) If there is any situation where testing security is enabled before the doPriv pattern is used, it will need to be in-lined in user code.

Please comment and indicate if this is an acceptable solution.

Thanks.
Albert Lee.","07/Jun/07 16:00;pcl;I think that an important design goal here is minimal invasiveness into the code. Java 2 security is something that many of us have never seen as an issue in practice, so ensuring that the security-friendly mechanisms are just as easy to use as the unfriendly versions is pretty important IMO.

Additionally, I'm concerned about the extra overhead incurred by these calls, which makes  me think that caching might be a good idea.

Given that you demonstrate in point 2 above that it is legit to cache the return values of the security-wrapping calls, can we achieve better encapsulation? For example, why not just have a J2DoPrivHelper.getDeclaredMethod() call that does the right thing internally?","07/Jun/07 16:01;pcl;Additionally, from a performance standpoint, it seems like we should make the J2DoPrivHelper methods non-static, create an interface, and provide access to the instance via the OpenJPAConfiguration object. This will allow us to have an impl that doesn't do security checks at all and a separate impl that does the security checks.","07/Jun/07 18:07;allee8285;>>  I think that an important design goal here is minimal invasiveness into the code. Java 2 security is something that many of us have never seen as an issue in practice, so ensuring that the security-friendly mechanisms are just as easy to use as the unfriendly versions is pretty important IMO. 

I agree with you.  This is one of the goal set right from the beginning. See the first comment .

>>  Additionally, I'm concerned about the extra overhead incurred by these calls, which makes me think that caching might be a good idea. 

We have also considered and discussed the performance aspects. There will be 2 extra calls, i.e. AccessController and PrivelegedAction.run if security is enabled.  This can not be avoid.  However the JIT may optimize/in-line the call as the runtime is stablized.  Architectually, I agree making the helper methods non-static to encapsulate the doPriv wrapper function for the security disable scenario is desirable. However this will sill incur a minimum of 1 and 3 method calls for security disable and enable scernario respectively. e.g.    helper.getDeclaredMethod()     and helper.getDeclaredMethod() -> AccessController -> run().

>> Given that you demonstrate in point 2 above that it is legit to cache the return values of the security-wrapping calls, can we achieve better encapsulation? For example, why not just have a J2DoPrivHelper.getDeclaredMethod() call that does the right thing internally?

If I hear you right, the sugguestion is to have all the doPriv processing in the J2DoPrivHelper.getDeclaredMethod().   This was the original proposal and Mitesh has pointed out that this is a security leak. See previous comment.

>> Additionally, from a performance standpoint, it seems like we should make the J2DoPrivHelper methods non-static, create an interface, and provide access to the instance via the OpenJPAConfiguration object. This will allow us to have an impl that doesn't do security checks at all and a separate impl that does the security checks.

Sounds good. 

I'll draft another proposal and post it back here soon.

Thanks.
Albert Lee","07/Jun/07 21:11;pcl;> > Given that you demonstrate in point 2 above that it is legit to cache the
> > return values of the security-wrapping calls, can we achieve better 
> > encapsulation? For example, why not just have a J2DoPrivHelper.getDeclaredMethod()
> > call that does the right thing internally?
> 
> If I hear you right, the sugguestion is to have all the doPriv processing in the 
> J2DoPrivHelper.getDeclaredMethod().   This was the original proposal and Mitesh
> has pointed out that this is a security leak. See previous comment.

... but it looks like your most recent proposal shares this leak, since it has methods like getLineSeparator(). We should either make all of the methods secure and consider it a goal to not allow that leak, or make all of the helper methods behave the same, no?

-Patrick","08/Jun/07 05:03;allee8285;The getLineSeparator() will not compromise security because this function only return specifically the line.separator String and nothing else, hence there is no side effect. This method may cache the value for performance and better code readability and maintenance.

In the original proposal, application can call one of the J2DoPrivHelper public methods which may grant user resource privileges on behalf of the caller, which is not good. If there is a resource requires privilege, the AccessController.doPrivileged() must be in-line in the openjpa code base, but the ""new Privilege(Exception)Action"" can be common or factor out.  Even if the doPrivilege() is inlined, one must also be careful not to allow any public method to be accessed by the application with user specified resource that eventually grant privilege to access the resource.

>>> Additionally, from a performance standpoint, it seems like we should make the J2DoPrivHelper methods non-static, create an interface, and provide access to the instance via the OpenJPAConfiguration object. This will allow us to have an impl that doesn't do security checks at all and a separate impl that does the security checks.

>Sounds good. 

After some thought on this topics, I just realized that use of interface will not work. The same reason as just described. The interface can only get the PrivilegedAction because the doPriv must be in-lined. E.g.

The use cases are:

   private static final String SEP = J2DoPrivHelper.getLineSeparator();

   ClassLoader loader = (ClassLoader) (System.getSecurityManager() == null)
                            ? clazz.getClassLoader()
                            : AccessController.doPrivileged( J2DoPrivHelper.getClassLoaderAction( clazz ) );

   try
   {
       method = ( System.getSecurityManager() == null )
                   ? clazz.getDeclaredMethod(name,parameterType)
                   : (Method) AccessController.doPrivileged( J2DoPrivHelper.getDeclaredMethodAction( clazz, name, parameterType) );
   } catch( PrivilegedActionException pae )
   {
           throws (NoSuchMethodException)pae.getException()
   }


       ","29/Jun/07 15:37;allee8285;Based on the previous design/implementation discussions. attached is a fix to enable Java 2 security in openjpa implementation.

Tested platforms
----------------
Basic tests runs on Win32 system and have verified on WebSphere Application Server with security both disabled/enabled.

Test profile option
-------------------
A new profile 'enabled-security' is added to openjpa pom.xml to enable running tests with security on. The default is seourity off. 

E.g. To run test with security on, 
   mvn test -P enabled-security,test-derby

TCK 
---
Tests passed and no regression.

Performance
-----------
Overall no difference when security is off but showed a 8.4% degradation with security on.

1) Results: base revision run before any changes were made.
            > mvn test 
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] OpenJPA ............................................... SUCCESS [0.016s]
[INFO] OpenJPA Utilities ..................................... SUCCESS [6.718s]
[INFO] OpenJPA Kernel ........................................ SUCCESS [3.532s]
[INFO] OpenJPA JDBC .......................................... SUCCESS [0.328s]
[INFO] OpenJPA XML Store ..................................... SUCCESS [0.047s]
[INFO] OpenJPA Kernel 1.5 .................................... SUCCESS [0.078s]
[INFO] OpenJPA JPA ........................................... SUCCESS [0.078s]
[INFO] OpenJPA JDBC 1.5 ...................................... SUCCESS [0.031s]
[INFO] OpenJPA JPA JDBC ...................................... SUCCESS [1:10.547s]
[INFO] OpenJPA Aggregate Jar ................................. SUCCESS [1.547s]
[INFO] OpenJPA Distribution .................................. SUCCESS [0.141s]
[INFO] OpenJPA Integration Tests ............................. SUCCESS [0.000s]
[INFO] OpenJPA Examples Integration Tests .................... SUCCESS [0.000s]
[INFO] OpenJPA JPA TCK Integration Tests ..................... SUCCESS [0.000s]
[INFO] OpenJPA Xmlmapping 1.5 ................................ SUCCESS [0.015s]
[INFO] OpenJPA Persistence Examples .......................... SUCCESS [0.031s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 minute 23 seconds
[INFO] Finished at: Fri Jun 29 10:18:45 CDT 2007
[INFO] Final Memory: 10M/28M
[INFO] ------------------------------------------------------------------------

2) Results: base revision plus patch applied, run with default security disabled.
            > mvn test 
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] OpenJPA ............................................... SUCCESS [0.000s]
[INFO] OpenJPA Utilities ..................................... SUCCESS [7.718s]
[INFO] OpenJPA Kernel ........................................ SUCCESS [3.625s]
[INFO] OpenJPA JDBC .......................................... SUCCESS [0.407s]
[INFO] OpenJPA XML Store ..................................... SUCCESS [0.031s]
[INFO] OpenJPA Kernel 1.5 .................................... SUCCESS [0.094s]
[INFO] OpenJPA JPA ........................................... SUCCESS [0.093s]
[INFO] OpenJPA JDBC 1.5 ...................................... SUCCESS [0.032s]
[INFO] OpenJPA JPA JDBC ...................................... SUCCESS [1:09.453s]
[INFO] OpenJPA Aggregate Jar ................................. SUCCESS [1.156s]
[INFO] OpenJPA Distribution .................................. SUCCESS [0.125s]
[INFO] OpenJPA Integration Tests ............................. SUCCESS [0.000s]
[INFO] OpenJPA Examples Integration Tests .................... SUCCESS [0.000s]
[INFO] OpenJPA JPA TCK Integration Tests ..................... SUCCESS [0.000s]
[INFO] OpenJPA Xmlmapping 1.5 ................................ SUCCESS [0.031s]
[INFO] OpenJPA Persistence Examples .......................... SUCCESS [0.032s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 minute 23 seconds
[INFO] Finished at: Fri Jun 29 09:30:18 CDT 2007
[INFO] Final Memory: 10M/23M
[INFO] ------------------------------------------------------------------------

3) Results: base revision plus patch applied, run with security enabled.
            > mvn test -P enable-security,test-derby

[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] OpenJPA ............................................... SUCCESS [0.016s]
[INFO] OpenJPA Utilities ..................................... SUCCESS [7.969s]
[INFO] OpenJPA Kernel ........................................ SUCCESS [3.234s]
[INFO] OpenJPA JDBC .......................................... SUCCESS [0.438s]
[INFO] OpenJPA XML Store ..................................... SUCCESS [0.093s]
[INFO] OpenJPA Kernel 1.5 .................................... SUCCESS [0.110s]
[INFO] OpenJPA JPA ........................................... SUCCESS [0.078s]
[INFO] OpenJPA JDBC 1.5 ...................................... SUCCESS [0.047s]
[INFO] OpenJPA JPA JDBC ...................................... SUCCESS [1:16.312s]
[INFO] OpenJPA Aggregate Jar ................................. SUCCESS [2.094s]
[INFO] OpenJPA Distribution .................................. SUCCESS [0.125s]
[INFO] OpenJPA Integration Tests ............................. SUCCESS [0.000s]
[INFO] OpenJPA Examples Integration Tests .................... SUCCESS [0.000s]
[INFO] OpenJPA JPA TCK Integration Tests ..................... SUCCESS [0.000s]
[INFO] OpenJPA Xmlmapping 1.5 ................................ SUCCESS [0.016s]
[INFO] OpenJPA Persistence Examples .......................... SUCCESS [0.046s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 minute 30 seconds
[INFO] Finished at: Fri Jun 29 09:39:55 CDT 2007
[INFO] Final Memory: 10M/23M
[INFO] ------------------------------------------------------------------------

Albert Lee.","29/Jun/07 21:16;mprudhom;After quick review, the patch looks good to me. Anyone else have any opinions an committing it?",29/Jun/07 23:24;clr;I'm reviewing it right now. Will be done in an hour.,"30/Jun/07 00:43;clr;Very nice piece of work, Albert.

The original patch should be removed since it's no longer valid.

Just a few comments on the patch itself.

1. Typos in javadoc for almost all the methods in J2DoPrivHelper, e.g. 
PrivilegeExceptionAction should be PrivilegedExceptionAction

2. The cases where you call  this.getClass().getClassLoader()) don't need to be wrapped in a doPrivileged block. 

(From the javadoc of getClassLoader, If a security manager is present, and the caller's class loader is not null and the caller's class loader is not the same as or an ancestor of the class loader for the class whose class loader is requested, then this method calls the security manager's checkPermission method with a RuntimePermission(""getClassLoader"") permission to ensure it's ok to access the class loader for the class.)

3. In openjpa-lib/src/main/java/org/apache/openjpa/lib/util/MultiClassLoader.java
you might have missed this case:
@@ -238,12 +246,18 @@
             if (loader == THREAD_LOADER)
                 loader = Thread.currentThread().getContextClassLoader();
 
4. Several cases of try or catch with the { on the following line instead of on the same line.

5. In openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java

don't you need to have a doPrivileged around f.length() ? The javadoc would suggest so.

6. javadoc typos in newFIleOutputStreamAction methods in J2Helper class

7. I don't understand the rationale for newInstanceOfAction. I guess I don't know what a BCClass is and why its behavior is different from Class.
","02/Jul/07 16:36;allee8285;Craig, Thanks for the detailed review.

>> 1. Typos in javadoc for almost all the methods in J2DoPrivHelper, e.g.
PrivilegeExceptionAction should be PrivilegedExceptionAction

Done.

>> 2. The cases where you call this.getClass().getClassLoader()) don't need to be wrapped in a doPrivileged block.
>>
>> (From the javadoc of getClassLoader, If a security manager is present, and the caller's class loader is not null and the caller's class loader is not the same as or an ancestor of the class loader for the class whose class loader is requested, then this method calls the security manager's checkPermission method with a RuntimePermission(""getClassLoader"") permission to ensure it's ok to access the class loader for the class.)

Done. There are 14 instances that can take advantage of these performance short-cut.

>> 3. In openjpa-lib/src/main/java/org/apache/openjpa/lib/util/MultiClassLoader.java
you might have missed this case:
>> @@ -238,12 +246,18 @@
             if (loader == THREAD_LOADER)
                 loader = Thread.currentThread().getContextClassLoader();
 
Good eye.. Done.

>> 4. Several cases of try or catch with the { on the following line instead of on the same line.

All fixed up

>> 5. In openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java
>> 
>> don't you need to have a doPrivileged around f.length() ? The javadoc would suggest so.

You are correct. Somehow I don't get any security exception even without the doPriv wrapping. I have added a new lengthAction and ""do the right thing"" now.

>> 6. javadoc typos in newFIleOutputStreamAction methods in J2Helper class

Done.

>> 7. I don't understand the rationale for newInstanceOfAction. I guess I don't know what a BCClass is and why its behavior is different from Class. 

The BCClass is from serp and it needs getClassLoader permission to perform some privileged operations. Since we cannot instrument the doPriv wrapping in Serp, we delegated and moved up the doPriv in OpenJPA code base, hence the need for the 2 newCodeAction and isInstanceOfAction.

Thank everyone's input to enable the security feature in openjpa. 

If there is no further comments, we'll commit this changes. This completed and concluded Jira-244.

Albert Lee.","02/Jul/07 17:52;clr;>> 3. In openjpa-lib/src/main/java/org/apache/openjpa/lib/util/MultiClassLoader.java you might have missed this case: 
>> @@ -238,12 +246,18 @@ 
>>             if (loader == THREAD_LOADER) 
>>                 loader = Thread.currentThread().getContextClassLoader(); 
  
>Good eye.. Done. 

>> 5. In openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java don't you need to have a doPrivileged around f.length() ? The javadoc would suggest so. 

> You are correct. Somehow I don't get any security exception even without the doPriv wrapping. I have added a new lengthAction and ""do the right thing"" now. 

My only concern now is that without the above changes, your tests ran correctly. Do you have a test bench where the caller is not privileged and the OpenJPA is privileged? One suspicious change is in the security permissions file: 
+// ================================================================
+// The following permissions are needed to invoke the 'test' target in OpenJPA maven build.
+grant {
+  permission java.security.AllPermission;
+};
+

This would appear to grant everyone AllPermissions, which might explain why the tests all work. Can this be restricted to granting permission to just the test framework (javax.junit) and see what happens?

","02/Jul/07 19:25;allee8285;Craig,

I wrote a small program to test the validity of the required permission for File.length() and it showed below that proper permission/doPriv is required for this method and it matches the javadoc description.

------------------------------------------

package test;
import java.io.File;
public class TestFileLength {
    public static void main(String[] args) {
        File f = new File(""C:\\a.workspace\\eclipse.workspace\\ejb3.serv1\\testSer\\src\\test\\TestFileLength.java"");
        System.out.println(f.length());
    }
}

C:\a.workspace\eclipse.workspace\ejb3.serv1\testSer\build\classes>type j2.security.test.policy
grant {
     permission java.io.FilePermission       ""<<ALL FILES>>"",    ""read"";
};

C:\a.workspace\eclipse.workspace\ejb3.serv1\testSer\build\classes>java -cp . test.TestFileLength
1266

C:\a.workspace\eclipse.workspace\ejb3.serv1\testSer\build\classes>java -cp . -Djava.security.manager test.TestFileLength

Exception in thread ""main"" java.security.AccessControlException: Access denied (java.io.FilePermission C:\a.workspace\ec
lipse.workspace\ejb3.serv1\testSer\src\test\TestFileLength.java read)
        at java.security.AccessController.checkPermission(AccessController.java:104)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:547)
        at java.lang.SecurityManager.checkRead(SecurityManager.java:886)
        at java.io.File.length(File.java:839)
        at test.TestFileLength.main(TestFileLength.java:38)

C:\a.workspace\eclipse.workspace\ejb3.serv1\testSer\build\classes>java -cp . -Djava.security.manager -Djava.security.policy=j2.security.test.policy test.TestFileLength
1266

C:\a.workspace\eclipse.workspace\ejb3.serv1\testSer\build\classes>
------------------------------------------

May be the reason the tests passed before is because the first condition of the expression in XMLFileHandler is false and the f.length() is not evaluated.

-        if (!f.exists() || f.length() == 0)

BTW, scanning for .length() in the source code one more time and I found another instance of _file.length() that needs the doPriv. I corrected the problem and a new patch is attached.

Albert Lee.

","02/Jul/07 21:33;clr;Thanks for your attention to detail here. I'm still concerned that the patch to the security policy file that grants all permissions to all code bases masks the issues. See my comments from earlier today 10:52 AM.

Craig","03/Jul/07 19:13;allee8285;Craig,

After some experimentation to narrow down the code bases and permissions required  for the test bucket, here is the refined policy:

// derby code base
grant CodeBase ""file:///${user.home}/.m2/repository/org/apache/derby/derby/-"" {

    permission java.io.FilePermission           ""<<ALL FILES>>"",    ""read,write,delete"";
    permission java.lang.RuntimePermission                          ""createClassLoader"";
    permission java.util.PropertyPermission     ""derby.*"",          ""read"";
};

// openjpa code base.
grant CodeBase ""file:///${test.basedir}/-"" {

    permission java.io.FilePermission           ""<<ALL FILES>>"",    ""read,write"";
    permission java.io.SerializablePermission                       ""enableSubstitution"";
    permission java.lang.RuntimePermission                          ""accessDeclaredMembers"";
    permission java.lang.RuntimePermission                          ""createClassLoader"";
    permission java.lang.RuntimePermission                          ""getClassLoader"";
    permission java.lang.RuntimePermission                          ""setIO"";
    permission java.lang.reflect.ReflectPermission                  ""suppressAccessChecks"";
    permission java.util.PropertyPermission     ""*"",                ""read,write"";
};

// depending packages code base, e.g junit, surefire etc.
grant CodeBase ""file:///${user.home}/.m2/repository/-"" {

    permission java.io.FilePermission           ""<<ALL FILES>>"",    ""read,write"";
    permission java.io.SerializablePermission                       ""enableSubstitution"";
    permission java.lang.RuntimePermission                          ""accessDeclaredMembers"";
    permission java.lang.RuntimePermission                          ""createClassLoader"";
    permission java.lang.RuntimePermission                          ""getClassLoader"";
    permission java.lang.RuntimePermission                          ""setContextClassLoader"";
    permission java.lang.RuntimePermission                          ""setIO"";
    permission java.lang.reflect.ReflectPermission                  ""suppressAccessChecks"";
    permission java.util.PropertyPermission     ""*"",                ""read,write"";
};

Attached is a new patch with this new policy.

I hope this has addressed your concern.

Albert Lee,","03/Jul/07 19:24;clr;Nice job. Ship it.

Craig","03/Jul/07 22:50;mprudhom;I'm re-opening the issue because it looks like there are at least a few secure calls that were missed. I ran a test by building a new rt.jar with a java.lang.SecurityException that extends java.lang.Exception (instead of java.lang.RuntimeException), and then compiling the openjpa classes with the new rt.jar in the bootclasspath, which does a nice job at finding all the calls to methods that might throw SecutiryException.

For example, FieldMetaData.java:1477 contains the line ""Method[] methods = cls.getMethods()"".

Are these oversights, or is there some reason that these calls don't need to be wrapped in doPriv blocks?","03/Jul/07 23:36;clr;I almost commented on this earlier. I'm not sure that the grant of CodeBase ""file:///${user.home}/.m2/repository/-"" { and grant CodeBase ""file:///${test.basedir}/-"" { are correct.

The grants might mask the required grants in OpenJPA by ""catching"" the illegal access by the test case or the framework. 

Do we know why the test.basedir needs e.g. suppressAccessChecks? Do the test cases themselves use reflection?","04/Jul/07 02:29;allee8285;Marc,

Finding 'ALL' the security sensitive calls are tedious and error-prone. I probably have missed some along the way.

I like your approach to get a more complete picture and catch them all.  I'll try to see if I can go through it one more time to be sure.

Stay tune.
Albert Lee.","05/Jul/07 03:24;allee8285;>> I'm re-opening the issue because it looks like there are at least a few secure calls that were missed. I ran a test by building a new rt.jar with a java.lang.SecurityException that extends java.lang.Exception (instead of java.lang.RuntimeException), and then compiling the openjpa classes with the new rt.jar in the bootclasspath, which does a nice job at finding all the calls to methods that might throw SecutiryException.

This is a reasonable technique to catch some/most of the methods.  If the calling method has a try {  } catch (Exception e)... bracket the security sensitive call, it will still compile without error.  I'll need to use some other means, in combination to this suggestion, to get a more complete picture.

>> For example, FieldMetaData.java:1477 contains the line ""Method[] methods = cls.getMethods()"".

>> Are these oversights, or is there some reason that these calls don't need to be wrapped in doPriv blocks?

There are a set of getter methods in Class.class, e.g. getMethod(s), getField(s), getClasses, getConstructor(s) etc.. documented to throw SecurityException. The contract for these methods are:

-----------------------------
    SecurityException - If a security manager, s, is present and any of the following conditions is met:

        * invocation of s.checkMemberAccess(this, Member.PUBLIC) denies access to the field
        * the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of s.checkPackageAccess() denies access to the package of this class 
-----------------------------

The reason no doPriv is needed for these conditons are:
1) Since all these methods returns public/visible constructs, s.CheckMemberAccess(PUBLIC) will always pass with no exception.
2) If s.checkPackageAccess() is tested, we need to make sure the package of this class is not in java.security 's ""package.access"" list. If it is, explicit permission must be specified in the policy, Typically, I only see ""sun."" package is in this ""package.access"" list, therefore, we do not see any security violation for this condition.

I'm continuing to investigate and make sure no security sensitive method calls are missed. I'll leave the Jira report open for further required changes.

Thanks Marc.
Albert Lee.","05/Jul/07 03:42;allee8285;>> I almost commented on this earlier. I'm not sure that the grant of CodeBase ""file:///${user.home}/.m2/repository/-"" { and grant CodeBase ""file:///${test.basedir}/-"" { are correct.

Typically a security exception stack looks something like this:

java.security.AccessControlException: Access denied (java.util.PropertyPermission localRepository write)
        at java.security.AccessController.checkPermission(AccessController.java:104)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:547)
        at java.lang.System.setProperty(System.java:385)
        at org.apache.maven.surefire.booter.SurefireBooter.setSystemProperties(SurefireBooter.java:624)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:692)

or

java.security.AccessControlException: Access denied (java.lang.reflect.ReflectPermission suppressAccessChecks)
        at java.security.AccessController.checkPermission(AccessController.java:104)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:547)
        at java.lang.reflect.AccessibleObject.setAccessible(AccessibleObject.java:119)
        at org.apache.openjpa.event.MethodLifecycleCallbacks.makeCallback(MethodLifecycleCallbacks.java:87)
        at org.apache.openjpa.event.LifecycleEventManager.makeCallbacks(LifecycleEventManager.java:329)
        at org.apache.openjpa.event.LifecycleEventManager.fireEvent(LifecycleEventManager.java:291)
        at org.apache.openjpa.kernel.BrokerImpl.fireLifecycleEvent(BrokerImpl.java:671)
        at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2393)
        at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2244)
        at org.apache.openjpa.kernel.DelegatingBroker.persist(DelegatingBroker.java:1010)
        at org.apache.openjpa.persistence.EntityManagerImpl.persist(EntityManagerImpl.java:541)
        at org.apache.openjpa.persistence.callbacks.TestExceptionsFromCallbacks.testPrePersistException(TestExceptionsFromCallbacks.java:50)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:615)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:615)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:210)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:135)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:122)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:129)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:615)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:225)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:747)

The 3 major packages that needs security permission are org.apache.maven.surefire.*, junit.* and org.apache.*.Test*. The CodeBase ""file:///${user.home}/.m2/repository/-"" is for the first 2 package category and CodeBase ""file:///${test.basedir}/-"" is for the openjpa test cases. So the 'grant's are needed for these CodeBase. 

I can further narrow down the surefire and junit. However some of the openjpa tests use the same packages as the code (e.g. org.apache.openjpa.persistence.jdbc), so the grant codebase for the tests may not be specific just to the test packages.

>> The grants might mask the required grants in OpenJPA by ""catching"" the illegal access by the test case or the framework.

I agree, see reason before.

>> Do we know why the test.basedir needs e.g. suppressAccessChecks? Do the test cases themselves use reflection?

This is a oversight because AccessibleObject.setAccessible is not being bracketted with doPrive.  I'll get this fix.

Albert Lee.","08/Aug/07 23:55;allee8285;After a more comprehensive search, here is the second ( and hopefully last ) round of changes needed to enable Java 2 security.","09/Aug/07 00:22;clr;Looks good. Just a couple of comments:

1. Lots of cases of white space differences. Here's an example:
Index: openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java
===================================================================
--- openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java	(revision 562121)
+++ openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java	(working copy)
@@ -14,7 +14,7 @@
  * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
- * under the License.    
+ * under the License.

I have no objection to cleaning up white space (removing trailing spaces, converting tabs to spaces, etc.) but it should be a separate checkin with an innocuous ""Fixed white space"" comment.

2. In file Index: openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java
should we define a new action for this case:
@@ -104,7 +105,12 @@
             throws IOException {
             super(delegate);
             _ctx = ctx;
-            enableReplaceObject(true);
+            AccessController.doPrivileged(new PrivilegedAction() {
+                public Object run() {
+                    enableReplaceObject(true);
+                    return null;
+                }
+            });
         }
like J2DoPrivHelper.replaceObject()?

3. And the same for enableResolveObject?

","09/Aug/07 19:18;allee8285;Craig, 

Thanks for reviewing the patch.

Regarding the Serialization changes that the enableReplaceObject PrivilegedAction is created in-line in the code and not in J2DoPrivHelper, the reasons are:

1) PersistentObjectOutputStream extends ObjectOutputStream.
2) enabelReplaceObject is defined in ObjectOutputStream and is qualified as protected.
3) enabelReplaceObject is called in the PersistentObjectOutputStream constructor.
4) Initially, I had the following helper to get the enableReplaceObjectAction, 

    public static final PrivilegedAction enableReplaceObjectAction(
        final ObjectOutputStream oos, final boolean enable) {
        return new PrivilegedAction() {
            public Object run() {
                oos.enableReplaceObject(enable);
                return null;
            }
        };
    }

but this will not compile due to:

J2DoPrivHelper.java: enableReplaceObject(boolean) has protected access in java.io.ObjectOutputStream
                oos.enableReplaceObject(enable);
                   ^

Hence the in-line alternative is used to perform the doPrivlege call.

The same reason applies to the ObjectInputStream.enableResolveObject method call.

Albert Lee.","10/Aug/07 13:05;kwsutter;I believe Albert's patch that I just committed now resolves this Issue.  As Albert pointed out, hopefully we have found and fixed all of these java 2 security holes.",,,
Extra SQL on lazy CMR load,OPENJPA-241,12369742,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,rob.wisniewski,rob.wisniewski,19/May/07 12:41,23/Jul/08 23:08,14/Mar/19 03:02,22/Jul/08 18:01,1.0.0,,,,,,,,,1.2.0,,,,,sql,,,,,,0,,"This issue is similar to openjpa-134 but occurs in a slightly different manner.

I've got two entities:

Account (LAZY) (one) <--------> (many) (EAGER) Holding

So when I load account nothing is loaded from holdings, but once I load the holding, I observe each holding separately making a database call to load it's eager account.  This is quite alot of overhead, and through a simple conditional check we should be able to avoid it.  Essentially if we're loading an entity from a CMR, and the multiplicity of the field from the bidirectional relationship is one, then we don't need to load the data for that entity.  We did something similar to this in openjpa-134 when everything was eager (essentially avoiding the extra left out joing back into account).  Can we avoid these separate calls?",all,,,,,,,,,,,,,,,,,,,,,21/Jul/08 23:49;faywang;openjpa_241.patch;https://issues.apache.org/jira/secure/attachment/12386589/openjpa_241.patch,23/Jul/08 23:08;faywang;openjpa_241_1.patch;https://issues.apache.org/jira/secure/attachment/12386767/openjpa_241_1.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-07-21 23:49:50.079,,,no_permission,,,,,,,,,,,160571,,,Wed Jul 23 23:08:16 UTC 2008,,,,,,,0|i0z1jj:,202552,,,,,,,,"21/Jul/08 23:49;faywang;The attached patch fixes the scenario described by Rob. The following is the test I used to reproduce the problem:

@Entity
public class Customer {
...
    @OneToMany(fetch=FetchType.LAZY, mappedBy=""customer"")
    private Collection<Order> orders = new ArrayList<Order>();
...
}

@Entity
public class Order {
	@Id 
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	 int oid;
	
	 double amount;
	 boolean delivered;
	 
	 @ManyToOne (fetch=FetchType.EAGER)
	 Customer customer;
...
}

The test case:

        String query = ""select c FROM Customer c"";
        Query q = em.createQuery(query);
        List list = q.getResultList();
        for (int i = 0; i < list.size(); i++) {
            Customer c = (Customer)list.get(i);
            System.out.println(""Customer = "" + c);
            Collection orders = c.getOrders();
            for (Iterator iter=orders.iterator(); iter.hasNext();) {
                Order order = (Order)iter.next();
                System.out.println(""order = "" + order);
            }
        }

As Rob indicates, since the Orders field in the Customer entity is lazy, when the Customer is first loaded, the Orders will not be loaded. After the Orders is loaded, the extra join sql is executed to get the customer field in the Order because it is an eager field.

The above test generates the following sql:

(1) SELECT t0.countryCode, t0.id, t0.version, t0.city, t0.state, t0.street, t0.zip 
     FROM PdqCustomer t0 

(2) SELECT t0.name FROM PdqCustomer t0 WHERE t0.countryCode = ? AND t0.id = ? 

(3) SELECT t0.oid, t0.version, t0.amount, t0.delivered 
      FROM PdqOrder t0 WHERE t0.CUSTOMER_COUNTRYCODE = ? AND t0.CUSTOMER_ID = ? 

(4) SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip 
       FROM PdqOrder t0 
       INNER JOIN PdqCustomer t1 
       ON t0.CUSTOMER_COUNTRYCODE = t1.countryCode AND t0.CUSTOMER_ID = t1.id 
        WHERE t0.oid = ?  optimize for 1 row

(5) SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip 
      FROM PdqOrder t0 
      INNER JOIN PdqCustomer t1 
     ON t0.CUSTOMER_COUNTRYCODE = t1.countryCode AND t0.CUSTOMER_ID = t1.id 
      WHERE t0.oid = ?  optimize for 1 row

(6) SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip 
      FROM PdqOrder t0 
      INNER JOIN PdqCustomer t1 
      ON t0.CUSTOMER_COUNTRYCODE = t1.countryCode AND t0.CUSTOMER_ID = t1.id 
      WHERE t0.oid = ?  optimize for 1 row

(7) SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip 
      FROM PdqOrder t0 
      INNER JOIN PdqCustomer t1 
      ON t0.CUSTOMER_COUNTRYCODE = t1.countryCode AND t0.CUSTOMER_ID = t1.id 
      WHERE t0.oid = ?  optimize for 1 row
 
The purpose of sql (4) - (7) is to retrieve the inverse relationship of Customer in the Order entity. The attached fix will detect this relationship to get rid of these sql.  

Please note that this patch included the fix in JIRA-134 scenario 3. Please code review it. Any comments are mostly appreciated.

",22/Jul/08 18:01;fancy;Patch from Fay Wang has been committed in svn r678828,"23/Jul/08 23:08;faywang;The attached patch addresses the following issues raised by Pinaki:

1. Should all the fields including superclass fields be considered for matching? getDeclaredFieldMappings() only return the fields declared in the current class.
2. Can be modified from linear scan to lookup. Please see ClassMapping.getField(String fieldName) or ClassMapping.getDeclaredField(String fieldName).
3. Test cases?

The test case will be attached to JIRA-292.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Value.setAliases does not copy alias strings,OPENJPA-237,12368804,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,dezzio,dezzio,07/May/07 23:10,09/Mar/10 18:32,14/Mar/19 03:02,21/May/07 16:36,0.9.7,,,,,,,,,1.0.0,,,,,lib,,,,,,0,,"The org.apache.openjpa.lib.conf.Value.setAliases method does not copy the array of strings passed as a parameter.  As a result, later operations on the Value object's aliases can change the array that the caller is using.  This method should be pass by value rather than by reference -- in other words, the method should copy the array.",,,,,,,,,,,,,,,,,,,,,,07/May/07 23:11;dezzio;Value.diff;https://issues.apache.org/jira/secure/attachment/12356891/Value.diff,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-05-21 16:36:05.122,,,no_permission,,,,,,,,,,,160568,,,Mon May 21 16:36:05 UTC 2007,,,,,,,0|i0zb93:,204125,,,,,,,,"07/May/07 23:11;dezzio;SVN diff for the change required, plus a test case.",21/May/07 16:36;mprudhom;Committed patch.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Top level POM declares a compile-time dependency on JUnit,OPENJPA-233,12368469,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,clr,clr,clr,02/May/07 14:50,09/Mar/10 18:32,14/Mar/19 03:02,17/May/07 01:38,0.9.7,,,,,,,,,1.0.0,,,,,build / infrastructure,,,,,,0,,"trunk/pom.xml declares the following maven dependency on JUnit. 
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>compile</scope>
        </dependency>

The dependency should be test, not compile, as required only by test components.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160564,,,Thu May 17 01:38:26 UTC 2007,,,,,,,0|i1dpcn:,288204,,,,,,,,"02/May/07 14:55;clr;This patch changes the dependency from compile to test.

Index: pom.xml
===================================================================
--- pom.xml     (revision 534391)
+++ pom.xml     (working copy)
@@ -220,7 +220,7 @@
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
             <version>3.8.1</version>
-            <scope>compile</scope>
+            <scope>test</scope>
         </dependency>
     </dependencies>
     <build>
","02/May/07 15:28;clr;> Why not move on up to the 4.1 junit suite as well while we are at it. Backwards compatible and more robust? 

I guess because I believe in making one change at a time. I'm not sure I have the complete test infrastructure to make sure that a new version of JUnit would work. There are several test suites outside of the project that might be affected.",17/May/07 01:38;clr;checked in patch.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect handling of cascading bidirectional collections during merge/attach,OPENJPA-231,12368352,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,gergul,gergul,01/May/07 01:07,09/Mar/10 18:32,14/Mar/19 03:02,12/May/08 05:43,0.9.7,,,,,,,,,1.1.0,,,,,kernel,,,,,,2,,"As posted on open-jpa-dev mailing list:

-----

I'm having a problem merging an entity, here's the simplified structure:

Class A {     @OneToMany(cascade=CascadeType.ALL, mappedBy=""parent"")
   Set<B> b_set;
   ...
}

Class B {
   @ManyToOne
   A parent;

   @OneToMany(cascade=CascadeType.ALL, mappedBy=""parent"")
   Set<C> c_set;
   ...
}

Class C {
   @ManyToOne
   B parent;
   ...
}

New instances of A,B,C are persisted correctly. However when I retrieve A, add some entries to A.b_set (with some of the new B entries have attached C's), em.merge(A) fails:

- If A is detached:

    org.apache.openjpa.persistence.ArgumentException: Encountered new object ""B@..."" in persistent field ""C.parent"" of managed object ""C@..."" during attach.  However, this field does not allow cascade attach.  You cannot attach a reference to a new object without cascading.

- If A is not detached:
                 C instances are inserted before B instances, resulting in a foreign key violation.

Setting openjpa.jdbc.SchemaFactory to 'native(ForeignKeys=true)' does not seem to have an effect.

----",platform-independent,,,,,,,,,,,,,,,,,,,,,01/May/07 01:08;gergul;jira-test-case.zip;https://issues.apache.org/jira/secure/attachment/12356555/jira-test-case.zip,10/May/08 22:46;xiaoqinfeng2000;openjpa-231-1.1.x.patch;https://issues.apache.org/jira/secure/attachment/12381828/openjpa-231-1.1.x.patch,20/Jul/07 01:56;m_fuchs;openjpa-231.patch;https://issues.apache.org/jira/secure/attachment/12362189/openjpa-231.patch,05/May/08 23:45;xiaoqinfeng2000;openjpa-jira-231-255-new.patch;https://issues.apache.org/jira/secure/attachment/12381461/openjpa-jira-231-255-new.patch,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2007-07-19 21:29:37.126,,,no_permission,,,,,,,,,,,160562,,,Sat May 10 22:46:48 UTC 2008,,,,,,,0|i0z1j3:,202550,,,,,,,,01/May/07 01:08;gergul;Attaching test-case to reproduce the issue and suggested patch.,"01/May/07 01:11;gergul;Note that the patch is developed against a nightly-snapshot of 0.9.7. 

Bug is reproducible both with released 0.9.7 and latest 0.9.8-snapshot.","02/May/07 20:01;gergul;Further testing reveals that the patch I submitted solves only detached object merge case. Persisting and later merging in a single EntityManager session produces unreliable results, sometimes insert statements of C precede insert statements of B resulting in a FK violation, other times the statements are executed in the correct order --I have no idea as to why the order would change in different test runs with identical configuration. ","19/Jul/07 21:29;kwsutter;Just curious...  If you put the CascadeType.ALL on the ManyToOne annotations, does your merge processing work okay?  That should not be required, but I am wondering whether we are dealing with similar problems.  Thanks.","20/Jul/07 01:42;gergul;Kevin, 

Just reran tests against latest svn with CascadeType.ALL on ManyToOne annotations, detached testcase fails with duplicate key exceptions, attached testcase passes --openjpa-friendly version of testcases are at https://issues.apache.org/jira/secure/attachment/12360321/merge-testcases.patch in case you want to run them yourself. Also see https://issues.apache.org/jira/browse/OPENJPA-255 for a similar issue with detached objects, it's basically a different manifestation of the same problem.","20/Jul/07 01:56;m_fuchs;I propose a slight change to Gokhan's patch, please see openjpa-231.patch.","20/Jul/07 03:11;gergul;That'll do too, but still we'd need the isManaged() check to fix OPENJPA-255 as well, see https://issues.apache.org/jira/secure/attachment/12359302/openjpa-jira-255.patch.","05/May/08 23:45;xiaoqinfeng2000;I added TestNoCascadeOneToManyMerge.java based on the test case provided in this bug.
The attached patch includes both tests and fixes for open-231 and open-255.",10/May/08 22:46;xiaoqinfeng2000;This fix is for openjpa1.1.x branch. Test case is also included in this patch.,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Handle guaranteed delivery of Data Cache events on normal JVM termination using TCPRemoteCommitProvider,OPENJPA-230,12368224,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,vbhatia,vbhatia,27/Apr/07 20:50,09/Mar/10 18:32,14/Mar/19 03:02,29/May/07 08:19,0.9.0,0.9.6,0.9.7,,,,,,,1.0.0,,,,,kernel,,,,,,0,,"When an application is commiting a transaction and then terminating, often not all events regarding Data Cache are dispatched by the TCPRemoteCommitProvider. It seems that the JVM on termination is not waiting until TCPRemoteCommitProvider has dispatched all events regarding Data Cache. In this way some cache synchronization is lost.",,,,,,,,,,,,,,,,,,,,,,27/Apr/07 21:51;pcl;OPENJPA-230.patch;https://issues.apache.org/jira/secure/attachment/12356440/OPENJPA-230.patch,27/Apr/07 21:11;pcl;OPENJPA-230.patch;https://issues.apache.org/jira/secure/attachment/12356438/OPENJPA-230.patch,27/Apr/07 21:27;vbhatia;reproducer.zip;https://issues.apache.org/jira/secure/attachment/12356439/reproducer.zip,27/Apr/07 20:54;vbhatia;soln.diff;https://issues.apache.org/jira/secure/attachment/12356436/soln.diff,21/May/07 09:42;vbhatia;testcase.zip;https://issues.apache.org/jira/secure/attachment/12357737/testcase.zip,,,,,,,,,,5.0,,,,,,,,,,,,,,,,,,,2007-04-27 21:11:45.366,,,no_permission,,,,,,,,,,,160561,,,Tue May 29 08:19:07 UTC 2007,,,,,,,0|i1dpd3:,288206,,,,,,,,27/Apr/07 20:54;vbhatia;Proposed Solution.,"27/Apr/07 21:11;pcl;It'd be nice to not have to synchronize. What about if we made the threads non-daemon, and just call setRunning(false) instead? See attached (completely-untested) patch.

Also, I think that that boolean should be volatile to ensure thread-safety.","27/Apr/07 21:25;vbhatia;Well I have though about it, but it fails the following scenario.

1. Four Threads running and eight Packets in queue. The four threads are busy sending packets.
3. In case, _keepRunning is set to false, four packets will still be left to synchronize as threads exit from while loop.","27/Apr/07 21:51;pcl;Good point -- _keepRunning is a bit too abrupt.

How does this work?","27/Apr/07 22:49;vbhatia;It works based on size of the packet queue. Once the broadcast queue is empty, it interrupts the thread assuming that all the packets are broadcasted.

Why do _processLock is required?
It may call interrupt even if the thread is calling sendUpdateQueue if we dont have a syncronization. I was thinking about having boolean variable, but that will have synchronization issues, and thread may be interrupted without completely sending the packet.","27/Apr/07 22:59;vbhatia;I tried this too, but what will happen in case thread is already in wait() state, and there are no more packets. join() will keep on waiting forever and process will never exit.",21/May/07 09:42;vbhatia;JUnit testcase.,29/May/07 08:19;vbhatia;The issue is resolved. Thanks,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA fails with MappedSuperclasses and Entities with the same short names,OPENJPA-229,12368016,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,tbee,25/Apr/07 09:22,09/Mar/10 18:32,14/Mar/19 03:02,26/Apr/07 19:59,0.9.0,0.9.6,0.9.7,,,,,,,1.0.0,,,,,kernel,,,,,,0,,"When running the test case from OPENJPA-228 (after a few modifications to get it working), I get the exception included below. If I change the 'Article' mapped superclass to be named 'ArticleBase', things work.

It looks like this is happening because multiple classes are registering for the same alias. We should change the enhancer to not register aliases for mapped superclasses.

Exception in thread ""main"" <0.0.0 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: 0
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:805)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:766)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:762)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:517)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:230)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:269)
	at nl.reinders.bm.BMTestOpenJPA.main(BMTestOpenJPA.java:41)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)
Caused by: java.lang.ArrayIndexOutOfBoundsException: 0
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.appendTo(PCPath.java:636)
	at org.apache.openjpa.jdbc.kernel.exps.FilterValueImpl.appendTo(FilterValueImpl.java:62)
	at org.apache.openjpa.jdbc.kernel.exps.FilterValueImpl.appendTo(FilterValueImpl.java:58)
	at org.apache.openjpa.jdbc.sql.DBDictionary.appendCast(DBDictionary.java:2486)
	at org.apache.openjpa.jdbc.sql.DBDictionary.comparison(DBDictionary.java:2443)
	at org.apache.openjpa.jdbc.kernel.exps.CompareExpression.appendTo(CompareExpression.java:75)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.buildWhere(SelectConstructor.java:238)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.evaluate(SelectConstructor.java:79)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.createWhereSelects(JDBCStoreQuery.java:330)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeQuery(JDBCStoreQuery.java:169)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:677)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:985)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:796)
	... 11 more
","WindowsXP SP2 full updates 2007-04-25, Informix 10, Java 1.6.0",,,,,,,,,,OPENJPA-228,,,,,,,,,,,25/Apr/07 21:39;pcl;OPENJPA-229.patch;https://issues.apache.org/jira/secure/attachment/12356273/OPENJPA-229.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160560,,,Wed Apr 25 21:39:55 UTC 2007,,,,,,,0|i0z43z:,202968,,,,,,,,"25/Apr/07 21:39;pcl;This fixes the problem by changing the enhancer to not register aliases for types that are not mapped, as determined by a call to ClassMetaData.isMapped(). Thoughts?",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Could not locate metadata for the class using alias,OPENJPA-228,12368005,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,tbee,tbee,25/Apr/07 06:59,25/Apr/07 09:22,14/Mar/19 03:02,25/Apr/07 09:21,0.9.6,0.9.7,,,,,,,,,,,,,,,,,,,0,,"This: 

	        List lArticles = lEntityManager.createQuery(""select a from Article a where a.iArticlenr < 103"").getResultList(); // where articlenr < 103

Results in:

Exception in thread ""main"" <0.9.7-incubating fatal user error> org.apache.openjpa.persistence.ArgumentException: Could not locate metadata for the class using alias ""Article"". Registered alias mappings: ""{Article=null}""
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:348)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getClassMetaData(JPQLExpressionBuilder.java:167)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.resolveClassMetaData(JPQLExpressionBuilder.java:145)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:214)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:184)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateType(JPQLExpressionBuilder.java:177)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.access$500(JPQLExpressionBuilder.java:64)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.populate(JPQLExpressionBuilder.java:1671)
	at org.apache.openjpa.kernel.jpql.JPQLParser.populate(JPQLParser.java:55)
	at org.apache.openjpa.kernel.ExpressionStoreQuery.populateFromCompilation(ExpressionStoreQuery.java:148)
	at org.apache.openjpa.kernel.QueryImpl.newCompilation(QueryImpl.java:649)
	at org.apache.openjpa.kernel.QueryImpl.compilationFromCache(QueryImpl.java:630)
	at org.apache.openjpa.kernel.QueryImpl.compileForCompilation(QueryImpl.java:596)
	at org.apache.openjpa.kernel.QueryImpl.compileForExecutor(QueryImpl.java:658)
	at org.apache.openjpa.kernel.QueryImpl.getOperation(QueryImpl.java:1483)
	at org.apache.openjpa.kernel.DelegatingQuery.getOperation(DelegatingQuery.java:123)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:219)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:269)
	at nl.reinders.bm.BMTestOpenJPA.main(BMTestOpenJPA.java:41)
","WindowsXP SP2 full updates 2007-04-25, Informix 10, Java 1.6.0",,,,,,,,,,,,,,,,,,,,,25/Apr/07 07:02;tbee;bm.zip;https://issues.apache.org/jira/secure/attachment/12356206/bm.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-04-25 07:10:07.209,,,no_permission,,,,,,,,,,,160559,,,Wed Apr 25 09:21:09 UTC 2007,,,,,,,0|i0z44f:,202970,,,,,,,,"25/Apr/07 07:02;tbee;This is the BM archive with ""@Entity extends @Entity"" instead of ""@Entity extends @MappedSuperclass"". 

It does not contain the OpenJPA 0.9.7 jars in order to get a smaller file.","25/Apr/07 07:10;pcl;I haven't run it yet, but a couple of things look suspicious:

1. You've got multiple @Entity classes called Article. The spec says that if an entity name is not specified, the name defaults to the short name of the entity.

2. Given that you're listing your persistent types, you should also list the generated classes as well. I think that this shouldn't be causing this problem, but it feels like it's best practice to list all or none of the classes.",25/Apr/07 09:21;pcl;Persistent classes were not enhanced prior to use. Added a better error message in r532273.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FOR READ ONLY clause getting generated for subselects,OPENJPA-222,12367509,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,wisneskid,ritika,ritika,18/Apr/07 17:01,09/Mar/10 18:35,14/Mar/19 03:02,07/Aug/07 22:30,0.9.7,,,,,,,,,,,,,,jpa,,,,,,0,,FOR READ ONLY clause is generated for subselects in DB2. which throws a DB2 Exception,,,,,,,,,,,,,,,,,,,,,,18/Apr/07 20:49;mikedd;JIRA182-subselect.patch;https://issues.apache.org/jira/secure/attachment/12355789/JIRA182-subselect.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-04-18 20:49:14.658,,,no_permission,,,,,,,,,,,160553,,,Wed Apr 18 20:49:14 UTC 2007,,,,,,,0|i0z4an:,202998,,,,,,,,18/Apr/07 20:49;mikedd;Attaching Ritika's patch here.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Examples of using ElementJoinColumn show the wrong usage,OPENJPA-220,12367411,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,jaydm,jaydm,17/Apr/07 20:58,09/Mar/10 18:32,14/Mar/19 03:02,26/Jul/08 20:58,0.9.7,,,,,,,,,1.2.0,,,,,docs,,,,,,0,,"The example in the online manual shows the usage as:
@ElementJoinColumn(name=""<child table ref column>"" target=""<parent table ref column>"")

This should be:
@ElementJoinColumn(name=""<child table ref column>"" referencedColumnName=""<parent table ref column>"")",,,,,,,,,,,,,,,,,,,,,,17/Apr/07 21:00;jaydm;openjpa-220.patch;https://issues.apache.org/jira/secure/attachment/12355716/openjpa-220.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-07-26 20:58:54.299,,,no_permission,,,,,,,,,,,160551,,,Sat Jul 26 20:58:54 UTC 2008,,,,,,,0|i1dpef:,288212,,,,,,,,"17/Apr/07 21:00;jaydm;This patch corrects the syntax in the ref_guide_mapping.xml file.

I don't know where else this should be corrected.

I could not find any other places where a code example or list of attributes was given.","06/Nov/07 16:14;jaydm;Unless the syntax of this annotation has changed - the documentation is still wrong.

I'm not sure whether this patch will still work, but - could someone take a look at this?

Thanks",26/Jul/08 20:58;ppoddar@apache.org;SVN Revision 676584,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Reflection: negative caching would be beneficial in redeployment scenarios,OPENJPA-219,12367409,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,pcl,pcl,pcl,17/Apr/07 20:31,09/Mar/10 18:32,14/Mar/19 03:02,24/Apr/07 23:38,0.9.0,0.9.6,0.9.7,,,,,,,1.0.0,,,,,kernel,,,,,,1,,"In a variety of situations, OpenJPA searches class hierarchies for fields. These searches invoke Class.getDeclaredField() in order to find non-public fields. This method throws an exception when it fails to find the specified field, and the exception creation is, as ever, slow.

It would be useful to create a static (and thus per-classloader) Map<WeakReference<Class>,Collection<String>> of fields known not to be available in a given class.

It may also be beneficial to maintain a cache of which fields *are* present in a given class, but this issue is being filed as a result of a demonstrated performance hit during deployment due to the lack of a negative cache. If we obtain quantitative data indicating that a positive cache would be useful, we might want to implement such a thing at that time.

Trace 3 (2115 occurances): [excepti][00090] java/lang/NoSuchFieldException: domainName
     at java/lang/Class.getDeclaredField(Ljava/lang/String;I)Ljava/lang/reflect/Field;(Unknown Source)
     at org/apache/openjpa/enhance/Reflection.findField(Ljava/lang/Class;Ljava/lang/String;Z)Ljava/lang/reflect/Field;(Reflection.java:101)
     at org/apache/openjpa/util/ApplicationIds.toPKValues(Ljava/lang/Object;Lorg/apache/openjpa/meta/ClassMetaData;)[Ljava/lang/Object;
(ApplicationIds.java:89)

",,,,,,,,,,,,,,,,,,,,,,24/Apr/07 21:06;bretweinraub;OPENJPA-219-NoLeak.patch;https://issues.apache.org/jira/secure/attachment/12356183/OPENJPA-219-NoLeak.patch,18/Apr/07 00:29;pcl;OPENJPA-219.patch;https://issues.apache.org/jira/secure/attachment/12355723/OPENJPA-219.patch,24/Apr/07 22:19;bretweinraub;openJPABenchmark.tar.gz;https://issues.apache.org/jira/secure/attachment/12356186/openJPABenchmark.tar.gz,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-04-23 20:00:37.073,,,no_permission,,,,,,,,,,,160550,,,Tue Apr 24 22:19:14 UTC 2007,,,,,,,0|i0z1i7:,202546,,,,,,,,17/Apr/07 20:37;pcl;Note that we invoke Class.getDeclaredField() (and Class.getDeclaredMethod()) in a number of places. We should take care to replace all the uses of that method with our optimized version.,"17/Apr/07 21:56;pcl;I think that this patch should fix the issue, but haven't tested it yet. I only replaced the getDeclaredField() cases that were iterating through superclasses.",18/Apr/07 00:29;pcl;New version of patch that uses iterated class instead of method argument.,"23/Apr/07 20:00;awhite;If we're going to cache, I don't see why we wouldn't cache the declared fields/methods rather than the nonexistent ones.  It would be a simple matter of keeping a Class->Set cache, where the Set is the names of the fields/methods returned by Class.getDeclaredFields/Methods().  Then we'd have both a positive (set.contains(x)) and negative (!set.contains(x)) cache.

I'd also like to see some explicit control over whether requests to find a field/method cause cache additions.  It might be that we always want caching now, but it's such a general class that I can imagine naïvely using the Reflection class's helper methods on one-off random field/method requests in the future without remembering the memory consequences.  If all use results in caching, that could be bad.  So I'd like us to either add separate caching methods or a boolean parameter to the existing methods.  And either way, we need to revisit our current use of Reflection to decide which version to use in the current code.","23/Apr/07 21:49;bretweinraub;I developed a patch version that cached both ""success"" and ""failure"" cases - here are some of the performance numbers I generated:

VM	Implementation	Benchmark Rate (ms)
Sun	1 - Original	333
Sun	2 - Cache v1	83
Sun	3 - Cache v2	40
JRockit	1 - Original	176
JRockit	2 - Cache v1	72
JRockit	3 - Cache v2	22

Where 

Original : recent svn version
Cache V1: patch above plus a couple of minor tweaks
Cache V2: caches both success and failure calls thereby minimizing calls to Reflection API.

Adding a boolean that says ""use cache"" or not would be simple.

Anyway let me add that I/we feel that permanently caching Class objects would create memory leak problems in the case where a ClassLoader were to be thrown away.  Holding the class Object in a hash will keep the ClassLoader tree from being garbage collected ; we see this anti-pattern frequently, it is pathalogical, and can eventually lead to OOME for operations that recycle class loaders.  An example would be repeatedly deploying the same application to an application server, such as done during iterative development of WebApps/EnterpriseApps.  So I/we believe to be critical to create a mechanism whereby these Class object were not held in a static context.  If this code were associated with an object then when the object was GC-ed the Class references would be eliminated therey by allowing the class loader to be GC-ed.

","23/Apr/07 21:59;bretweinraub;I will add the ""Cache v2"" version here shortly.","24/Apr/07 00:23;pcl;I agree about the mem leak problem in the patch that I created; hence my comments in the original post about using weak references. There are a number of ways that you could solve this caching problem, such as making all / part of Reflection non-static and setting up per-Configuration caches, or using weak references in the cache, or even (and probably least attractively) creating undeploy APIs.

Abe said: 
> If we're going to cache, I don't see why we wouldn't cache the declared 
> fields/methods rather than the nonexistent ones. It would be a simple
> matter of keeping a Class->Set cache, where the Set is the names of 
> the fields/methods returned by Class.getDeclaredFields/Methods(). 
> Then we'd have both a positive (set.contains(x)) and negative 
> (!set.contains(x)) cache.

As I mentioned in the original description, the bug here is that negative lookups are slow because of the exception creation. I see no reason to add extra caching if we don't know if we need it, although Bret's numbers potentially indicate that there is a benefit to positive caching. I have no problem with having a positive cache, but I think that we should only include it if it's going to help, since otherwise it'll just be one more thing contributing to memory consumption.","24/Apr/07 14:54;awhite;1. Yes, clearly we'd use our org.apache.openjpa.lib.util.concurrent. ConcurrentReferenceHashMap with weak keys to hold the Classes.

2. We have no evidence that a positive cache would consume any more memory than a negative cache in this case.  A positive cache's entry size for a given class is limited by the number of fields/methods in that class.  A negative cache's entry size is limited only by how many nonexistent field/method names we look for.  The negative cache will probably be smaller in this case except in deep inheritance hierarchies because I don't think we look for field or method names outside the inheritance hierarchy, but (a) I'm not sure of that and (b) there's no guarantee that will always be the case.

3. You know, another way to approach this would be not to cache at all, and just iterate over getDeclaredFields/Methods() looking for a match rather than using the singular getDeclaredField/Method() that throws an exception.  If that gives decent performance, we wouldn't have to worry about the memory consumption and complication of caching.  Bret, do you think you could try that out and see how it does?","24/Apr/07 15:17;pcl;> another way to approach this would be not to cache at all,
> and just iterate over getDeclaredFields/Methods() looking for a match

Good point. That would certainly be a better approach. It looks like Class.getDeclaredFields() will be a bit slower, since more memory copying happens (the array is copied before being returned -- bummer that those APIs don't use collections), but that might not be noticeable in the benchmark.","24/Apr/07 21:06;bretweinraub;Includes a non-caching performance enhancement for Reflection.findField()

Other implementations held on to references to class objects in static collections.   If the class loader which created this Class went away (like an application classloader during redeployment), this reference would prevent the ClassLoader object and associated Class objects from being garbage collected, which would have led to a memory leak.

This version is about 3X faster than the original for JRockit, and about 5X faster for HotSpot.",24/Apr/07 21:16;pcl;How does this compare to the leaky-patch version?,"24/Apr/07 22:07;bretweinraub;The no-leak version is ""cache v3"" although that's a misnomer ; there's no cache involved.

VM - Version ms

Sun - Original 333
Sun - Cache v1 83
Sun - Cache v2 40
Sun - Cache v3 73

JRockit - Original 176
JRockit - Cache v1 72
JRockit - Cache v2 22
JRockit - Cache v3 52

","24/Apr/07 22:19;bretweinraub;My benchmark code.

Easy to write a new implementation and get comparitive benchmark data.

Measurements created in this issue were generated from this code.
",,,,,,,,,,,,,,,,,,,,,,,,
pcNewInstance and ApplicationId,OPENJPA-218,12367383,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,knisterpeter,knisterpeter,17/Apr/07 14:39,09/Mar/10 18:31,14/Mar/19 03:02,02/Apr/09 20:08,0.9.6,0.9.7,,,,,,,,2.0.0-M2,,,,,kernel,,,,,,1,,"When using an application id class containing a reference to another entity (example given below) a NPE is thrown when merging/reattaching the instance to an entity manager. 
The problem is caused by the involved AttachStrategy where on line 89 (pc.pcNewInstance(null, appId, false);) the call to pcNewInstance is null for the first parameter (StateManager). This statemanager is used to retrieve the object reference when reattaching using the method pcCopyKeyFieldsFromObjectId in the pcNewInstance method.

Source for this bug:

@Entity
@Table(name = ""domain_record"")
@IdClass(DomainRecord.DomainRecordId.class)
public class DomainRecord implements Serializable {

	private static final long serialVersionUID = 2966781630801201103L;

	public static class DomainRecordId implements Serializable {

		private static final long serialVersionUID = 3629556841694516032L;

		private String zone;

		private String name;

		private Type type;

		private String data;

		public DomainRecordId() {
		}

		public DomainRecordId(DomainRecord record) {
			this.zone = record.zone.getName();
			this.name = record.name;
			this.type = record.type;
			this.data = record.data;
		}

		public DomainRecordId(String zone, String name, Type type, String data) {
			this.zone = zone;
			this.name = name;
			this.type = type;
			this.data = data;
		}

		/**
		 * @see java.lang.Object#hashCode()
		 */
		@Override
		public int hashCode() {
			final int PRIME = 31;
			int result = 1;
			result = PRIME * result + ((data == null) ? 0 : data.hashCode());
			result = PRIME * result + ((name == null) ? 0 : name.hashCode());
			result = PRIME * result + ((type == null) ? 0 : type.hashCode());
			result = PRIME * result + ((zone == null) ? 0 : zone.hashCode());
			return result;
		}

		/**
		 * @see java.lang.Object#equals(java.lang.Object)
		 */
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			final DomainRecordId other = (DomainRecordId) obj;
			if (data == null) {
				if (other.data != null)
					return false;
			} else if (!data.equals(other.data))
				return false;
			if (name == null) {
				if (other.name != null)
					return false;
			} else if (!name.equals(other.name))
				return false;
			if (type == null) {
				if (other.type != null)
					return false;
			} else if (!type.equals(other.type))
				return false;
			if (zone == null) {
				if (other.zone != null)
					return false;
			} else if (!zone.equals(other.zone))
				return false;
			return true;
		}

	}

	/**
	 * @author markusw
	 * @version $Revision$
	 */
	public enum Type {
		A, AAAA, ALIAS, CNAME, HINFO, MX, NAPTR, NS, PTR, RP, SRV, TXT
	}

	@Id
	@ManyToOne(fetch = FetchType.LAZY, cascade = { CascadeType.ALL })
	@JoinColumn(name = ""domain"", referencedColumnName = ""name"")
	private Domain zone;

	@Id
	@Column(length = 64)
	private String name;

	@Id
	@Enumerated(EnumType.STRING)
	private Type type;

	@Id
	@Column(length = 128)
	private String data;
...
}
",Java 6,,,,,,,,,,,,,,,,,,,,,01/Apr/09 21:28;faywang;OPENJPA-218-testcase.patch;https://issues.apache.org/jira/secure/attachment/12404386/OPENJPA-218-testcase.patch,01/Apr/09 20:52;faywang;OPENJPA-218.patch;https://issues.apache.org/jira/secure/attachment/12404377/OPENJPA-218.patch,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2009-04-01 17:09:12.346,,,no_permission,,,,,,,,,,,160549,,,Wed Apr 01 20:52:29 UTC 2009,,,,,,,0|i0z1hr:,202544,,,,,,,,"17/Apr/07 14:51;knisterpeter;To be more complete I'll attach the NPE stacktrace:

java.lang.NullPointerException
	at de.esw.services.model.DomainRecord.pcCopyKeyFieldsFromObjectId(DomainRecord.java)
	at de.esw.services.model.DomainRecord.pcNewInstance(DomainRecord.java)
	at org.apache.openjpa.kernel.AttachStrategy.persist(AttachStrategy.java:89)
	at org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:85)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:236)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:97)
	at org.apache.openjpa.kernel.BrokerImpl.attach(BrokerImpl.java:3124)
	at org.apache.openjpa.kernel.DelegatingBroker.attach(DelegatingBroker.java:1120)
	at org.apache.openjpa.persistence.EntityManagerImpl.merge(EntityManagerImpl.java:591)
	at org.springframework.orm.jpa.JpaTemplate$6.doInJpa(JpaTemplate.java:272)
	at org.springframework.orm.jpa.JpaTemplate.execute(JpaTemplate.java:191)
	at org.springframework.orm.jpa.JpaTemplate.merge(JpaTemplate.java:270)
	at de.esw.services.domain.DomainRecordProcessorImpl.update(DomainRecordProcessorImpl.java:53)","01/Apr/09 17:09;faywang;I tried the following scenario to reproduce this problem without success:

(1) create an EntityManager: em
(2) create a DomainRecord: record
(3) call persist: em.persist(record)
(4) em.flush()
(5) commit
(6) em.clear()
(7) em.merge(record)

This situation can only be reproduced in the following scenario:
(1) create an EntityManager: em
(2) create a DomainRecord: record
(3) em.merge(record)

When merge is called on the record, this record does not have StateManagerImpl yet, causing NPE.","01/Apr/09 20:52;faywang;The patch is to fix PCEnhancer to guard against null StateManagerImpl:

Before the patch:
-----------------------
  public void pcCopyKeyFieldsFromObjectId(Object paramObject)
  {
    ChildId localChildId = (ChildId)((ObjectId)paramObject).getId();
    this.id = localChildId.id;
    Child tmp28_27 = this;
    tmp28_27.parent = ((Parent)tmp28_27.pcStateManager.getPCPrimaryKey(localChildId, 2 + pcInheritedFieldCount));
  }

After the patch:
--------------------
  public void pcCopyKeyFieldsFromObjectId(Object paramObject)
  {
    ChildId localChildId = (ChildId)((ObjectId)paramObject).getId();
    this.id = localChildId.id;
    if (this.pcStateManager == null)
      return;
    Child tmp28_27 = this;
    tmp28_27.parent = ((Parent)tmp28_27.pcStateManager.getPCPrimaryKey(localChildId, 2 + pcInheritedFieldCount));
  }

After the patch, the test case to merge new entity with IdClass works fine. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Need to support floating point primary keys,OPENJPA-214,12366995,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,kwsutter,kwsutter,11/Apr/07 15:42,09/Mar/10 18:32,14/Mar/19 03:02,11/Apr/07 20:26,0.9.7,,,,,,,,,0.9.7,,,,,jdbc,,,,,,0,,"Dain first reported this problem on the dev mailing list:

http://www.nabble.com/Float-primary-key--tf3557137.html

>My response:
>Okay, I looked at the spec a bit closer and it looks like we need to allow for floats as primary keys:

>""The primary key (or field or property of a composite primary key) should be one of the following types:
>any Java primitive type; any primitive wrapper type; java.lang.String; java.util.Date;
>java.sql.Date. In general, however, approximate numeric types (e.g., floating point types) should
>never be used in primary keys.""

>Although the spec clearly recommends against the use of floating points, floats are a primitive type (or the Float wrapper) and need to be allowed.  With no >special ""AllowStupidApproximatePrimaryKeys"" flag.  :-)

>Am I trying to read too much into the spec or Dain's request?  This seems to be something that we need to support.

>>Abe's response:
>>Given the spec section you quoted, you're definitely right.  It's something we need to support.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-04-11 20:26:14.588,,,no_permission,,,,,,,,,,,160545,,,Wed Apr 11 20:26:14 UTC 2007,,,,,,,0|i0z493:,202991,,,,,,,,11/Apr/07 20:26;awhite;Support float/Float and double/Double primary key fields in single-field identity handling.  Fixed in revision 527648.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Query returning 2 entities w/1-1 relationship returns wrong types in the result list,OPENJPA-210,12366751,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,ghongell,ghongell,06/Apr/07 23:27,09/Mar/10 18:32,14/Mar/19 03:02,11/Jul/08 14:33,0.9.7,,,,,,,,,1.0.4,1.2.0,,,,,,,,,,0,,"Query returning 2 entities w/1-1 relationship returns [Address, Address]  instead of [Winery, Address]

""SELECT r,r.address from Winery r"" returns [Address, Address] 
""SELECT r,r.home from EmpBean r"" returns [null, AddressBean] 

does not matter if 1-1 relationship is uni-directional or bi-directional

(NOTE: ""SELECT r.address,r"" gets same Address id already exists in the L1 cache  if uni-dir relationship (issue 209))  

clear detaches all entities from the persistent context
1302  bugsmall  TRACE  [main] openjpa.Query - Executing query: SELECT r,r.home FROM EmpBean r
1302  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 755379462> executing prepstmnt 335287292 SELECT t0.empid, t1.street, t1.city, t1.state, t1.zip FROM bugsmallEmpBean t0 LEFT OUTER JOIN bugsmallAddressBean t1 ON t0.home_street = t1.street
1302  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 755379462> [0 ms] spent
1302  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 755379462> executing prepstmnt 695216496 SELECT t0.city, t0.state, t0.zip FROM bugsmallAddressBean t0 WHERE t0.street = ? [params=(String) 1]
1312  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 755379462> [10 ms] spent
java.lang.NullPointerException
	at com.ibm.websphere.ejb3sample.winetour.bugsmall.BugSmallWineryTest.test_1_1relationshipQuery_EmpBean_AddressBean(BugSmallWineryTest.java:468)
	at com.ibm.websphere.ejb3sample.winetour.bugsmall.BugSmallWineryTest.main(BugSmallWineryTest.java:103)
1352  bugsmall  TRACE  [main] openjpa.Query - Executing query: [SELECT r,r.address FROM Winery r WHERE r.wineryid = ?1] with parameters: {1=1}
1352  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 755379462> executing prepstmnt 1670669204 SELECT t0.wineryid, t1.phone, t1.city, t1.state, t1.street, t1.zip FROM bugsmallWinery t0 LEFT OUTER JOIN bugsmallAddress t1 ON t0.address_phone = t1.phone WHERE (t0.wineryid = ?) [params=(int) 1]
1362  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 755379462> [10 ms] spent
1362  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 755379462> executing prepstmnt 2097052926 SELECT t0.city, t0.state, t0.street, t0.zip FROM bugsmallAddress t0 WHERE t0.phone = ? [params=(String) 1]
1512  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 755379462> [0 ms] spent
java.lang.ClassCastException: com.ibm.websphere.ejb3sample.winetour.bugsmall.Address incompatible with com.ibm.websphere.ejb3sample.winetour.bugsmall.Winery
	at com.ibm.websphere.ejb3sample.winetour.bugsmall.BugSmallWineryTest.test_1_1relationshipQuery_Winery_Address(BugSmallWineryTest.java:374)
	at com.ibm.websphere.ejb3sample.winetour.bugsmall.BugSmallWineryTest.main(BugSmallWineryTest.java:104)
close(only used for application managed Persistent Context) inactivates the EntityManager and detaches all entities
create new Application Managed Persistent Context with no managed entities

====================================
Starting test_1_1relationshipQuery_EmpBean_AddressBean()
====================================
Shows a EmpBean and its address
String sql = ""SELECT r,r.home FROM EmpBean r WHERE r.empid = ?1""
Caution: requires _em.find(EmpBean.class,parm1) to avoid cache exception or incorrect types in result list
Caution: ""SELECT r,r.home"" currently fails, returns [null, AddressBean] instead of [EmpBean, AddressBean]
-----------------------------------------------------------------------------
1-1 query oa[0] is null 
1-1 query oa[1] = com.ibm.websphere.ejb3sample.winetour.bugsmall.AddressBean

====================================
Starting test_1_1relationshipQuery_Winery_Address()
====================================
Shows a winery and its address
String sql = ""SELECT r,r.address FROM Winery r WHERE r.wineryid = :wineryid ""
Caution: requires _em.find(Winery.class,parm1) to avoid cache exception or incorrect types in result list
Caution: ""SELECT r,r.address"" currently fails, returns [Address, Address] instead of [Winery, Address]
-----------------------------------------------------------------------------
1-1 query oa[0] = com.ibm.websphere.ejb3sample.winetour.bugsmall.Address
1-1 query oa[1] = com.ibm.websphere.ejb3sample.winetour.bugsmall.Address


","0.9.7-incubating-SNAPSHOT,  windows, db2",,,,,,,,,,,,,,,,,,,,,06/Apr/07 23:30;ghongell;1_1WrongReturnTypesBugWineryTest.zip;https://issues.apache.org/jira/secure/attachment/12355112/1_1WrongReturnTypesBugWineryTest.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-08-10 13:35:23.07,,,no_permission,,,,,,,,,,,160541,,,Fri Jul 11 14:33:47 UTC 2008,,,,,,,0|i0z48f:,202988,,,,,,,,06/Apr/07 23:30;ghongell;run main method of BugSmallWineryTest in attached application to reproduce error,"06/Apr/07 23:51;ghongell;The same test on a similar application fails with java.lang.InstantiationException: java.lang.Integer
String sql = ""SELECT r,r.home FROM EmpBean r"";

clear detaches all entities from the persistent context
2463  mdd  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1297894748> executing prepstmnt 96339390 SELECT t0.empid, t1.street, t1.city, t1.state, t1.zip FROM EmpBean t0 LEFT OUTER JOIN AddressBean t1 ON t0.home_street = t1.street
2463  mdd  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1297894748> [0 ms] spent
<0|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.PersistenceException: java.lang.Integer
	at org.apache.openjpa.util.ApplicationIds.copy(ApplicationIds.java:301)
	at org.apache.openjpa.util.ApplicationIds.copy(ApplicationIds.java:239)
	at org.apache.openjpa.kernel.StateManagerImpl.initialize(StateManagerImpl.java:236)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:327)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:252)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:108)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:54)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:873)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:831)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:753)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:773)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:254)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2115)
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.load(PCPath.java:684)
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.load(PCPath.java:672)
	at org.apache.openjpa.jdbc.kernel.ProjectionResultObjectProvider.getResultObject(ProjectionResultObjectProvider.java:73)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:33)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1214)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:981)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:791)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:761)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:757)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:512)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:225)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:264)
	at com.ibm.ws.query.tests.BugTest.test_1_1relationshipQuery_EmpBean_AddressBean(BugTest.java:252)
	at com.ibm.ws.query.tests.BugTest.main(BugTest.java:96)
Caused by: java.lang.InstantiationException: java.lang.Integer
	at java.lang.Class.newInstanceImpl(Native Method)
	at java.lang.Class.newInstance(Class.java:1243)
	at org.apache.openjpa.util.ApplicationIds.copy(ApplicationIds.java:299)
	... 26 more
close(only used for application managed Persistent Context) inactivates the EntityManager and detaches all entities
create new Application Managed Persistent Context with no managed entities

====================================
Starting test_1_1relationshipQuery_EmpBean_AddressBean()
====================================
Shows a EmpBean and its address
String sql = ""SELECT r.home,r FROM EmpBean r WHERE r.empid = ?1""
Caution: requires _em.find(EmpBean.class,parm1) to avoid cache exception
Caution: ""SELECT r,r.home"" currently fails, returns [AddressBean, AddressBean] instead of [EmpBean, AddressBean]
-----------------------------------------------------------------------------
",10/Aug/07 13:35;kwsutter;Some of the problems identified in this Issue sound very similar to other problems that I am currently driving.  I'll take a look at this Issue and see where it goes.,21/Aug/07 14:57;mprudhom;Bumping to release 1.0.1 since 1.0.0 is being released.,30/Oct/07 16:15;allee8285;Defer to next release.,10/Jul/08 02:12;mikedd;Defer to next release. ,"11/Jul/08 14:33;ppoddar@apache.org;Consider not deferring.
Resolved with r666515 (2008-06-10).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Query returning 2 entities w/unidir 1-1 relationship gets openjpa.persistence.ArgumentException: Address with the same id already exists in the L1 cache.,OPENJPA-209,12366750,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ghongell,ghongell,06/Apr/07 22:52,09/Mar/10 18:32,14/Mar/19 03:02,24/Jun/08 16:33,0.9.7,,,,,,,,,1.2.0,,,,,,,,,,,1,,"Query returning 2 entities w/unidir 1-1 relationship gets openjpa.persistence.ArgumentException: Address with the same id already exists in the L1 cache.

ok if 1-1 relationship is bi-directional.

found with test_1_1relationshipQuery_Winery_Address()
same behavior with test_1_1relationshipQuery_EmpBean_AddressBean()

Starting getEntityManager()
60  bugsmall  INFO   [main] openjpa.Runtime - Starting OpenJPA 0.9.7-incubating-SNAPSHOT
220  bugsmall  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.DB2Dictionary"".
2423  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1207977984> executing prepstmnt 223874392 SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES
2433  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1207977984> [10 ms] spent
0  bugsmall  INFO   [main] openjpa.Runtime - Starting OpenJPA 0.9.7-incubating-SNAPSHOT
10  bugsmall  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.DB2Dictionary"".
Starting getEntityManager()
741  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 698362272> executing prepstmnt 223087948 SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES
741  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 698362272> [0 ms] spent
982  bugsmall  TRACE  [main] openjpa.Query - Executing query: [SELECT r.address,r FROM Winery r WHERE r.wineryid = ?1] with parameters: {1=1}
1082  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 698362272> executing prepstmnt 1433294190 SELECT t1.phone, t1.city, t1.state, t1.street, t1.zip, t0.wineryid FROM bugsmallWinery t0 LEFT OUTER JOIN bugsmallAddress t1 ON t0.address_phone = t1.phone WHERE (t0.wineryid = ?) [params=(int) 1]

====================================
Starting test_1_1relationshipQuery_Winery_Address()
====================================
Shows a winery and its address
String sql = ""SELECT r.address,r FROM Winery r WHERE r.wineryid = :wineryid ""
Caution: requires _em.find(Winery.class,parm1) to avoid cache exception
-----------------------------------------------------------------------------
1092  bugsmall  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 698362272> [0 ms] spent
<4|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: Cannot load object with id ""1"".  Instance ""com.ibm.websphere.ejb3sample.winetour.bugsmall.Address-1"" with the same id already exists in the L1 cache.  This can occur when you assign an existing id to a new instance, and before flushing attempt to load the existing instance for that id.
FailedObject: com.ibm.websphere.ejb3sample.winetour.bugsmall.Address-1
	at org.apache.openjpa.kernel.BrokerImpl$ManagedCache.add(BrokerImpl.java:4418)
	at org.apache.openjpa.kernel.BrokerImpl.setStateManager(BrokerImpl.java:3773)
	at org.apache.openjpa.kernel.StateManagerImpl.initialize(StateManagerImpl.java:297)
	at org.apache.openjpa.kernel.StateManagerImpl.initialize(StateManagerImpl.java:258)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:327)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:252)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:108)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:54)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:873)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:831)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:753)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:773)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:254)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2115)
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.load(PCPath.java:684)
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.load(PCPath.java:672)
	at org.apache.openjpa.jdbc.kernel.ProjectionResultObjectProvider.getResultObject(ProjectionResultObjectProvider.java:73)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:33)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1214)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:981)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:791)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:761)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:528)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:222)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:264)
	at com.ibm.websphere.ejb3sample.winetour.bugsmall.BugSmallWineryTest.test_1_1relationshipQuery_Winery_Address(BugSmallWineryTest.java:344)
	at com.ibm.websphere.ejb3sample.winetour.bugsmall.BugSmallWineryTest.main(BugSmallWineryTest.java:91)
","0.9.7-incubating-SNAPSHOT,  windows, db2",,,,,,,,,,,,,,,,,,,,,06/Apr/07 22:55;ghongell;1_1CacheBugWineryTest.zip;https://issues.apache.org/jira/secure/attachment/12355111/1_1CacheBugWineryTest.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-08-21 14:57:09.583,,,no_permission,,,,,,,,,,,160540,,,Fri Oct 17 20:41:27 UTC 2008,,,,,,,0|i0z0zj:,202462,,,,,,,,06/Apr/07 22:55;ghongell;run main method of BugSmallWineryTest in attached application to reproduce error,21/Aug/07 14:57;mprudhom;Bumping to release 1.0.1 since 1.0.0 is being released.,30/Oct/07 16:28;allee8285;Defer to next release.,24/Jun/08 16:33;ppoddar@apache.org;SVN revision 666515,"17/Oct/08 20:41;mikedd;This change was never committed to 1.0.x, I'm removing 1.0.3 from the list of releases it was ""fixed"" in. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NoResultException and NonUniqueResultException are not thrown when expected,OPENJPA-208,12366747,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mprudhom,mprudhom,mprudhom,06/Apr/07 22:25,09/Mar/10 18:32,14/Mar/19 03:02,09/Apr/07 17:06,0.9.6,,,,,,,,,0.9.7,,,,,jpa,,,,,,0,,"When calling Query.getSingleResult() on a query that either has no result or multiple results, either a NoResultException and NonUniqueResultException (respectively) should be thrown in accordance with section 3.6.1 of the JPA spec. Instead, we appear to throw a org.apache.openjpa.persistence.InvalidStateException:

org.apache.openjpa.persistence.InvalidStateException: The query on candidate type ""class com.sun.ts.tests.ejb30.persistence.query.apitests.Department"" with filter ""select d.name from Department d where d.id > 1"" was configured to have a unique result, but more than one instance matched the query.
     at org.apache.openjpa.kernel.QueryImpl.singleResult(QueryImpl.java:1282)
     at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1207)
     at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:982)
     at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:791)
     at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:761)
     at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:757)
     at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:514)
     at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:225)
     at org.apache.openjpa.persistence.QueryImpl.getSingleResult(QueryImpl.java:287)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160539,,,Mon Apr 09 17:06:36 UTC 2007,,,,,,,0|i0z1gv:,202540,,,,,,,,"06/Apr/07 22:32;mprudhom;This seems to have slipped in in the fix for OPENJPA-168: see http://svn.apache.org/viewvc/incubator/openjpa/trunk/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java?p2=%2Fincubator%2Fopenjpa%2Ftrunk%2Fopenjpa-persistence%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fopenjpa%2Fpersistence%2FQueryImpl.java&p1=%2Fincubator%2Fopenjpa%2Ftrunk%2Fopenjpa-persistence%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fopenjpa%2Fpersistence%2FQueryImpl.java&r1=522581&r2=522580&view=diff&pathrev=522581
",06/Apr/07 22:33;mprudhom;This appears to have been introduced by the commits for the fix for OPENJPA-168.,"06/Apr/07 22:48;mprudhom;The change to OPENJPA-168 seems to have been done to make the validation of a single result a little cleaner by having the kernel query perform the validation that there is a single result. However, this meant that we could only do generic exception translation, and so were no longer throwing a NoResultException or NonUniqueResultException. We could fix this by introducing a could new kernel exceptions or exception types, but it might just be easier to revert to having the validation done in the persistence QueryImpl.

Any objections to fixing this the easy way?",06/Apr/07 23:33;mprudhom;Went ahead and restored the previous behavior where the QueryImpl itself checks for non-uniqueness and throws the expected exception.,"09/Apr/07 16:42;mprudhom;From Abe on mailing list: That breaks the single result optimization that was added for  OPENJPA-168 when getSingleResult() is called.  There was a reason we moved the validation to the kernel.  The previous code was correct. You need to use the ""hard"" way of creating new exception types.
",09/Apr/07 17:06;mprudhom;Added NoResultException and NonUniqueResultException to kernel to allow the identification of the case where a unique result was selected by either none or too many were found,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
failure when composite ID has another composite ID as a field ,OPENJPA-207,12366739,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,farble1670,farble1670,06/Apr/07 20:56,09/Mar/10 18:31,14/Mar/19 03:02,01/May/09 01:02,0.9.6,,,,,,,,,2.0.0-M2,,,,,,,,,,,0,,"see attached test case: entities Library, Book, and Page. there is a one-many bidirectional relationship between Library and Book, and Book and Page. a Library's ID is simply it's name. a Book's ID is it's name, plus it's owning library's ID. A Page's ID is it's number, plus it's owning Book's ID. 

this arrangement results in composite IDs for Book and Page. and moreover, Page's composite ID, PageId, contains a page number field plus a BookId. however, this arrangement results in an exception at runtime w/ the included test case ...

...
 Caused by: java.lang.ClassCastException: org.apache.openjpa.util.ObjectId
 at com.mycompany.book.Page.pcCopyKeyFieldsToObjectId(Page.java)
 at org.apache.openjpa.util.ApplicationIds.create(ApplicationIds.java:383)
 at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2349) 

note that if i remove the bookId field from PageId, the test case succeeds. 

also note that this problem is also observed against a trunk field from march 3 (0.9.7 snapshot).","derby
jdk 1.5.0_07",,,,,,,,,,,,,,,,,,,,,06/Apr/07 20:57;farble1670;book.zip;https://issues.apache.org/jira/secure/attachment/12355106/book.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-07-21 18:01:54.027,,,no_permission,,,,,,,,,,,160538,,,Mon Jul 21 18:01:54 UTC 2008,,,,,,,0|i0za5z:,203949,,,,,,,,"06/Apr/07 20:57;farble1670;to run the test case, please start a derby network server on localhost:1527.","21/Jul/08 18:01;ppoddar@apache.org;The change incorporated includes a change in enhancer.
The multiple-level of derived identity is handled in enhancer by proper casts.
Runtime is modified to accommodate a user-defined identity class by wrapping it in OpenJPA wrapper identity type i.e. org.apache.openjpa.util.ObjectId.  

The attached test by the issue reporter is cannibalized (with due references)  in OpenJPA test suite. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Pessimistic Lock Manager not locking the rows ,OPENJPA-203,12366626,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ssegu,ssegu,05/Apr/07 08:55,09/Mar/10 18:32,14/Mar/19 03:02,07/Aug/07 18:08,0.9.0,0.9.6,,,,,,,,1.0.0,,,,,kernel,,,,,,0,,With  pessimistic lock manager multiple EMs are able to modify the same object concurrently.,ran against Oracle,,,,,,,,,,,,,,,,,,,,,05/Apr/07 09:16;ssegu;NotesAndDiff.txt;https://issues.apache.org/jira/secure/attachment/12354992/NotesAndDiff.txt,05/Apr/07 08:57;ssegu;testcase.zip;https://issues.apache.org/jira/secure/attachment/12354990/testcase.zip,06/Apr/07 04:04;ssegu;testcase2.zip;https://issues.apache.org/jira/secure/attachment/12355054/testcase2.zip,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-04-05 15:10:00.685,,,no_permission,,,,,,,,,,,160534,,,Thu Apr 05 19:13:46 UTC 2007,,,,,,,0|i0zb4n:,204105,,,,,,,,"05/Apr/07 15:10;awhite;Looks good.  Although I think I'd prefer to make lockInternal() responsible for setting the lock level rather than having to set it and unset it so that lock() can set it again... it's just too ugly.  So instead we just remove the setting of the lock level in lock() and make VersionLockManager only unset the lock level in its lockInternal if an exception occurs.  PessimisticLockManager wouldn't have to change (outside of the changes already in your patch) because it delegates to super.lockInternal already, so the lock level would get set appropriately.  ","05/Apr/07 18:20;ssegu;My initial approach was the same that we could move the responsibility of setting the lock-level to lockInternal. The only concern that lead me to this approach was that - if an overriding lockInternal method calls super() following up with some code that can throw an exception - the lockInternal override will have to unset the lock in its catch block to unset the value set by the super call. (Note the current override PessimisticLockManager does not run into this issue as the super() call is at the end).

So I went with the idea that the lock() is responsible for setting the lock level, and in the special case of VersionLockManager where its lockInternal code needs the lock-level set before to avoid infinite recursion - it can handle the case by setting, later unsetting - keeping the lock-level change need local.

That being said I dont terribly mind changing to the suggested approach.","05/Apr/07 19:13;awhite;If we don't want the subclasses to have to unset the lock value in case of exception, another option would be to have lock() delegate to lockInternal for setting the lock value, but to unset the lock value itself on error:

int oldValue = getLockValue(sm);
try {
    lockInternal(...);
} catch (RuntimeException re) {
    setLockValue(sm, oldValue);
    throw re;
}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"after invoking LRS processing in a client by calling an @LRS annotated relationship, the next em.clear()/em.close() gets org.apache.openjpa.persistence.InvalidStateException: You cannot transfer large result set fields from one object or field to another",OPENJPA-202,12366611,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ghongell,ghongell,05/Apr/07 00:56,09/Mar/10 18:32,14/Mar/19 03:02,06/Apr/07 19:19,0.9.7,,,,,,,,,0.9.7,,,,,kernel,,,,,,0,,"after invoking LRS processing in a client by calling an @LRS annotated relationship, the next em.clear()/em.close() gets org.apache.openjpa.persistence.InvalidStateException: You cannot transfer large result set fields from one object or field to another

<4|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.InvalidStateException: You cannot transfer large result set fields from one object or field to another.
	at org.apache.openjpa.util.AbstractLRSProxyCollection.setOwner(AbstractLRSProxyCollection.java:77)
	at org.apache.openjpa.kernel.DetachManager$DetachFieldManager.reproxy(DetachManager.java:523)
	at org.apache.openjpa.kernel.DetachManager.detachInternal(DetachManager.java:431)
	at org.apache.openjpa.kernel.DetachManager.detachAll(DetachManager.java:299)
	at org.apache.openjpa.kernel.BrokerImpl.detachAllInternal(BrokerImpl.java:3150)
	at org.apache.openjpa.kernel.BrokerImpl.detachAll(BrokerImpl.java:3123)
	at org.apache.openjpa.kernel.DelegatingBroker.detachAll(DelegatingBroker.java:1136)
	at org.apache.openjpa.persistence.EntityManagerImpl.clear(EntityManagerImpl.java:868)
	at com.ibm.websphere.ejb3sample.winetour.bug.BugWineryTest.testLargeResultSetAnnotation(BugWineryTest.java:902)
	at com.ibm.websphere.ejb3sample.winetour.bug.BugWineryTest.main(BugWineryTest.java:146)",0.9.7-incubating-SNAPSHOT,,,,,,,,,,,,,,,,,,,,,05/Apr/07 00:57;ghongell;lrsBugWineryTest.zip;https://issues.apache.org/jira/secure/attachment/12354968/lrsBugWineryTest.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-04-06 19:19:32.77,,,no_permission,,,,,,,,,,,160533,,,Fri Apr 06 19:38:01 UTC 2007,,,,,,,0|i0z473:,202982,,,,,,,,05/Apr/07 00:57;ghongell;run main method to get error,"06/Apr/07 19:19;awhite;Changed detach process to never detach LRS fields.  In the future we might consider enhancements like detaching write-only proxies for LRS fields.  The only way to fully detach an LRS field, though, would be to read it all into memory, which would defeat the purpose.  Fixed in revision 526253.","06/Apr/07 19:38;pcl;Another possibility would be to detach the field if it is explicitly included in the fetch configuration, either directly or via a fetch group that contains it. That would let people get the data if they were willing to pay the price.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"cannot use enum type as input parameter for a query, and you cannot specify an Enum type as a literal, this also means that there is no way to update an enum type using jpaql bulk update",OPENJPA-200,12366607,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ghongell,ghongell,05/Apr/07 00:13,09/Mar/10 18:35,14/Mar/19 03:02,17/Nov/07 06:38,0.9.7,,,,,,,,,,,,,,query,,,,,,0,,"cannot use enum as input parameter for a query, Enum cannot be used as argument in setParm, since you also cannot specify an Enum type as a literal, this means that there is no way to update an enum type using jpaql bulk  update 

update Wine w set w.type = ?1 where w.type = ?2

<4|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: The specified parameter of type ""class com.ibm.websphere.ejb3sample.winetour.bug.Wine$WineType"" is not a valid query parameter.
	at org.apache.openjpa.jdbc.sql.DBDictionary.setUnknown(DBDictionary.java:1273)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.setParameters(SQLBuffer.java:564)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:475)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:451)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:440)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeBulkOperation(JDBCStoreQuery.java:490)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeUpdate(JDBCStoreQuery.java:420)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeUpdate(ExpressionStoreQuery.java:687)
	at org.apache.openjpa.kernel.QueryImpl.update(QueryImpl.java:1030)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:795)
	at org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:870)
	at org.apache.openjpa.kernel.DelegatingQuery.updateAll(DelegatingQuery.java:568)
	at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:316)
	at com.ibm.websphere.ejb3sample.winetour.bug.BugWineryTest.testBulkUpdate(BugWineryTest.java:553)

=========================================================================
""update Wine w set w.type = ""+Wine.WineType.Propriatory+"" where w.type = ""+Wine.WineType.Varietal 

<4|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: null
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:800)
	at org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:870)
	at org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:866)
	at org.apache.openjpa.kernel.DelegatingQuery.updateAll(DelegatingQuery.java:560)
	at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:319)
	at com.ibm.websphere.ejb3sample.winetour.bug.BugWineryTest.testBulkUpdate(BugWineryTest.java:557)
	at com.ibm.websphere.ejb3sample.winetour.bug.BugWineryTest.main(BugWineryTest.java:141)
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.initialize(PCPath.java:442)
	at org.apache.openjpa.jdbc.kernel.exps.CompareEqualExpression.initialize(CompareEqualExpression.java:77)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.initialize(SelectConstructor.java:175)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.newSelect(SelectConstructor.java:116)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.evaluate(SelectConstructor.java:70)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeBulkOperation(JDBCStoreQuery.java:458)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeUpdate(JDBCStoreQuery.java:420)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeUpdate(ExpressionStoreQuery.java:687)
	at org.apache.openjpa.kernel.QueryImpl.update(QueryImpl.java:1030)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:795)
	... 6 more
	at com.ibm.websphere.ejb3sample.winetour.bug.BugWineryTest.main(BugWineryTest.java:141)

=========================================================================
update Wine w set w.type = 'Propriatory' where w.type = 'Varietal'

<4|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: java.lang.String incompatible with java.lang.Enum
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:800)
	at org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:870)
	at org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:866)
	at org.apache.openjpa.kernel.DelegatingQuery.updateAll(DelegatingQuery.java:560)
	at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:319)
	at com.ibm.websphere.ejb3sample.winetour.bug.BugWineryTest.testBulkUpdate(BugWineryTest.java:558)
	at com.ibm.websphere.ejb3sample.winetour.bug.BugWineryTest.main(BugWineryTest.java:141)
Caused by: java.lang.ClassCastException: java.lang.String incompatible with java.lang.Enum
	at org.apache.openjpa.jdbc.meta.strats.EnumValueHandler.toDataStoreValue(EnumValueHandler.java:90)
	at org.apache.openjpa.jdbc.meta.strats.HandlerStrategies.toDataStoreValue(HandlerStrategies.java:220)
	at org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy.toDataStoreValue(HandlerFieldStrategy.java:223)
	at org.apache.openjpa.jdbc.meta.FieldMapping.toDataStoreValue(FieldMapping.java:795)
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.toDataStoreValue(PCPath.java:620)
	at org.apache.openjpa.jdbc.kernel.exps.Lit.calculateValue(Lit.java:86)
	at org.apache.openjpa.jdbc.kernel.exps.CompareEqualExpression.appendTo(CompareEqualExpression.java:85)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.buildWhere(SelectConstructor.java:235)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.evaluate(SelectConstructor.java:76)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeBulkOperation(JDBCStoreQuery.java:458)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeUpdate(JDBCStoreQuery.java:420)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeUpdate(ExpressionStoreQuery.java:687)
	at org.apache.openjpa.kernel.QueryImpl.update(QueryImpl.java:1030)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:795)
	... 6 more
",0.9.7-incubating-SNAPSHOT,,,,,,,,,,,,,,,,,,,,,05/Apr/07 00:14;ghongell;enumBugWineryTest.zip;https://issues.apache.org/jira/secure/attachment/12354966/enumBugWineryTest.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-11-17 06:38:52.545,,,no_permission,,,,,,,,,,,160531,,,Sat Nov 17 06:38:52 UTC 2007,,,,,,,0|i0z47r:,202985,,,,,,,,05/Apr/07 00:14;ghongell;run main to get error,"17/Nov/07 06:38;pcl;I haven't tested with the attached test case, but reproduced something based on the description.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
bulk update gets parsing exception trying to update an attribute of an embedded class,OPENJPA-199,12366605,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ghongell,ghongell,04/Apr/07 23:34,09/Mar/10 18:32,14/Mar/19 03:02,01/Jul/07 21:13,0.9.7,,,,,,,,,1.0.0,,,,,query,,,,,,0,,"<4|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: An error occurred while parsing the query filter 'update Wine w set w.label.wineName = ?1'. Error message: <4|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.kernel.jpql.ParseException: Encountered ""."" at character 26, but expected: [""=""].
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.parse(JPQLExpressionBuilder.java:1661)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.<init>(JPQLExpressionBuilder.java:1641)
	at org.apache.openjpa.kernel.jpql.JPQLParser.parse(JPQLParser.java:44)
	at org.apache.openjpa.kernel.ExpressionStoreQuery.newCompilation(ExpressionStoreQuery.java:141)
	at org.apache.openjpa.kernel.QueryImpl.newCompilation(QueryImpl.java:643)
	at org.apache.openjpa.kernel.QueryImpl.compilationFromCache(QueryImpl.java:625)
	at org.apache.openjpa.kernel.QueryImpl.compileForCompilation(QueryImpl.java:591)
	at org.apache.openjpa.kernel.QueryImpl.compileForExecutor(QueryImpl.java:653)
	at org.apache.openjpa.kernel.QueryImpl.getOperation(QueryImpl.java:1475)
	at org.apache.openjpa.kernel.DelegatingQuery.getOperation(DelegatingQuery.java:120)
	at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:305)
	at com.ibm.websphere.ejb3sample.winetour.bug.BugWineryTest.testBulkUpdate(BugWineryTest.java:551)
	at com.ibm.websphere.ejb3sample.winetour.bug.BugWineryTest.main(BugWineryTest.java:141)
Caused by: <4|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: Encountered ""."" at character 26, but expected: [""=""].
	at org.apache.openjpa.kernel.jpql.JPQL.generateParseException(JPQL.java:9322)
	at org.apache.openjpa.kernel.jpql.JPQL.jj_consume_token(JPQL.java:9199)
	at org.apache.openjpa.kernel.jpql.JPQL.EQ(JPQL.java:5718)
	at org.apache.openjpa.kernel.jpql.JPQL.update_item(JPQL.java:729)
	at org.apache.openjpa.kernel.jpql.JPQL.set_clause(JPQL.java:706)
	at org.apache.openjpa.kernel.jpql.JPQL.update_clause(JPQL.java:701)
	at org.apache.openjpa.kernel.jpql.JPQL.update_statement(JPQL.java:147)
	at org.apache.openjpa.kernel.jpql.JPQL.parseQuery(JPQL.java:65)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.parse(JPQLExpressionBuilder.java:1654)
	... 12 more",0.9.7-incubating-SNAPSHOT,,,,,,,,,,,,,,,,,,,,,04/Apr/07 23:36;ghongell;embeddedBugWineryTest.zip;https://issues.apache.org/jira/secure/attachment/12354963/embeddedBugWineryTest.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-07-01 21:14:07.91,,,no_permission,,,,,,,,,,,74218,,,Sun Jul 01 21:14:07 UTC 2007,,,,,,,0|i0zb7r:,204119,,,,,,,,01/Jul/07 21:14;pcl;The OpenJPA parser did not allow any path traversals in the left-hand side of SET clause items.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Build failure of OpenJPA sources from trunk,OPENJPA-186,12365984,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mprudhom,jlaskowski,jlaskowski,28/Mar/07 07:50,09/Mar/10 18:32,14/Mar/19 03:02,29/Mar/07 08:34,0.9.7,,,,,,,,,0.9.7,,,,,build / infrastructure,,,,,,0,,"(I have sent it to the mailing list on March 26th, but it didn't get through)

As I'm not alone with the build failure, see http://www.nabble.com/error-building-openjpa-tf3478705.html, here goes the issue report.

I've been trying to build OpenJPA source from trunk for a couple of days and no joy so far. Anything missing?

jlaskowski@dev /cygdrive/c/oss/openjpa
$ svn up
At revision 522565.

jlaskowski@dev /cygdrive/c/oss/openjpa
$ svn status

jlaskowski@dev /cygdrive/c/oss/openjpa
$ mvn clean install
[INFO] Executing tasks
    [echo] Revision: 406193:522097
[INFO] Executed tasks
[INFO] [antrun:run {execution: delete sun.misc.Perf}]
[INFO] Executing tasks
[INFO] Executed tasks
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Compiling 33 source files to
c:\oss\openjpa\openjpa-lib\target\test-classes
[INFO] [surefire:test]
[INFO] Surefire report directory:
c:\oss\openjpa\openjpa-lib\target\surefire-reports
[INFO] Building jar: c:\DOCUME~1\JLASKO~1\LOCALS~1\Temp\surefirebooter30238.jar
java.lang.NoClassDefFoundError: org/apache/maven/surefire/booter/SurefireBooter
Exception in thread ""main""
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] There are test failures.
[INFO] ------------------------------------------------------------------------
[INFO] For more information, run Maven with the -e switch
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 16 seconds
[INFO] Finished at: Mon Mar 26 19:16:09 CEST 2007
[INFO] Final Memory: 21M/254M
[INFO] ------------------------------------------------------------------------

jlaskowski@dev /cygdrive/c/oss/openjpa
$ mvn -v
Maven version: 2.0.5

jlaskowski@dev /cygdrive/c/oss/openjpa
$ java -version
java version ""1.5.0_11""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_11-b03)
Java HotSpot(TM) Client VM (build 1.5.0_11-b03, mixed mode)",,,,,,,,,,,,,,,,,,,,,,28/Mar/07 18:04;jlaskowski;OPENJPA-186-builderror-2.txt;https://issues.apache.org/jira/secure/attachment/12354457/OPENJPA-186-builderror-2.txt,28/Mar/07 11:32;jlaskowski;OPENJPA-186.buildfailure.txt;https://issues.apache.org/jira/secure/attachment/12354421/OPENJPA-186.buildfailure.txt,28/Mar/07 20:08;jlaskowski;OPENJPA-186.patch;https://issues.apache.org/jira/secure/attachment/12354463/OPENJPA-186.patch,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-03-28 09:00:09.128,,,no_permission,,,,,,,,,,,160518,,,Thu Mar 29 08:34:25 UTC 2007,,,,,,,0|i0z45r:,202976,,,,,,,,"28/Mar/07 09:00;mprudhom;This is almost certainly a general maven setup problem. Try building another maven project and see if the same problem occurs. I recommend re-installing maven.

If this problem only happens with OpenJPA, please re-open this bug and post the output of the mvn command with the ""-e"" and ""-X"" flags.","28/Mar/07 11:30;jlaskowski;What?! Please appologize my lack of understanding, but comments like this ""Try building another maven project and see if the same problem occurs. I recommend re-installing maven."" doesn't apply in this scenario. I'm building Apache Geronimo and Apache OpenEJB almost every day with success (they're built with M2) and there are other M2-ized projects that work fine (with OpenJPA as a dependency, too) and I can't understand why re-installing M2 would help here if everything but OpenJPA builds fine?

Please have a look at the attachment with the output of executing 'mvn -e -X clean install' command.",28/Mar/07 11:31;jlaskowski;The attachment contains all that's necessary to back up the reopening.,"28/Mar/07 13:54;kwsutter;Jacek,
I just reproduced your problem.  It looks to be related to the surefire 2.3 plugin for maven.  I first tried my current maven setup and that had surefire 2.0.  Everything worked just fine.  I then attempted to remove just the surefire 2.0 plugin, but maven just downloaded the same 2.0 version.  So, I removed maven completely from my .m2 repository and surefire 2.3 was downloaded and my build failed in the same way as yours (same exception anyway):

[INFO] Surefire report directory: C:\eclipse.workspaces\3.2.2\openjpa\openjpa-lib\target\surefire-reports
[INFO] Building jar: C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp\surefirebooter27730.jar
java.net.MalformedURLException: unknown protocol: c
        at java.net.URL.<init>(URL.java:608)
        at java.net.URL.<init>(URL.java:498)
        at sun.misc.URLClassPath$JarLoader.parseClassPath(URLClassPath.java:1118)
        at sun.misc.URLClassPath$JarLoader.getClassPath(URLClassPath.java:1091)
        at sun.misc.URLClassPath.getLoader(URLClassPath.java:476)
        at sun.misc.URLClassPath.getResource(URLClassPath.java:322)
        at java.net.URLClassLoader$ClassFinder.run(URLClassLoader.java:959)
        at java.security.AccessController.doPrivileged(AccessController.java:275)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:487)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:602)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:327)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:568)
The java class is not found:  org.apache.maven.surefire.booter.SurefireBooter

If I modify my pom.xml to use surefire 2.2, everything builds again...

                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-surefire-plugin</artifactId>
                    <version>2.2</version>
                  :

Not sure what is wrong with surefire 2.3, but we have experienced a few problems with it.  Maybe we should update our pom.xml to use version 2.2 until it gets more stable.

Kevin","28/Mar/07 16:28;mprudhom;I haven't had any problems with surefire 2.3, but I don't build on Windows. I think setting the surefire version to 2.2 in the pom.xml is a fine solution ... I've gone ahead and committed this change. Please comment in this issue if the problem still occurs.","28/Mar/07 18:03;jlaskowski;Alas, the build went further, but still fails. See the attached output of 'mvn clean install' command.","28/Mar/07 18:18;mprudhom;If you manually include the tools.jar (in your Java system library directory) in your CLASSPATH, do you still get the same error? Can you post the setting of your CLASSPATH?","28/Mar/07 19:40;jlaskowski;It's something pertaining to the way Ant is executed from within M2, and OpenJPA build runs into troubles. I could reproduce it with a simple, almost empty project. When build.xml is executed directly with ant it runs fine. When it's executed from M2 it fails with the following error message. Any hints on how to work it out?

jlaskowski@dev /cygdrive/c/OPENJPA-186
$ ant -version
Apache Ant version 1.7.0 compiled on December 13 2006

jlaskowski@dev /cygdrive/c/OPENJPA-186
$ mvn -v
Maven version: 2.0.5

jlaskowski@dev /cygdrive/c/OPENJPA-186
$ echo $CLASSPATH


jlaskowski@dev /cygdrive/c/OPENJPA-186
$ echo $JAVA_HOME
/cygdrive/c/apps/java5

jlaskowski@dev /cygdrive/c/OPENJPA-186
$ java -version
java version ""1.5.0_11""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_11-b03)
Java HotSpot(TM) Client VM (build 1.5.0_11-b03, mixed mode)

jlaskowski@dev /cygdrive/c/OPENJPA-186
$ ant
Buildfile: build.xml

compile:
    [javac] Compiling 1 source file

BUILD SUCCESSFUL
Total time: 0 seconds

jlaskowski@dev /cygdrive/c/OPENJPA-186
$ mvn integration-test
[INFO] Scanning for projects...
[INFO] ----------------------------------------------------------------------------
[INFO] Building OpenJPA Examples Integration Tests
[INFO]    task-segment: [integration-test]
[INFO] ----------------------------------------------------------------------------
[INFO] [site:attach-descriptor]
[INFO] [antrun:run {execution: run-examples}]
[INFO] Executing tasks
     [echo] Running OpenJPA Examples

compile:
    [javac] Compiling 1 source file
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ------------------------------------------------------------------------
[INFO] Error executing ant tasks

Embedded error: The following error occurred while executing this line:
C:\OPENJPA-186\build.xml:4: Unable to find a javac compiler;
com.sun.tools.javac.Main is not on the classpath.
Perhaps JAVA_HOME does not point to the JDK
[INFO] ------------------------------------------------------------------------
[INFO] For more information, run Maven with the -e switch
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 second
[INFO] Finished at: Wed Mar 28 21:36:02 CEST 2007
[INFO] Final Memory: 4M/254M
[INFO] ------------------------------------------------------------------------

$ cat pom.xml
<project xmlns=""http://maven.apache.org/POM/4.0.0""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
    xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0
        http://maven.apache.org/maven-v4_0_0.xsd"">
    <modelVersion>4.0.0</modelVersion>
    <groupId>xxx</groupId>
    <artifactId>examples</artifactId>
    <packaging>pom</packaging>
    <version>1.0</version>
    <name>OpenJPA Examples Integration Tests</name>
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-antrun-plugin</artifactId>
                <executions>
                    <execution>
                        <id>run-examples</id>
                        <phase>integration-test</phase>
                        <configuration>
                        <tasks>
                        <echo>Running OpenJPA Examples</echo>

                        <subant inheritAll=""false"">
                            <fileset dir="".""
                                includes=""build.xml""/>
                        </subant>

                        </tasks>
                        </configuration>
                        <goals>
                            <goal>run</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

jlaskowski@dev /cygdrive/c/OPENJPA-186
$ cat build.xml
<project default=""compile"">

    <target name=""compile"" description=""Compile the example java files"">
        <javac srcdir=""src"" />
    </target>

</project>
","28/Mar/07 20:08;jlaskowski;Applying the patch lets you go on with the build until another BUILD ERROR:

[INFO] ----------------------------------------------------------------------------
[INFO] Building OpenJPA JPA TCK Integration Tests
[INFO]    task-segment: [clean, install]
[INFO] ----------------------------------------------------------------------------
[INFO] [clean:clean]
[INFO] Deleting directory c:\oss\openjpa\openjpa-integration\tck\target
[INFO] Deleting directory c:\oss\openjpa\openjpa-integration\tck\target\classes
[INFO] Deleting directory c:\oss\openjpa\openjpa-integration\tck\target\test-classes
[INFO] [site:attach-descriptor]
[INFO] [antrun:run {execution: run-tck}]
[INFO] Executing tasks
     [echo] Running Sun JPA TCK
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ------------------------------------------------------------------------
[INFO] Error executing ant tasks

Embedded error: The TCK file C:\.m2/../privaterepos/jpa-1_0a-tck.zip does not exist. This file must be downloaded separately in order to be able to run the JPA TCK
[INFO] ------------------------------------------------------------------------
[INFO] For more information, run Maven with the -e switch
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3 minutes 33 seconds
[INFO] Finished at: Wed Mar 28 21:58:01 CEST 2007
[INFO] Final Memory: 35M/254M
[INFO] ------------------------------------------------------------------------

I wonder how non-committers build OpenJPA?! Could the tck modue be moved to a profile that's executed for some?","28/Mar/07 22:23;jlaskowski;mvn package -Dtest=false did the trick. mvn clean package works now too! mvn install fails. See the following build error (after the successful build message). It looks install isn't for faint-hearted.  It should be documented somewhere on the website. 

[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] OpenJPA ............................................... SUCCESS [1.328s]
[INFO] OpenJPA Utilities ..................................... SUCCESS [29.250s]
[INFO] OpenJPA Kernel ........................................ SUCCESS [15.453s]
[INFO] OpenJPA JDBC .......................................... SUCCESS [12.203s]
[INFO] OpenJPA XML Store ..................................... SUCCESS [0.407s]
[INFO] OpenJPA Kernel 1.5 .................................... SUCCESS [0.312s]
[INFO] OpenJPA JDBC 1.5 ...................................... SUCCESS [0.297s]
[INFO] OpenJPA JPA ........................................... SUCCESS [2.015s]
[INFO] OpenJPA JPA JDBC ...................................... SUCCESS [11.203s]
[INFO] OpenJPA Aggregate Jar ................................. SUCCESS [20.438s]
[INFO] OpenJPA Persistence Examples .......................... SUCCESS [0.562s]
[INFO] OpenJPA Distribution .................................. SUCCESS [35.578s]
[INFO] OpenJPA Integration Tests ............................. SUCCESS [0.000s]
[INFO] OpenJPA Examples Integration Tests .................... SUCCESS [0.000s]
[INFO] OpenJPA JPA TCK Integration Tests ..................... SUCCESS [0.000s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2 minutes 9 seconds
[INFO] Finished at: Thu Mar 29 00:07:18 CEST 2007
[INFO] Final Memory: 26M/254M
[INFO] ------------------------------------------------------------------------

     [echo] Running Sun JPA TCK
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ------------------------------------------------------------------------
[INFO] Error executing ant tasks

Embedded error: The TCK file C:\.m2/../privaterepos/jpa-1_0a-tck.zip does not exist. This file must be downloaded separately in order to be able to run the JPA TCK
[INFO] ------------------------------------------------------------------------
[INFO] For more information, run Maven with the -e switch
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3 minutes 36 seconds
[INFO] Finished at: Thu Mar 29 00:18:28 CEST 2007
[INFO] Final Memory: 35M/254M
[INFO] ------------------------------------------------------------------------","29/Mar/07 08:34;pcl;Sorry about that -- I don't think that many of us run 'mvn install' all that often.

I just removed the line that tries to invoke the tck in r523613; hopefully, you should now be able to build successfully. I was just able to run a 'mvn clean install' without issue.",,,,,,,,,,,,,,,,,,,,,,,,,,
optional attribute is not overriden by xml descriptor,OPENJPA-185,12365962,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,28/Mar/07 03:25,17/Apr/07 18:38,14/Mar/19 03:02,02/Apr/07 21:15,0.9.0,0.9.6,,,,,,,,0.9.7,,,,,,,,,,,0,,"The optional attribute of the @Basic annotation is not being overriden if it's defined in orm.xml. 

",,,,,,,,,,,,,,,,,,,,,,28/Mar/07 03:28;mikedd;OpenJPA-185.patch.txt;https://issues.apache.org/jira/secure/attachment/12354387/OpenJPA-185.patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160517,,,2007-03-28 03:25:31.0,,,,,,,0|i0z46f:,202979,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException when executing bulk delete on an entity that owns a OneToOne with a Cascade.DELETE when DataCache is on,OPENJPA-181,12365816,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,jdf@us.ibm.com,jdf@us.ibm.com,26/Mar/07 15:26,09/Mar/10 18:32,14/Mar/19 03:02,27/Mar/07 19:25,0.9.7,,,,,,,,,0.9.7,,,,,kernel,,,,,,0,,"Given an entity class A which owns a OneToOne entity of class B, and given a cascade on that OneToOne that includes DELETE, an attempt to bulk-delete A when using the DataCache results in a stack trace like the following:

java.lang.ClassCastException: org.apache.openjpa.datacache.QueryCacheStoreQuery cannot be cast to org.apache.openjpa.kernel.ExpressionStoreQuery
    at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:674)
    at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:979)
    at org.apache.openjpa.kernel.QueryImpl.deleteInMemory(QueryImpl.java:1005)
    ... 28 more

The proximate cause for the bug is that when the JDBCStoreQuery does this:

    private Table getTable(FieldMapping fm, Table table) {
        if (fm.getCascadeDelete() != ValueMetaData.CASCADE_NONE)
            return INVALID;

it causes ""isSingleTableMapping"" to be considered false, which in turn permits executeBulkOperation to return null. Meanwhile, back in DataStoreExecutor:

       public Number executeDelete(StoreQuery q, Object[] params) {
            Number num = ((ExpressionStoreQuery) q).executeDelete(this, _meta,
                _metas, _subs, _facts, _exps, params);
            if (num == null)
                return q.getContext().deleteInMemory(this, params);   // <- now we have come here because executeDelete punted
            return num;
        }

So deleteInMemory gets called in QueryImpl:

   public Number deleteInMemory(StoreQuery.Executor executor,
        Object[] params) {
        try {
            Object o = execute(executor, params);

, but a DataStoreExecutor doesn't know how to execute the QueryCacheStoreQuery that it gets.

Somehwere, something is too unwrapped, or not wrapped enough. Good luck!

Workaround:

If A owns B, then instead of cascade=CascadeType.ALL, you can

@Entity
class A {
    B myThing;

    @OneToOne(cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH })
   B getMyThing() { return myThing; }
}

@Entity
class B {
    A owner;

    @ForeignKey(deleteAction=ForeignKeyAction.CASCADE)
    A getOwner() { return owner; }
}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-03-27 19:25:48.185,,,no_permission,,,,,,,,,,,160513,,,Tue Mar 27 19:25:48 UTC 2007,,,,,,,0|i0zb73:,204116,,,,,,,,27/Mar/07 19:25;awhite;Fixed in SVN revision 523046.  See test case added to TestBulkJPQLAndDataCache.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Batch Update support needed for OpenJPA performance,OPENJPA-180,12365700,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,jstecher,jstecher,23/Mar/07 21:03,18/Sep/08 16:46,14/Mar/19 03:02,18/Sep/08 16:46,0.9.0,0.9.6,0.9.7,1.0.0,1.1.0,,,,,,,,,,,,,,,,0,,"After doing some more performance testing on OpenJPA using a variety of primitive benchmarks I have noticed that it lags competitors significantly in performance in scenarios that stress multiple updates inside of a single transaction.  Obviously almost every application server out there today overcomes this by implementing some sort of batch update feature and I would almost consider it a bug that OpenJPA does not have this support as it appears that Hibernate and Toplink both do as do most J2EE vendors CMP 2.X containers.

I would say that the ramifications of not shipping batch update support would be fairly huge from both a JPA performance perspective but also from the more costly backend database perspective where typically CPU cycles are far more limited than on the application server machine.  Looking at most complex applications in the market place today and realizing almost all of them need this support to some degree I want this JIRA to drive that feature into OpenJPA.  Given the fact so many legacy containers and persistence engines have support for it, I consider it a bug that OpenJPA does not have it already.

Always open for thoughts.  Just started looking at this so I am not sure if it has been brought up in the past but does anyone have ideas or implementation prototypes that we could work together to build? ",All,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-09-18 16:46:38.319,,,no_permission,,,,,,,,,,,160512,,,Thu Sep 18 16:46:38 UTC 2008,,,,,,,0|i0z4db:,203010,,,,,,,,18/Sep/08 16:46;mikedd;This issue was fixed under OPENJPA-464 (if not before then). ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Schemas defined in orm.xml are only applied when a name is also specified. ,OPENJPA-179,12365607,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,22/Mar/07 19:49,02/May/13 02:29,14/Mar/19 03:02,03/Apr/07 02:59,0.9.6,0.9.7,,,,,,,,0.9.7,,,,,jpa,,,,,,0,,"If a default schema name is specified (either as a mapping file default or a persistence unit default) it will only be applied if a table name is also included in the same xml descriptor. 

For example if the xml file looks like this 

<?xml version=""1.0"" encoding=""UTF-8""?>
<entity-mappings xmlns=""http://java.sun.com/xml/ns/persistence/orm""
	xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
	xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence/orm http://java.sun.com/xml/ns/persistence/orm_1_0.xsd""
	version=""1.0"">
	<persistence-unit-metadata>
		<persistence-unit-defaults>
			<schema>DefSchema</schema>
		</persistence-unit-defaults>
	</persistence-unit-metadata>
	<entity class=""mdd.MyEntity"">
		<attributes>
			<id name=""id""></id>
			<basic name=""name""></basic>
		</attributes>
	</entity>
	<entity class=""mdd.MyEntityWithTable"">
		<table name=""MyEntityWithTable""/>
		<attributes>
			<id name=""id""></id>
			<basic name=""name""></basic>
		</attributes>
	</entity>
</entity-mappings>

The default schema will be applied to MyEntityWithTable, but will not be applied to MyEntity. The same applies if the xml looks like this : 
<?xml version=""1.0"" encoding=""UTF-8""?>
<entity-mappings xmlns=""http://java.sun.com/xml/ns/persistence/orm""
	xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
	xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence/orm http://java.sun.com/xml/ns/persistence/orm_1_0.xsd""
	version=""1.0"">
	<schema>DefSchema</schema>
         . . .
</entity-mappings>

I think there are two problems here : 

1. The mapping file default schema (example 2) should apply to every entity in the xml mapping file (except where it's overridden by another entry or an annotation). 

2. A schema defined in the <persistence-unit-defaults> tag should apply to all entities in the persistence unit, not just the ones defined or overridden in the xml file. This default is overridden my the mapping file default schema, other xml schema entries and annotations. 

I'll attach a simple sample of the problem, in case I'm missing something. 
",,,,,,,,,,,,,OPENJPA-400,,,,,,,,,22/Mar/07 19:54;mikedd;OpenJPA-179-example.zip;https://issues.apache.org/jira/secure/attachment/12353993/OpenJPA-179-example.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160511,,,Tue Apr 03 02:59:48 UTC 2007,,,,,,,0|i1dpjj:,288235,,,,,,,,22/Mar/07 19:54;mikedd;Attaching simple example. Contains a test which just drives some SQL statements which show the default schema is only used if I define a table in orm.xml. ,03/Apr/07 02:59;mikedd;Fixed with revision 525006. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
When using NOT NULL constraint on foreign key it is not possible to use CascadeType.ALL and GeneratedId,OPENJPA-177,12365447,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,danielgajdos,danielgajdos,21/Mar/07 11:19,09/Mar/10 18:32,14/Mar/19 03:02,31/Jul/07 19:53,0.9.6,,,,,,,,,1.0.0,,,,,jpa,,,,,,0,,"When using on entity Application
	@OneToOne(cascade = CascadeType.ALL)
	@JoinColumn(name = ""C_PERSON_ID"", nullable=false)
	@ForeignKey
	private Person person;
and on entity Person using generated ID, it fails on inserting Application because of performing db actions in this order:
INSERT INTO T_APPLICATION (C_ID, C_APPLICATION_NUMBER, C_APPLIED_DATE, C_STATUS) VALUES (:1, :2, :3, :4) - here it tries to insert null value as 		C_PERSON_ID, which is not permited because of nullable=false declaration. This declaration creates NOT NULL constraint on C_PERSON_ID.
INSERT INTO NSVISP.T_PERSON (C_ID, C_BIRTH_DATE, C_FIRST_NAME, C_LAST_NAME) VALUES (:1, :2, :3, :4)
UPDATE NSVISP.T_APPLICATION SET C_PERSON_ID = :1 WHERE C_ID = :2
Error reported from DB:
org.apache.openjpa.lib.jdbc.ReportingSQLException: ORA-01400: cannot insert NULL into (""T_APPLICATION"".""C_PERSON_ID"")

Is there any chance to change the order in which this operations are executed? On this type of constraint we have to insert Person before inserting Application and include the generated Person Id into insert statement for Application. Otherwise we have to deffer the NOT NULL constraint which can be dangerous and it is not defered initialy.","Windows XP, IBM 32-bit SDK 5.0, WebSphere 6.1",,,,,,,,,,,,,,,OPENJPA-235,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-03-21 16:15:44.27,,,no_permission,,,,,,,,,,,160509,,,Tue Jul 31 19:53:09 UTC 2007,,,,,,,0|i0zb87:,204121,,,,,,,,"21/Mar/07 16:15;awhite;OpenJPA will insert records in the order that you persist the corresponding objects.  When you persist in an order that would violate foreign key constraints, OpenJPA attempts to insert null and then update the foreign key value in a separate statement.  If you use non-nullable constraints, though, you must persist your objects in the correct order.","22/Mar/07 09:15;danielgajdos;In official manual for OpenJPA, chapter 13.2. Schema Factory (http://people.apache.org/~mprudhom/openjpa/site/openjpa-project/manual/ref_guide_schema_info.html#ref_guide_schema_info_factory) I found:
When using this factory, it is important that your mapping metadata correctly represent your database's foreign key constraints so that OpenJPA can order its SQL statements to meet them.
And my question is how is OpenJPA ordering it;s statements when as you can see it is inserting Application first and then Person and it takes care about @ForeignKey constraint by inserting null value in Application and then updating this value to PersonID. Is it true that OpenJPA doesn't take care about non-nullable constraints? Another interesting thing is that after changing nullable to false it does not change the DB schema by adding not null constraint, it adds this constraint only when creating TABLE. Is this correct?","11/Jul/07 23:25;m_fuchs;Daniel,

I submitted a patch for OPENJPA-235 that prevents nullifying not-nullable columns. The patch is openjpa-235-break-nullable.patch. Would you be able to test it or provide a test case for me? Thanks!","31/Jul/07 19:34;m_fuchs;This problem should be solved by openjpa-235-break-nullable.patch, which has been checked in. ","31/Jul/07 19:53;clr;The fix for OPENJPA-235 should resolve this issue as well. 

If any problems remain, please reopen this JIRA.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Eager selects by PagingResultObjectProvider may not use the FetchBatchSize,OPENJPA-175,12365310,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ssegu,ssegu,19/Mar/07 23:57,09/Mar/10 18:32,14/Mar/19 03:02,24/Mar/07 00:42,0.9.0,0.9.6,,,,,,,,0.9.7,,,,,,,,,,,0,,"The PagingResultObjectProvider during initialization does checks to determine the appropriate pageSize. While this logic caps the size to 50 and addresses determining an appropriate page size, it doesn't always conform to the set batch size. For example with the size being 1000 and FetchBatchSize set to say 500, the page size is determined to be 50 resulting in eager selects happening in batches of 50 when the user expects it to be in batches of 500. ",,,,,,,,,,,,,,,,,,,,,,22/Mar/07 05:45;ssegu;InExpression-Diff.txt;https://issues.apache.org/jira/secure/attachment/12353927/InExpression-Diff.txt,20/Mar/07 19:43;ssegu;OPENJPA-175-patch.txt;https://issues.apache.org/jira/secure/attachment/12353782/OPENJPA-175-patch.txt,20/Mar/07 00:05;ssegu;OPENJPA-175-patch.txt;https://issues.apache.org/jira/secure/attachment/12353704/OPENJPA-175-patch.txt,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-03-20 15:11:08.867,,,no_permission,,,,,,,,,,,160507,,,Wed Mar 21 22:57:08 UTC 2007,,,,,,,0|i0z4cf:,203006,,,,,,,,"20/Mar/07 15:11;awhite;+1, with some caveats:

- The proposed patch doesn't handle the common cases where the FetchBatchSize is -1 (unlimited) or 0 (driver default).
- I'm a little nervous about defaulting the in clause limit to ""unlimited"" when we don't have much info on actual database limits other than Oracle.","20/Mar/07 19:43;ssegu;Patch with fixes to address the FetchBatchSize values of -1, 0. For FetchBatchSize being 0 or negative value other than -1 uses the earlier logic of determining a pageSize capped by 50 based on size.","21/Mar/07 16:22;awhite;I'll have to see the code in context once it's checked in because I'm not very good at reading patches, but it looks good to me.","21/Mar/07 22:06;awhite;1. Are you also going to fix InExpression to honor the DBDictionary's new in clause limit?
2. After reviewing the patch some more, I propose the following simplified version:

        // try to find a good page size.  if the known size < batch size, use
        // it.  if the batch size is set, then use that; if it's sorta close
        // to the size, then use the size / 2 to get two full pages rather
        // than a possible big one and small one
        int batch = getFetchConfiguration().getFetchBatchSize();
        int pageSize;
        if (batch < 0)
            pageSize = (int) size;
        else {
            if (batch == 0)
                batch = 50; // reasonable default
            if (size <= batch)
                pageSize = (int) size;
            else if (size <= batch * 2) {
                if (size % 2 == 0)
                    pageSize = (int) (size / 2);
                else
                    pageSize = (int) (size / 2 + 1);
            } else
                pageSize = batch;
        } ","21/Mar/07 22:57;ssegu;1 - Yes, was planning to do it as a separate JIRA given that it directly does not concern the issue raised here, however I will include it here since we are introducing the in-clause limit in the DBDictionary for this fix.
2 - Looks fine to me, except for the minor issue that in the (size <= batch * 2) case we will not be adhering to the FetchBatchSize for pageSize in that the first in-clause query will be for lesser than the FetchBatchSize number of entries, however we will still endup running the same number of in-clause queries - 2.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
error when find()'ing an abstract class,OPENJPA-174,12365277,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,farble1670,farble1670,19/Mar/07 17:31,09/Mar/10 18:32,14/Mar/19 03:02,19/Mar/07 21:47,0.9.6,,,,,,,,,0.9.7,,,,,,,,,,,0,,"class B extends A
A is abstract
B is concrete

i have persisted an instance of B. now i try:

A a = em.find(A.class, anId);

openjpa fails with:

... Cannot create new application identity instance for abstract   class ""class A""

if i change the find to:

A a = em.find(B.class, anId);

openjpa works okay.

note that i have two test cases. one is my real model, and one is the simple A and B class example above. my real model fails, where the simple A, B class example works as expected. so, it's is either a side affect of some other issue, or there is something wrong in my model and the error message is misleading or lacking information.","Java SE 5
Derby ",,,,,,,,,,,,,,,,,,,,,19/Mar/07 17:37;farble1670;abstracttest.zip;https://issues.apache.org/jira/secure/attachment/12353672/abstracttest.zip,19/Mar/07 17:35;farble1670;pom.zip;https://issues.apache.org/jira/secure/attachment/12353670/pom.zip,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-03-19 21:47:59.642,,,no_permission,,,,,,,,,,,160506,,,Mon Mar 19 21:47:59 UTC 2007,,,,,,,0|i0z4cv:,203008,,,,,,,,"19/Mar/07 17:35;farble1670;this is a netbeans maven2 project that shows the error. the test case that fails is in PersistTest.java line 61 and 62. 61 fails. 62 succeeds (but is commented out right now.

to run the test case you need a derby network server running on localhost and default port.","19/Mar/07 17:37;farble1670;this is the simple A, B class test case the works. again, maven2 netbeans projects ... requires derby on localhost:1527 running.",19/Mar/07 21:47;awhite;Only affected abstract base types with a single String id field.  Fixed in SVN revision 520117.  Added test case in org.apache.openjpa.persistence.inheritance.TestFindAbstractClass.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JOIN in subselect generates bad SQL,OPENJPA-173,12364867,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,rogerkeays,rogerkeays,14/Mar/07 00:38,09/Mar/10 18:35,14/Mar/19 03:02,02/May/07 21:44,0.9.6,,,,,,,,,,,,,,sql,,,,,,0,,"As reported at openjpa-dev [1], the following query generates invalid SQL:

    UPDATE Email e SET e.totalDeliveries = e.totalDeliveries + 1
    WHERE e.email IN (
        SELECT m.email FROM MailingList l JOIN l.subscribers m)

OpenJPA (0.9.6) parses this correctly, but can't seems to be missing the JOIN clause or some table names from the generated SQL:

 org.apache.openjpa.lib.jdbc.ReportingSQLException: ERROR: syntax error at or near ""WHERE"" {prepstmnt 27475707 UPDATE FB_EMAILS SET totalDeliveries = (totalDeliveries + ?) WHERE email IN (SELECT DISTINCT t2.email FROM WHERE (t2.email IN (SELECT t3.email FROM FB_EMAILS t3 WHERE t0.id = t1.id AND t1.subscribers_email = t3.email))) [params=(long) 1]} [code=0, state=42601]

    org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:188)
    org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$800(LoggingConnectionDecorator.java:53)
    org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:854)
    org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:266)
    org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:266)
    org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1360)
    org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeBulkOperation(JDBCStoreQuery.java:491)
    org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeUpdate(JDBCStoreQuery.java:420)
    org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeUpdate(ExpressionStoreQuery.java:685)
     org.apache.openjpa.datacache.QueryCacheStoreQuery$QueryCacheExecutor.executeUpdate(QueryCacheStoreQuery.java:343)
    org.apache.openjpa.kernel.QueryImpl.update(QueryImpl.java:1028)
    org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:793)
    org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:868)
    org.apache.openjpa.kernel.QueryImpl.updateAll(QueryImpl.java:864)
    org.apache.openjpa.kernel.DelegatingQuery.updateAll(DelegatingQuery.java:560)
    org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:304) 

[1] http://www.nabble.com/forum/ViewPost.jtp?post=9450588&framed=y",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-05-02 21:44:46.904,,,no_permission,,,,,,,,,,,160505,,,Wed May 02 21:44:46 UTC 2007,,,,,,,0|i0z4br:,203003,,,,,,,,"02/May/07 21:44;wisneskid;This issue should be fixed by r534623, a similar issue OPENJPA-51.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
QueryImpl.setFirstResult does not take already set maxResults into account,OPENJPA-165,12364581,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,jdf@us.ibm.com,jdf@us.ibm.com,09/Mar/07 18:06,09/Mar/10 18:32,14/Mar/19 03:02,07/Aug/07 23:47,0.9.7,,,,,,,,,1.0.0,,,,,query,,,,,,0,,"If you want rows 10-19 of some query, the sequence

  q.setFirstResult(10).setMaxResults(10);

behaves as expected. On the other hand

  q.setMaxResults(10).setFirstResult(10);

returns the empty list. QueryImpl.setFirstResult should reset the range endpoint. maxResults is a count, not an index.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-03-13 12:24:43.343,,,no_permission,,,,,,,,,,,160497,,,Tue Mar 13 12:24:43 UTC 2007,,,,,,,0|i0z1a7:,202510,,,,,,,,13/Mar/07 12:24;kwsutter;I've discussed this problem with Jonathan and we should have a patch available soon.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@OrderBy on @OneToMany does not allow ordering by @Id value,OPENJPA-162,12364095,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,spatula,spatula,05/Mar/07 04:10,09/Mar/10 18:32,14/Mar/19 03:02,05/Mar/07 20:14,0.9.6,,,,,,,,,0.9.7,,,,,jpa,,,,,,0,,"Using the following annotation:

   @OneToMany(mappedBy=""root"", fetch=FetchType.LAZY)
    @OrderBy(""objectId ASC"")
    private List<Message> messages;

I get the exception ""Cannot order ""net.spatula.tally_ho.model.MessageRoot.messages"" on ""objectId"", because that field is not in the default fetch group.  You can only order on fields that will be selected when the related object is loaded.""

I should certainly hope that the primary key of the related object is going to be selected when the object is loaded:

    @Id
    @Column(name = ""object_id"")
    private long objectId;
",Using PostgreSQL 8.1 as the database,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-03-05 18:38:53.888,,,no_permission,,,,,,,,,,,160494,,,Mon Mar 05 20:14:49 UTC 2007,,,,,,,0|i0z49z:,202995,,,,,,,,"05/Mar/07 18:38;pcl;I believe that the issue is that the field is not in the current fetch configuration; i.e., it's a lazy relationship. The ID field will clearly be part of the instance that is selected , but when you're selecting Messages, not Threads (or whatever it is that contains Messages).

What happens if you just say '@OrderBy' and leave out the string argument? According to 9.1.28 of the spec, if you just specify @OrderBy and nothing else, the ordering will be ascending by the pk of the associated records, which happens to be what you want.",05/Mar/07 20:14;awhite;Fixed in revision 514847.  Test case TestIdOrderedOneMany added.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException when running query with null parameter,OPENJPA-157,12363281,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ssegu,ssegu,21/Feb/07 03:48,09/Mar/10 18:32,14/Mar/19 03:02,21/Feb/07 04:07,,,,,,,,,,0.9.7,,,,,jdbc,,,,,,0,,"NullPointerException when running query with null parameter value, testcase attached. 

Caused by: java.lang.NullPointerException
        at org.apache.openjpa.jdbc.meta.strats.RelationStrategies.toDataStoreValue(RelationStrategies.java:87)
        at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.toDataStoreValue(RelationFieldStrategy.java:597)
        at org.apache.openjpa.jdbc.meta.FieldMapping.toDataStoreValue(FieldMapping.java:795)
        at org.apache.openjpa.jdbc.kernel.exps.PCPath.toDataStoreValue(PCPath.java:542)
        at org.apache.openjpa.jdbc.kernel.exps.Param.calculateValue(Param.java:106)
        at org.apache.openjpa.jdbc.kernel.exps.CompareEqualExpression.appendTo(CompareEqualExpression.java:86)
        at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.buildWhere(SelectConstructor.java:237)
        at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.evaluate(SelectConstructor.java:78)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.createWhereSelects(JDBCStoreQuery.java:323)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeQuery(JDBCStoreQuery.java:165)
        at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:672)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:930)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:742)",,,,,,,,,,,,,,,,,,,,,,21/Feb/07 03:54;ssegu;testcase.zip;https://issues.apache.org/jira/secure/attachment/12351654/testcase.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160489,,,Wed Feb 21 04:07:31 UTC 2007,,,,,,,0|i0zaxj:,204073,,,,,,,,"21/Feb/07 04:07;ssegu;Completed: At revision: 509885  
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 java.lang.ArrayIndexOutOfBoundsException during commit,OPENJPA-155,12363190,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ssegu,ssegu,20/Feb/07 04:53,09/Mar/10 18:32,14/Mar/19 03:02,20/Feb/07 09:01,,,,,,,,,,0.9.7,,,,,jdbc,,,,,,0,,"After a RowImpl is created for persisting an Entity, when more mapping information is found corresponding to the same table the _table of the already created RowImpl gets modified, in the attached scenario causing the ArrayIndexOutOfBoundsException ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160487,,,Tue Feb 20 09:01:08 UTC 2007,,,,,,,0|i0z6b3:,203324,,,,,,,,"20/Feb/07 09:01;ssegu;Completed: At revision: 509473  

Capturing reference to the Column[] at the creation time in the RowImpl instead of the Table, to work with DynamicSchemaFactory where the Table's columns can get modified after the creation of the RowImpl before the flush.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OptimisticLockException working with  Savepoints,OPENJPA-154,12363186,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,ssegu,ssegu,20/Feb/07 01:41,09/Mar/10 18:32,14/Mar/19 03:02,20/Feb/07 02:03,,,,,,,,,,0.9.7,,,,,kernel,,,,,,0,,"Call to flush following  a call to rollbackToSavepoint causes OptimisticLockException  on account of the version data not being rolled back. Testcase attached, run with <property name=""openjpa.SavepointManager"" value=""oracle""/>
",Using Oracle,,,,,,,,,,,,,,,,,,,,,20/Feb/07 01:43;ssegu;testcase.zip;https://issues.apache.org/jira/secure/attachment/12351552/testcase.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160486,,,Tue Feb 20 02:03:26 UTC 2007,,,,,,,0|i1dp3z:,288165,,,,,,,,20/Feb/07 01:43;ssegu;Testcase,20/Feb/07 02:03;ssegu;Completed: At revision: 509411,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Column in @AttributeOverride not honoring table attribute that maps to a secondary table in mappedsuperclass entity,OPENJPA-150,12362925,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,allee8285,allee8285,15/Feb/07 14:38,30/Oct/07 14:45,14/Mar/19 03:02,20/Feb/07 17:38,,,,,,,,,,0.9.7,,,,,jdbc,sql,,,,,0,,"I have the following scenario mapping entity to 2 tables:

- a mapped super class that has a field
- a subclass with a pk and a field.
- trying to map all the fields (except the pk (id) ) to a secondary table (SEC_TABLE2MSC)
  - use @Column in the sub-class to override (name) to the secondary table
  - use @AttributeOverride to override the field (street) in the mapped super class to the secondary table.

===============
@MappedSuperclass
public abstract class AnnMSCMultiTable
implements IMultiTableEntity
{
    // @Column(table=""SEC_TABLE2MSC"")
    private String street;
    public String getStreet() {
        return street;
    }
   public void setStreet(String street) {
        this.street = street;
    }
}
===============
@Entity
@SecondaryTable(name=""SEC_TABLE2MSC"", pkJoinColumns=@PrimaryKeyJoinColumn(name=""id""))
@AttributeOverrides(
        {
            @AttributeOverride(name=""street"", column=@Column(name=""street"", table=""SEC_TABLE2MSC"")),
        })
public class AnnMSCMultiTableEnt
extends AnnMSCMultiTable
{
    @Id
    private int id;

    @Column(name=""name2"", table=""SEC_TABLE2MSC"")
    private String name;
}
===============

From examining JPA spec, there is no specific in the @Column and @AttributeOverride that this should not be allow. So I believe this is a valid scenario.

Using the MappingTool, the attribute override does not map the street field to the SEC_TABLE2MSC as I would expect:

CREATE TABLE AnnMSCMultiTableEnt (id INTEGER NOT NULL, street VARCHAR(254), PRIMARY KEY (id));
CREATE TABLE SEC_TABLE2MSC (id INTEGER, name2 VARCHAR(254));
CREATE INDEX I_SC_TMSC_ID ON SEC_TABLE2MSC (id);

I experiment this a little bit and the only way I can map the street field to SEC_TABLE2MSC is
to add the @Column against the ""street"" attribute in the super class. (the commented @Column in the example).
The expected SQL are:

CREATE TABLE AnnMSCMultiTableEnt (id INTEGER NOT NULL, PRIMARY KEY (id));
CREATE TABLE SEC_TABLE2MSC (id INTEGER, street VARCHAR(254), name2 VARCHAR(254));
CREATE INDEX I_SC_TMSC_ID ON SEC_TABLE2MSC (id);

I tried to create the tables manually using the expected layout, but the runtime still using the incorrect tables structure. I would suspect the MappingTool and the runtime are using the same mapping strategy.

Albert Lee,",Any,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-02-20 17:38:06.711,,,no_permission,,,,,,,,,,,41969,,,Tue Feb 20 17:38:06 UTC 2007,,,,,,,0|i0z4fr:,203021,,,,,,,,"16/Feb/07 18:38;allee8285;I investigated into this problem and the following changes has corrected the problem scenarios:

public class org.apache.openjpa.persistence.jdbc.AnnotationPersistenceMappingParser
{
    .......
    private void parseAttributeOverrides(ClassMapping cm,
        AttributeOverride... attrs) {
        .......
        for (AttributeOverride attr : attrs) {
            ...........
//            unique = (scol.unique()) ? TRUE : FALSE;
//            setColumns(sup, sup.getValueInfo(), Arrays.asList
//                (new Column[]{ newColumn(scol) }), unique);
            // *** Replace the above statements by parseColumns()
            parseColumns( sup, scol);
        }
    }

    private void parseAttributeOverrides(FieldMapping fm,
        AttributeOverride... attrs) {
        ..........
        for (AttributeOverride attr : attrs) {
            ...........
//            unique = (ecol.unique()) ? TRUE : FALSE;
//            setColumns(efm, efm.getValueInfo(), Arrays.asList
//                (new Column[]{ newColumn(ecol) }), unique);
            // *** Replace the above statements by parseColumns()
            parseColumns( efm, ecol);
        }
    }
}

Basically, the changes are to re-use the parseColumns() method to process the @Column defintion(s) in @AttributeOverride to handle all the @Column attributes.

I ran some basic tests and there is no regression.

I am new to the openjpa code base and still have a long way to fully understand all the the ins and outs. 

Can someone, who has more thorough knowledge of this code path, review these changes to ensure I am not ""way-off""?

Thanks.
Albert Lee.",20/Feb/07 17:38;awhite;Committed suggested changes (with very minor modifications) in revision 509674.  Thanks for the fix.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Parsing exception while using an ""exploded"" archive",OPENJPA-148,12362833,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,benoitf,benoitf,14/Feb/07 21:45,09/Mar/10 18:32,14/Mar/19 03:02,22/May/07 16:28,,,,,,,,,,1.0.0,,,,,jpa,,,,,,0,,"This happens when using OpenJPA as persistence provider for the EasyBeans ObjectWeb container.
The error is happening with ""exploded"" archive.
Exploded means that there is a directory, named ""entitybean.jar"" with a folder META-INF which contains a file named persistence.xml, and other directories/files for the classes.

It seems that when using this mode, OpenJPA is trying to parse the directory inputstream (which is failing).
This exception is not occuring if a jar file is used instead of the ""exploded"" mode, but the exploded mode is the default mode for EasyBeans.
Note also that this exception don't occur by using Hibernate Entity Manager or Oracle TopLink Essentials as persistence provider.

I will attach to this issue a stack trace (with the exploded directory) which fails and at the end with a jar file (which work)
And 4 steps used to reproduce this problem",Sun JDK 5.0 / EasyBeans / OpenJPA snapshot 0.9.7,,,,,,,,,,,,,,,,,,,,,16/May/07 21:17;djencks;OPENJPA-148-2.patch;https://issues.apache.org/jira/secure/attachment/12357497/OPENJPA-148-2.patch,02/May/07 22:05;djencks;OPENJPA-148.patch;https://issues.apache.org/jira/secure/attachment/12356673/OPENJPA-148.patch,17/Feb/07 17:14;benoitf;debug_traces_directorymode.txt;https://issues.apache.org/jira/secure/attachment/12351432/debug_traces_directorymode.txt,17/Feb/07 17:15;benoitf;debug_traces_filemode_working.txt;https://issues.apache.org/jira/secure/attachment/12351433/debug_traces_filemode_working.txt,14/Feb/07 21:47;benoitf;stacktrace-error.txt;https://issues.apache.org/jira/secure/attachment/12351179/stacktrace-error.txt,14/Feb/07 21:48;benoitf;steps.txt;https://issues.apache.org/jira/secure/attachment/12351180/steps.txt,,,,,,,,,6.0,,,,,,,,,,,,,,,,,,,2007-05-02 22:05:52.283,,,no_permission,,,,,,,,,,,160482,,,Tue May 22 16:28:45 UTC 2007,,,,,,,0|i1dp4f:,288167,,,,,,,,"14/Feb/07 21:47;benoitf;On the top of the file, the error.

At the end, the same data but packaged in a .jar file and in this case, it works.",14/Feb/07 21:48;benoitf;The steps to reproduce this error.,"17/Feb/07 17:13;benoitf;Here is a follow up for explaining the process that OpenJPA is using on exploded jar files:

The PersistenceUnitInfo object build by the EJB3 container(EasyBeans in my testcase) is sent to OpenJPA.
Then, in the method toOpenJPAProperties of org.apache.openjpa.persistence.PersistenceUnitInfoImpl class

The getPersistenceUnitRootUrl() URL (which is the directory URL
 file:/home/florent/workspace/easybeans/ejb3s/entitybean.jar/) is transformed
 into /home/florent/workspace/easybeans/ejb3s/entitybean.jar/ as it is a ""file:"" URL


Then, the getJarFileUrls() is returning the same URL (file:/home/florent/workspace/easybeans/ejb3s/entitybean.jar/)
This URL is an exploded JAR file URL which is valid for this method as said in the specification
 ""Returns a list of URLs for the jar files or exploded jar file directories that the persistence provider [...]""
 (It has been clarified between the proposed final specification and the final specification)

The PersistenceUnitInfoImpl class is then transforming these two URLs into:
  - ""Files"" property with the value /home/florent/workspace/easybeans/ejb3s/entitybean.jar/
  - ""URLs"" property with the value file:/home/florent/workspace/easybeans/ejb3s/entitybean.jar/

Then, these values will be analyzed in  parsePersistentTypeNames(ClassLoader loader) method of
 the class org.apache.openjpa.meta.AbstractCFMetaDataFactory

1/ First, the ""Files"" property is analyzed:
As /home/florent/workspace/easybeans/ejb3s/entitybean.jar/ is a directory, it goes in:

                if (file.isDirectory()) {
                    if (log.isTraceEnabled())
                        log.trace(_loc.get(""scanning-directory"", file));
                    scan(new FileMetaDataIterator(dir, newMetaDataFilter()),
                        cparser, names, true, file);
                } 

which found...nothing. (I have done another test with a file for the PersistenceUnitRootUrl
 (and not a directory) and in this case the scan of the file finds the Entity class while it doesn't
 find the entity class in directory mode).
Also here, dir is null, if dir = file, it finds the entity class.

The corresponding debug trace is:
[TRACE] MetaData - Scanning directory ""/home/florent/workspace/easybeans/ejb3s/entitybean.jar"" for persistent types.


2/ Then, the ""URLs"" property is analyzed:
It's not a .jar file so the case ""else if (url.getPath().endsWith("".jar""))"" is not used and it fallbacks
 in the default case:

                } else {
                    if (log.isTraceEnabled())
                        log.trace(_loc.get(""scanning-url"", url));
                    clss = cparser.parseTypeNames(new URLMetaDataIterator(url));
                    if (log.isTraceEnabled())
                        log.trace(_loc.get(""scan-found-names"", clss, url));
                    names.addAll(Arrays.asList(clss));
                    mapPersistentTypeNames(url, clss);
                }

And mapPersistentTypeNames method do the following:
_unparsed.add((URL) rsrc);

so, the URL which is referencing an exploded jar is considered as an unparsed URL from now.

The corresponding traces are:
[TRACE] MetaData - Scanning URL ""file:/home/florent/workspace/easybeans/ejb3s/entitybean.jar/"" for persistent types.
[TRACE] MetaData - Scan of ""file:/home/florent/workspace/easybeans/ejb3s/entitybean.jar/"" found persistent types [Ljava.lang.String;@14c7cd.
[TRACE] MetaData - Mapping resource location ""file:/home/florent/workspace/easybeans/ejb3s/entitybean.jar/"" to persistent types ""[]"".

(with [Ljava.lang.String;@14c7cd. being an empty array.)

When a class needs to be loaded by the load(Class cls, int mode, ClassLoader envLoader) method of org.apache.openjpa.persistence.PersistenceMetaDataFactory class, there is a check on the _unparsed attribute.

And in this case, it tries to parse the URL as an XML file:
  for (URL url : _unparsed)
    parseXML(url, cls, mode, envLoader);

And we can imagine the result of parsing a directory as an XML file.

The result is:
[WARN] Enhance - An exception was thrown while attempting to perform class file transformation on ""org/objectweb/easybeans/examples/entitybean/SessionFacadeRemote"": <<0|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.util.GeneralException: org.xml.sax.SAXException: file:/home/florent/workspace/easybeans/ejb3s/entitybean.jar/ [Location: Line: 1, C: 1]: org.xml.sax.SAXParseException: Content is not allowed in prolog.><0|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.util.GeneralException: org.xml.sax.SAXException: file:/home/florent/workspace/easybeans/ejb3s/entitybean.jar/ [Location: Line: 1, C: 1]: org.xml.sax.SAXParseException: Content is not allowed in prolog.
	at org.apache.openjpa.persistence.PersistenceMetaDataFactory.parseXML(PersistenceMetaDataFactory.java:233)


So, I think that you have now a complete report and that you're understanding why OpenJPA is failing.


",17/Feb/07 17:14;benoitf;add traces with debug mode on (for the directory failing case),17/Feb/07 17:15;benoitf;Add debug traces for the same classes packaged in a .jar file and that is working.,"02/May/07 22:05;djencks;This patch fixes the issue for me in the geronimo integration.  There are 2 changes:

1. there's an apparent bug in the treatment of a directory.  There's a var ""dir"" which is AFAICT never set that used to be scanned.  I changed it to scan the directory under consideration, which does find the persistent classes in the dir.  I don't know if dir should be set to one of the scanned directories.

2. In the geronimo environment, the same locations show up in both the files and urls lists.  I haven't figured out exactly why.  However, this lets the second part of the fix work, which is to ignore urls that point to a file that has already been scanned.  I think this is probably OK since non-file urls generally can't be scanned like a directory.  

I'll be happy to work on improvements given advice on problems with this patch, but this patch would IMO be a good start.",04/May/07 09:38;mprudhom;Applied (partial) patch.,"04/May/07 16:21;djencks;Marc did not apply this part of the patch, which was actually the crucial part to get this to work for geronimo :-).  As I noted before this may well not be the best way to solve the problem, its only virtue is that it works:

+                if (""file"".equals(url.getProtocol())) {
+                    File file = new File(url.getFile()).getAbsoluteFile();
+                    if (files.contains(file)) {
+                        continue;
+                    }
+                }

For reasons that are not entirely clear to me yet, the war WEB-INF/classes directory is showing up both in the files list (where it is processed correctly) and the urls list where it is causing an error since the code tries to treat it as an xml file.  The patch excerpt above is a bit of a hack but it checks each url to see if it matches a file in the files list and if so skips it.  In particular the directory WEB-INF/classes is matched so it is skipped, thus sidestepping the problem.

IMO it would be better to avoid duplicating locations in the files and urls list but I haven't figured out how to make that happen yet.  I don't see much harm in this patch in any case since AFAICT there is never a reason to process a location twice.",04/May/07 16:38;mprudhom;I understand the reason for that part now. I've applied and committed the rest of the patch. Please comment in this issue if you still experience the problem with this patch.,"04/May/07 16:38;clr;Just thinking a bit outside the box here. Is it possibly a bug that the classes directory is being presented as a file? 

And perhaps defensively OpenJPA might check to see if the file is actually a directory and then just ignore it. i.e. if (file.isDirectory()) continue;

But I'd like to see a bit more investigation into whether the behavior of the container is correct. It does seem odd that the container is expecting the provider to remove duplicate items from the deployment artifact.","04/May/07 16:57;benoitf;I tested with the last revision 535321 (that includes the second commit of this patch) and the deployment works fine on EasyBeans when using exploded archive.

Thanks.","04/May/07 17:09;djencks;Craig said...
<Just thinking a bit outside the box here. Is it possibly a bug that the classes directory is being presented as a file?

I don't think presenting it as a file is a problem, that part works fine.  Presenting it as a URL is what causes problems.

<And perhaps defensively OpenJPA might check to see if the file is actually a directory and then just ignore it. i.e. if (file.isDirectory()) continue;

A couple lines above this patch file.isDirectory() is treated correctly, and ignoring it is not necessary :-)

<But I'd like to see a bit more investigation into whether the behavior of the container is correct. It does seem odd that the container is expecting the provider to remove duplicate items from the <deployment artifact.

I agree.  I think there's something wrong that the same things are showing up in the list of files and the list of urls.  However based on my very limited tracing through the code I think this is caused by some multiple format conversions openjpa is doing: list of urls >> ';' separated string >> list of files + list of urls.  I haven't figured out exactly what is going on here, and any comments on the codes' purpose would be welcome :-)


","16/May/07 21:17;djencks;Some more experience indicates my previous patch suffers from at least 2 problems:

- NPE if files is null
- If one of the URLs is a directory, but not a file, we still get the same problem of trying to read a directory like an xml document.",16/May/07 21:17;djencks;Attached patch fixes the 2 additional issues I've found.,"21/May/07 20:44;mprudhom;I've gone ahead and applied OPENJPA-148-2.patch. If this works for you, please go ahead and mark this issue as resolved.","22/May/07 16:28;djencks;It works for geronimo now, many thanks!",,,,,,,,,,,,,,,,,,,,,
Entity enhancement fails while using EmbeddedId on a MappedSuperclass,OPENJPA-146,12362779,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,gergul,gergul,14/Feb/07 12:00,09/Mar/10 18:32,14/Mar/19 03:02,20/Feb/07 16:35,,,,,,,,,,0.9.7,,,,,kernel,,,,,,0,,"Both buildtime and runtime class enhancement fail with the following error:

...
1339  TRACE  [main] openjpa.Enhance - Enhancing type ""class test.B"".
Exception in thread ""main"" <0|false|0.9.6-incubating> org.apache.openjpa.util.GeneralException: null
        at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:350)
        at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:3711)
        at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:3661)
        at org.apache.openjpa.enhance.PCEnhancer.main(PCEnhancer.java:3633)
Caused by: java.lang.NullPointerException
        at org.apache.openjpa.enhance.PCEnhancer.enhanceObjectId(PCEnhancer.java:2745)
        at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:338)
        ... 3 more

Test code as follows:

test/A.java:
--------------
package test;

import javax.persistence.*;
import java.io.Serializable;

@MappedSuperclass
abstract public class A {

    @Embeddable
    public static class A_PK implements Serializable {
        @Basic
        protected int id1;
        
        @Basic
        protected String id2;
        
        public boolean equals (Object other) {
            return false;
        }

        public int hashCode () {
            return 0;
        }

    }

    @EmbeddedId
    protected A_PK pk;

    @Basic
    protected String val;

}
--------------

test/B.java:
--------------
package test;

import javax.persistence.Entity;

@Entity
public class B extends A {

}
--------------

META-INF/persistence.xml:
--------------
<persistence xmlns=""http://java.sun.com/xml/ns/persistence""
        xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
        xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence/orm http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd""
        version=""1.0"">
    <persistence-unit name=""TestService"" transaction-type=""RESOURCE_LOCAL"">
        <class>test.A$A_PK</class>
        <class>test.A</class>
        <class>test.B</class>
        <properties>
            <property name=""openjpa.Log"" value=""DefaultLevel=TRACE""/>

            <property name=""openjpa.ConnectionUserName"" value=""test""/>
            <property name=""openjpa.ConnectionPassword"" value=""test""/>
            <property name=""openjpa.ConnectionURL"" value=""jdbc:mysql://localhost:3306/oam?useServerPrepStmts=false""/>
            <property name=""openjpa.ConnectionDriverName"" value=""com.mysql.jdbc.Driver""/>
        </properties>
    </persistence-unit>
</persistence>
--------------



",openjpa 0.9.6,,,,,,,,,,,,,,,,,,,,,14/Feb/07 12:04;gergul;test-case.zip;https://issues.apache.org/jira/secure/attachment/12351129/test-case.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-02-14 15:25:19.349,,,no_permission,,,,,,,,,,,160480,,,Tue Feb 20 18:39:52 UTC 2007,,,,,,,0|i0z1dr:,202526,,,,,,,,14/Feb/07 12:04;gergul;Test case and trace output attached.,"14/Feb/07 15:25;awhite;We don't enhance the oid class anymore, so this bug is probably fixed or at least will manifest itself in a different way in the latest code.","17/Feb/07 09:13;gergul;0.9.7-snapshot seems to have solved this indeed, thanks.","17/Feb/07 10:08;gergul;Alright, it did manifest itself in a different way as you guessed:

java.lang.NullPointerException
	at org.apache.openjpa.jdbc.meta.strats.EmbedValueHandler.map(EmbedValueHandler.java:50)
	at org.apache.openjpa.jdbc.meta.strats.ObjectIdValueHandler.map(ObjectIdValueHandler.java:46)
	at org.apache.openjpa.jdbc.meta.strats.HandlerStrategies.map(HandlerStrategies.java:56)
	at org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy.map(HandlerFieldStrategy.java:77)
	at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:117)
...

Bit of debugging into the code:

(EmbedValueHandler.java) 
    protected void map(ValueMapping vm, String name, ColumnIO io,
        boolean adapt, List cols, List args) {
        // have to resolve embedded value to collect its columns
        vm.getEmbeddedMapping().resolve(vm.MODE_META | vm.MODE_MAPPING);
...

vm .getEmbeddedMapping() returns null, since:

(ValueMetaDataImpl.java)
    public ClassMetaData getEmbeddedMetaData() {
        if (_embeddedMeta == null && isEmbeddedPC())
            addEmbeddedMetaData();
        return _embeddedMeta;
    }

and

    public boolean isEmbeddedPC() {
        return _decCode == JavaTypes.PC && isEmbedded();
    }

_decCode is JavaTypes.OID. 

JavaTypes.PC was possibly overwritten by:

    public boolean resolve(int mode) {
...
        // oid as primary key field?
        if (_decCode == JavaTypes.PC && isEmbedded()
            && _owner.isPrimaryKey() && _owner.getValue() == this)
            _code = _decCode = JavaTypes.OID; 

So I've changed

    public boolean isEmbeddedPC() {
        return _decCode == JavaTypes.PC && isEmbedded();
    }

to 

    public boolean isEmbeddedPC() {
        return (_decCode == JavaTypes.PC || _decCode == JavaTypes.OID) && isEmbedded();
    }

seems to have fixed the problem, tho I'm not sure if it has any nasty sideeffects.

Any comments?
",20/Feb/07 15:33;awhite;Looks like a good fix to me.  Do you need someone to commit this for you?,"20/Feb/07 16:07;awhite;Cancel my previous comment.  Embedded PCs are handled very differently than OIDs at runtime, and so changing the isEmbeddedPC method to encompass OIDs as well might cause problems.  I think the root of the problem has to do with metadata resolution of mapped superclass fields (after all, EmbeddedIds in Entities work fine, just not in MappedSuperclasses).  I'll investigate further.","20/Feb/07 16:35;awhite;Resolved with revision 509632.  When copying OID superclass fields for mapping in a subclass, revert the type of the field to PC.  It will re-resolve to OID when the copied field's metadata is resolved, and in the meantime it ensures that the copied field resolution will use the same code path as non-copied fields.","20/Feb/07 18:39;gergul;Fix confirmed, thanks.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JDBCConfigurationImpl does not support JNDI lookup for non-jta-data-source.  ,OPENJPA-144,12362708,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,bradmoon,bradmoon,13/Feb/07 17:25,09/Mar/10 18:32,14/Mar/19 03:02,16/Feb/07 16:22,,,,,,,,,,0.9.7,,,,,jdbc,,,,,,1,,"A non-jta-data-source is required for DB2 sequences; however, org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl does not support a JNDI lookup for this data source from the openjpa.ConnectionFactory2Name property as documented (refer to section 5.12 and 4.2.1 of the OpenJPA manual).

It seems like the same implementation for the jta-data-source should be implemented for the non-jta-data-source.  i.e.

// ADD createConnectionFactory2()
private DecoratingDataSource createConnectionFactory2() {
        DataSource ds = (DataSource) connectionFactory2.get();
        if (ds != null)
            return setupConnectionFactory(ds, true);

        ds = (DataSource) super.getConnectionFactory2(); // JNDI lookup
        if (ds == null)
            ds = DataSourceFactory.newDataSource(this, true);

        return setupConnectionFactory(ds, true);
    }

// MODIFY this method 
public Object getConnectionFactory2() {
        // override to configure data source
        if (dataSource2 == null) {
            DecoratingDataSource ds = createConnectionFactory2();
            dataSource2 = DataSourceFactory.installDBDictionary
                (getDBDictionaryInstance(), ds, this, true);
        }
        return dataSource2;
    }

","WebSphere 6.1, DB2 v8.1 and sequences",,,,,,,,,,,,,,,OPENJPA-149,,,,,,14/Feb/07 23:56;pcl;ASF.LICENSE.NOT.GRANTED--OPENJPA-144-patch.diff;https://issues.apache.org/jira/secure/attachment/12351196/ASF.LICENSE.NOT.GRANTED--OPENJPA-144-patch.diff,15/Feb/07 20:56;pcl;ASF.LICENSE.NOT.GRANTED--openjpa-144-patch-2.jar;https://issues.apache.org/jira/secure/attachment/12351281/ASF.LICENSE.NOT.GRANTED--openjpa-144-patch-2.jar,15/Feb/07 18:22;pcl;ASF.LICENSE.NOT.GRANTED--openjpa-144-patch.jar;https://issues.apache.org/jira/secure/attachment/12351270/ASF.LICENSE.NOT.GRANTED--openjpa-144-patch.jar,14/Feb/07 21:09;bradmoon;Both-JTAandNonJTASpecified.txt;https://issues.apache.org/jira/secure/attachment/12351176/Both-JTAandNonJTASpecified.txt,14/Feb/07 21:09;bradmoon;Only-JTASpecified.txt;https://issues.apache.org/jira/secure/attachment/12351177/Only-JTASpecified.txt,15/Feb/07 20:39;bradmoon;PostPatch-144.txt;https://issues.apache.org/jira/secure/attachment/12351280/PostPatch-144.txt,16/Feb/07 14:50;bradmoon;PostPatch-144fix2.txt;https://issues.apache.org/jira/secure/attachment/12351366/PostPatch-144fix2.txt,,,,,,,,7.0,,,,,,,,,,,,,,,,,,,2007-02-13 17:38:36.036,,,no_permission,,,,,,,,,,,160478,,,Fri Feb 16 20:00:46 UTC 2007,,,,,,,0|i0z1fr:,202535,,,,,,,,"13/Feb/07 17:38;pcl;Are you also specifying a jta-data-source, or only a non-jta-data-source? If specifying both, what error do you get when you don't specify a non-jta-data-source at all? I believe that there could be a problem, but I did some work a while back that makes it unnecessary to specify a non-jta-data-source if you're specifying a jta-data-source. That code works on WebLogic, but that's the only environment that I've tested it in.",14/Feb/07 12:57;bradmoon;The above solution is offered as an analysis level solution only.   Testing is in process.,"14/Feb/07 13:18;bradmoon;When we specify only a jta-data-source, we get:  ""<4|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.util.InvalidStateException: Unable to execute suspend on a WebSphere managed transaction. WebSphere does not support direct manipulation of managed transactions.""

When we try to use JNDI to specify the non-jta-data-source, we get the same error.  JDBCConfigurationImpl doesn't appear to use this information to populate datasource2.

When we pass the properties to have OpenJPA create the connection it works fine.  Here's the properties we pass: 

       <entry key=""openjpa.Connection2DriverName"" value=""com.ibm.db2.jcc.DB2Driver""/>
        <entry key=""openjpa.Connection2UserName"" value=""Test""/>
        <entry key=""openjpa.Connection2Password"" value=""password""/>
        <entry key=""openjpa.Connection2URL"" value=""jdbc:db2://localhost:3700/RQSTSET""/>	
        <entry key=""openjpa.jdbc.Schema"" value=""PROPCAS""/>

In this later case, JDBCConfigurationImpl creates a SimpleDriverDataSource for the datasource2 and uses it to do the sequence.
",14/Feb/07 17:02;pcl;Interesting. Can you post the full stack trace both without specifying a non-jta-data-source and with a non-jta-data-source specified?,"14/Feb/07 21:09;bradmoon;Requested stack traces provided above.  I also verified that JDBCConfigurationImpl.connectionFactory2Name contained my non-jta-data-source reference (i.e. ""java:comp/env/jdbc/RequestSetNoTran"") when producing Both-JTAandNonJTASpecified.txt.","14/Feb/07 21:37;pcl;It looks like there are two issues here. First, we seem to be incorrectly attempting to suspend the transaction when a non-jta data source is specified. Second, our WAS integration does not allow suspending of the JTA transaction. I will create a new issue for this second problem.",14/Feb/07 21:51;bradmoon;Great.  Is there something I can do? ,"14/Feb/07 22:01;pcl;If you could create and attach a patch akin to what you described in the original notes, that'd be great. One modification: instead of adding a new createConnectionFactory2() method, it'd be great if you could just modify the (private) createConnectionFactory() method that exists already, maybe to take as an argument a boolean indicating which connection factory to use.","14/Feb/07 23:56;pcl;It turns out I had a few free minutes. Attached is a wholly-untested patch to JDBCConfigurationImpl.java that might work. Can you test this out and let me know if it works?

If you don't have access to the OpenJPA sources, I can build a jar with the patched class in it for testing also.",15/Feb/07 12:52;bradmoon;I will test today.,"15/Feb/07 14:00;bradmoon;I thought I could get this from the svn repository, but it does not appear as though the java file has been checked in.  If you'd attach the java file, I can test.

Bottom line I only have access to the subversion web interface. ","15/Feb/07 18:21;pcl;I've attached a jar file containing the compiled class. Put this jar ahead of OpenJPA in your classpath.

FTR, the source for the file in question is at https://svn.apache.org/viewvc/incubator/openjpa/trunk/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java",15/Feb/07 20:39;bradmoon;The error has changed a bit.  New stack trace is in PostPatch-144.  Debugging indicates that JDCConfigurationImpl.datasource2 contains a managed datasource.  ,"15/Feb/07 20:56;pcl;Oops, I made a mistake in the createConnectionFactory() logic. This one looks better.","15/Feb/07 23:05;bradmoon;I am getting a different error this time, but before I pass on the stack trace information, perhaps you can tell me what properties you'd expect to see set i.e. non-jta-data-source, openjpa.Connection2DriverName, openjpa.ConnectionFactory2Name, etc.....","15/Feb/07 23:17;pcl;For openjpa-144-patch-2.jar, I would expect you to need to set jta-data-source and non-jta-data-source appropriately. The second patch should correctly pick up the non-jta-data-source and use it for sequence purposes.","16/Feb/07 14:50;bradmoon;Getting a different exception now.  It is contained in attached ""PostPatch-144fix2.txt"".  It appears as though all JNDI lookups in WebSphere return a managed connection as JDBCConfigurationImpl.datasource2 contains an instance of com.ibm.ws.rsadapter.jdbc.WSJdbcDataSource.   

Just to recap.   Without the patches, I have been able to get sequences two work by two different methods: 

Approach 1: specify connection properties so OpenJPA can build a SimpleDriverDataSource.  Properties are as follows: 

        <entry key=""openjpa.Connection2DriverName"" value=""com.ibm.db2.jcc.DB2Driver""/>
        <entry key=""openjpa.Connection2UserName"" value=""Test""/>
        <entry key=""openjpa.Connection2Password"" value=""xxxxxxxx""/>
        <entry key=""openjpa.Connection2URL"" value=""jdbc:db2://localhost:3700/RQSTSET""/>	
        <entry key=""openjpa.jdbc.Schema"" value=""PROPCAS""/>

       Under this approach, SimpleDriverDataSource is contained in JDBCConfigurationImpl.datasource2.

Approach 2: pass the webspeher transaction manager to OpenJPA per the below property:

        <entry key=""openjpa.ManagedRuntime"" value=""invocation(TransactionManagerMethod=com.ibm.ws.Transaction.TransactionManagerFactory.getTransactionManager)""/>


","16/Feb/07 16:22;pcl;I'm guessing that Approach 2 works with just a single jta-data-source listed, right?

Also, your description implies that with the most recent code, OpenJPA is looking up the non-jta-data-source, but WAS is still returning a data source with limitations. Is that correct? Based on this assumption, I will close this issue and create a new one re: our defaults and corresponding WAS limitations.","16/Feb/07 20:00;bradmoon;Approach 2 will actually work when specifying only the jta-data-source or specifying both the jta-data-source and the non-jta-data-source.

As far as your second question: WAS is retuning a managed connection for the second data source.  

",,,,,,,,,,,,,,,,,,
Problems with Single Table Inheritance Strategy (and Discriminator Type of Integer),OPENJPA-143,12362705,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,kwsutter,kwsutter,13/Feb/07 17:19,12/Oct/07 15:59,14/Mar/19 03:02,16/Aug/07 21:13,,,,,,,,,,1.0.0,,,,,jpa,,,,,,1,,"Using the @DiscriminatorType of Integer with Single Table Inheritance, I've come across two problems...

o  The @DiscriminatorValue seems to be required on abstract classes in the hierarchy.  This should not be required.  Actually, according to section 9.1.31 of the spec, this annotation should only be required on concrete classes.  But, without this annotation, I am getting an exception about not being able to cast a String to an Int.

o  This exception that I am receiving with a ""missing"" @DiscriminatorValue would indicate that the default value being provided by OpenJPA is a String all the time instead of basing the default the value off of the DiscriminatorType of Integer.  This is further described in Table 21 of section 9.1.31 of the spec.

As described, I have a workaround by specifying a @DiscriminatorValue on the abstract class, but these seem to be real problems that need to be addressed.  Thus, this defect.

Kevin",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160477,,,2007-02-13 17:19:09.0,,,,,,,0|i0z1cv:,202522,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Entity name is ignored when specified in the orm.xml file,OPENJPA-142,12362662,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,mprudhom,mprudhom,13/Feb/07 07:58,09/Mar/10 18:32,14/Mar/19 03:02,10/Mar/07 11:15,0.9.0,0.9.6,,,,,,,,0.9.7,,,,,jpa,,,,,,0,,"The XMLPersistenceMetaDataParser ignores the ""name"" attriburte of an ""entity"" element, and instead always uses the default alias. For example, with the following declaration in the orm.xml file:

   <entity name=""Foo"" class=""mypackage.Bar"">

the entity will be aliased to ""Bar"", rather than to ""Foo"".

Original report by Dain Sundstrom on the open-jpa-dev mailing list:

I'm using 0.9.6 and it appears the OpenJPA is ignoring the entity name when processing queries.  In stead it seems to always choose the class name for the schema name of the bean.  For example, I have the following bean declared in my entity mappings:

    <entity name=""BasicCmp2Bean"" class=""org.apache.openejb.test.entity.cmp.BasicCmp2Bean_BasicCmp2Bean"">
        <description>BasicCmp2Bean</description>
        <attributes>
            <id name=""id""/>
            <basic name=""firstName""/>
            <basic name=""lastName""/>
        </attributes>
    </entity>


The following query does not work:

        SELECT o FROM BasicCmp2Bean o WHERE o.lastName = ?1

But this one does:

        SELECT o FROM BasicCmp2Bean_BasicCmp2Bean o WHERE o.lastName = ?1

When the query fails, I get this message (reformatted a bit with ** added to important entries):

ERROR - The bean instances business method encountered a system exception: Could not locate metadata for the class using alias ""BasicCmp2Bean"". Registered alias mappings: ""{
AllowedOperationsCmp2Bean_AOBasicCmp2Bean=
  [class org.apache.openejb.test.entity.cmp.AllowedOperationsCmp2Bean_AOBasicCmp2Bean],
AllowedOperationsCmpBean=
  [class org.apache.openejb.test.entity.cmp.AllowedOperationsCmpBean],
ContextLookupCmpBean=
  [class org.apache.openejb.test.entity.cmp.ContextLookupCmpBean],
Employee=
  [class org.apache.openejb.test.entity.cmp2.Employee],
ManyOwningSideBean_ManyOwningSideBean=
  [class org.apache.openejb.test.entity.cmr.cmrmapping.ManyOwningSideBean_ManyOwningSideBean],
**BasicCmp2Bean_BasicCmp2Bean=
  [class org.apache.openejb.test.entity.cmp.BasicCmp2Bean_BasicCmp2Bean],
EncCmpBean=
  [class org.apache.openejb.test.entity.cmp.EncCmpBean],
BBean_OneToOneB=
  [class org.apache.openejb.test.entity.cmr.onetoone.BBean_OneToOneB],
OneOwningSideBean_OneOwningSideBean=
  [class org.apache.openejb.test.entity.cmr.cmrmapping.OneOwningSideBean_OneOwningSideBean],
ABean_OneToOneA=
  [class org.apache.openejb.test.entity.cmr.onetoone.ABean_OneToOneA],
**BasicCmp2Bean=null,
RmiIiopCmpBean=
  [class org.apache.openejb.test.entity.cmp.RmiIiopCmpBean],
ABean_OneToManyA=
  [class org.apache.openejb.test.entity.cmr.onetomany.ABean_OneToManyA],
OneInverseSideBean_OneInverseSideBean=
  [class org.apache.openejb.test.entity.cmr.cmrmapping.OneInverseSideBean_OneInverseSideBean],
BBean_OneToManyB=
  [class org.apache.openejb.test.entity.cmr.onetomany.BBean_OneToManyB],
RmiIiopCmp2Bean_Cmp2_RMI_IIOP_Bean=
  [class org.apache.openejb.test.entity.cmp.RmiIiopCmp2Bean_Cmp2_RMI_IIOP_Bean],
EncCmp2Bean_EncCmp2Bean=
  [class org.apache.openejb.test.entity.cmp.EncCmp2Bean_EncCmp2Bean],
BasicCmpBean=
  [class org.apache.openejb.test.entity.cmp.BasicCmpBean]}""

",,,,,,,,,,,,,,,,,,,,,,23/Feb/07 10:53;ephemeris;Tests-JPA-1.zip;https://issues.apache.org/jira/secure/attachment/12351880/Tests-JPA-1.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-02-13 19:34:42.887,,,no_permission,,,,,,,,,,,160476,,,Fri Feb 23 10:53:24 UTC 2007,,,,,,,0|i0z1ef:,202529,,,,,,,,"13/Feb/07 08:01;mprudhom;This can be worked around by adding the annotation to the class (e.g., @Entity(name=""Foo"") ).","13/Feb/07 19:34;dain;I think I found a related bug to this.  When you have a mapped-superclass and an entity with the same class name (but not the same package).  The query compiler seems to get confused and throws the exception following this message.

You should be able to reproduce this by putting your sub class in a different package but with the same class name, and executing any query.  I'm not sure if this problem goes away by annotating the entity as you described above.

-dain


3276  TRACE  [main] openjpa.jdbc.JDBC - <t 5323819, conn 2614990> [0 ms] close
ERROR - Executing query SELECT o FROM BasicCmpBean o WHERE o.lastName = ?1
11:30:06,372 ERROR [OpenEJB] Executing query SELECT o FROM BasicCmpBean o WHERE o.lastName = ?1
3561  TRACE  [main] openjpa.Query - Executing query: [SELECT o FROM BasicCmpBean o WHERE o.lastName = ?1] with parameters: {1=Blevins}
ERROR - The bean instances business method encountered a system exception:0
<4|false|0.9.6-incubating> org.apache.openjpa.persistence.ArgumentException: 0
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:798)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:759)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:528)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:210)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:251)
	at org.apache.openejb.core.cmp.jpa.JpaCmpEngine.queryBeans(JpaCmpEngine.java:192)
	at org.apache.openejb.core.cmp.CmpContainer.findEJBObject(CmpContainer.java:640)
	at org.apache.openejb.core.cmp.CmpContainer.invoke(CmpContainer.java:245)
	at org.apache.openejb.core.entity.EntityEjbHomeHandler.findX(EntityEjbHomeHandler.java:56)
	at org.apache.openejb.core.ivm.EjbHomeProxyHandler._invoke(EjbHomeProxyHandler.java:122)
	at org.apache.openejb.core.ivm.BaseEjbProxyHandler.invoke(BaseEjbProxyHandler.java:186)
	at org.apache.openejb.util.proxy.Jdk13InvocationHandler.invoke(Jdk13InvocationHandler.java:49)
	at $Proxy35.findByLastName(Unknown Source)
	at org.apache.openejb.test.entity.cmp.CmpHomeIntfcTests.test03_findByLastName(CmpHomeIntfcTests.java:77)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.openejb.test.NumberedTestCase.runTestMethod(NumberedTestCase.java:135)
	at org.apache.openejb.test.NumberedTestCase$1.protect(NumberedTestCase.java:120)
	at junit.framework.TestResult.runProtected(TestResult.java:128)
	at org.apache.openejb.test.NumberedTestCase.run(NumberedTestCase.java:123)
	at org.apache.openejb.test.NumberedTestCase.run(NumberedTestCase.java:102)
	at org.apache.openejb.test.TestSuite.run(TestSuite.java:46)
	at org.apache.openejb.test.TestSuite.run(TestSuite.java:46)
	at junit.textui.TestRunner.doRun(TestRunner.java:115)
	at com.intellij.rt.execution.junit2.IdeaJUnitAgent.doRun(IdeaJUnitAgent.java:58)
	at junit.textui.TestRunner.start(TestRunner.java:179)
	at com.intellij.rt.execution.junit.TextTestRunner2.startRunnerWithArgs(TextTestRunner2.java:23)
	at com.intellij.rt.execution.junit2.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:98)
	at com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)
Caused by: java.lang.ArrayIndexOutOfBoundsException: 0
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.appendTo(PCPath.java:633)
	at org.apache.openjpa.jdbc.kernel.exps.EqualExpression.appendTo(EqualExpression.java:68)
	at org.apache.openjpa.jdbc.kernel.exps.CompareEqualExpression.appendTo(CompareEqualExpression.java:95)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.buildWhere(SelectConstructor.java:235)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.evaluate(SelectConstructor.java:76)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.createWhereSelects(JDBCStoreQuery.java:323)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeQuery(JDBCStoreQuery.java:165)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:672)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:977)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:789)
	... 30 more
11:30:06,664 ERROR [OpenEJB] The bean instances business method encountered a system exception:0
<4|false|0.9.6-incubating> org.apache.openjpa.persistence.ArgumentException: 0
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:798)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:759)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:528)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:210)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:251)
	at org.apache.openejb.core.cmp.jpa.JpaCmpEngine.queryBeans(JpaCmpEngine.java:192)
	at org.apache.openejb.core.cmp.CmpContainer.findEJBObject(CmpContainer.java:640)
	at org.apache.openejb.core.cmp.CmpContainer.invoke(CmpContainer.java:245)
	at org.apache.openejb.core.entity.EntityEjbHomeHandler.findX(EntityEjbHomeHandler.java:56)
	at org.apache.openejb.core.ivm.EjbHomeProxyHandler._invoke(EjbHomeProxyHandler.java:122)
	at org.apache.openejb.core.ivm.BaseEjbProxyHandler.invoke(BaseEjbProxyHandler.java:186)
	at org.apache.openejb.util.proxy.Jdk13InvocationHandler.invoke(Jdk13InvocationHandler.java:49)
	at $Proxy35.findByLastName(Unknown Source)
	at org.apache.openejb.test.entity.cmp.CmpHomeIntfcTests.test03_findByLastName(CmpHomeIntfcTests.java:77)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.openejb.test.NumberedTestCase.runTestMethod(NumberedTestCase.java:135)
	at org.apache.openejb.test.NumberedTestCase$1.protect(NumberedTestCase.java:120)
	at junit.framework.TestResult.runProtected(TestResult.java:128)
	at org.apache.openejb.test.NumberedTestCase.run(NumberedTestCase.java:123)
	at org.apache.openejb.test.NumberedTestCase.run(NumberedTestCase.java:102)
	at org.apache.openejb.test.TestSuite.run(TestSuite.java:46)
	at org.apache.openejb.test.TestSuite.run(TestSuite.java:46)
	at junit.textui.TestRunner.doRun(TestRunner.java:115)
	at com.intellij.rt.execution.junit2.IdeaJUnitAgent.doRun(IdeaJUnitAgent.java:58)
	at junit.textui.TestRunner.start(TestRunner.java:179)
	at com.intellij.rt.execution.junit.TextTestRunner2.startRunnerWithArgs(TextTestRunner2.java:23)
	at com.intellij.rt.execution.junit2.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:98)
	at com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)
Caused by: java.lang.ArrayIndexOutOfBoundsException: 0
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.appendTo(PCPath.java:633)
	at org.apache.openjpa.jdbc.kernel.exps.EqualExpression.appendTo(EqualExpression.java:68)
	at org.apache.openjpa.jdbc.kernel.exps.CompareEqualExpression.appendTo(CompareEqualExpression.java:95)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.buildWhere(SelectConstructor.java:235)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.evaluate(SelectConstructor.java:76)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.createWhereSelects(JDBCStoreQuery.java:323)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeQuery(JDBCStoreQuery.java:165)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:672)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:977)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:789)
	... 30 more
org.apache.openejb.InvalidateReferenceException: java.rmi.RemoteException: The bean encountered a non-application exception.; nested exception is: 
	<4|false|0.9.6-incubating> org.apache.openjpa.persistence.ArgumentException: 0: The bean encountered a non-application exception.; nested exception is: 
	<4|false|0.9.6-incubating> org.apache.openjpa.persistence.ArgumentException: 0
	at org.apache.openejb.core.transaction.TransactionPolicy.throwExceptionToServer(TransactionPolicy.java:208)
	at org.apache.openejb.core.transaction.TxRequired.handleSystemException(TxRequired.java:83)
	at org.apache.openejb.core.cmp.CmpContainer.findEJBObject(CmpContainer.java:682)
	at org.apache.openejb.core.cmp.CmpContainer.invoke(CmpContainer.java:245)
	at org.apache.openejb.core.entity.EntityEjbHomeHandler.findX(EntityEjbHomeHandler.java:56)
	at org.apache.openejb.core.ivm.EjbHomeProxyHandler._invoke(EjbHomeProxyHandler.java:122)
	at org.apache.openejb.core.ivm.BaseEjbProxyHandler.invoke(BaseEjbProxyHandler.java:186)
	at org.apache.openejb.util.proxy.Jdk13InvocationHandler.invoke(Jdk13InvocationHandler.java:49)
	at $Proxy35.findByLastName(Unknown Source)
	at org.apache.openejb.test.entity.cmp.CmpHomeIntfcTests.test03_findByLastName(CmpHomeIntfcTests.java:77)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.openejb.test.NumberedTestCase.runTestMethod(NumberedTestCase.java:135)
	at org.apache.openejb.test.NumberedTestCase$1.protect(NumberedTestCase.java:120)
	at junit.framework.TestResult.runProtected(TestResult.java:128)
	at org.apache.openejb.test.NumberedTestCase.run(NumberedTestCase.java:123)
	at org.apache.openejb.test.NumberedTestCase.run(NumberedTestCase.java:102)
	at org.apache.openejb.test.TestSuite.run(TestSuite.java:46)
	at org.apache.openejb.test.TestSuite.run(TestSuite.java:46)
	at junit.textui.TestRunner.doRun(TestRunner.java:115)
	at com.intellij.rt.execution.junit2.IdeaJUnitAgent.doRun(IdeaJUnitAgent.java:58)
	at junit.textui.TestRunner.start(TestRunner.java:179)
	at com.intellij.rt.execution.junit.TextTestRunner2.startRunnerWithArgs(TextTestRunner2.java:23)
	at com.intellij.rt.execution.junit2.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:98)
	at com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)
Caused by: java.rmi.RemoteException: The bean encountered a non-application exception.; nested exception is: 
	<4|false|0.9.6-incubating> org.apache.openjpa.persistence.ArgumentException: 0
	at org.apache.openejb.core.transaction.TransactionPolicy.throwExceptionToServer(TransactionPolicy.java:206)
	... 26 more
Caused by: <4|false|0.9.6-incubating> org.apache.openjpa.persistence.ArgumentException: 0
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:798)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:759)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:528)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:210)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:251)
	at org.apache.openejb.core.cmp.jpa.JpaCmpEngine.queryBeans(JpaCmpEngine.java:192)
	at org.apache.openejb.core.cmp.CmpContainer.findEJBObject(CmpContainer.java:640)
	... 24 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: 0
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.appendTo(PCPath.java:633)
	at org.apache.openjpa.jdbc.kernel.exps.EqualExpression.appendTo(EqualExpression.java:68)
	at org.apache.openjpa.jdbc.kernel.exps.CompareEqualExpression.appendTo(CompareEqualExpression.java:95)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.buildWhere(SelectConstructor.java:235)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.evaluate(SelectConstructor.java:76)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.createWhereSelects(JDBCStoreQuery.java:323)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeQuery(JDBCStoreQuery.java:165)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:672)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:977)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:789)
	... 30 more
","23/Feb/07 10:50;ephemeris;I have a similar problem with a really veru simple test that works as expected with TopLink (RI) and Hibernate implementations.
I've tried to add the ""name"" attribute to the entities annotations, or disable the orm.xml use, but this work-around doesn't seem to work in my case.
I've tested it with the release 0.9.6 and snapshot 0.9.7, and i have the same result...
Does anyone have more ideas ?
NB : I attach my project, just in case...
","23/Feb/07 10:53;ephemeris;A simple project with the same error :

30  my-persistence-unit-for-open-jpa  INFO   [main] openjpa.Runtime - Starting OpenJPA 0.9.7-incubating-SNAPSHOT
140  my-persistence-unit-for-open-jpa  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.DerbyDictionary"".
270  my-persistence-unit-for-open-jpa  INFO   [main] openjpa.MetaData - Found 3 classes with metadata in 10 milliseconds.
Exception in thread ""main"" <4|true|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: Could not locate metadata for the class using alias ""Person"". Registered alias mappings: ""{Person=null}""
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:345)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getClassMetaData(JPQLExpressionBuilder.java:164)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.resolveClassMetaData(JPQLExpressionBuilder.java:142)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:211)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:181)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateType(JPQLExpressionBuilder.java:174)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.access$500(JPQLExpressionBuilder.java:61)
	at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.populate(JPQLExpressionBuilder.java:1668)
	at org.apache.openjpa.kernel.jpql.JPQLParser.populate(JPQLParser.java:52)
	at org.apache.openjpa.kernel.ExpressionStoreQuery.populateFromCompilation(ExpressionStoreQuery.java:145)
	at org.apache.openjpa.kernel.QueryImpl.newCompilation(QueryImpl.java:644)
	at org.apache.openjpa.kernel.QueryImpl.compilationFromCache(QueryImpl.java:625)
	at org.apache.openjpa.kernel.QueryImpl.compileForCompilation(QueryImpl.java:591)
	at org.apache.openjpa.kernel.QueryImpl.compileForExecutor(QueryImpl.java:653)
	at org.apache.openjpa.kernel.QueryImpl.getOperation(QueryImpl.java:1475)
	at org.apache.openjpa.kernel.DelegatingQuery.getOperation(DelegatingQuery.java:120)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:214)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:264)
	at my.jpa.one.Test.test(Test.java:34)
	at my.jpa.one.MainForOpenJPA.main(MainForOpenJPA.java:7)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong package name in test classes,OPENJPA-140,12362454,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mprudhom,mikedd,mikedd,09/Feb/07 19:38,17/Apr/07 18:38,14/Mar/19 03:02,09/Feb/07 21:52,,,,,,,,,,0.9.7,,,,,,,,,,,0,,"It looks like the package for some of the new test classes is out of sync with where they are in the filesystem : 

Hi Mike,

This is clearly wrong. Can you file a JIRA?

Craig

On Feb 9, 2007, at 8:17 AM, Michael Dick wrote:

> Hi Marc,
>
> The classes in
> incubator/openjpa/trunk/openjpa-persistence-jdbc/src/test/java/org/
> apache/openjpa/persistence/models
> declare package org.apache.openjpa.persistence.models.company.
> This is
> causing a lot of errors in Eclipse, maven builds fine though. Is this
> intentional?
>
> Thanks,
> -Mike


I'm not sure whether the java files should be moved or if the package declarations need to be changed though. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-02-09 21:52:40.839,,,no_permission,,,,,,,,,,,160474,,,Fri Feb 09 21:52:40 UTC 2007,,,,,,,0|i0z4ef:,203015,,,,,,,,09/Feb/07 21:52;mprudhom;Fixed incorrect directory locations.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PersistenceException merging an entity with a Calendar field. ,OPENJPA-139,12362387,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,mikedd,mikedd,09/Feb/07 00:19,17/Apr/07 18:38,14/Mar/19 03:02,27/Feb/07 19:36,,,,,,,,,,0.9.7,,,,,kernel,,,,,,0,,"I get the following exception when I try to merge an entity which contains a java.util.Calendar field. 

<0|true|0.0.0> org.apache.openjpa.persistence.PersistenceException: mikedd.entities.CalendarEntity.cal
	at org.apache.openjpa.kernel.AttachStrategy.attachField(AttachStrategy.java:255)
	at org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:131)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:236)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:97)
	at org.apache.openjpa.kernel.BrokerImpl.attach(BrokerImpl.java:3141)
	at org.apache.openjpa.kernel.DelegatingBroker.attach(DelegatingBroker.java:1128)
	at org.apache.openjpa.persistence.EntityManagerImpl.merge(EntityManagerImpl.java:650)
	at mikedd.tests.TestCalendar.testMergeCalendar(TestCalendar.java:47)
        <snip>

I'm running the test in eclipse and my classpath probably isn't set up to properly display the openjpa version, 
output from svnversion -c : 406193:505052M

It looks like we're missing a case statement for JavaTypes.CALENDAR in org.apache.openjpa.kernelAttachStrategy.attachField. I added one under JavaTypes.DATE and that resolved the issue for me. 


",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-02-09 00:21:43.931,,,no_permission,,,,,,,,,,,160473,,,Tue Feb 27 19:36:16 UTC 2007,,,,,,,0|i0z4dz:,203013,,,,,,,,09/Feb/07 00:21;kwsutter;Mike will work with me to get this patch committed.,27/Feb/07 19:36;kwsutter;Code changed per Issue comments via SVN revision 505099.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Extra unneeded SQL joins for OneToMany relationship with fetch type EAGER,OPENJPA-134,12362266,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,fancy,fancy,08/Feb/07 01:47,20/Nov/12 08:43,14/Mar/19 03:02,11/Apr/07 16:26,,,,,,,,,,0.9.7,,,,,sql,,,,,,1,,"Running JPAConfiguration default setting for EagerFetchMode (FetchModeValue.EAGER_PARALLEL), 
the SQL generated is sub-optimal.
Consider the following entities:

                                     lineitems( OneToMany ) 
            Order  <===========================> OrderItem
                                    order ( ManyToOne )


Case 1:  why not combining 2 SQL to 1 SQL ?
=================================================================================================
Order.lineitmes(EAGER):
OrderItem.order(LAZY):

Executing query: select o from Order o
2173  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094730048, conn 1318342292> executing prepstmnt 1299336562 
SELECT t0.oid, t0.version, t0.amount, t0.customer_countryCode, t0.customer_id, t0.delivered, t0.shipaddr FROM Order t0
2213  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094730048, conn 1318342292> [40 ms] spent
2223  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094730048, conn 1318342292> executing prepstmnt 1406424020 
SELECT t0.oid, t1.lid, t1.version, t1.cost, t1.order_oid, t1.part_partno, t1.quantity FROM Order t0 INNER JOIN OrderItem t1 ON t0.oid = t1.order_oid ORDER BY t0.oid ASC


Case 2: extra unneeded LEFT OUTER JOIN,  if eliminated, the selection aliase t2 should change to t1:
=============================================================================================
Order.lineitmes(EAGER):
OrderItem.order(LAZY):

Executing query: select o from Order o left join fetch o.lineitems
2403  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094730048, conn 1314410072> executing prepstmnt 1500797300 
SELECT t0.oid, t0.version, t0.amount, t0.customer_countryCode, t0.customer_id, t0.delivered, t0.shipaddr, t2.order_oid, t2.lid, t2.version, t2.cost, t2.part_partno, t2.quantity FROM Order t0 LEFT OUTER JOIN OrderItem t1 ON t0.oid = t1.order_oid LEFT OUTER JOIN OrderItem t2 ON t0.oid = t2.order_oid ORDER BY t2.order_oid ASC


Case  3: why not generating 1 SQL ?
==================================================================================================
Order.lineitmes(EAGER):
OrderItem.order(EAGER):

Executing query: select o from Order o
2343  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094730048, conn 1318342292> executing prepstmnt 384833264 SELECT t0.oid, t0.version, t0.amount, t0.customer_countryCode, t0.customer_id, t0.delivered, t0.shipaddr FROM Order t0
2383  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094730048, conn 1318342292> [40 ms] spent
2393  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094730048, conn 1318342292> executing prepstmnt 1722705582 
SELECT t0.oid, t1.lid, t1.version, t1.cost, t2.oid, t2.version, t2.amount, t2.customer_countryCode, t2.customer_id, t2.delivered, t2.shipaddr, t1.part_partno, t1.quantity FROM Order t0 INNER JOIN OrderItem t1 ON t0.oid = t1.order_oid LEFT OUTER JOIN Order t2 ON t1.order_oid = t2.oid ORDER BY t0.oid ASC
2393  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094730048, conn 1318342292> [0 ms] spent
3134  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094730048, conn 1318342292> executing prepstmnt 950548648 
SELECT t0.lid, t0.version, t0.cost, t1.oid, t1.version, t1.amount, t1.customer_countryCode, t1.customer_id, t1.delivered, t1.shipaddr, t0.part_partno, t0.quantity FROM OrderItem t0 LEFT OUTER JOIN Order t1 ON t0.order_oid = t1.oid WHERE t0.order_oid = ? [params=(int) 88]
3134  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094730048, conn 1318342292> [0 ms] spent


Case 4:  duplicate selections and redundant joins
==================================================================================================
Order.lineitmes(EAGER):
OrderItem.order(EAGER):

Executing query: select o from Order o left join fetch o.lineitems
2273  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094730048, conn 1307463150> executing prepstmnt 1565154634 
SELECT t0.oid, t0.version, t0.amount, t0.customer_countryCode, t0.customer_id, t0.delivered, t0.shipaddr, t2.order_oid, t2.lid, t2.version, t2.cost, t3.oid, t3.version, t3.amount, t3.customer_countryCode, t3.customer_id, t3.delivered, t3.shipaddr, t2.part_partno, t2.quantity FROM Order t0 LEFT OUTER JOIN OrderItem t1 ON t0.oid = t1.order_oid LEFT OUTER JOIN OrderItem t2 ON t0.oid = t2.order_oid LEFT OUTER JOIN Order t3 ON t2.order_oid = t3.oid ORDER BY t2.order_oid ASC",,,,,,,,,,,,,,,,OPENJPA-2296,,,,,,21/Jul/08 02:40;faywang;openjpa134_3.patch;https://issues.apache.org/jira/secure/attachment/12386501/openjpa134_3.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-02-26 22:43:42.895,,,no_permission,,,,,,,,,,,160469,,,Tue Nov 20 08:43:07 UTC 2012,,,,,,,0|i0l3z3:,121294,,,,,,,,"26/Feb/07 22:43;jstecher;Just curious if there has been any movement on this JIRA.  This problem actually presents itself in the test bucket that IBM has been running trying to work through the performance issues of OpenJPA and puts the OpenJPA runtime behind the competitive implementations in the scenarios above.  I am interested in getting some feedback from those that understand the code a little more about this bug and getting a possible fix generated for it.  

In my mind there is no reason that the the Orderlines->Orders Eager,Eager relationship should ever issues a 2 join query.  It should be a single left outer join with the eager back pointer filled by the initial orderline query.

Thoughts?
",26/Feb/07 22:54;pcl;Could you attach a test case that demonstrates this problem?,"27/Feb/07 01:48;kwsutter;The following conversation has also been recorded in the dev mailing list concerning this OPENJPA-134 Issue:

http://www.nabble.com/extraneous-joins-OPENJPA-134-tf3230933.html#a8977476","27/Feb/07 17:17;jstecher;I think the links to the mailing list post that Kevin has shows a good example of the code causing the problem.  In reality any one to many relationship with a back pointer generates two joins when only one is necessary to pull in all the information needed for the query.

Dave's example in the mailing list should be something you can run pretty quick and see the problem.  Catalina's original JIRA entry contains a pretty good example of the SQL. ","07/Mar/07 21:45;dangalvin;We find that this case also occurs on the getReference() call as well, I assume because associated fetch is eager? ",29/Mar/07 16:10;jstecher;Any update on where we stand with getting this issue addressed?,"11/Apr/07 16:26;awhite;Fixed the most egregious issue, which was the cyclic fetching of eager bidirectional relations.  Changed to cut off SELECTs when we're traversing the back-ptr to the owning side of a relation we've already fetched.  I'm not convinced all the other issues mentioned are bugs given the eager fetch settings used.  Please open new JIRAs for any individual issues that you believe remain.  Fixed in revision 527565.","12/Apr/07 22:15;rob.wisniewski;I did some performance testing and things look good here.  My 'one to many eager' scenario, which would be affected the most by this looping query behavior, improved in performance by 6%, and verified by sql dumps.

I did notice that my lazy scenarios are almost 50% slower now, but looking at the sql dumps it appears that we were fetching eagerly even in those scenarios and this (or another JIRA?) seems to have fixed that functional error.  Does that seem like something your changes would resolve?  Did you run into anything that would cause an eager fetch even when lazy was specified?","12/Apr/07 22:19;rob.wisniewski;To illustrate the 'eager despite lazy' behavior...  here's the before and after sql:

svn 04/03/2007:

executed once:

SELECT t0.HOLDINGID, t1.ACCOUNTID, t1.PROFILE_USERID, t1.BALANCE, t1.CREATIONDATE, t1.LASTLOGIN, t1.LOGINCOUNT, t1.LOGOUTCOUNT, t1.OPENBALANCE, t0.PURCHASEDATE, t0.PURCHASEPRICE, t0.QUANTI
TY, t2.SYMBOL, t2.CHANGE1, t2.COMPANYNAME, t2.HIGH, t2.LOW, t2.OPEN1, t2.PRICE, t2.VOLUME FROM HOLDINGEJB t0 LEFT OUTER JOIN ACCOUNTEJB t1 ON t0.ACCOUNT_ACCOUNTID = t1.ACCOUNTID LEFT OUTER JOIN QUOTEEJB t2 ON t0.QUOTE_SYMBOL =
 t2.SYMBOL WHERE t0.ACCOUNT_ACCOUNTID = ?

executed once:

SELECT t0.PROFILE_USERID, t0.BALANCE, t0.CREATIONDATE, t0.LASTLOGIN, t0.LOGINCOUNT, t0.LOGOUTCOUNT, t0.OPENBALANCE FROM ACCOUNTEJB t0 WHERE t0.ACCOUNTID = ? optimize for 1 row

CORRECT svn 04/12/2007:

executed once:

SELECT t0.PROFILE_USERID, t0.BALANCE, t0.CREATIONDATE, t0.LASTLOGIN, t0.LOGINCOUNT, t0.LOGOUTCOUNT, t0.OPENBALANCE FROM ACCOUNTEJB t0 WHERE t0.ACCOUNTID = ?  FOR READ ONLY  optimize for 1
row

executed 4 times:

SELECT t1.ACCOUNTID, t1.PROFILE_USERID, t1.BALANCE, t1.CREATIONDATE, t1.LASTLOGIN, t1.LOGINCOUNT, t1.LOGOUTCOUNT, t1.OPENBALANCE FROM HOLDINGEJB t0 INNER JOIN ACCOUNTEJB t1 ON t0.ACCOUNT_A
CCOUNTID = t1.ACCOUNTID WHERE t0.HOLDINGID = ?  FOR READ ONLY  optimize for 1 row","21/Jul/08 02:40;faywang;I have tested the following scenario:

@Entity
public class Customer {
..
   @OneToMany(fetch=FetchType.EAGER, mappedBy=""customer"")
    private Collection<Order> orders = new ArrayList<Order>();
...
}

@Entity
public class Order {
	@Id 
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	 int oid;

	 double amount;
	 boolean delivered;
	 
	 @ManyToOne (fetch=FetchType.EAGER)
	 Customer customer;

...

}

A JPQL :
   Select c from Customer c

generates the following SQL:

(1) SELECT t0.countryCode, t0.id, t0.version, t0.city, t0.state, t0.street, t0.zip 
      FROM PdqCustomer t0 

(2) SELECT t0.countryCode, t0.id, t1.oid, t1.version, t1.amount, t1.delivered 
      FROM PdqCustomer t0 
      INNER JOIN PdqOrder t1 ON t0.countryCode = t1.CUSTOMER_COUNTRYCODE AND 
                             t0.id = t1.CUSTOMER_ID ORDER BY t0.countryCode ASC, t0.id ASC 

(3) SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip 
      FROM PdqOrder t0 
      INNER JOIN PdqCustomer t1 ON t0.CUSTOMER_COUNTRYCODE = t1.countryCode 
                             AND t0.CUSTOMER_ID = t1.id WHERE t0.oid = ?  optimize for 1 row

(4) SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip 
      FROM PdqOrder t0 
      INNER JOIN PdqCustomer t1 ON t0.CUSTOMER_COUNTRYCODE = t1.countryCode 
                              AND t0.CUSTOMER_ID = t1.id WHERE t0.oid = ?  optimize for 1 row

(5) SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip 
      FROM PdqOrder t0 
      INNER JOIN PdqCustomer t1 ON t0.CUSTOMER_COUNTRYCODE = t1.countryCode 
                             AND t0.CUSTOMER_ID = t1.id WHERE t0.oid = ?  optimize for 1 row

(6) SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip 
      FROM PdqOrder t0 
      INNER JOIN PdqCustomer t1 ON t0.CUSTOMER_COUNTRYCODE = t1.countryCode 
                              AND t0.CUSTOMER_ID = t1.id WHERE t0.oid = ?  optimize for 1 row

Note that the last four sql are the same ((3) -(6)). This is because there are four orders for the customer and each loading of order will load its inverse relationship with customer.

This case is most similar to the case (3) described by Catalina. The attached patch detects the inverse relationship and get rid of sql (3) to (6). 




","31/Jul/08 22:10;faywang;Scenario (2) could no longer be reproduced with r680566:

@Entity
public class Order {
	@Id 
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	 int oid;
	
	 double amount;
	 boolean delivered;
	 
	@ManyToOne (fetch=FetchType.LAZY)
	 Customer customer;
	
	@OneToMany (fetch=FetchType.EAGER , mappedBy=""order"")
	 Collection<OrderItem> lineitems = new ArrayList<OrderItem>();
...
}

@Entity

public class OrderItem {
	@Id 
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	int lid;
	
	int quantity;
	double cost;
	 
	@ManyToOne (fetch=FetchType.LAZY)
	Order order;
...
}

JPQL:
--------
select o from Order o left join fetch o.lineitems

Generated SQL:
----------------------
SELECT t0.oid, t0.version, t0.amount, t0.CUSTOMER_COUNTRYCODE, t0.CUSTOMER_ID, 
t0.delivered, t1.ORDER_OID, t1.lid, t1.version, t1.cost, t1.PART_PARTNO, t1.quantity 
FROM Order t0  LEFT OUTER JOIN OrderItem t1 ON t0.oid = t1.ORDER_OID ORDER BY t1.ORDER_OID ASC 

Note that the unneeded LEFT OUTER JOIN is gone .
","20/Nov/12 08:43;slowstrider;Unfortunately for the above eager bidirectional Order and Customer example, when selecting from Order instead of Customer, OpenJPA still uses ""load field"" for Customer.orders for each Customer that was fetched. Another problem (very similar, both A and C are Order and B is Customer) happens when selecting A from A *..1 B 1..* C. OpenJPA loads B's List<C> using a ""load field"" for each B. See OPENJPA-2296.",,,,,,,,,,,,,,,,,,,,,,,,,
Can't find non-public callback methods with superclass or interface parameters,OPENJPA-133,12362260,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,07/Feb/07 22:52,31/Jul/07 19:02,14/Mar/19 03:02,08/Feb/07 18:44,,,,,,,,,,0.9.7,,,,,jpa,,,,,,0,,"Using xml to define my listener callback methods (doesn't make any difference whether we're using MappedSuperclass or Entity):

	<mapped-superclass class=""com.ibm.ws.persistence.tests.callbacks.CallbackSuperclass"">
			<entity-listeners>
				<entity-listener class=""com.ibm.ws.persistence.tests.callbacks.CallbackListener"">
					<!--
					<pre-persist  method-name=""prePersistXML"" />
					-->
					<post-persist method-name=""postPersistXML"" />
					<!--
					<pre-remove   method-name=""preRemove"" />
					<post-remove  method-name=""postRemove"" />
					<pre-update   method-name=""preUpdate"" />
					<post-update  method-name=""postUpdate"" />
					<post-load    method-name=""postLoad"" />
					-->
				</entity-listener>
			</entity-listeners>
	</mapped-superclass>

My Entity heirarchy is defined as follows:

public interface CallbackMarker { }

@MappedSuperclass
public class CallbackSuperclass implements CallbackMarker { .. }

@Entity
public class CallbackEntity extends CallbackSuperclass { .. }

My listener method is defined as follows:

public class CallbackListener {
:
    private void postPersistXML(CallbackMarker cbm) {
        System.out.println(""PostPersist (ListenerXML) on CallbackMarker: "" + cbm);
        ((CallbackEntity)cbm).postSuccessful = true;
    }
:
}

I'm probably clouding the issue with all of these details, but the real problem is that we're not properly finding the postPersistXML(CallbackMarker cbm) method.  When I run the example, I am getting the following exception.  The original
call stack is huge, so I will just include the ""caused by"":

Caused by: java.lang.NoSuchMethodException: com.ibm.ws.persistence.tests.callbacks.CallbackListener.postPersistXML(com.ibm.ws.persistence.tests.callbacks.CallbackSuperclass)
	at java.lang.Class.throwNoSuchMethodException(Class.java:271)
	at java.lang.Class.getMethod(Class.java:748)
	at org.apache.openjpa.event.MethodLifecycleCallbacks.getMethod(MethodLifecycleCallbacks.java:123)

Digging through the problem, I am finding that we're not properly reflecting on the Class to find the appropriate Method.  First, we
do a getMethods(), which only returns the public methods.  Of course, nothing matches up, so we end up in the catch {} block.  Here,
we attempt a getDeclaredMethod() passing in the specific type for the argument.  This doesn't work in this case since the specific
type (CallbackSuperclass) isn't on the Method signature (the interface CallbackMarker is).  Also, calling getDeclaredMethod only looks in the specific Class and does not go up the heirarchy (like getMethods() does).  So, we have a couple of problems with this
method.

My proposed change is to use the getDeclaredMethods() invocation and manually go up the heirarchy (if necessary).  If we go all the way up the tree without finding the method, then we throw the exception.  This seems to clear up the processing and makes the code
more readable (no try/catch is required).  You could argue that this approach might take more processing since we might have to get the Superclass and make additional getDeclaredMethods() invocations.  But, my guess is that most of the methods being requested will be on the base class and no additional invocations will be necessary.

FYI, this problem only exists with the XML configuration since the annotated version doesn't do this parameter checking.  Annotated callback methods just register the method and assume that it will work.  If it doesn't, then we get a runtime exception with IllegalArgumentException.  Whether we should do this type checking for the annotated callbacks is a topic for a separate JIRA report...",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160468,,,Thu Feb 08 18:44:25 UTC 2007,,,,,,,0|i0z67r:,203309,,,,,,,,"08/Feb/07 18:44;kwsutter;Modified the processing of the getMethod() method to find the designated method, regardless if it's public, private, protected, or package.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.NoSuchMethodError for entity with ID of type java.sql.Date,OPENJPA-132,12362259,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,mikedd,mikedd,07/Feb/07 22:40,17/Apr/07 18:38,14/Mar/19 03:02,20/Mar/07 19:02,,,,,,,,,,0.9.7,,,,,kernel,,,,,,0,,"Opening JIRA report to track the following problem (posted to development forum http://www.nabble.com/Exception-when-using-java.sql.Date-as-an-id-tf3189597.html) 

I'm getting the following exception when I try to fetch an entity with a java.sql.Date as the id :

java.lang.NoSuchMethodError: org.apache.openjpa.util.DateId.getId()Ljava/sql/Date;
    at mikedd.entities.SqlDatePK.pcCopyKeyFieldsFromObjectId (SqlDatePK.java)
    at mikedd.entities.SqlDatePK.pcNewInstance(SqlDatePK.java)
    at org.apache.openjpa.enhance.PCRegistry.newInstance(PCRegistry.java:118)
    at org.apache.openjpa.kernel.StateManagerImpl.initialize (StateManagerImpl.java:247)
    at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:327)
    at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:252)
    at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:108)
    at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:54)
    at org.apache.openjpa.kernel.BrokerImpl.initialize (BrokerImpl.java:868)
    at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:826)
    at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:743)
    at org.apache.openjpa.kernel.DelegatingBroker.find (DelegatingBroker.java:169)
    at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:346)
    at mikedd.tests.TestSqlDateId.testFindAfterClear(TestSqlDateId.java:25)
    at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke (Method.java:585)
    at junit.framework.TestCase.runTest(TestCase.java:154)
    . . .

It's coming from the generated bytecode which expects there to be a getId method that returns the same type of the Id, however java.sql.Date is using the same ID class as java.util.Date. Do we need a separate class for java.sql.Date? 


Responses from Patrick and Craig follow. The consensus so far is to provide ID separate classes for java.sql.Date and java.util.Date. 

It looks like we either need a separate type for java.sql.Date (and
presumably java.sql.Timestamp), or we need to change the logic to accept
a getId() method that returns a type that is assignable from the id
field's type.

-Patrick

It's probably cleaner if we have separate classes for the different
types. That is, have the getId method in the new
org.apache.openjpa.util.SQLDateId return the proper type
(java.sql.Date). After all, java.sql.{Date, Time, Timestamp} are not
really the same as java.util.Date.

-Craig

FTR, I think that I prefer separate classes as well; it's clearer, and
avoids any ambiguity with other subclasses in the future.

-Patrick",,,,,,,,,,,,,,,,,,,,,,19/Mar/07 15:59;mikedd;OpenJPA-132.patch.txt;https://issues.apache.org/jira/secure/attachment/12353664/OpenJPA-132.patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-03-19 23:18:23.175,,,no_permission,,,,,,,,,,,160467,,,Tue Mar 20 19:04:20 UTC 2007,,,,,,,0|i1dp5j:,288172,,,,,,,,"19/Mar/07 15:59;mikedd;Attaching a patch.  

The patch includes a new Id class for java.sql.Date and the appropriate hooks so that if will be used.

I chose to move the SQL_DATE constant from JavaSQLTypes to its superclass JavaTypes. The constant for java.sql.Date needed to be visible to the classes in openjpa-kernel and I didn't see a reason to have define two constants. 

The remainder of the changes are fairly straightforward whenever there is special processing for java.util.Date I did the same thing for java.sql.Date. 

I'll attach testcases separately, this is probably a big enough patch file to review and the tests need a little cleaning up. ","19/Mar/07 23:18;awhite;I have a fix ready to commit that consists of about 6 lines of enhancer code to account for Date subclasses when using DateId, just as we account for Object subclasses when using ObjectId.  The fix avoids the new type constant, new identity class, and all the additional ""case"" statements for SQL dates in the patch proposed by Michael Dick.  Additionally, the fix should work with java.sql.Time and java.sql.Timestamp too; Michael's fix will not.  I believe this is a simpler, better solution.  I also have a test case for SQL date id's ready to commit; we can use it with either my patch or Michael's.  I will hold off on committing until we resolve whose patch to use.  ","20/Mar/07 17:16;mikedd;I'm fine using Abe's patch. The patch I submitted was just focussed on java.sql.Date, not the other java.sql classes. A simpler fix which adds more function is usually a good thing. ","20/Mar/07 18:06;kwsutter;Abe,
Can you post your patch so that we can see how the two approaches differ?  Thanks.

Kevin",20/Mar/07 19:02;awhite;Fixed in SVN revision 520522.  We can back out if we decide to use an alternative fix strategy in the future.,"20/Mar/07 19:04;awhite;Sorry Kevin; I didn't see your comment before committing.  As my resolution comment states, though, I can back my fix out if we decide we don't like it.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Test framework should allow tests that are expected to fail to be checked in,OPENJPA-123,12361715,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,01/Feb/07 07:05,02/May/13 02:29,14/Mar/19 03:02,12/Nov/09 08:23,,,,,,,,,,2.0.0-beta,2.0.0-M1,2.0.0-M2,2.0.0-M3,,build / infrastructure,,,,,,0,,"Often, tests are developed before solutions are implemented. It should be possible for us to check in such tests to svn without causing the build to fail.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-02-01 07:59:38.748,,,no_permission,,,,,,,,,,,160459,,,Thu Nov 12 08:23:51 UTC 2009,,,,,,,0|i0za33:,203936,,,,,,,,01/Feb/07 07:31;pcl;OPENJPA-122 is an example of a test case that should have been commitable before the behavior was implemented.,"01/Feb/07 07:59;mprudhom;I believe the Maven test plugin (""surefire"") supports both JUnit and TestNG at the same time. If so, then we could use the TestNG concept of ""groups"" (http://testng.org/doc/documentation-main.html#test-groups) to be able to specify groups for bugs that we expect to fail.","01/Feb/07 18:48;dain;You can list excluded tests in the maven pom.   If you are using TestNG, there is a way to configure that in the pom also.  See the surefire plugin documentation here:

http://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html

","01/Feb/07 19:03;pcl;I think that I prefer moving to TestNG; I like the idea of keeping the information about whether or not the test should run colocated with the test itself, rather than separated out into the pom.",12/Nov/09 08:23;ppoddar@apache.org;We now have multiple mechanisms to suppress a test failure.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
EntityManager does not throw exceptions after close() in required cases,OPENJPA-122,12361713,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,clr,clr,clr,01/Feb/07 05:34,09/Mar/10 18:32,14/Mar/19 03:02,01/Feb/07 20:06,,,,,,,,,,0.9.7,,,,,jpa,,,,,,0,,"A new test case TestEntityManagerMethodsThrowAfterClose has 2 failures and 2 errors.

The test case has not been checked in so that the build does not fail. The test case is attached.

1. Wrong exception thrown for flush after close:

testFlushAfterClose(org.apache.openjpa.persistence.simple.TestEntityManagerMethodsThrowAfterClose)  Time elapsed: 1.294 sec  <<< ERROR!
<4|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.TransactionRequiredException: Can only perform operation while a transaction is active.
        at org.apache.openjpa.kernel.BrokerImpl.assertActiveTransaction(BrokerImpl.java:4252)
        at org.apache.openjpa.kernel.DelegatingBroker.assertActiveTransaction(DelegatingBroker.java:1292)
        at org.apache.openjpa.persistence.EntityManagerImpl.flush(EntityManagerImpl.java:472)
        at org.apache.openjpa.persistence.simple.TestEntityManagerMethodsThrowAfterClose.testFlushAfterClose(TestEntityManagerMethodsThrowAfterClose.java:113)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:210)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:135)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:122)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:129)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:225)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:747)

2. No exception thrown for setFlushMode after close:

testSetFlushModeAfterClose(org.apache.openjpa.persistence.simple.TestEntityManagerMethodsThrowAfterClose)  Time elapsed: 0.338 sec  <<< FAILURE!
junit.framework.AssertionFailedError: Expected exception for method setFlushMode after em.close()
        at junit.framework.Assert.fail(Assert.java:47)
        at org.apache.openjpa.persistence.simple.TestEntityManagerMethodsThrowAfterClose.testSetFlushModeAfterClose(TestEntityManagerMethodsThrowAfterClose.java:123)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:210)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:135)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:122)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:129)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:225)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:747)

3. No exception thrown for getFlushMode after close:

testGetFlushModeAfterClose(org.apache.openjpa.persistence.simple.TestEntityManagerMethodsThrowAfterClose)  Time elapsed: 0.227 sec  <<< FAILURE!
junit.framework.AssertionFailedError: Expected exception for method getFlushMode after em.close()
        at junit.framework.Assert.fail(Assert.java:47)
        at org.apache.openjpa.persistence.simple.TestEntityManagerMethodsThrowAfterClose.testGetFlushModeAfterClose(TestEntityManagerMethodsThrowAfterClose.java:132)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:210)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:135)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:122)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:129)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:225)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:747)

4. Wrong exception thrown for createNamedQuery after close:

testCreateNamedQueryAfterClose(org.apache.openjpa.persistence.simple.TestEntityManagerMethodsThrowAfterClose)  Time elapsed: 0.26 sec  <<< ERROR!
<4|true|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: There is no query with the name ""NamedQuery"" defined for any of the known persistent classes: [org.apache.openjpa.persistence.simple.AllFieldTypes].
        at org.apache.openjpa.meta.MetaDataRepository.getQueryMetaData(MetaDataRepository.java:1494)
        at org.apache.openjpa.persistence.EntityManagerImpl.createNamedQuery(EntityManagerImpl.java:765)
        at org.apache.openjpa.persistence.EntityManagerImpl.createNamedQuery(EntityManagerImpl.java:62)
        at org.apache.openjpa.persistence.simple.TestEntityManagerMethodsThrowAfterClose.testCreateNamedQueryAfterClose(TestEntityManagerMethodsThrowAfterClose.java:185)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:210)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:135)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:122)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:129)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:225)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:747)

",,,,,,,,,,,,,,,,OPENJPA-123,,,,,,01/Feb/07 06:17;clr;EntityManagerImpl.patch.txt;https://issues.apache.org/jira/secure/attachment/12350114/EntityManagerImpl.patch.txt,01/Feb/07 05:36;clr;TestEntityManagerMethodsThrowAfterClose.java;https://issues.apache.org/jira/secure/attachment/12350109/TestEntityManagerMethodsThrowAfterClose.java,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-02-01 16:00:57.676,,,no_permission,,,,,,,,,,,87711,,,Thu Feb 01 20:06:51 UTC 2007,,,,,,,0|i1dp73:,288179,,,,,,,,"01/Feb/07 05:36;clr;This test cannot be checked in until the bugs are fixed, or the build will break.","01/Feb/07 06:17;clr;Please review this patch.

This patch fixes the issue but I'd like to have it reviewed. ","01/Feb/07 16:00;awhite;I personally would put the _broker.assertOpen() calls before the assertNotCloseInvoked() calls, just because it seems like the sensible progression to check whether the broker is closed and then check whether it isn't closed yet but close() has been invoked and it's waiting for a transaction commit.  But it makes absolutely no functional difference, so the patch looks good to me.","01/Feb/07 20:06;clr;svn commit -m ""OPENJPA-122 Added check for methods that require the EntityManager to be open but where the Broker would throw a different exception"" openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java
Sending        openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java
Transmitting file data .
Committed revision 502325.

svn commit -m ""OPENJPA-122 Added test for throwing IllegalStateException after EntityManager.close"" src/test/java/org/apache/openjpa/persistence/simple/TestEntityManagerMethodsThrowAfterClose.java
Adding         src/test/java/org/apache/openjpa/persistence/simple/TestEntityManagerMethodsThrowAfterClose.java
Transmitting file data .
Committed revision 502341.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Table name defaults to the class name instead of the entity name,OPENJPA-121,12361710,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,mprudhom,mprudhom,01/Feb/07 02:42,09/Mar/10 18:32,14/Mar/19 03:02,07/Mar/07 02:04,,,,,,,,,,0.9.7,,,,,jpa,,,,,,0,,"Section 9.1.1 of the JPA 1.0 spec says that if the @Table annotation is not defined, then it should default to the name of the entity. However, we always default to the name of the class. For example, the entity define as ""@Entity(name=""FOO"") public class Bar"" should default to be mapped to the table named ""FOO"", but we incorrectly default to ""Bar"".

The workaround is to just specify the @Table name as well.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-03-07 02:05:40.246,,,no_permission,,,,,,,,,,,160458,,,Wed Mar 07 02:05:40 UTC 2007,,,,,,,0|i1dp7b:,288180,,,,,,,,07/Mar/07 02:05;pcl;Tested with annotations; have not tested with XML-based entity names.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
EntityManager.clear() should not implicitly invoke the flush operation,OPENJPA-119,12361701,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,31/Jan/07 23:58,31/Jul/07 19:01,14/Mar/19 03:02,02/Feb/07 21:17,,,,,,,,,,0.9.7,,,,,jpa,,,,,,0,,"From the dev mailing list... 

======================================= 
We've noticed that when EntityManager.clear() is invoked, an implicit flush() is performed. Although the spec is cloudy in this area, I don't think this processing is correct. The javadoc is as follows for clear(): 

/** 
* Clear the persistence context, causing all managed 
* entities to become detached. Changes made to entities that 
* have not been flushed to the database will not be 
* persisted. 
*/ 
public void clear(); 

This indicates that Entities that have not been flushed will not be persisted. Thus, I would say this implies that we should not be doing an implicit flush. If the application wanted their Entities to be flushed before the clear, then they can call the flush() method before calling clear(). We shouldn't be doing this for them because then they have no choice. 

The Pro EJB3 Java Persistence API book has similar wording on pages 138-139: 

""..In many respects [clear] is semantically equivalent to a transaction rollback. All entity instances managed by the persistence context become detached with their state left exactly as it was when the clear() operation was invoked..."" 

Our current processing for clear() eventually gets to this code: 

public void detachAll(OpCallbacks call) { 
beginOperation(true); 
try { 
if ((_flags & FLAG_FLUSH_REQUIRED) != 0) 
flush(); 
detachAllInternal(call); 
} catch (OpenJPAException ke) { 
throw ke; 
} catch (RuntimeException re) { 
throw new GeneralException(re); 
} finally { 
endOperation(); 
} 
} 

Basically, if we have dirtied the Persistence Context, then do a flush() followed by the detachAllInternal(). I don't think the clear() should be doing this flush() operation. Any disagreement? 
======================================= 

There was no disagreement, thus this JIRA issue.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-02-01 19:51:54.765,,,no_permission,,,,,,,,,,,160456,,,Mon Feb 05 03:56:24 UTC 2007,,,,,,,0|i0z4if:,203033,,,,,,,,"01/Feb/07 19:29;kwsutter;Contrary to Abe's comments in the dev mailing list, this problem may easily be resolved by just removing the conditional and flush() invocation from the detachAll() method.

After analyzing this further, the detachAllInternal() invocation eventually creates a DetachManager passing in ""true"" as the second parameter on the constructor.  This ""true"" parameter indicates that any flushing has already been processed, as the following javadoc indicates:

     * @param full whether the entire broker cache is being detached; if
     * this is the case, we assume the broker has already
     * flushed if needed, and that we're detaching in-place

Thus, when we get to the detachInternal method on the DetachManager, the _flushed flag is already set to true and no more flushing is performed.

So, by removing the flush() processing in the detachAll() method on BrokerImpl, it seems to resolve the problem.

Abe had indicated that we still might need this flush processing for JDO.  But, since I don't know how JDO is using the kernel, it's kind of difficult for me to determine how to make this work for both cases -- since I don't know the code paths that JDO follows.  So, my take is that I will fix the problem for the JPA clear() processing.  If this causes a problem with other usages of the kernel, then somebody more familiar with that usage may need to further adjust the code.

Fair?  Or, am I missing something?

Kevin","01/Feb/07 19:51;awhite;""But, since I don't know how JDO is using the kernel, it's kind of difficult for me to determine how to make this work for both cases""

JDO needs to flush when detachAll() is called.  JPA doesn't.  Rather than changing the code out from under JDO, how about adding a boolean to the method.  At least then JDO code (and theoretically any other code using the method) will fail to compile.  That will allow us (and theoretically anyone else) to see the incompatibility and update our code, rather than having our detach behavior suddenly become incorrect.  If we later discover a better way to do it, we can remove the boolean and fix the compile-time problems that will again result -- I'd much rather be getting compile time errors that I'm forced to fix than to have to debug why an obscure unit test or user case suddenly stops working at a later date.

In fact given the new (and correct) clear() behavior, I think we should add an OpenJPAEntityManager.detachAll() method that retains the old behavior, because it is actually useful in some cases.  So the EntityManagerImpl would end up using Broker.detachAll with both ""true"" and ""false"" flush flags.","01/Feb/07 20:01;kwsutter;Sure, I can do the boolean parameter.  I just thought a compile failure might be more harsh.  But, I can see your point that detecting this change in behavior would be more difficult to detect.

As far as adding methods to OpenJPA public interfaces...  Do we need any consensus to do this?  Would we break any existing users?  Or, isn't that a concern with this young project at this point?

Kevin","01/Feb/07 21:06;pcl;Generally-speaking, adding new methods should not be a problem for users, although it may be a problem for people writing products that extend OpenJPA.

In general, I think that adding new methods to the OpenJPA published interfaces is something that we should do deliberately. Whether or not that means a vote on the dev list is a good question.","02/Feb/07 20:49;kwsutter;Here's what I decided to do...  I introduced a new boolean on the detachAll(OpCallbacks, boolean) method, leaving the original detachAll(OpCallbacks) as is.  The original method now calls the new method with a value of ""true"" so that the original processing takes place.  I have changed the EM.clear path so that it now calls the new method with a value of ""false"" so that no flushing takes place.  This seemed to be the least amount of churn and still allow both types of flush/clear processing to take place.

I have decided not to introduce a new detachAll method on the OpenJPAEntityManager interface at this time.  I personally like to wait for a need for modifying public interfaces, even if it's just for other products extending OpenJPA.

I'll be dropping the changes shortly (after the testing checks out).  I have also added a testcase for this scenario.

Kevin",02/Feb/07 21:17;kwsutter;Resolved.,"05/Feb/07 03:56;awhite;I'm not saying we need to add the new detachAll method, but I don't understand everyone's fear of breaking anything by adding new public methods.  It's very hard to break anything by adding a new public method.  The only thing you can possibly break is a non-dynamic proxy that implements the interface (OpenJPAEntityManager) without extending the impl (EntityManagerImpl).  Anyone layering on top of OpenJPA in that fashion has to realize that their implementation will need updating fairly often.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AutoDetach property has no effect,OPENJPA-118,12361655,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,dezzio,dezzio,31/Jan/07 16:05,09/Mar/10 18:32,14/Mar/19 03:02,31/Jan/07 22:27,,,,,,,,,,0.9.7,,,,,lib,,,,,,0,,"Setting the openjpa.AutoDetach property to the string ""commit, close, nontx-read"" has no effect.  ",Java SE,,,,,,,,,,,,,,,,,,,,,31/Jan/07 16:10;dezzio;TestFixesForOpenJPA-118.zip;https://issues.apache.org/jira/secure/attachment/12350043/TestFixesForOpenJPA-118.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-01-31 17:40:33.125,,,no_permission,,,,,,,,,,,160455,,,Wed Jan 31 22:27:36 UTC 2007,,,,,,,0|i0z4h3:,203027,,,,,,,,31/Jan/07 16:10;dezzio;Tests and fixes for the bug.  Not sure if the tests are in the right module.  Perhaps they should be in openjpa-persistence instead of openjpa-persistence-jdbc.  The fixes also clean up the error message when the property has invalid values to conform to the documented settings.,"31/Jan/07 17:40;pcl;Sadly, due to some maven environment issues, all tests that need to communicate with a database need to be in openjpa-persistence-jdbc.","31/Jan/07 22:27;mprudhom;I've corrected a couple minior problems with the patch (no ASF license header, files in DOS format, non-standard indentation & linebreaks) and committed. Tests pass, closing issue.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
EntityManager.getDelegate should throw an IllegalStateException ,OPENJPA-116,12361513,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,kwsutter,mikedd,mikedd,29/Jan/07 22:28,17/Apr/07 18:38,14/Mar/19 03:02,30/Jan/07 19:45,,,,,,,,,,0.9.7,,,,,,,,,,,0,,"EntityManager.getDelegate() should throw an IllegalStateException if the EntityManager has been closed. 

I noticed then when debugging other problems. According to the javadoc http://java.sun.com/javaee/5/docs/api/javax/persistence/EntityManager.html#getDelegate() we need to throw an exception if the EM has been closed. 

In case I missed anything here's what I did to reproduce the problem. 


        EntityManagerFactory _emf = Persistence.createEntityManagerFactory(""test"");

        EntityManager em = _emf.createEntityManager();

        em.close();

        try {
            Object o = em.getDelegate();
            fail();
        }
        catch(IllegalStateException ise) {
            System.out.println(""Caught expected exception"");
        }

",,,,,,,,,,,,,,,,,,,,,,30/Jan/07 15:54;mikedd;openjpa-116-patch.txt;https://issues.apache.org/jira/secure/attachment/12349935/openjpa-116-patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-01-30 19:45:05.743,,,no_permission,,,,,,,,,,,160453,,,Tue Jan 30 19:45:05 UTC 2007,,,,,,,0|i1dp7z:,288183,,,,,,,,"30/Jan/07 19:45;kwsutter;This issue was temporarily resolved with the patch that Mike provided.  Abe has since changed the processing in this area of the code and, thus, the actual call to assertOpen() has been replaced with the assertNotCloseInvoked() method, but the same result still happens.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bottleneck(s) with using OpenJPA in a Container-managed environment,OPENJPA-115,12361497,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,kwsutter,kwsutter,kwsutter,29/Jan/07 19:20,31/Jul/07 19:00,14/Mar/19 03:02,01/Feb/07 22:57,,,,,,,,,,0.9.7,,,,,kernel,,,,,,0,,"Running some benchmarks against OpenJPA using the Sun Java System (SunOne) application server. Under load, we're not able to push the cpu to 100%. The culprit seems to be the lock and synchronization processing within AbstractBrokerFactory.newBroker(..). According to sections 5.9.1 and 5.9.2 in the JPA specification, it looks like OpenJPA is attempting to do too much management of the created EntityManagers. Within a Container-managed environment, the Container takes care of the lifecycle of the EntityManagers. So, there does not seem to be a need to do the findBroker(..) invocation, nor is there a need to keep track of the created EntityManagers (_brokers) so that they can be closed when the Factory is closed. 

Once we have verified these changes, there may be others that are needed. But, we have to get by this bottleneck first before going to the next layer... 

Kevin",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-01-29 20:11:51.123,,,no_permission,,,,,,,,,,,160452,,,Thu Feb 01 22:57:42 UTC 2007,,,,,,,0|i0ywan:,201702,,,,,,,,"29/Jan/07 20:11;pcl;From what I can tell, the locking is needed to guard the _brokers collection. (It is also guarding the _transactional collection, but findExisting is always false in the OpenJPA codebase, so that code is never used in OpenJPA.) In IMO, the guarding is overly-granular at best, and unneeded at worst.

The _brokers collection provides us with a means to ensure that when we close a BrokerFactory, all open Brokers are closed along with it. Additionally, we use a weak reference map here, so we don't need to maintain the _brokers collection during Broker.close().

So, we have a number of options:

1. move the locking logic to be just around the code that maintains the _brokers collection

2. implement a concurrent Collection class that uses weak references, and eliminate all locking

3. create a configuration option (openjpa.CloseBrokersOnBrokerFactoryClose or something) that controls whether or not OpenJPA tracks open brokers. This would allow default behavior to be pro-active about cleanup, but also allow containers (which are presumably doing a good job of resource clean-up) to bypass the overhead.","29/Jan/07 21:04;clr;Kevin opined: Within a Container-managed environment, the Container takes care of the lifecycle of the EntityManagers. 

I believe that this applies only to injected EntityManagers, not to those created by the user explicitly via EMF.createEntityManager. So there is still some cleanup needed to guarantee proper resource deallocation when the EMF is closed.

Patrick offered: implement a concurrent Collection class that uses weak references, and eliminate all locking

I believe that this is an optimal solution. Concurrent Collections should have almost zero locking in most containers.","29/Jan/07 22:21;pcl;Recall that we do have a 1.4-compatible concurrent collection at org.apache.openjpa.lib.util.concurrent.ConcurrentHashSet. However, to my knowledge, that impl uses hard references.","30/Jan/07 13:53;kwsutter;Thanks, Patrick and Craig.  I did some looking in lib and found that we also have a ConcurrentReferenceHashSet.  So, I have modified _brokers accordingly and am waiting for our test results.  I have also removed the explicit lock/unlock invocations.  As Patrick pointed out, the findBroker() is never called since findExisting is always false for OpenJPA, thus the other synch block shouldn't come into play.  Hopefully, with the weak references in ConcurrentReferenceHashSet _brokers, this should help with the blocking and broker cleanup.  Our original experimentation showed that even with the weak references in ReferenceHashSet, we still bogged down during the cleanup of the _brokers collection.  But, maybe there's a problem with SunOne where they are not properly closing the EntityManagers.  I'll post back when we get the test results.","30/Jan/07 17:47;pcl;> Our original experimentation showed that even with the weak references 
> in ReferenceHashSet, we still bogged down during the cleanup of the 
> _brokers collection.

But that should only be happening when the EMF is closed, right? Presumably, that corresponds to appserver shutdown / application undeploy. Is your test measuring that part of the application lifecycle?","01/Feb/07 22:22;kwsutter;I'm going to go ahead with the proposed changes to remove the explicit lock/unlock invocations, and change the _brokers definition to use ConcurrentReferenceHashSet with weak references.  The problem at shutdown was with the EMF.close processing.  It is attempting to close any outstanding EM's that had not been closed.  But, as it was iterating through this list, one of the EM instances became null and caused an NPE.  Not sure if this is due to the weak references being GC'd or it indicates a possible problem with the underlying Collections MapBackedSet or something else, but a simple null check gets around this problem.

With these changes, the initial bottleneck with running OpenJPA in a server environment has been resolved.  We are still pursuing other performance concerns, but we'll open new JIRA reports when we get something more concrete.

Kevin","01/Feb/07 22:35;pcl;The null problem is probably due to references being garbage collected -- this is a typical side-effect of weak reference collection types. The improved concurrency is typically worth the extra difficulty of checking for nulls, though.","01/Feb/07 22:46;clr;Yes, null checking is an expected requirement when dealing with weak references. If you can get a strong reference in a cleanup routine then it's ok to use it, because the fact that you have a strong reference will prevent garbage collection. 

If you get null from your weak reference, then the garbage collector has already done its job and by definition there can be nothing left for your routine to clean up.",01/Feb/07 22:57;kwsutter;Changes committed to SVN.,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"when you specify columm table=""empbean""  in the xml file entity id or basic type when empbean is the default table name, the mapping tool generates extra foreign key field (eg.EmpBean_empid) in the table produced.",OPENJPA-113,12361229,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,ghongell,ghongell,25/Jan/07 02:04,09/Mar/10 18:32,14/Mar/19 03:02,24/Oct/07 18:10,,,,,,,,,,1.0.1,1.1.0,,,,,,,,,,0,,"when you specify columm table=""empbean""  in the xml file entity id or basic type when empbean is the default table name, the mapping tool generates extra foreign key field (eg.EmpBean_empid) in the table produced. This causes a SQL0203 (A reference to column name is ambiguous) on empid when you try to persist this entity.


    <entity name=""EmpBean"" class=""EmpBean"" access=""FIELD"">
        <attributes>
            <id name=""empid"">
               <column name=""empid"" nullable=""false"" column-definition=""integer"" />
            </id>
            <basic name=""name"" fetch=""EAGER"">
                <column length=""40""/>
            </basic>

            <basic name=""salary"" fetch=""EAGER"" >
                <column name=""salary"" table=""empbean""/>
            </basic>

            <basic name=""bonus"" fetch=""EAGER"">
            </basic>
             <basic name=""isManager"" fetch=""EAGER"">
             </basic>
             <basic name=""execLevel"" fetch=""EAGER"">
             </basic>
            <basic name=""hireDate"" fetch=""EAGER"">
             </basic>
            <basic name=""hireTime"" fetch=""EAGER"">
             </basic>
            <basic name=""hireTimestamp"" fetch=""EAGER"">
             </basic>

           <many-to-one name=""dept"" target-entity=""com.ibm.ws.query.entities.xml.DeptBean"" fetch=""EAGER"">
           </many-to-one>

           <one-to-many name=""manages"" target-entity=""DeptBean"" fetch=""LAZY"" mapped-by=""mgr"">
                <cascade><cascade-remove/></cascade>
            </one-to-many>
 
           <one-to-one name=""home"" target-entity=""AddressBean"" fetch=""EAGER"">
           </one-to-one>
 
            <one-to-one name=""work"" target-entity=""AddressBean"" fetch=""EAGER"">
           </one-to-one>
            
            <many-to-many name=""tasks"" target-entity=""TaskBean"" fetch=""LAZY"" mapped-by=""emps"">
            </many-to-many>

        </attributes>        
    </entity>


4787  mdd  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1274432502> executing stmnt 1129857880 CREATE TABLE EmpBean (empid INTEGER NOT NULL, bonus DOUBLE, execLevel INTEGER, hireDate DATE, hireTime TIME, hireTimestamp TIMESTAMP, isManager SMALLINT, name VARCHAR(40), EmpBean_empid INTEGER, salary DOUBLE, dept_deptno INTEGER, home_street VARCHAR(40), work_street VARCHAR(40), PRIMARY KEY (empid))
","windows xp, openjpa_097_incubating",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-03-07 14:41:40.762,,,no_permission,,,,,,,,,,,160450,,,Wed Mar 07 14:41:40 UTC 2007,,,,,,,0|i1dp8f:,288185,,,,,,,,"07/Mar/07 14:41;kwsutter;FYI, we have also encountered this problem with annotations.  If you re-specify the table designation in the @Column
annotation, OpenJPA thinks there's another field named ""<class><id>"".  This only seems to be a problem with @Id fields that also have an @Column annotation:

@Entity
@Table(name=""ITEM"")
public class ItemJPA {

	public int itemId;
	public String itemName;
	public java.math.BigDecimal itemPrice;
	public String itemData;
	
	@Id
	@Column(name=""I_ID"", table=""ITEM"")
	@GeneratedValue(strategy=GenerationType.AUTO)
	public int getItemId() {
		return itemId;
	}
   :
}

In this case, OpenJPA created another attribute named ItemJPA_I_ID, and of course, the SQL statements generated were
not correct:

prepstmnt 1986688618 UPDATE ITEM SET I_PRICE = ? WHERE I_ID = ? AND ItemJPA_I_ID = ? [params=(BigDecimal) 500, (int) 1, (int) 1]

An easy workaround is to just remove this redundant specification in the @Column annotation.

Kevin


",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Native queries and named parameters: poor error message,OPENJPA-112,12361228,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,pcl,pcl,25/Jan/07 01:38,09/Mar/10 18:32,14/Mar/19 03:02,19/Jun/08 00:40,,,,,,,,,,1.2.0,,,,,,,,,,,0,,"native queries fail when use named parameters

 int parm3 = 100;
String sql = ""SELECT deptno,budget,NAME,MGR_EMPID,REPORTSTO_DEPTNO FROM DeptBean WHERE deptno >= :deptno "";
Query getDept = _em.createNativeQuery(sql,DeptBean.class
getDept.setParameter(""deptno"",parm3);
List<DeptBean> rl = (getDept.getResultList());


<4|false|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: The parameter name or position ""deptno"" passed to execute() is not valid.  All map keys must be a declared parameter name or a number matching the parameter position. 
	at org.apache.openjpa.kernel.QueryImpl.toParameterArray(QueryImpl.java:897)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:825)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:763)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:520)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:224)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:264)
	at com.ibm.ws.query.tests.JUNamedNativeQueryTest.testSelectDeptBean2(JUNamedNativeQueryTest.java:514)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.framework.TestCase.runTest(Unknown Source)
	at junit.framework.TestCase.runBare(Unknown Source)
	at junit.framework.TestResult$1.protect(Unknown Source)
	at junit.framework.TestResult.runProtected(Unknown Source)
	at junit.framework.TestResult.run(Unknown Source)
	at junit.framework.TestCase.run(Unknown Source)
	at junit.framework.TestSuite.runTest(Unknown Source)
	at junit.framework.TestSuite.run(Unknown Source)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)

","windows xp, openjpa_097_incubating",,,,,,,,,,OPENJPA-111,,,,,,,,,,,14/Jul/07 22:04;clr;openjpa-112.patch;https://issues.apache.org/jira/secure/attachment/12361840/openjpa-112.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-07-14 22:04:28.811,,,no_permission,,,,,,,,,,,160449,,,Thu Jun 19 00:40:53 UTC 2008,,,,,,,0|i1dp8n:,288186,,,,,,,,"25/Jan/07 01:38;pcl;While the failure is legit (see OPENJPA-111), the error message should be more clear.","14/Jul/07 22:04;clr;Please review this patch. It's a little tricky to describe the conditions under which this user error will be encountered. By the time this error is found, the parameters have already been set and the error message must cater to lots of different situations.",19/Jun/08 00:40;ppoddar@apache.org;Committed revision 669341.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Every NamedNativeQuery using ResultSetMapping fails at runtime with class cast exception when try to iterate over list<Some Entity>,OPENJPA-110,12361226,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ghongell,ghongell,25/Jan/07 01:05,01/Mar/07 02:20,14/Mar/19 03:02,01/Mar/07 02:20,,,,,,,,,,0.9.7,,,,,,,,,,,0,,"Every NamedNativeQuery using ResultSetMapping fails at runtime with class cast exception when try to iterate over list<Some Entity>

java.lang.ClassCastException: java.lang.Integer incompatible with com.ibm.ws.query.entities.objectgrid.xml.DeptBean
	at com.ibm.ws.query.tests.JUNamedNativeQueryTest.testJoinQuery(JUNamedNativeQueryTest.java:563)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.framework.TestCase.runTest(Unknown Source)
	at junit.framework.TestCase.runBare(Unknown Source)
	at junit.framework.TestResult$1.protect(Unknown Source)
	at junit.framework.TestResult.runProtected(Unknown Source)
	at junit.framework.TestResult.run(Unknown Source)
	at junit.framework.TestCase.run(Unknown Source)
	at junit.framework.TestSuite.runTest(Unknown Source)
	at junit.framework.TestSuite.run(Unknown Source)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
","windows xp, openjpa_097_incubating",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-01-25 01:13:28.915,,,no_permission,,,,,,,,,,,160447,,,Thu Feb 01 02:27:48 UTC 2007,,,,,,,0|i0z4jb:,203037,,,,,,,,25/Jan/07 01:13;mprudhom;It looks like you are getting back a list of Integers. What are the NamedNativeQuery and ResultSetMapping annotations in question?,01/Feb/07 02:27;wisneskid;already fixed in current code,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"every NativeQuery using SqlResultSetMapping fails at runtime with There is no query result mapping for ""null"" with name ""xxx"" when the entity is persisted in a different method than the method doing the query.  ",OPENJPA-109,12361225,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ghongell,ghongell,25/Jan/07 01:02,09/Mar/10 18:32,14/Mar/19 03:02,26/Jan/07 23:56,,,,,,,,,,0.9.7,,,,,,,,,,,0,,"every NativeQuery using SqlResultSetMapping fails at runtime with There is no query result mapping for ""null"" with name ""xxx"" when the entity is persisted in a different method than the method doing the query.  

<4|true|0.9.7-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: 
There is no query result mapping for ""null"" with name ""DeptBeanMapping"".
	at org.apache.openjpa.jdbc.meta.MappingRepository.getQueryResultMapping(MappingRepository.java:175)
	at org.apache.openjpa.jdbc.kernel.SQLStoreQuery$SQLExecutor.<init>(SQLStoreQuery.java:174)
	at org.apache.openjpa.jdbc.kernel.SQLStoreQuery.newDataStoreExecutor(SQLStoreQuery.java:143)
	at org.apache.openjpa.kernel.QueryImpl.createExecutor(QueryImpl.java:718)
	at org.apache.openjpa.kernel.QueryImpl.compileForDataStore(QueryImpl.java:676)
	at org.apache.openjpa.kernel.QueryImpl.compileForExecutor(QueryImpl.java:658)
	at org.apache.openjpa.kernel.QueryImpl.getOperation(QueryImpl.java:1463)
	at org.apache.openjpa.kernel.DelegatingQuery.getOperation(DelegatingQuery.java:120)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:214)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:264)
	at com.ibm.ws.query.tests.JUNamedNativeQueryTest.testSelectDeptBean(JUNamedNativeQueryTest.java:457)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.framework.TestCase.runTest(Unknown Source)
	at junit.framework.TestCase.runBare(Unknown Source)
	at junit.framework.TestResult$1.protect(Unknown Source)
	at junit.framework.TestResult.runProtected(Unknown Source)
	at junit.framework.TestResult.run(Unknown Source)
	at junit.framework.TestCase.run(Unknown Source)
	at junit.framework.TestSuite.runTest(Unknown Source)
	at junit.framework.TestSuite.run(Unknown Source)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)

","windows xp, openjpa_097_incubating",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-01-25 18:17:10.053,,,no_permission,,,,,,,,,,,160446,,,Fri Jan 26 23:56:26 UTC 2007,,,,,,,0|i0zb5z:,204111,,,,,,,,25/Jan/07 18:17;ppoddar@apache.org;Will you please attach a test case + annotated domain classes or domain classes + xml descriptors. This will help us to reproduce this failure as the test cases (within Kodo test corpus) for SQLResultMapping and SQLResultSetMappings that are based on the same implementation are not showing similar failure.  ,26/Jan/07 23:56;wisneskid;This problem is fixed in current code.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@SqlResultSetMappings fails in mapping tool with java.lang.ArrayStoreException,OPENJPA-107,12361222,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ghongell,ghongell,25/Jan/07 00:49,09/Mar/10 18:32,14/Mar/19 03:02,25/Jan/07 19:10,,,,,,,,,,0.9.7,,,,,,,,,,,0,,"@SqlResultSetMappings fails in mapping tool with java.lang.ArrayStoreException

7361  mdd  INFO   [main] openjpa.MetaData - Parsing class ""com.ibm.ws.query.entities.annotated.DeptBean"".
...
...
Exception in thread ""main"" java.lang.ArrayStoreException
	at com.ibm.oti.reflect.AnnotationHelper.getReturnValueFromEntry(Native Method)
	at com.ibm.oti.reflect.AnnotationHelper.access$000(AnnotationHelper.java:14)
	at com.ibm.oti.reflect.AnnotationHelper$AnnotationInvocationHandler.invoke(AnnotationHelper.java:104)
	at $Proxy12.value(Unknown Source)
	at org.apache.openjpa.persistence.jdbc.AnnotationPersistenceMappingParser.parseClassMappingAnnotations(AnnotationPersistenceMappingParser.java:280)
	at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parseClassAnnotations(AnnotationPersistenceMetaDataParser.java:601)
	at org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser.parse(AnnotationPersistenceMetaDataParser.java:344)
	at org.apache.openjpa.persistence.PersistenceMetaDataFactory.load(PersistenceMetaDataFactory.java:211)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:414)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:272)
	at org.apache.openjpa.meta.ValueMetaDataImpl.resolveDeclaredType(ValueMetaDataImpl.java:426)
	at org.apache.openjpa.meta.ValueMetaDataImpl.resolve(ValueMetaDataImpl.java:405)
	at org.apache.openjpa.jdbc.meta.ValueMappingImpl.resolve(ValueMappingImpl.java:467)
	at org.apache.openjpa.meta.FieldMetaData.resolve(FieldMetaData.java:1574)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:397)
	at org.apache.openjpa.meta.ClassMetaData.resolveMeta(ClassMetaData.java:1630)
	at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1565)
	at org.apache.openjpa.meta.MetaDataRepository.processBuffer(MetaDataRepository.java:656)
	at org.apache.openjpa.meta.MetaDataRepository.resolveMeta(MetaDataRepository.java:556)
	at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:481)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:285)
	at org.apache.openjpa.jdbc.meta.MappingRepository.getMapping(MappingRepository.java:273)
	at org.apache.openjpa.jdbc.meta.MappingTool.getMapping(MappingTool.java:660)
	at org.apache.openjpa.jdbc.meta.MappingTool.buildSchema(MappingTool.java:732)
	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:630)
	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:1059)
	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:966)
	at org.apache.openjpa.jdbc.meta.MappingTool.main(MappingTool.java:907)","windows xp, openjpa_097_incubating",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-01-25 01:11:32.011,,,no_permission,,,,,,,,,,,160444,,,Thu Jan 25 19:10:59 UTC 2007,,,,,,,0|i0zb0f:,204086,,,,,,,,"25/Jan/07 01:11;mprudhom;This is the same comment as I made in OPENJPA-108. This sounds like a bug with the IBM JVM, as reported at http://www-128.ibm.com/developerworks/forums/dw_thread.jsp?forum=367&thread=112543&cat=10 . Do you get the same error with the Sun JVM, or with a more recent version of the IBM JVM?","25/Jan/07 14:44;kwsutter;George,
I think Marc is right.  What version of the IBM JDK are you running with?   You need at least SR3 to get around this problem.

>java -fullversion
java full version ""J2RE 1.5.0 IBM Windows 32 build pwi32dev-20061002a (SR3)""

Thanks,
Kevin",25/Jan/07 18:57;ghongell;I agree.  This problem goes away when I use jdk 1.5 SR3.  I was using SR2.,25/Jan/07 19:10;kwsutter;George has verified that the problem goes away with SR3 of the IBM JDK 5.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA does not detach instances on rollback(),OPENJPA-104,12360697,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,pcl,pcl,pcl,17/Jan/07 20:23,09/Mar/10 18:32,14/Mar/19 03:02,17/Jan/07 22:17,,,,,,,,,,0.9.7,,,,,jpa,,,,,,0,,Section 3.3.2 of the JPA spec states that instances must be detached at rollback. OpenJPA does not do this.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160441,,,Wed Jan 17 22:17:38 UTC 2007,,,,,,,0|i0z693:,203315,,,,,,,,17/Jan/07 22:17;pcl;Resolved with svn 497185.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Default Listeners not being processed correctly,OPENJPA-103,12360675,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,17/Jan/07 17:08,31/Jul/07 18:57,14/Mar/19 03:02,17/Jan/07 22:50,,,,,,,,,,0.9.7,,,,,jpa,,,,,,0,,"The basic problem is this:  I'm attempting to specify some entity listeners in my orm.xml , but I continue to get the following TRACE message:

322664  my persistence unit  TRACE  [main] openjpa.MetaData - OpenJPA does not currently support XML element ""pre-persist"". Ignoring.

The following discussion is from the openjpa-dev mailing list...

------------------------------------------------------------
Marc,
Thanks for the background on the earlier drafts of the JPA spec.  That helps explain some of the processing that I see.  I also now see that elements tagged as MetaDataTags have corresponding annotation support associated with them.  So, it looks like I just need to provide similar callback processing for the pre-* and post-* methods at the ""system"" level as exist at the ""class"" levels.  Thanks for your insights.

Kevin
- Hide quoted text -


On 1/16/07, Marc Prud'hommeaux <mprudhom@apache.org> wrote:

    Kevin-

    The draft of the JPA spec said that ""pre-persist"" was only supported
    beneath the ""entity-listeners"" (note plural) element, rather than
    ""entity-listener"". This appears to have been corrected in the final
    version of the spec, but it looks like we never updated that part of
    the code (and the CTS doesn't test for it). This is indeed a bug.

    As for how the parser works, I'm afraid I don't know all that much
    about it (aside from sharing your observation that it is complex).
    Hopefully, though, my comment above will make the problem make a
    little more sense to you...



    On Jan 16, 2007, at 3:20 PM, Kevin Sutter wrote:

    > Looking for some assistance (that is, background information) on
    > how the
    > orm.xml parsing is supposed to work.  I'm attempting to specify
    > some entity
    > listeners in my orm.xml , but I continue to get the following TRACE
    > message:
    >
    > 322664  my persistence unit  TRACE  [main] openjpa.MetaData -
    > OpenJPA does
    > not currently support XML element ""pre-persist"". Ignoring.
    >
    > My orm.xml looks like this:
    >
    > <entity-mappings
    >    xmlns=""http://java.sun.com/xml/ns/persistence/orm""
    >    xmlns:xsi="" http://www.w3.org/2001/XMLSchema-instance""
    >    xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence/orm
    > http://java.sun.com/xml/ns/persistence/orm_1_0.xsd""
    >    version=""1.0"">
    >    <persistence-unit-metadata>
    >        <persistence-unit-defaults>
    >            <entity-listeners>
    >                <entity-listener class=""
    > com.ibm.ws.persistence.tests.simple.TestEntity"">
    >                    <pre-persist  method-name=""prePersist"" />
    >                    <post-persist method-name=""postPersist"" />
    >                    <pre-remove   method-name=""preRemove"" />
    >                    <post-remove  method-name=""postRemove"" />
    >                    <pre-update   method-name=""preUpdate"" />
    >                    <post-update  method-name=""postUpdate"" />
    >                    <post-load    method-name=""postLoad"" />
    >                </entity-listener>
    >            </entity-listeners>
    >        </persistence-unit-defaults>
    >    </persistence-unit-metadata>
    > </entity-mappings>
    >
    > I've started to debug this problem, but I have some general
    > questions on how
    > the SAX parser is supposed to work.  I see in the
    > CFMetaDataParser.startElement() where these ""entity-listener""
    > related tags
    > are treated as System Elements -- we end up calling
    > XMLPersistenceMetaDataParser.startSystemElement().
    >
    > The processing in this method is dependent on whether the given
    > element is a
    > MetaDataTag or not.  When we process the ""entity-listener"" element,
    > it's
    > treated like a ""normal"" element and we fall past the switch
    > statement and
    > eventually call startEntityListener().  This processing all seems
    > to depend
    > on whether the _elems hashmap contains a string entry or a
    > MetatDataTag for
    > a given Element.  What is the significance of being a MetaDataTag
    > or not?
    >
    > In this simple orm.xml, I have noticed that persistence-unit-metadata,
    > persistence-unit-defaults, and entity-listener are not
    > MetaDataTags.  But,
    > entity-listeners and the individual pre-persist, post-persist, etc
    > elements
    > are all MetaDataTags.
    >
    > When one of these pre-* or post-* MetaDataTag elements are
    > processed in the
    > startSystemElement() method, we fall into the default leg of the
    > switch
    > statement and produce the TRACE message outlined above.
    >
    > Any pointers would be appreciated.  Thanks!
    >
    > Kevin
------------------------------------------------------------",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160440,,,Wed Jan 17 22:50:03 UTC 2007,,,,,,,0|i0z4gf:,203024,,,,,,,,"17/Jan/07 22:50;kwsutter;The processing in the XMLPersistenceMetaDataParser.startSystemElement method had to be updated to recognize the pre-* and post-* lifecycle methods as being valid entries at the ""system"" level.  Since this processing was already part of the ""class"" level, I just had to add the corresponding case entry and invocation of the methods.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"JTA transaction rollback, nonexistant instances, transactional persistence context => failures during afterCompletion() and close()",OPENJPA-102,12360647,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,17/Jan/07 04:07,09/Mar/10 18:32,14/Mar/19 03:02,17/Jan/07 22:17,,,,,,,,,,0.9.7,,,,,jpa,kernel,,,,,0,,"Configuration: 
  - transactional persistence context
  - DetachState=fgs
  - JTA transactions

If an error causes the transaction manager to roll back the current transaction, BrokerImpl.afterCompletion() will be invoked with Status.STATUS_ROLLEDBACK. afterCompletion() will call BrokerImpl.free(), which will attempt to load the default fetch group. If there is an instance in the Broker's context that does not exist (that was looked up via EntityManager.getReference(), for example), then the code in free() will fail with an ObjectNotFoundException.",WebLogic Server 10.0,,,,,,,,,,,,,,,,,,,,,17/Jan/07 04:09;pcl;openjpa-detach.patch;https://issues.apache.org/jira/secure/attachment/12349055/openjpa-detach.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160439,,,Wed Jan 17 22:17:18 UTC 2007,,,,,,,0|i0z4hr:,203030,,,,,,,,"17/Jan/07 04:18;pcl;openjpa-detach.patch solves the described issue, but exposes another issue: an ObjectNotFoundException will be thrown during a subsequent BrokerImpl.close() call. The attached patch calls free() with Status.NO_TRANSACTION if BrokerImpl.close() is invoked.

The use case at hand seems to do the following:

1. UserTransaction.begin()
2. getReference() on a nonexistant record
3. close() in a session bean
4. UserTransaction.commit(), which fails

With the patch, BrokerImpl.afterCompletion() calls BrokerImpl.free(Status.STATUS_ROLLEDBACK) from line 1789, because close had been invoked. The patch makes that free() invocation work as expected.

However, close() is being invoked later on. This later invocation is probably erroneous, but currently it is causing OpenJPA to throw an exception from BrokerImpl.java:3984, because close() calls free() with Status.NO_TRANSACTION.

I believe that OpenJPA should be short-circuiting close() if isClosed() returns true, or that free() should short-circuit if isClosed() returns true.","17/Jan/07 19:37;pcl;Actually my description in the prior comment is incorrect. The test case does the following:

1. EntityTransaction.begin()
2. getReference() on nonexistent record
3. rollback() in a business method
4. EntityManager.close(), which fails while running the detach algorithm

IOW, short-circuiting close() won't fix the problem, as close() has only been called once. Additionally, on further inspection, EM.close() asserts that it's open before calling broker.close(), so there will never be multiple close() invocations.

The problem does not occur in a JTA context, as the persistence context is coincident with the JTA transaction in that scenario, not the lifecycle of the EntityManager.

It does not seem possible to disable the detach algorithm altogether. However, further investigation indicates that this is probably happening because OpenJPA is not clearing the persistence context during JPA rollback. From section 3.3.2 of the JPA spec:

""For both transaction-scoped and extended persistence contexts, transaction rollback causes all pre-existing
managed instances and removed instances[15] to become detached. The instances' state will be the
state of the instances at the point at which the transaction was rolled back. Transaction rollback typically
causes the persistence context to be in an inconsistent state at the point of rollback. In particular,
the state of version attributes and generated state (e.g., generated primary keys) may be inconsistent.
Instances that were formerly managed by the persistence context (including new instances that were
made persistent in that transaction) may therefore not be reusable in the same manner as other detached
objects—for example, they may fail when passed to the merge operation.[16]""

Resolving this discrepancy will address the case that I'm looking at in particular, but will not address the case where the getReference() method is invoked outside a transaction but in an extended persistence context.","17/Jan/07 20:24;pcl;New approach: I am going to change OpenJPA's detach algorithms to handle failures more gracefully, and back out the patch I mentioned earlier. This will resolve the unexpected exceptions I was seeing.

Separately, OPENJPA-104 tracks the JPA spec discrepancy.",17/Jan/07 22:17;pcl;Resolved with svn 497185.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
<jar-file> entries failing to be processed for persistence unit rooted in an EAR,OPENJPA-100,12360237,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,pcl,pcl,pcl,10/Jan/07 23:06,09/Mar/10 18:32,14/Mar/19 03:02,10/Jan/07 23:07,,,,,,,,,,0.9.7,,,,,kernel,,,,,,0,,"<jar-file> entries in the persistence.xml file of a jar in the root of an EAR fail to be parsed properly. OpenJPA incorrectly interprets the entries as URLs for orm.xml files, and attempts to parse them as XML instead of scanning them for annotated types.","WebLogic Server 10, OpenJPA 0.9.7 snapshot",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160437,,,Wed Jan 10 23:07:35 UTC 2007,,,,,,,0|i0zazj:,204082,,,,,,,,10/Jan/07 23:07;pcl;Resolved with 495028.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java deadlock when insert in t1 and find in t2 when using IBM JVM 1.5.0,OPENJPA-98,12360119,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,vtatavu,vtatavu,09/Jan/07 20:28,31/Jul/07 18:59,14/Mar/19 03:02,05/Feb/07 17:34,,,,,,,,,,0.9.7,,,,,,,,,,,0,,"I have a simple test program that uses OpenJPA 0.9.6 to insert an object into a db in one transaction (t1) and retrieve it in another transaction (t2).  The program hangs in 30-50% of the executions right before the call to entitymanager.find() (used to retrieve the object in t2).  I'm using OpenJPA runtime enhancement.


By looking at the JVM dump, I can see the following deadlock:
1LKDEADLOCK    Deadlock detected !!!
NULL           ---------------------
NULL           
2LKDEADLOCKTHR  Thread ""main"" (0x0015EC00)
3LKDEADLOCKWTR    is waiting for:
4LKDEADLOCKMON      sys_mon_t:0x41E40548 infl_mon_t: 0x41E40588:
4LKDEADLOCKOBJ      java/lang/Object@00D41010/00D4101C: 
3LKDEADLOCKOWN    which is owned by:
2LKDEADLOCKTHR  Thread ""Finalizer thread"" (0x41B36200)
3LKDEADLOCKWTR    which is waiting for:
4LKDEADLOCKMON      sys_mon_t:0x0035CD38 infl_mon_t: 0x0035CD78:
4LKDEADLOCKOBJ      sun/misc/Launcher$AppClassLoader@00D4E5B0/00D4E5BC: 
3LKDEADLOCKOWN    which is owned by:
2LKDEADLOCKTHR  Thread ""main"" (0x0015EC00)
","OpenJPA:
0.9.6

Java:
java version ""1.5.0""
Java(TM) 2 Runtime Environment, Standard Edition (build pwi32dev-20061002a (SR3)
)
IBM J9 VM (build 2.3, J2RE 1.5.0 IBM J9 2.3 Windows XP x86-32 j9vmwi3223-2006100
1 (JIT enabled)
J9VM - 20060915_08260_lHdSMR
JIT  - 20060908_1811_r8
GC   - 20060906_AA)
JCL  - 20061002

DB:
Derby 10.2.1.6",,,,,,,,,,,,,,,,,,,,,09/Jan/07 20:30;vtatavu;console.txt;https://issues.apache.org/jira/secure/attachment/12348582/console.txt,09/Jan/07 20:30;vtatavu;javacore.20070109.114312.3868.zip;https://issues.apache.org/jira/secure/attachment/12348581/javacore.20070109.114312.3868.zip,09/Jan/07 20:30;vtatavu;play.zip;https://issues.apache.org/jira/secure/attachment/12348580/play.zip,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-01-10 17:15:56.674,,,no_permission,,,,,,,,,,,160435,,,Tue Jul 31 18:59:34 UTC 2007,,,,,,,0|i0z1bj:,202516,,,,,,,,"09/Jan/07 20:33;vtatavu;Attachments:
play.zip - the Eclipse project used to reproduce this problem
javacore.20070109.114312.3868.zip - java dump after the deadlock occured
console.txt - java console of the test program after the deadlock occured",09/Jan/07 20:37;vtatavu;I cannot reproduce this problem with Sun JDK 1.5.0_04.,"10/Jan/07 17:15;kwsutter;I'll take ownership of this report (for now, at least).

I can now reproduce the problem.  Using the runtime enhancement and using previously created database tables, the problem reproduces itself quite easily.

From looking at the resulting stack traces for the deadlock, the dynamic enhancement processing is definitely the source of the problem.  If the classes were statically enhanced before the execution, this particular problem would not surface.  But, I don't see any processing within the dynamic enhancement class loader that should cause this type of deadlock.

Here are snippets from the javacore thread dump for the two deadlocked threads:

3XMTHREADINFO      ""main"" (TID:0x41DF8C00, sys_thread_t:0x0038B9D8, state:B, native ID:0x00001744) prio=5
4XESTACKTRACE          at com/ibm/oti/vm/BootstrapClassLoader.loadClass(BootstrapClassLoader.java:63(Compiled Code))
4XESTACKTRACE          at java/lang/ClassLoader.loadClass(ClassLoader.java:587(Compiled Code))
4XESTACKTRACE          at java/lang/ClassLoader.loadClass(ClassLoader.java:587(Compiled Code))
4XESTACKTRACE          at sun/misc/Launcher$AppClassLoader.loadClass(Launcher.java:327(Compiled Code))
4XESTACKTRACE          at java/lang/ClassLoader.loadClass(ClassLoader.java:563(Compiled Code))
4XESTACKTRACE          at org/apache/openjpa/jdbc/kernel/JDBCStoreManager.getManagedType(JDBCStoreManager.java:562)
4XESTACKTRACE          at org/apache/openjpa/kernel/DelegatingStoreManager.getManagedType(DelegatingStoreManager.java:140)
4XESTACKTRACE          at org/apache/openjpa/kernel/BrokerImpl.newStateManagerImpl(BrokerImpl.java:1136)
4XESTACKTRACE          at org/apache/openjpa/kernel/BrokerImpl.find(BrokerImpl.java:826)
4XESTACKTRACE          at org/apache/openjpa/kernel/BrokerImpl.find(BrokerImpl.java:743)
4XESTACKTRACE          at org/apache/openjpa/kernel/DelegatingBroker.find(DelegatingBroker.java:169)
4XESTACKTRACE          at org/apache/openjpa/persistence/EntityManagerImpl.find(EntityManagerImpl.java:346)
4XESTACKTRACE          at com/ibm/ws/persistence/tests/simple/TestInsertAndFind.test001(TestInsertAndFind.java:51)
:

3XMTHREADINFO      ""Finalizer thread"" (TID:0x41ED6200, sys_thread_t:0x42299718, state:B, native ID:0x00001078) prio=5
4XESTACKTRACE          at java/lang/ClassLoader.loadClass(ClassLoader.java:563(Compiled Code))
4XESTACKTRACE          at java/lang/Class.forNameImpl(Native Method)
4XESTACKTRACE          at java/lang/Class.forName(Class.java:160(Compiled Code))
4XESTACKTRACE          at org/apache/openjpa/lib/util/TemporaryClassLoader.loadClass(TemporaryClassLoader.java:55(Compiled Code))
4XESTACKTRACE          at org/apache/openjpa/lib/util/TemporaryClassLoader.loadClass(TemporaryClassLoader.java:40(Compiled Code))
4XESTACKTRACE          at java/lang/Class.forNameImpl(Native Method)
4XESTACKTRACE          at java/lang/Class.forName(Class.java:160(Compiled Code))
4XESTACKTRACE          at org/apache/openjpa/enhance/PCClassFileTransformer.needsEnhance(PCClassFileTransformer.java:171(Compiled Code))
4XESTACKTRACE          at org/apache/openjpa/enhance/PCClassFileTransformer.transform(PCClassFileTransformer.java:117(Compiled Code))
:

As the ""find"" operation is performed in the main thread, additional classes need to be loaded to satisfy the request.  As part of that class loading, the runtime enhancement is kicked off to determine whether the classes being loaded need to be enhanced or not.

As part of this checking, the following conditional is executed:

        if (name.startsWith(""java."") || name.startsWith(""javax."")
            || name.startsWith(""sun.""))
            return Class.forName(name, resolve, getClass().getClassLoader());

This call to Class.forName() eventually requests the same lock that is already in place on the Main thread.  Everytime I hit this deadlock, it's the same stack traces.  And, it's always at the same spot in the testcode.  But, like Vlad and I have mentioned, it doesn't deadlock on every execution.

My gut reaction at this point is that we have a problem with the IBM JDK.  But, I wanted to post my findings to this Issue to see if this description jogs any memory bits from the original OpenJPA authors.

Thanks,
Kevin","10/Jan/07 20:47;mprudhom;I've never seen any problem like this. It is interesting that the finalizer thread is causing the problem. Do you have a deeper stack for the ""Finalizer thread""?

Also, I wonder if running your test with the ""-verbose:class"" would help identify the class in question, and thereby shed some more light on the problem (or alternately putting a printf in TemporaryClassLoader.loadClass()).","10/Jan/07 22:08;kwsutter;Yes, I already did that printf thing.  It varies on exactly which class is ""caught"", but, of course, it always starts with java.*, or javax.*, or sun.* (since that's the conditional).

As far as the rest of the call stack...  I attached the javacore to this Issue so you can look at the whole thing.  But, the complete finalizer thread is as follows:

3XMTHREADINFO      ""Finalizer thread"" (TID:0x41ED5F00, sys_thread_t:0x42299718, state:B, native ID:0x0000165C) prio=5
4XESTACKTRACE          at java/lang/ClassLoader.loadClass(ClassLoader.java:563(Compiled Code))
4XESTACKTRACE          at java/lang/Class.forNameImpl(Native Method)
4XESTACKTRACE          at java/lang/Class.forName(Class.java:160(Compiled Code))
4XESTACKTRACE          at org/apache/openjpa/lib/util/TemporaryClassLoader.loadClass(TemporaryClassLoader.java:56(Compiled Code))
4XESTACKTRACE          at org/apache/openjpa/lib/util/TemporaryClassLoader.loadClass(TemporaryClassLoader.java:40(Compiled Code))
4XESTACKTRACE          at java/lang/Class.forNameImpl(Native Method)
4XESTACKTRACE          at java/lang/Class.forName(Class.java:160(Compiled Code))
4XESTACKTRACE          at org/apache/openjpa/enhance/PCClassFileTransformer.needsEnhance(PCClassFileTransformer.java:171(Compiled Code))
4XESTACKTRACE          at org/apache/openjpa/enhance/PCClassFileTransformer.transform(PCClassFileTransformer.java:117(Compiled Code))
4XESTACKTRACE          at sun/instrument/TransformerManager.transform(TransformerManager.java:141(Compiled Code))
4XESTACKTRACE          at sun/instrument/InstrumentationImpl.transform(InstrumentationImpl.java:174(Compiled Code))
4XESTACKTRACE          at com/ibm/oti/vm/VM.findClassOrNull(Native Method)
4XESTACKTRACE          at com/ibm/oti/vm/BootstrapClassLoader.loadClass(BootstrapClassLoader.java:64(Compiled Code))
4XESTACKTRACE          at java/lang/ref/ReferenceQueue.enqueue(ReferenceQueue.java:125)
4XESTACKTRACE          at java/lang/ref/Reference.enqueueImpl(Reference.java:93)
","10/Jan/07 22:55;mprudhom;I wonder what would happen if we replaced:

   return Class.forName(name, resolve, getClass().getClassLoader());

with:

  return super.loadClass(name, resolve);
",10/Jan/07 23:21;kwsutter;We're thinking along the same lines...  The super.loadClass just ends up in the same ClassLoader.loadClass code with the same deadlock.  Sorry that I didn't post this earlier.,"19/Jan/07 15:02;kwsutter;This looks to be a problem with the IBM JDK.  I reported the problem to IBM and I have just tested a possible fix for the problem.  So far, it looks good.  Since the original problem was intermittent, I guess I can't be sure that it's resolved.  But, after a couple days of testing, it looks to be standing up.  I am checking on the availability of a patch or updated version.",25/Jan/07 14:48;kwsutter;IBM has indicated that the fix will be available in SR5 for JDK 5.  I'm still checking on an interim iFix.,05/Feb/07 17:34;kwsutter;This problem will be resolved in SR5 of the IBM v5 JDK.  The availability of an interim iFix is still being investigated.  The Sun v5 JDK does not seem to exhibit this behavior.,31/Jul/07 18:59;kwsutter;This problem was resolved with IBM JDK 5 SR 5.,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.VerifyError on websphere after application reload,OPENJPA-91,12359284,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,g9adm,g9adm,22/Dec/06 12:07,18/Sep/08 18:31,14/Mar/19 03:02,18/Sep/08 18:31,,,,,,,,,,,,,,,,,,,,,0,,"Hi ..

Not sure if this is a bug or just the way websphere reacts to openjpa. 

I have a small test program using OpenJPA against an Oracle database. I am running this program in the Websphere 6.1 test environment included with Rational Developer 7. This is all working just fine. But when I make changes to some ressource in the application, the chagnes are automatically published to the test environment and the app is restarted. After this I get the Exception below, whenever I try to access an EntityManager. 

If I restart the entire server, the app is running fine again. So I guess this is related to restarting the application.

Caused by: java.lang.VerifyError: class loading constraint violated (class: org/apache/openjpa/kernel/BrokerImpl method: newQueryImpl(Ljava/lang/String;Lorg/apache/openjpa/kernel/StoreQuery;)Lorg/apache/openjpa/kernel/QueryImpl;) at pc: 0
	at java.lang.J9VMInternals.verifyImpl(Native Method)
	at java.lang.J9VMInternals.verify(J9VMInternals.java:59)
	at java.lang.J9VMInternals.initialize(J9VMInternals.java:120)
	at java.lang.Class.forNameImpl(Native Method)
	at java.lang.Class.forName(Class.java:131)
	at org.apache.openjpa.conf.OpenJPAConfigurationImpl.class$(OpenJPAConfigurationImpl.java:65)
	at org.apache.openjpa.conf.OpenJPAConfigurationImpl.<init>(OpenJPAConfigurationImpl.java:182)
	at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.<init>(JDBCConfigurationImpl.java:110)
	at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.<init>(JDBCConfigurationImpl.java:100)
	at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.<init>(JDBCConfigurationImpl.java:91)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newInstance(JDBCBrokerFactory.java:55)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at org.apache.openjpa.kernel.Bootstrap.invokeFactory(Bootstrap.java:117)
	at org.apache.openjpa.kernel.Bootstrap.newBrokerFactory(Bootstrap.java:57)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:70)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:78)
	at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:83)
	at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:60)
	at util.EntityManagerFactoryHelper.getEntityManagerFactory(EntityManagerFactoryHelper.java:22)
","Using OpenJPA (openjpa-all-0.9.6-incubating.jar) in Rational Developer 7 ( Websphere 6.1 test environment ) connected to Oracle 9.2 database.
OS: WinXP SP2",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-12-22 20:09:42.0,,,no_permission,,,,,,,,,,,160428,,,Thu Sep 18 18:31:42 UTC 2008,,,,,,,0|i1dpav:,288196,,,,,,,,"22/Dec/06 20:09;mprudhom;It sounds like a number of other people have experienced this sort of error with various other packages (see http://www-128.ibm.com/developerworks/forums/dw_thread.jsp?forum=275&thread=31014&cat=9 ). Sadly, there doesn't appear to be a resolution in there.

How are you deploying OpenJPA? Is it in the system classpath? If not, can you try putting it in the system classpath and restarting Websphere, and see if it still happens?","22/Dec/06 21:07;igorfie@yahoo.com;Also, how do you configure database connection? Do you use WAS datasource or tell OpenJPA driver/connection details? In the latter case, are you using type2 or type4 driver (hint: switching to type4 might help).","28/Dec/06 14:50;kwsutter;Not sure if this is the same problem or not, but we're hitting a similar problem when attempting to re-load an application that has been modified.  Our problem exists with the WebSphere Feature Pack v6.1 Alpha for EJB3/JPA (https://www14.software.ibm.com/iwm/web/cc/earlyprograms/websphere/was61ejb3/).  What we are finding is that the unloading of an application doesn't completely clean out the directory structure where the jar files exist (due to locks not properly cleaned up).  Then, when the application is re-installed, these jar files get overlayed, but it causes some ""corruption"" that produces errors similar to the one posted.  Sometimes we get a jar file corruption exception, sometimes we get a class loading error, and other similar exceptions have been produced.

We will continue to pursue this problem, but resources are light at this time due to the holidays.  A possible workaround is to re-start the application server.  This seems to release the locks and allows the re-installation of the application possible.  Something to try anyway...

Kevin","02/Jan/07 13:16;g9adm;I am using the type 4 driver, so there should not be any problems with native code. I tried to add the libraries as a shared library in WAS6.1 but had the same issue.

Now I added the OpenJPA libraries to the <was61>\lib\ext library, and restarted the server. This seems to be working!","10/Apr/07 16:44;dzhang2007;Hi, Patrick, what kind of DB2 driver info we should put into the config? DB2 connection pool driver class name?","10/Apr/07 23:23;pcl;> Hi, Patrick, what kind of DB2 driver info we should put into the config? 
> DB2 connection pool driver class name?

It depends on how you want the configuration to be structured. If you already have a data source defined within the application server, then you should provide its JNDI name. Otherwise, you can either provide direct connection URL / driver name / user credential information to OpenJPA, or provide a pooling data source configuration.","18/Sep/08 18:31;mikedd;Looks like this issue has been resolved.

The javax.persistence.Persistence class maintains a static cache of PersistenceProviderImpls, this static cache remains in memory for the life of the Application Server.

The problem occurs when OpenJPA is included in an Enterprise Application, the application runs (using classloader 1) and is restarted (classloader 1 is destroyed and a new classloader is created). The Persistence class may hold a reference to the OpenJPA classes which were loaded with classloader 1, when they are used with classloader 2 errors similar to the one reported by this issue occur.

As noted earlier one way to resolve the problem is to move the OpenJPA classes outside of the application - either to lib/ext, or to  shared library. This prevents the OpenJPA classes from being loaded by the application classloader (instead it's loaded by the ext classloader which is not destroyed). 

Whether this is the exact scenario that was reported by this issue is hard to say due to the age of the issue. Please re-open the issue if it can be reproduced with a more recent version of OpenJPA. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""ON DELETE SET NULL"" is getting overridden if the foreign column is ""NOT NULL""",OPENJPA-90,12358746,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,markus.herzog,markus.herzog,15/Dec/06 11:06,09/Mar/10 18:35,14/Mar/19 03:02,15/Dec/06 18:03,,,,,,,,,,,,,,,sql,,,,,,0,,"""ON DELETE SET NULL"" is getting overridden if the foreign column is ""NOT NULL"".
This behaviour was introduced in Revision 449532 of the DBDictionary (getForeignKeyConstraintSQL). I think this is implemented wrongly - you're checking the wrong side of the relation.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-12-15 18:03:40.0,,,no_permission,,,,,,,,,,,160427,,,Fri Dec 15 18:03:40 UTC 2006,,,,,,,0|i0z7lb:,203532,,,,,,,,"15/Dec/06 18:03;awhite;Right you are.  Changed to check local columns, not foreign ones.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""uuid-hex"" generator does not make affect in orm.xml",OPENJPA-86,12356226,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,macdoor,macdoor,21/Nov/06 01:42,09/Mar/10 18:32,14/Mar/19 03:02,07/Aug/07 23:13,0.9.6,,,,,,,,,1.0.0,,,,,,,,,,,0,,"I wish to generate uuid automatically. I modified Message.java in hellojpa example. 

@Entity
public class Message {
    @GeneratedValue(generator=""uuid-hex"")
    private String uuid;

    @Basic
    private String message;

    @Basic
    private Date created = new Date();

    public Message() {
    }

    public Message(String msg) {
        message = msg;
    }
   ...

and modified Main.java

...
        for (Message m : (List<Message>)q.getResultList()) {
            System.out.println(m.getMessage()
                + "" (created on: "" + m.getCreated() + "")"" + "" uuid: "" + m.getUuid()); 
        }
...

I got the output like this, I got the uuid like ""7A92CA0039483DD69B808001A9FE0202""

2493  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 29469766, conn 1398720> executing prepstmnt 30325919 SELECT SEQUENCE_VALUE FROM OPENJPA_SEQUENCE_TABLE WHERE ID = ? FOR UPDATE WITH RR [params=(int) 0]
2513  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 29469766, conn 1398720> [20 ms] spent
2593  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 29469766, conn 1398720> executing prepstmnt 16954038 UPDATE OPENJPA_SEQUENCE_TABLE SET SEQUENCE_VALUE = ? WHERE ID = ? AND SEQUENCE_VALUE = ? [params=(long) 101, (int) 0, (long) 51]
2613  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 29469766, conn 1398720> [20 ms] spent
2764  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 29469766, conn 31544052> executing prepstmnt 17243268 INSERT INTO Message (id, created, message, uuid) VALUES (?, ?, ?, ?) [params=(long) 51, (Timestamp) 2006-11-21 09:36:23.728, (String) Hello Persistence!, (String) 8808876039483DD6BA4C6A80A9FE0202]
2784  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 29469766, conn 31544052> [20 ms] spent
3194  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 29469766, conn 33041076> executing prepstmnt 6576294 SELECT t0.id, t0.created, t0.message, t0.uuid FROM Message t0
3194  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 29469766, conn 33041076> [0 ms] spent
Hello Persistence! (created on: Tue Nov 21 09:36:01 CST 2006) uuid: 7A92CA0039483DD69B808001A9FE0202
Hello Persistence! (created on: Tue Nov 21 09:36:23 CST 2006) uuid: 8808876039483DD6BA4C6A80A9FE0202
<END>

When I changed to orm.xml to define the entity mapping, I add orm.xml in META-INF folder
<entity-mappings xmlns=""http://java.sun.com/xml/ns/persistence/orm"" 
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" 
    xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence/orm orm_1_0.xsd""
    version=""1.0"">
<package>hellojpa</package>
<entity class=""hellojpa.Message"" metadata-complete=""false"" access=""PROPERTY"">
      <attributes>
          <id name=""uuid"">
             <generated-value generator=""uuid-hex""/>
          </id>
          <basic name=""message"" optional=""false"">
          </basic>
          <basic name=""created"" optional=""false"">
          </basic>
      </attributes>
</entity>
</entity-mappings>

and modified Message.java 
...
//@Entity
public class Message {
//    @GeneratedValue(generator=""uuid-hex"")
    private String uuid;

//    @Basic
    private String message;

//    @Basic
    private Date created = new Date();

    public Message() {
    }
....

I got the output like this, A sequence number (1, 51, 101, 151, 201) replaced uuid-hex in output, 
....
2864  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 26373776, conn 10014334> executing prepstmnt 23585701 SELECT SEQUENCE_VALUE FROM OPENJPA_SEQUENCE_TABLE WHERE ID = ? FOR UPDATE WITH RR [params=(int) 0]
2864  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 26373776, conn 10014334> [0 ms] spent
2944  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 26373776, conn 10014334> executing prepstmnt 5676128 UPDATE OPENJPA_SEQUENCE_TABLE SET SEQUENCE_VALUE = ? WHERE ID = ? AND SEQUENCE_VALUE = ? [params=(long) 251, (int) 0, (long) 201]
2984  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 26373776, conn 10014334> [40 ms] spent
3044  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 26373776, conn 4102111> executing prepstmnt 5057266 INSERT INTO Message (uuid, created, message) VALUES (?, ?, ?) [params=(String) 201, (Timestamp) 2006-11-21 09:22:33.774, (String) Hello Persistence!]
3074  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 26373776, conn 4102111> [30 ms] spent
3495  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 26373776, conn 27790058> executing prepstmnt 33108879 SELECT t0.uuid, t0.created, t0.message FROM Message t0
3495  hellojpa  TRACE  [main] openjpa.jdbc.SQL - <t 26373776, conn 27790058> [0 ms] spent
Hello Persistence! (created on: Mon Nov 20 19:10:57 CST 2006) uuid: 1
Hello Persistence! (created on: Mon Nov 20 19:11:14 CST 2006) uuid: 51
Hello Persistence! (created on: Mon Nov 20 19:22:01 CST 2006) uuid: 101
Hello Persistence! (created on: Tue Nov 21 09:21:54 CST 2006) uuid: 151
Hello Persistence! (created on: Tue Nov 21 09:22:33 CST 2006) uuid: 201

<END>

","JDK 1.5.0_09, eclipse 3.2.1, openjpa-0.9.6-incubating, openjpa-0.9.7-incubating-SNAPSHOT(Nov 20, 2006)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-08-07 23:13:06.089,,,no_permission,,,,,,,,,,,160423,,,Tue Aug 07 23:13:06 UTC 2007,,,,,,,0|i0z4kn:,203043,,,,,,,,07/Aug/07 23:13;pcl;Fixed for uuid-string; I anticipate that the fix will work for both uuid-hex and uuid-string. I unified our handling of generation types between our XML and annotation parsers.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bad SQL for Subselect BETWEEN,OPENJPA-83,12355776,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,brj,brj,15/Nov/06 19:50,09/Mar/10 18:32,14/Mar/19 03:02,02/May/07 21:54,,,,,,,,,,1.0.0,,,,,query,,,,,,0,,"the following query generates an sql with no table in the FROM-clause of the subselct:

em.createQuery(""select k from Kauf k where "" +
""((select sum(p.betrag) from Posten p where p.kauf = k) between :betrVon and :betrBis) "" +
""order by k.datum asc"");

SELECT t1.id, t1.bemerkung, t1.datum, t2.id, t2.idEinkauferAlt, t2.name
FROM ekv2kauf t1 LEFT OUTER JOIN ekv2einkaufer t2 ON t1.idEinkaufer = t2.id
WHERE ((SELECT SUM(t0.betrag) FROM WHERE (t0.idKauf = t1.id)) >= ? AND (SELECT SUM(t0.betrag) FROM WHERE (t0.idKauf = t1.id)) <= ?) ORDER BY t1.datum ASC
[params=(double) 1800.0, (double) 3000.0]

when i use the query without BETWEEN it works:

em.createQuery(""select k from Kauf k where "" +
""((select sum(p.betrag) from Posten p where p.kauf = k) > :betr) "" +
""order by k.datum asc"");

SELECT t1.id, t1.bemerkung, t1.datum, t2.id, t2.idEinkauferAlt, t2.name
FROM ekv2kauf t1 LEFT OUTER JOIN ekv2einkaufer t2 ON t1.idEinkaufer = t2.id
WHERE ((SELECT SUM(t0.betrag) FROM ekv2posten t0 WHERE (t0.idKauf = t1.id)) > ?)
ORDER BY t1.datum ASC
[params=(double) 1800.0]

when i rewrite the query using groupby / having it also works, but the generated sql does not use BETWEEN:

em.createQuery(""select p.kauf from Posten p "" +
        ""group by p.kauf "" +
                ""having sum(p.betrag) between :betrVon and :betrBis "" +
                ""order by p.kauf.datum asc"");

SELECT t1.id, t1.bemerkung, t1.datum, t1.idEinkaufer
FROM ekv2posten t0 INNER JOIN ekv2kauf t1 ON t0.idKauf = t1.id
GROUP BY t1.id, t1.bemerkung, t1.datum, t1.idEinkaufer
HAVING SUM(t0.betrag) >= ? AND SUM(t0.betrag) <= ?
ORDER BY t1.datum ASC
[params=(double) 1800.0, (double) 3000.0]","openJPA 0.9.7
MySQL 5.0.15",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-05-02 21:54:45.058,,,no_permission,,,,,,,,,,,160420,,,Wed May 02 21:54:45 UTC 2007,,,,,,,0|i0zb6f:,204113,,,,,,,,02/May/07 21:54;wisneskid;fixed by r534623,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bad Escaping for LIKE in MySQL,OPENJPA-80,12355510,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,brj,brj,13/Nov/06 20:01,09/Mar/10 18:32,14/Mar/19 03:02,06/Mar/07 09:34,,,,,,,,,,0.9.7,,,,,query,,,,,,0,,"the following query :

em.createQuery(""select k from KategorieGruppe k  where k.bezeichnung like ?1 order by k.bezeichnung asc"");

generates an sql-statement with a bad escaping character '\' for MySQL :

SELECT t0.id, t0.bezeichnung FROM ekv2kategoriegruppe t0 WHERE (t0.bezeichnung LIKE ? ESCAPE '\') ORDER BY t0.bezeichnung ASC

the correct escaping would be '\\'.","openJPA 0.9.7 
MySQL 5.0.15",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-11-13 20:22:35.0,,,no_permission,,,,,,,,,,,160417,,,Mon Nov 13 20:22:35 UTC 2006,,,,,,,0|i0zb4f:,204104,,,,,,,,"13/Nov/06 20:16;brj;the variable  searchStringEscape must be correctly set in org.apache.openjpa.jdbc.sql.MySQLDictionary:

...
 searchStringEscape = ""\\\\"";
...","13/Nov/06 20:22;mprudhom;Note that you should be able to work around the issue for the time being by setting the property ""openjpa.jdbc.DBDictionary"" to ""searchStringEscape=\\"" in your persistence.xml file or in the properties you use to create the EntityManagerFactory.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Problems in default setting in DB2Dictionary , also missing support for DB2 z/OS platforms",OPENJPA-77,12355182,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,fancy,fancy,09/Nov/06 17:55,31/Jul/07 18:58,14/Mar/19 03:02,29/Dec/06 15:23,,,,,,,,,,0.9.7,,,,,jdbc,,,,,,0,,"There are following problems:
1. the default storeCharsAsNumbers = true, does not work well in DB2. Preferable default setting should be false.
2. nextSequenceSQL() generates DB2 UDB specific SQLs which fails on DB2 z/OS platforms.
3. lastGeneratedKeyQuery SQL string is applicable for DB2 UDB only, needs to provide DB2 z/OS specific SQL.
4. bigintTypeName =""BIGINT"" does not work for DB2 z/OS Version 8. 
5. characterColumnSize = 255 for default CHAR or VARCHAR fails on DB2 UDB platforms. DB2 UDB CHARACTER  size limit is 254",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-11-09 19:42:09.0,,,no_permission,,,,,,,,,,,160414,,,Fri Dec 29 15:23:15 UTC 2006,,,,,,,0|i0z16v:,202495,,,,,,,,29/Dec/06 15:15;kwsutter;Catalina has provided a new private patch for this Issue which does not introduce the multiple database dictionaries for the various DB2 z/OS versions.  It's much cleaner.  I'm in the process of verifying it and will be committing the changes soon.  Thanks. ,29/Dec/06 15:23;kwsutter;Catalina provided a patch to me to check out.  The changes looked good and the regression bucket ran just fine.  The z/OS specific testing was done by another team. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"add-was-interfaces ant task throws exception on a ""non-clean"" build.",OPENJPA-76,12354902,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,mikedd,mikedd,07/Nov/06 04:35,17/Apr/07 18:38,14/Mar/19 03:02,07/Nov/06 08:02,,,,,,,,,,,,,,,kernel,,,,,,0,,"Patrick Linskey found the problem and posted to the dev mailing list. Here's the original post :

Hi,

I get the following stack trace when running 'mvn package'. It looks
like I don't have some required IBM classes in my classpath.
Surprisingly, this exception does not cause the build to fail, but
presumably, the output bytes are not the same as if this had run
successfully.

Does anyone have any suggestions for either getting the classes into the
classpath or moving the exception to runtime, so that there aren't
build-time dependency issues resulting in different jars from the same
sources?

Thanks,

-Patrick


Partial stack trace:

[INFO] [antrun:run {execution: add-was-interfaces}]
[INFO] Executing tasks
    [java] java.lang.IllegalArgumentException:
java.lang.NoClassDefFoundError:
com/ibm/websphere/jtaextensions/SynchronizationCallback
    [java]     at
org.apache.tools.ant.taskdefs.ExecuteJava.execute(ExecuteJava.java:180)
    [java]     at org.apache.tools.ant.taskdefs.Java.run(Java.java:710)
    [java]     at
org.apache.tools.ant.taskdefs.Java.executeJava(Java.java:178)

    [java]     at
org.apache.tools.ant.taskdefs.Java.execute(Java.java:84)
    [java]     at
org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
    [java]     at org.apache.tools.ant.Task.perform(Task.java:364)
    [java]     at org.apache.tools.ant.Target.execute(Target.java:341)
    [java]     at
org.apache.maven.plugin.antrun.AbstractAntMojo.executeTasks(AbstractAntM
ojo.java:108)
    [java]     at
org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:83)
    [java]     at
org.apache.maven.plugin.DefaultPluginManager.executeMojo(DefaultPluginMa
nager.java:412)
    [java]     at
org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoals(Default
LifecycleExecutor.java:534)
    .....

    [java] Caused by: java.lang.IllegalArgumentException:
java.lang.NoClassDefFoundError:
com/ibm/websphere/jtaextensions/SynchronizationCallback
    [java]     at serp.util.Strings.toClass(Strings.java:211)
    [java]     at serp.util.Strings.toClass(Strings.java:140)
    [java]     at serp.bytecode.BCClass.getType(BCClass.java:565)
    [java]     at serp.bytecode.BCClass.write(BCClass.java:202)
    [java]     at
org.apache.openjpa.ee.WASManagedRuntime.main(WASManagedRuntime.java:412)
    [java]     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native
Method)


Upon further examination the problem occurs if the WASSynchronization class is modified a second time (ie you don't run mvn clean before running mvn package). 

",,,,,,,,,,,,,,,,,,,,,,07/Nov/06 04:52;mikedd;openjpa-76-patch.txt;https://issues.apache.org/jira/secure/attachment/12344444/openjpa-76-patch.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2006-11-07 07:35:53.0,,,no_permission,,,,,,,,,,,160413,,,Tue Nov 07 08:02:24 UTC 2006,,,,,,,0|i0z6gf:,203348,,,,,,,,"07/Nov/06 04:52;mikedd;Attaching a patch file which avoids the problem (at least for the time being). 

The problem occurs when the new BCClass is written out to the file system. The patch will check whether the interface is already included in the class. If the ""new"" interface is already there the program will terminate. 

The larger question remains: should Serp be used in this manner, or should a stub class be created and used at compile time. Currently a stub class for misc.sun.Perf is being created in the openjpa-lib project, but is removed before the jar files are created and is not distributed with OpenJPA.

","07/Nov/06 07:35;pcl;I'm perfectly happy with the use of serp here. Historically, we (the Kodo team) have created stub jars etc. with abandon, since the source was not available and thus we were not at risk of distributing bits that violated copyrights. Obviously, this is more of a concern with an open-source project, so we probably will need to be more careful about things like this in the future.

Currently, this seems to be the only big issue. It used to be that we needed to link against various Oracle-specific classes, but between judicious reflection and Oracle's increased standards compliance over the years, we've been able to avoid that for now. But I'm sure that similar situations will crop up in the future.",07/Nov/06 08:02;pcl;I applied the patch with revision 472018. I changed it slightly to make it use resources instead of files.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
error message for missing query id var needs improvement,OPENJPA-75,12354865,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,wisneskid,wisneskid,06/Nov/06 19:18,22/Apr/10 20:32,14/Mar/19 03:02,01/Aug/08 20:05,,,,,,,,,,1.3.0,,,,,query,,,,,,0,,"the query is 
select sum(loginCount), sum(logoutCount) from AccountEntity as a where a.accountProfile.userID like 'uid:%' 
loginCount and logoutCount are declared in a MappedSuperClass.
the correct query is 
select sum(a.loginCount), sum(a.logoutCount) from AccountEntity as a where a.accountProfile.userID like 'uid:%' 

Rather than a syntax error, a ArgumentException was thrown.  (see below)

Also the user would like to see a better error message in the case of a field name using wrong upper/lower case.
In other words, if the query was 
    where  a.userid = ...
and what he intended was 
   where a.userId = ...
then the message should say  "" userid undefined.  DId you mean userId? ""

Also if a state field is inherited but declared private and hence not visible, then error message should read 
  ""a.userId invalid because it is not visible"" rather than ""a.userId not defined"".

  <4|false|0.9.0-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: null
[11/3/06 12:47:04:734 CST] 0000003c SystemOut     O <4|false|0.9.0-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: null
[11/3/06 12:47:04:734 CST] 0000003c SystemOut     O 	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:755)
[11/3/06 12:47:04:734 CST] 0000003c SystemOut     O 	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:716)
[11/3/06 12:47:04:734 CST] 0000003c SystemOut     O 	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:712)

[11/3/06 12:47:04:734 CST] 0000003c SystemOut     O 	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:512)
[11/3/06 12:47:04:734 CST] 0000003c SystemOut     O 	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:216)
[11/3/06 12:47:04:734 CST] 0000003c SystemOut     O 	at org.apache.openjpa.persistence.QueryImpl.getSingleResult(QueryImpl.java:271)
[11/3/06 12:47:04:734 CST] 0000003c SystemOut     O 	at org.apache.geronimo.samples.daytrader.ejb3.TradeJPA.resetTrade(TradeJPA.java:1864)

while running a JPA query.  The code for it looks like the following:
	q = em.createQuery(""select sum(loginCount), sum(logoutCount) from AccountEntity as a where a.accountProfile.userID like 'uid:%'"");
	Object[] rs = (Object[]) q.getSingleResult();",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-11-06 19:33:39.0,,,no_permission,,,,,,,,,,,160412,,,Fri Aug 01 20:05:52 UTC 2008,,,,,,,0|i1dozb:,288144,,,,,,,,"06/Nov/06 19:33;mprudhom;That sounds like a very good idea. We already do something along those lines for unrecognized configuration property names (see ConfigurationImpl.warnInvalidProperty and StringDistance.getClosestLevenshteinDistance), so that sort of thing could be used also for unrecognized variable/field names in queries.",01/Aug/08 20:05;ppoddar@apache.org;Committed revision 681807.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Trying to create a named query that is defined in an orm.xml file causes a NullPointerException,OPENJPA-74,12354515,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mprudhom,mprudhom,mprudhom,02/Nov/06 02:48,09/Mar/10 18:35,14/Mar/19 03:02,03/Nov/06 21:10,,,,,,,,,,,,,,,query,,,,,,0,,"When declaring a <named-query> element in the orm.xml and trying to create that query with ""EntityManager.createNamedQuery"", a NullPointerException is always thrown:

Caused by: java.lang.NullPointerException
       at java.io.StringReader.<init>(StringReader.java:33)
       at org.apache.openjpa.kernel.jpql.JPQL.<init>(JPQL.java:17)
       at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.parse(JPQLExpressionBuilder.java:1638)
       at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.<init>(JPQLExpressionBuilder.java:1628)
       at org.apache.openjpa.kernel.jpql.JPQLParser.parse(JPQLParser.java:44)
       at org.apache.openjpa.kernel.ExpressionStoreQuery.newCompilation(ExpressionStoreQuery.java:141)
       at org.apache.openjpa.kernel.QueryImpl.newCompilation(QueryImpl.java:594)

This is because XMLPersistenceMetaDataParser.startNamedQuery() is checking for the ""query"" attribute of the ""named-query"" element for the query string, as was defined in a pre-release version of the JPA spec. Subsequent versions changed this to be a ""query"" sub-element rather than an attribute, and we never updated our parser (and the TCK never tests for it).

Note that this only affects named queries as defined in orm.xml files. Named queries defined via @NamedQuery annotations don't suffer from this problem.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160411,,,Fri Nov 03 21:10:49 UTC 2006,,,,,,,0|i1dozj:,288145,,,,,,,,"03/Nov/06 21:10;mprudhom;Fixed multiple problems with named queries: 

1. They were not being parsed as part of the or m.xml file, since we were incorrectly looking for an attribute named 'query' (when it really should have been a sub-element named 'query'). 

2. Looking for a named query did not force resolution of all metadatas.

3. An NPE was being thrown when a JPQL query was created with a null filter",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PersistenceProviderImpl.createContainerEntityManagerFactory() doesn't work if you supply jdbc specific properties,OPENJPA-73,12354404,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,djencks,djencks,31/Oct/06 22:19,09/Mar/10 18:35,14/Mar/19 03:02,06/Nov/06 18:26,,,,,,,,,,,,,,,,,,,,,0,,"PersistenceProviderImpl.createContainerEntityManagerFactory() doesn't work if you supply jdbc specific properties such as 

                        <property name=""openjpa.Sequence"" value=""table(Table=OPENJPASEQ, Increment=100)""/>

(or rather its string equivalent in the map argument)

The problem is that the ClassTransformerImpl creates a OpenJPAConfigurationImpl which doesn't know anything about jdbc configuration properties such as the sequence, but it gets fed all the properties you supply.

Changing the code in PersistenceProviderImpl to create a JDBCConfigurationImpl makes everything work:  heres a patch to do this:

Index: openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java
===================================================================
--- openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java       (revision 469568)
+++ openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java       (working copy)
@@ -89,17 +89,17 @@
             // add enhancer
             String ctOpts = (String) Configurations.getProperty
                 (CLASS_TRANSFORMER_OPTIONS, pui.getProperties());
-            pui.addTransformer(new ClassTransformerImpl(cp, ctOpts, 
+            pui.addTransformer(new ClassTransformerImpl(cp, ctOpts,
                 pui.getNewTempClassLoader()));
 
-            BrokerFactory factory = Bootstrap.newBrokerFactory(cp, 
+            BrokerFactory factory = Bootstrap.newBrokerFactory(cp,
                 pui.getClassLoader());
             return OpenJPAPersistence.toEntityManagerFactory(factory);
         } catch (Exception e) {
             throw PersistenceExceptions.toPersistenceException(e);
         }
     }
-    
+
     /**
      * Java EE 5 class transformer.
      */
@@ -108,10 +108,24 @@
 
         private final ClassFileTransformer _trans;
 
-        private ClassTransformerImpl(ConfigurationProvider cp, String props, 
+        private ClassTransformerImpl(ConfigurationProvider cp, String props,
             final ClassLoader tmpLoader) {
             // create an independent conf for enhancement
-            OpenJPAConfiguration conf = new OpenJPAConfigurationImpl();
+            OpenJPAConfiguration conf = null;
+            try {
+                ClassLoader tccl = Thread.currentThread().getContextClassLoader();
+                Class clazz = Class.forName(""org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl"", true, tccl);
+                conf = (OpenJPAConfiguration)clazz.newInstance();
+            } catch (ClassNotFoundException e) {
+                e.printStackTrace();
+            } catch (IllegalAccessException e) {
+                e.printStackTrace();
+            } catch (InstantiationException e) {
+                e.printStackTrace();
+            }
+            if (conf == null) {
+                conf = new OpenJPAConfigurationImpl();
+            }
             cp.setInto(conf);
             // don't allow connections
             conf.setConnectionUserName(null);


It seems to me that using a JDBCConfiguration here is not needed: what is needed is to ignore properties that the OpenJPAConfigurationImpl doesn't understand, rather than throwing an exception.  We're only setting up the class transformer here, not the runtime configuration.

I don't understand enough to suggest where to fix this, but given some hints I could make a try.


The relevant parts of the stacktrace showing the original error is:

Caused by: java.lang.IllegalArgumentException: java.lang.ClassNotFoundException: table in classloader org.apache.geronimo.configs/openjpa/1.2-SNAPSHOT/car
        at serp.util.Strings.toClass(Strings.java:211)
        at serp.util.Strings.toClass(Strings.java:140)
        at org.apache.openjpa.lib.conf.Configurations.newInstance(Configurations.java:135)
        ... 62 more

        at org.apache.openjpa.lib.conf.ConfigurationImpl.instantiateAll(ConfigurationImpl.java:278)
        at org.apache.openjpa.conf.OpenJPAConfigurationImpl.instantiateAll(OpenJPAConfigurationImpl.java:1400)
        at org.apache.openjpa.persistence.PersistenceProviderImpl$ClassTransformerImpl.<init>(PersistenceProviderImpl.java:130)
        at org.apache.openjpa.persistence.PersistenceProviderImpl$ClassTransformerImpl.<init>(PersistenceProviderImpl.java:106)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:92)
        at org.apache.geronimo.persistence.PersistenceUnitGBean.<init>(PersistenceUnitGBean.java:91)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-11-01 16:07:04.0,,,no_permission,,,,,,,,,,,160410,,,Mon Nov 06 18:26:15 UTC 2006,,,,,,,0|i0z7lr:,203534,,,,,,,,"01/Nov/06 01:34;djencks;Abe White suggested on the dev list that the transformer configuration will never need to load optional plugins so eliminating line 130

            conf.instantiateAll();

should not break anything and should fix the problems.  I've verified that removing line 130 fixes the problems I was seeing, and my sample app now works fine.  I pre-enhanced my classes so my experience may not indicate much about lack of other side effects :-)","01/Nov/06 16:07;awhite;David -- if you can verify that things also work if you don't pre-enhance, we'll commit the change.","05/Nov/06 08:32;djencks;After a lot of work to get runtime enhancement sometimes working in geronimo, I've found a simple enough example to not run into other problems and verify that removing line 130 solves the problem both with and without runtime enhancement.  So, I'd appreciate this change being made in trunk.",06/Nov/06 18:26;awhite;Fixed by not instantiating all plugins up front in class transformer.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Caching primitive array types consumes excessive memory,OPENJPA-71,12354330,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,rogerkeays,rogerkeays,31/Oct/06 01:06,09/Mar/10 18:32,14/Mar/19 03:02,08/Mar/07 09:34,0.9.0,0.9.6,,,,,,,,0.9.7,,,,,datacache,,,,,,0,,"As reported on the mailing list: http://www.nabble.com/cached-byte---consumes-excessive-memory-tf2543098.html , in org.apache.openjpa.AbstractPCData#toData() an ArrayList is used to cache all types of arrays, including arrays of primitives. This can use excessively large amounts of memory because of the wrappers required for each element in the array. In one test case, a 7MB byte[] consumed 127MB when converted to a cached ArrayList.

AbstractPCData needs to be fixed to handle simple arrays.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-03-01 01:22:45.5,,,no_permission,,,,,,,,,,,160408,,,Thu Mar 08 09:34:51 UTC 2007,,,,,,,0|i0z4l3:,203045,,,,,,,,01/Mar/07 01:22;pcl;What happens if openjpa.DynamicDataStructs is enabled?,"08/Mar/07 09:34;pcl;Resolved. I changed AbstractPCData to not marshal / unmarshal arrays via Lists, but I did not do any memory footprint measurement.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Data caching + external modifications could result in stale data getting stuck in cache,OPENJPA-70,12354323,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,pcl,pcl,pcl,30/Oct/06 23:21,09/Mar/10 18:35,14/Mar/19 03:02,30/Oct/06 23:37,,,,,,,,,,,,,,,datacache,,,,,,0,,"When using the data cache, stale data could get stuck in the cache if changes were made outside of the context of OpenJPA. In this situation, repeated attempts to update a given record could result in optimistic lock exceptions ad infinitum.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160407,,,Mon Oct 30 23:37:08 UTC 2006,,,,,,,0|i1dozz:,288147,,,,,,,,30/Oct/06 23:37;pcl;Resolved with 469313.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PCClassFileTransformer.isEnhanced() fails because PersistenceCapable package name is wrong,OPENJPA-68,12354098,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,,cklaasmeyer,cklaasmeyer,27/Oct/06 06:10,09/Mar/10 18:35,14/Mar/19 03:02,27/Oct/06 17:03,,,,,,,,,,,,,,,jpa,,,,,,0,,"On line 201, the fully qualified interface name should be ""org/openjpa/enhance/PersistenceCapable"" not ""openjpa/enhance/PersistenceCapable"":

    /**
     * Analyze the bytecode to see if the given class definition implements
     * {@link PersistenceCapable}.
     */
    private static boolean isEnhanced(byte[] b) {
        ConstantPoolTable table = new ConstantPoolTable(b);
        int idx = table.getEndIndex();

        idx += 6; // skip access, cls, super
        int ifaces = table.readUnsignedShort(idx);
        int clsEntry, utfEntry;
        String name;
        for (int i = 0; i < ifaces; i++) {
            idx += 2;
            clsEntry = table.readUnsignedShort(idx);
            utfEntry = table.readUnsignedShort(table.get(clsEntry));
            name = table.readString(table.get(utfEntry));
            if (""openjpa/enhance/PersistenceCapable"".equals(name))
                return true;
        }
        return false;
    }","Win32, JDK1.5, OpenJPA 0.9.0-incubating",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-10-27 17:03:29.0,,,no_permission,,,,,,,,,,,160405,,,Fri Oct 27 17:03:29 UTC 2006,,,,,,,0|i0ywdr:,201716,,,,,,,,"27/Oct/06 17:03;awhite;Thanks, fixed.  (FTR, the correct name is org/apache/openjpa/enhance/PersistenceCapable)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bug with creating a named Sequence Generator for DB2,OPENJPA-67,12353882,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,24/Oct/06 18:38,31/Jul/07 18:56,14/Mar/19 03:02,27/Oct/06 16:18,,,,,,,,,,,,,,,jdbc,,,,,,0,,"We discovered that the usage of a named Sequence Generator with DB2 doesn't work as expected:

@Entity
@Table(name=""ORDEREJB"")
public class OrderEntity implements Serializable {
        @Id
        @SequenceGenerator(name=""OrderSeq"", sequenceName=""O_SEQ"")
        @GeneratedValue(strategy=GenerationType.SEQUENCE, generator=""OrderSeq"")
        private int orderid;
...

This results in the following error:

2188  TRACE  [main] openjpa.jdbc.SQL - <t 11372121, conn 27778511> [985 ms] executing prepstmnt 3860801 SELECT NEXTVAL FOR O_SEQ
2188  TRACE  [main] openjpa.jdbc.JDBC - <t 11372121, conn 27778511> [0 ms] commit
2203  TRACE  [main] openjpa.jdbc.JDBC - <t 11372121, conn 27778511> [15 ms] close
<0|false|0.9.0-incubating-SNAPSHOT> org.apache.openjpa.persistence.PersistenceException: An unexpected token ""END-OF-STATEMENT"" was found following ""CT NEXTVAL FOR O_SEQ"".  Expected tokens may include:  ""<table_expr>"". {prepstmnt 3860801 SELECT NEXTVAL FOR O_SEQ} [code=-104, state=42601]
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3713)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:94)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:80)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:56)

We have discovered that the incorrect SQL statement is specified in the DB2Dictionary.  Instead of this:

        nextSequenceQuery = ""SELECT NEXT VALUE FOR{0}"";

We need this:

        nextSequenceQuery = ""VALUES NEXTVAL FOR {0}"";

I just wanted to document this issue instead of just fixing it so that the problem can be searchable (we've had a few people run into this when using OpenJPA with DB2).

Thanks,
Kevin",DB2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160404,,,Fri Oct 27 16:18:12 UTC 2006,,,,,,,0|i0z4lr:,203048,,,,,,,,27/Oct/06 16:18;kwsutter;Updated the DB2 Dictionary with the proper DB2 statements.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Ejbql join queries show invalid null Entities when run in a new persistence context where no entity instances exist.,OPENJPA-62,12352341,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ghongell,ghongell,04/Oct/06 01:33,01/Mar/07 02:20,14/Mar/19 03:02,01/Mar/07 02:20,,,,,,,,,,0.9.7,,,,,query,,,,,,0,,"Each of the following queries, when run by itself in a new persistence context where EmpBean and  DeptBean are not populated, 
is showing null values for DeptBean and EmpBean respectively which should be impossible for an inner join.
Outer join queries have similar results.
The DataBase is populated.
Whether or not the query is run in a transaction context does not matter.

select d,e from DeptBean d join d.emps e where e.bonus<100.02 or e.name='name2' 
select d,e from EmpBean e join e.dept d where e.bonus<100.02 or e.name='name6' 

 TEST1; select d,e from DeptBean d join d.emps e where e.bonus<100.02 or e.name='name2' 
DeptBean EmpBean 
~~~~~~~~ ~~~~~~~ 
  null     [1]   
  null     [3]   
  null     [5]   
  null     [6]   
 [100]     [8]   
 [200]     [4]   
 [210]     [2]   
 [210]     [7]   
 [210]     [9]   
 TEST1; 9 tuples


 TEST1; select d,e from EmpBean e join e.dept d where e.bonus<100.02 or e.name='name6' 
DeptBean EmpBean 
~~~~~~~~ ~~~~~~~ 
 [100]     [8]   
 [100]    null   
 [200]     [3]   
 [200]    null   
 [210]    null   
 [210]    null   
 [210]    null   
 [210]    null   
 [220]    null   
 TEST1; 9 tuples

Furthermore, if either of these queries is run twice in a new persistence context, 
the second query gets a Cannot load object with id ""1"" error.  

   ACTUAL(
 TEST2; select d,e from EmpBean e join e.dept d where e.bonus<100.02 or e.name='name6' 
                                                                                                                                               d                                                                                                                                                
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
Cannot load object with id ""1"".  Instance ""com.ibm.ws.query.entities.objectgrid.annotated.DeptBean-1"" with the same id already exists in the L1 cache.  This can occur when you assign an existing id to a new instance, and before flushing attempt to load the existing instance for that id. 
 TEST2; 1 tuple

However, if
select d,e from DeptBean d join d.emps e where e.bonus<100.02 or e.name='name2' 
is proceeded by 
select d from DeptBean d
it gets the correct result.
and if select d,e from EmpBean e join e.dept d where e.bonus<100.02 or e.name='name6' 
is proceeded by 
select e from EmpBean e 
it gets the correct result.
should be
 TEST2; select d,e from EmpBean e join e.dept d where e.bonus<100.02 or e.name='name6' 
DeptBean EmpBean 
~~~~~~~~ ~~~~~~~ 
 [100]     [6]   
 [100]     [8]   
 [200]     [3]   
 [200]     [4]   
 [210]     [1]   
 [210]     [2]   
 [210]     [7]   
 [210]     [9]   
 [220]     [5]   
 TEST2; 9 tuples)

 TEST2; select d,e from DeptBean d join d.emps e where e.bonus<100.02 or e.name='name2' 
DeptBean EmpBean 
~~~~~~~~ ~~~~~~~ 
 [100]     [6]   
 [100]     [8]   
 [200]     [3]   
 [200]     [4]   
 [210]     [1]   
 [210]     [2]   
 [210]     [7]   
 [210]     [9]   
 [220]     [5]   
 TEST2; 9 tuples)

the database shows
select t0.empid, t0.dept_deptno, t0.name, t0.bonus, t0.home_street, t0.work_street FROM EmpBean t0
EMPID :DEPT_DEPTNO :NAME :BONUS :HOME_STREET :WORK_STREET :
1 :210 :david :0.0 :1780 Mercury Way :555 Silicon Valley Drive :
2 :210 :andrew :0.0 :1780 Mercury Way :555 Silicon Valley Drive :
3 :200 :minmei :0.0 :1780 Mercury Way :555 Silicon Valley Drive :
4 :200 :george :0.0 :512 Venus Drive :555 Silicon Valley Drive :
5 :220 :ritika :0.0 :12440 Vulcan Avenue :555 Silicon Valley Drive :
6 :100 :ahmad :0.0 :4983 Plutonium Avenue :4983 Plutonium Avenue :
7 :210 :charlene :0.0 :182 Martian Street :555 Silicon Valley Drive :
8 :100 :Tom Rayburn :0.0 :6200 Vegas Drive :555 Silicon Valley Drive :
9 :210 :harry :0.0 :150 North First Apt E1 :8900 Jupiter Park :
10 : SQL_NULL :Catalina Wei :0.0 : SQL_NULL :555 Silicon Valley Drive :

select * from deptbean
DEPTNO :BUDGET :NAME :MGR_EMPID :REPORTSTO_DEPTNO :
210 :2.1 :Development :3 :200 :
220 :2.1 :Service :4 :200 :
300 :2.1 :Sales :6 :100 :
200 :2.1 :Admin :8 :100 :
100 :2.1 :CEO :10 :100 :

simple ejb queries are always correct
 TEST1; select e from EmpBean e 
EmpBean 
~~~~~~~ 
  [1]   
  [2]   
  [3]   
  [4]   
  [5]   
  [6]   
  [7]   
  [8]   
  [9]   
 [10]   
 TEST1; 10 tuples)


 TEST1; select d from DeptBean d
DeptBean 
~~~~~~~~ 
 [100]   
 [200]   
 [210]   
 [220]   
 [300]   
 TEST1; 5 tuples)

the trace statements
for select d,e from DeptBean d join d.emps e where e.bonus<100.02 or e.name='name2' 
359  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 615523504 SELECT t0.deptno, t1.empid, t1.bonus, t1.dept_deptno, t1.execLevel, t1.hireDate, t1.hireTime, t1.hireTimestamp, t1.home_street, t1.isManager, t1.name, t1.salary, t1.work_street FROM DeptBean t0 INNER JOIN EmpBean t1 ON t0.deptno = t1.dept_deptno WHERE ((CAST(t1.bonus AS DOUBLE) < ? OR t1.name = ?)) [params=(BigDecimal) 100.02, (String) name2]
406  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 380245674 SELECT t0.bonus, t1.deptno, t1.budget, t1.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t2.street, t2.city, t2.state, t2.zip, t0.isManager, t0.name, t0.salary, t3.street, t3.city, t3.state, t3.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno LEFT OUTER JOIN AddressBean t2 ON t0.home_street = t2.street LEFT OUTER JOIN AddressBean t3 ON t0.work_street = t3.street WHERE t0.empid = ? [params=(int) 100]
469  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1021328608 SELECT t0.budget, t0.name FROM DeptBean t0 WHERE t0.deptno = ? [params=(int) 100]
484  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1420580012 SELECT t0.city, t0.state, t0.zip FROM AddressBean t0 WHERE t0.street = ? [params=(String) 4983 Plutonium Avenue]
562  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 799027104 SELECT t1.empid, t1.bonus, t1.execLevel, t1.hireDate, t1.hireTime, t1.hireTimestamp, t1.isManager, t1.name, t1.salary FROM DeptBean t0 INNER JOIN EmpBean t1 ON t0.mgr_empid = t1.empid WHERE t0.deptno = ? [params=(int) 100]
609  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 931018622 SELECT t1.deptno, t1.budget, t1.name FROM DeptBean t0 INNER JOIN DeptBean t1 ON t0.reportsTo_deptno = t1.deptno WHERE t0.deptno = ? [params=(int) 100]
625  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1703830926 SELECT t0.city, t0.state, t0.zip FROM AddressBean t0 WHERE t0.street = ? [params=(String) 6200 Vegas Drive]
625  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 494935424 SELECT t0.city, t0.state, t0.zip FROM AddressBean t0 WHERE t0.street = ? [params=(String) 555 Silicon Valley Drive]
625  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1753245824 SELECT t0.bonus, t1.deptno, t1.budget, t1.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t2.street, t2.city, t2.state, t2.zip, t0.isManager, t0.name, t0.salary, t3.street, t3.city, t3.state, t3.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno LEFT OUTER JOIN AddressBean t2 ON t0.home_street = t2.street LEFT OUTER JOIN AddressBean t3 ON t0.work_street = t3.street WHERE t0.empid = ? [params=(int) 200]
640  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1718773362 SELECT t0.budget, t0.name FROM DeptBean t0 WHERE t0.deptno = ? [params=(int) 200]
656  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 252841746 SELECT t0.city, t0.state, t0.zip FROM AddressBean t0 WHERE t0.street = ? [params=(String) 1780 Mercury Way]
656  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1000749990 SELECT t1.empid, t1.bonus, t1.execLevel, t1.hireDate, t1.hireTime, t1.hireTimestamp, t1.isManager, t1.name, t1.salary FROM DeptBean t0 INNER JOIN EmpBean t1 ON t0.mgr_empid = t1.empid WHERE t0.deptno = ? [params=(int) 200]
656  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 2040035736 SELECT t1.deptno, t1.budget, t1.name FROM DeptBean t0 INNER JOIN DeptBean t1 ON t0.reportsTo_deptno = t1.deptno WHERE t0.deptno = ? [params=(int) 200]
672  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 441981528 SELECT t0.city, t0.state, t0.zip FROM AddressBean t0 WHERE t0.street = ? [params=(String) 512 Venus Drive]
672  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1135756210 SELECT t0.bonus, t1.deptno, t1.budget, t1.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t2.street, t2.city, t2.state, t2.zip, t0.isManager, t0.name, t0.salary, t3.street, t3.city, t3.state, t3.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno LEFT OUTER JOIN AddressBean t2 ON t0.home_street = t2.street LEFT OUTER JOIN AddressBean t3 ON t0.work_street = t3.street WHERE t0.empid = ? [params=(int) 210]
687  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1956672672 SELECT t0.budget, t0.name FROM DeptBean t0 WHERE t0.deptno = ? [params=(int) 210]
687  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 497163682 SELECT t1.empid, t1.bonus, t1.execLevel, t1.hireDate, t1.hireTime, t1.hireTimestamp, t1.isManager, t1.name, t1.salary FROM DeptBean t0 INNER JOIN EmpBean t1 ON t0.mgr_empid = t1.empid WHERE t0.deptno = ? [params=(int) 210]
734  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1160398122 SELECT t1.deptno, t1.budget, t1.name FROM DeptBean t0 INNER JOIN DeptBean t1 ON t0.reportsTo_deptno = t1.deptno WHERE t0.deptno = ? [params=(int) 210]
734  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1948939306 SELECT t0.city, t0.state, t0.zip FROM AddressBean t0 WHERE t0.street = ? [params=(String) 182 Martian Street]
750  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1117667998 SELECT t0.city, t0.state, t0.zip FROM AddressBean t0 WHERE t0.street = ? [params=(String) 150 North First Apt E1]
750  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1403016096 SELECT t0.city, t0.state, t0.zip FROM AddressBean t0 WHERE t0.street = ? [params=(String) 8900 Jupiter Park]
765  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 1997174538 SELECT t0.bonus, t1.deptno, t1.budget, t1.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t2.street, t2.city, t2.state, t2.zip, t0.isManager, t0.name, t0.salary, t3.street, t3.city, t3.state, t3.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno LEFT OUTER JOIN AddressBean t2 ON t0.home_street = t2.street LEFT OUTER JOIN AddressBean t3 ON t0.work_street = t3.street WHERE t0.empid = ? [params=(int) 220]
765  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 658908998 SELECT t0.budget, t0.name FROM DeptBean t0 WHERE t0.deptno = ? [params=(int) 220]
765  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1279413314> [0 ms] executing prepstmnt 947140724 SELECT t0.city, t0.state, t0.zip FROM AddressBean t0 WHERE t0.street = ? [params=(String) 12440 Vulcan Avenue]


the trace statements
for select d,e from EmpBean e join e.dept e where e.bonus<100.02 or e.name='name2' 
312  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 784346816 SELECT t1.deptno, t1.budget, t1.mgr_empid, t1.name, t1.reportsTo_deptno, t0.empid FROM EmpBean t0 INNER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno WHERE ((CAST(t0.bonus AS DOUBLE) < ? OR t0.name = ?)) [params=(BigDecimal) 100.02, (String) name6]
343  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 1902276962 SELECT t0.bonus, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t0.isManager, t0.name, t0.salary FROM EmpBean t0 WHERE t0.empid = ? [params=(int) 3]
359  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 692463942 SELECT t0.budget, t0.name FROM DeptBean t0 WHERE t0.deptno = ? [params=(int) 200]
375  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 288493874 SELECT t0.budget, t1.empid, t1.bonus, t1.execLevel, t1.hireDate, t1.hireTime, t1.hireTimestamp, t1.isManager, t1.name, t1.salary, t0.name, t2.deptno, t2.budget, t2.name FROM DeptBean t0 LEFT OUTER JOIN EmpBean t1 ON t0.mgr_empid = t1.empid LEFT OUTER JOIN DeptBean t2 ON t0.reportsTo_deptno = t2.deptno WHERE t0.deptno = ? [params=(int) 1]
375  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 1962964224 SELECT t0.budget, t1.empid, t1.bonus, t1.execLevel, t1.hireDate, t1.hireTime, t1.hireTimestamp, t1.isManager, t1.name, t1.salary, t0.name, t2.deptno, t2.budget, t2.name FROM DeptBean t0 LEFT OUTER JOIN EmpBean t1 ON t0.mgr_empid = t1.empid LEFT OUTER JOIN DeptBean t2 ON t0.reportsTo_deptno = t2.deptno WHERE t0.deptno = ? [params=(int) 2]
375  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 1125139216 SELECT t0.bonus, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t0.isManager, t0.name, t0.salary FROM EmpBean t0 WHERE t0.empid = ? [params=(int) 8]
375  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 1682728012 SELECT t0.budget, t0.name FROM DeptBean t0 WHERE t0.deptno = ? [params=(int) 100]
390  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 485498096 SELECT t1.deptno, t1.budget, t1.name FROM EmpBean t0 INNER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno WHERE t0.empid = ? [params=(int) 3]
437  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 495459720 SELECT t1.street, t1.city, t1.state, t1.zip FROM EmpBean t0 INNER JOIN AddressBean t1 ON t0.home_street = t1.street WHERE t0.empid = ? [params=(int) 3]
468  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 1370640818 SELECT t1.street, t1.city, t1.state, t1.zip FROM EmpBean t0 INNER JOIN AddressBean t1 ON t0.work_street = t1.street WHERE t0.empid = ? [params=(int) 3]
484  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 492576092 SELECT t0.budget, t1.empid, t1.bonus, t1.execLevel, t1.hireDate, t1.hireTime, t1.hireTimestamp, t1.isManager, t1.name, t1.salary, t0.name, t2.deptno, t2.budget, t2.name FROM DeptBean t0 LEFT OUTER JOIN EmpBean t1 ON t0.mgr_empid = t1.empid LEFT OUTER JOIN DeptBean t2 ON t0.reportsTo_deptno = t2.deptno WHERE t0.deptno = ? [params=(int) 4]
500  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 1356091604 SELECT t0.bonus, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t0.isManager, t0.name, t0.salary FROM EmpBean t0 WHERE t0.empid = ? [params=(int) 4]
500  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 1002191804 SELECT t0.budget, t1.empid, t1.bonus, t1.execLevel, t1.hireDate, t1.hireTime, t1.hireTimestamp, t1.isManager, t1.name, t1.salary, t0.name, t2.deptno, t2.budget, t2.name FROM DeptBean t0 LEFT OUTER JOIN EmpBean t1 ON t0.mgr_empid = t1.empid LEFT OUTER JOIN DeptBean t2 ON t0.reportsTo_deptno = t2.deptno WHERE t0.deptno = ? [params=(int) 5]
515  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 1076117540 SELECT t0.bonus, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t0.isManager, t0.name, t0.salary FROM EmpBean t0 WHERE t0.empid = ? [params=(int) 10]
515  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 104728126 SELECT t0.budget, t1.empid, t1.bonus, t1.execLevel, t1.hireDate, t1.hireTime, t1.hireTimestamp, t1.isManager, t1.name, t1.salary, t0.name, t2.deptno, t2.budget, t2.name FROM DeptBean t0 LEFT OUTER JOIN EmpBean t1 ON t0.mgr_empid = t1.empid LEFT OUTER JOIN DeptBean t2 ON t0.reportsTo_deptno = t2.deptno WHERE t0.deptno = ? [params=(int) 6]
531  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [16 ms] executing prepstmnt 591274814 SELECT t0.budget, t1.empid, t1.bonus, t1.execLevel, t1.hireDate, t1.hireTime, t1.hireTimestamp, t1.isManager, t1.name, t1.salary, t0.name, t2.deptno, t2.budget, t2.name FROM DeptBean t0 LEFT OUTER JOIN EmpBean t1 ON t0.mgr_empid = t1.empid LEFT OUTER JOIN DeptBean t2 ON t0.reportsTo_deptno = t2.deptno WHERE t0.deptno = ? [params=(int) 7]
531  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 2091941040 SELECT t1.deptno, t1.budget, t1.name FROM EmpBean t0 INNER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno WHERE t0.empid = ? [params=(int) 8]
531  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 747777170 SELECT t1.street, t1.city, t1.state, t1.zip FROM EmpBean t0 INNER JOIN AddressBean t1 ON t0.home_street = t1.street WHERE t0.empid = ? [params=(int) 8]
531  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 1392268028 SELECT t1.street, t1.city, t1.state, t1.zip FROM EmpBean t0 INNER JOIN AddressBean t1 ON t0.work_street = t1.street WHERE t0.empid = ? [params=(int) 8]
546  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1164199268> [0 ms] executing prepstmnt 335680514 SELECT t0.budget, t1.empid, t1.bonus, t1.execLevel, t1.hireDate, t1.hireTime, t1.hireTimestamp, t1.isManager, t1.name, t1.salary, t0.name, t2.deptno, t2.budget, t2.name FROM DeptBean t0 LEFT OUTER JOIN EmpBean t1 ON t0.mgr_empid = t1.empid LEFT OUTER JOIN DeptBean t2 ON t0.reportsTo_deptno = t2.deptno WHERE t0.deptno = ? [params=(int) 9]

","openjpa  version 443432, derby, db2",,,,,,,,,,,,,,,,,,,,,04/Oct/06 01:35;ghongell;failureEntities.zip;https://issues.apache.org/jira/secure/attachment/12342227/failureEntities.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-02-01 02:17:18.119,,,no_permission,,,,,,,,,,,160399,,,Thu Feb 01 02:17:18 UTC 2007,,,,,,,0|i0z6dj:,203335,,,,,,,,04/Oct/06 01:35;ghongell;attachment included to help recreate issue,01/Feb/07 02:17;wisneskid;fixed in recent code,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missing usage of TransactionSynchronizationRegistry,OPENJPA-61,12351985,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,28/Sep/06 13:29,31/Jul/07 18:56,14/Mar/19 03:02,26/Jun/07 18:26,,,,,,,,,,1.0.0,,,,,jdbc,,,,,,0,,"A discussion on the dev mailing list indicates that OpenJPA currently does not utilize the TransactionSynchronizationRegistry.  Although OpenJPA does provide other means of finding and accessing the various TransactionManagers, we should update OpenJPA to use the standard interfaces.  Following are the two notes on this subject...

========================================================================================		
o  David Jencks 	<david_jencks@yahoo.com> to open-jpa-dev 	 More options	  Sep 27 (19 hours ago)
I'm trying to get openjpa running in geronimo and wonder how openjpa
locates the TransactionSynchronizationRegistry.  Grep'ing for
TransactionSynchronizationRegistry I don't see it used anywhere in
the code base.  What am I missing?

thanks
david jencks
========================================================================================
o  Marc Prud'hommeaux 	to open-jpa-dev	 More options	  Sep 27 (19 hours ago)
David-

We don't use TransactionSynchronizationRegistry (not yet, at least).
Instead, we manually locate the TransactionManager via appserver-
specific heuristics defined in openjpa-kernel/src/main/java/org/
apache/openjpa/ee/AutomaticManagedRuntime.java

If the Geronimo TransactionManager is accessible from JNDI or some
method invocation, you can just add it into AutomaticManagedRuntime
as a default (you can test it out by specifying the
""openjpa.ManagedRuntime"" property to ""jndi
(TransactionManagerName=java:/GeronimoJNDINameForTransactionManager)"".

We may add support for integration via
TransactionSynchronizationRegistry in the future, but the fact that
it doesn't provide support for accessing the current Transaction
would mean that we would need to rework some OpenJPA internals.
========================================================================================",,,,,,,,,,,,,,,,,,,,,,22/Apr/07 21:24;mprudhom;OPENJPA-61.patch;https://issues.apache.org/jira/secure/attachment/12356011/OPENJPA-61.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2006-10-20 16:45:02.0,,,no_permission,,,,,,,,,,,160398,,,Wed Jun 27 13:29:34 UTC 2007,,,,,,,0|i0ywwn:,201801,,,,,,,,"20/Oct/06 16:09;kwsutter;It's turning out that we have two problems to resolve via this defect.  The first (more immediate) problem is to remove the usage of the internal WebSphere API usage.  Currently, OpenJPA is using one of three API's to get access to the WebSphere TransactionManager.  These API's were never meant to be used by applications or other persistence mechanisms.  The API's in question are:

        ""com.ibm.ejs.jts.jta.JTSXA.getTransactionManager""
        ""com.ibm.ejs.jts.jta.TransactionManagerFactory.getTransactionManager""
        ""com.ibm.ws.Transaction.TransactionManagerFactory.getTransactionManager""

Instead, the preferred (public, documented) method of interfacing with the WebSphere TransactionManager is via the
ExtendedJTATransaction interface.  This provides similar access to TM-like functions without opening direct access to the TM, which could possibly cause integrity issues.  This will involve looking up the java:/comp/websphere/ExtendedJTATransaction object, and then using this object to register for synchronization (which also uses a websphere-specific interface, to protect the innocent).

That's the first step.  We need to do this first so that we can get WebSphere's buy-in of the OpenJPA project.

The follow-on issue is to introduce the usage of the Java EE 5 feature for the TransactionSynchronizationRegistry.  This will standardize the persistence provider's access to TM's across all Java EE 5 application servers.  We will leave the other mechanisms in place for non-Java EE 5 compliant application servers, but the TransactionSynchronizationRegistry will be the first option to try.  Once we get the first item complete (using the WebSphere interfaces), this item should follow shortly.

Please comment with any questions or concerns with this approach.  Thanks.

Kevin","20/Oct/06 16:15;kwsutter;Question:  From a pure JPA perspective, you would need WebSphere v6.1 Application Server in order to use OpenJPA within a WebSphere container (at a minimum).  This is due to the requirement of Java SE 5, which was first available in WAS v6.1.  So, if the use of the proper ExtendedJTATransaction interface was limited to JPA, then we could remove the other three internal API references.  But, since this OpenJPA kernel is also used by Kodo's JDO support, what levels of the WebSphere runtime need to be supported?  The ExtendedJTATransaction interface was introduced in WAS v5.0.2.  Since WAS v4.x is out of service, do we need to leave the three internal API references in the code base?  Or, can these be removed once we get the ExtendedJTATransaction processing committed?",20/Oct/06 16:45;pcl;I'd say that we (OpenJPA) should not worry about the older versions -- we (BEA) will just need to add the appropriate logic in Kodo to handle the older versions of WebSphere.,"22/Apr/07 21:24;mprudhom;The attached patch might work. It contains a new RegistryManagedRuntime class that just uses a TransactionManager facade around a TransactionSynchronizationRegistry. This will allow us to use the standard TransactionSynchronizationRegistry interface without breaking the ManagedRuntime contracts. The only shortcoming is that direct control over the Transaction will fail (since TransactionSynchronizationRegistry doesn't provide direct access to the current Transaction).

Note also that this patch will require us to update our JTA dependency from geronimo-jta_1.0.1B_spec to geronimo-jta_1.1_spec. I don't envision that being a problem, since it should be backwards-compatible.

I will need someone who has access to a container that supports the TransactionSynchronizationRegistry interface to test this out before we can commit it.","24/Apr/07 19:26;mikedd;Marc, I started testing this with the WebSphere EJB3 feature pack. So far I haven't found any bugs, but I've really only run a few simple tests. I'll add more comments to the JIRA when I've tested it more thoroughly. ","24/Apr/07 19:57;mprudhom;Note that you should make sure that you are really using the new RegistryManagedRuntime, since if any exceptions occur when loading that class, they will be silently consumed and it will fall back to using the old internal APIs for accessing the TransactionManager.

You should be able to force it to use the new class by specifying ""openjpa.ManagedRuntime"" to be ""org.apache.openjpa.ee.RegistryManagedRuntime"".","18/May/07 15:22;mikedd;The patch looks good on our end, running with the Transacton Synchronization Registry in WebSphere. If other vendors would like to test it out as well that's fine with me, but you have my +1 to integrate.. ","26/Jun/07 18:26;kwsutter;Committed a slightly-modified version of Marc's patch.  All of our junit tests pass (of course) and it seems to work well in the WebSphere environment.  We need to work through any wrinkles with this TransactionSynchronizationRegistry, so we might as well go ahead with the integration.  Thanks, Marc, for the patch!","27/Jun/07 12:09;pcl;I don't think that we want this to necessarily be the default ManagedRuntime implementation, since the TSR does not provide any support for executing work in a separate transaction. This behavior is required for sequence maintenance in some scenarios.

Maybe we should change our ManagedRuntime interface to get rid of the begin() / commit() etc. APIs, and add a new interface for executing a Runnable in a different transaction. This would allow us to use the TSR ManagedRuntime for general use, and just plug in different ways of performing out-of-transaction work.

Thoughts?","27/Jun/07 13:29;kwsutter;Patrick, I agree with that idea.  That was exactly along the lines of my thinking, but I needed to get the first step done first -- get the TSR available.  Our ""hack"" for utilizing the WebSphere JTAExtendedTransaction interface wasn't cutting it and the TSR implementation that Marc provided got us around a couple of the problems.  So, I wanted to get a portion of the fix integrated.  Since the original problem as documented was resolved, I will create a new Issue to cover this additional ""out of transaction"" work request.  Sound okay?",,,,,,,,,,,,,,,,,,,,,,,,,,,
Specifying the wrong persistence implementation in persistence.xml leads to misleading error message,OPENJPA-60,12351917,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,dezzio,dezzio,27/Sep/06 18:49,09/Mar/10 18:32,14/Mar/19 03:02,06/Feb/07 03:03,,,,,,,,,,0.9.7,,,,,,,,,,,0,,"If ""kodo.persistence.PersistenceProviderImpl"" is specified instead of ""org.apache.openjpa.persistence.PersistenceProviderImpl"", a misleading error message results that suggests that the persistence.xml file is missing or cannot be found.

enhance:
     [java] Exception in thread ""main"" java.util.MissingResourceException: org.apache.openjpa.persistence.PersistenceProductDerivation:java.util.MissingResourceException: The specified XML resource ""META-INF/persistence.xml"" for persistence unit ""null"" can't be found in your class path.
     [java] at org.apache.openjpa.lib.conf.ProductDerivations.reportErrors(ProductDerivations.java:217)
     [java] at org.apache.openjpa.lib.conf.ProductDerivations.load(ProductDerivations.java:135)
     [java] at org.apache.openjpa.lib.conf.Configurations.populateConfiguration(Configurations.java:198)
     [java] at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:3468)
     [java] at org.apache.openjpa.enhance.PCEnhancer.main(PCEnhancer.java:3441)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-09-27 23:16:56.0,,,no_permission,,,,,,,,,,,160397,,,Tue Feb 06 03:03:39 UTC 2007,,,,,,,0|i1dp13:,288152,,,,,,,,27/Sep/06 23:16;ppoddar@apache.org;Fix available on revision #450632.,"06/Feb/07 03:03;pcl;Resolving, assuming that Pinaki's change is correct.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Eager fetching not occuring for ToOne relationships during detachment,OPENJPA-59,12350944,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,,dezzio,dezzio,25/Sep/06 13:22,09/Mar/10 18:35,14/Mar/19 03:02,26/Sep/06 17:40,,,,,,,,,,,,,,,kernel,,,,,,0,,"If there is a bidirectional onetomany relationship between parent and child maintained with a foreign key, during detachment, the parent and children are correctly detached, but the back reference in child to the parent is not populated.",Any,,,,,,,,,,,,,,,,,,,,,25/Sep/06 13:25;dezzio;detachmentTestOpenJPA.zip;https://issues.apache.org/jira/secure/attachment/12341631/detachmentTestOpenJPA.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2006-09-25 18:39:58.0,,,no_permission,,,,,,,,,,,160396,,,Tue Sep 26 17:40:47 UTC 2006,,,,,,,0|i0ywcv:,201712,,,,,,,,25/Sep/06 13:25;dezzio;JUnit test suitable for openjpa-persistence-jdbc\src\test\java demonstrating the problem.,"25/Sep/06 18:39;awhite;The behavior of the test case is technically correct, because the default global MaxFetchDepth is 1.  If I modify the test case to set a MaxFetchDepth of 2 in setUp, it passes.  I agree that this is not necessarily user-friendly, though.  So the question is: what should our default max fetch depth be?  Unlimited?  2, so that at least both sides of bi-di relations are handled?  Some other arbitrary number that we think is reasonable?","25/Sep/06 19:51;mprudhom;I'd vote for MaxFetchDepth defaulting to unlimited. It seems like a useful setting to tune downwards (especially for tree-type parent-child structures), but having it default to 1 seems like it cause more confusion without providing much performance benefit in most cases.","25/Sep/06 20:01;kwsutter;I definitely agree it shouldn't be 1.  But, could defaulting to unlimited cause undue stress to an application?  I suppose that's an application architecture question.  I would be okay with unlimited as the default.",26/Sep/06 17:40;awhite;Changed default MaxFetchDepth to -1 (unlimited).  Checked in given test case.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The snapshots at http://people.apache.org/repo/m2-snapshot-repository/ are out of date,OPENJPA-58,12350572,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,sateh,sateh,23/Sep/06 12:03,09/Mar/10 18:35,14/Mar/19 03:02,23/Sep/06 18:44,,,,,,,,,,,,,,,,,,,,,0,,"The snapshots at

 http://people.apache.org/repo/m2-snapshot-repository/

were last updated on august 26th.

The wiki points to this repository from here:

 http://cwiki.apache.org/openjpa/obtaining.html

Probably good to either add something to the wiki so that people don't expect a daily snapshot there or simply keep uploading snapshots ;)

S.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-09-23 18:44:06.0,,,no_permission,,,,,,,,,,,160395,,,Sat Sep 23 18:44:06 UTC 2006,,,,,,,0|i0z14f:,202484,,,,,,,,"23/Sep/06 18:44;mprudhom;Thanks for the reminder ... I've gone ahead and uploaded a new snapshot. Ideally we'd have some automated way of doing this, but for the time being, I'll try to frequently do it manually.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"in derby concat with input parameter needs a cast, otherwise becomes long varchar and some operations do not work",OPENJPA-56,12350360,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ghongell,ghongell,20/Sep/06 16:55,01/Mar/07 02:20,14/Mar/19 03:02,01/Mar/07 02:20,,,,,,,,,,0.9.7,,,,,query,,,,,,0,,"run on version 443432.
in derby concat with input parameter needs a cast, otherwise becomes long varchar and some operations do not work
(NOTE:already done if concat is inside substring eg. substring(concat(xxx,yyy),n,m)

EJBQL:
select d from EmpBean e left join e.dept d where concat(d.name, 'ahmad') = 'AhmadDept' 
 
OPENJPA ERROR OR SQL PUSHDOWN:
Comparisons between 'LONG VARCHAR' and 'LONG VARCHAR' are not supported. {SELECT t1.deptno, t1.budget, t1.mgr_empid, t1.name, t1.reportsTo_deptno FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno WHERE ((t1.name||?) = ?)} [code=30000, state=42818] 

SUGGESTED SQL PUSHDOWN:
select t1.deptno, t1.name FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno WHERE (cast((t1.name||?) as Varchar(1000))) = ?  {String ahmad, String AhmadDept}

","Windows xp, derby, openjpa  version 443432.
",,,,,,,,,,,,,,,,,,,,,20/Sep/06 16:56;ghongell;failureEntities.jar;https://issues.apache.org/jira/secure/attachment/12341226/failureEntities.jar,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-02-01 01:24:36.095,,,no_permission,,,,,,,,,,,160393,,,Thu Feb 01 01:24:36 UTC 2007,,,,,,,0|i0z6c7:,203329,,,,,,,,20/Sep/06 16:56;ghongell;entity java files and derby ddl script to use to recreate this issue,01/Feb/07 01:24;wisneskid;already fixed in latest code,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"bad sql pushdown, should use all syntax",OPENJPA-54,12350215,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ghongell,ghongell,19/Sep/06 01:25,01/Mar/07 02:20,14/Mar/19 03:02,01/Mar/07 02:20,,,,,,,,,,0.9.7,,,,,query,,,,,,0,,"454 bad sql pushdown, should use all syntax
 TEST454; select e from EmpBean e where e.empid not in (select e.no from DeptBean e) 
Scalar subquery is only allowed to return a single row. {prepstmnt 241176160 SELECT t0.empid, t0.bonus, t2.deptno, t2.budget, t2.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t3.street, t3.city, t3.state, t3.zip, t0.isManager, t0.name, t0.salary, t4.street, t4.city, t4.state, t4.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t2 ON t0.dept_deptno = t2.deptno LEFT OUTER JOIN AddressBean t3 ON t0.home_street = t3.street LEFT OUTER JOIN AddressBean t4 ON t0.work_street = t4.street WHERE (NOT (t0.empid = (SELECT t1.deptno FROM DeptBean t1)) AND t0.empid IS NOT NULL)} [code=30000, state=21000] 
s/b
select   t0.empid from EMPBean t0 where  ( t0.empid  <> ALL  ( select  t2.deptno from DEPTbean t2) ) 

  [ FAILED 454- bucket = fvtfull, query = select e from EmpBean e where e.empid not in (select e.no from DeptBean e)  : 
   DIFFERENCE-locations based on expected-(
diff at line 2 position 2 EXPECTED [T]  ACTUAL [ ] 
 TEST454; 0 tuples 
                                                                                                                                                                                                                                                                                                                e                                                                                                                                                                                                                                                                                                                  
) 
   EXPECTED(
 TEST454; select e from EmpBean e where e.empid not in (select e.no from DeptBean e) 
 TEST454; 0 tuples ) 
   ACTUAL(
 TEST454; select e from EmpBean e where e.empid not in (select e.no from DeptBean e) 
                                                                                                                                                                                                                                                                                                                e                                                                                                                                                                                                                                                                                                                  
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
Scalar subquery is only allowed to return a single row. {prepstmnt 241176160 SELECT t0.empid, t0.bonus, t2.deptno, t2.budget, t2.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t3.street, t3.city, t3.state, t3.zip, t0.isManager, t0.name, t0.salary, t4.street, t4.city, t4.state, t4.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t2 ON t0.dept_deptno = t2.deptno LEFT OUTER JOIN AddressBean t3 ON t0.home_street = t3.street LEFT OUTER JOIN AddressBean t4 ON t0.work_street = t4.street WHERE (NOT (t0.empid = (SELECT t1.deptno FROM DeptBean t1)) AND t0.empid IS NOT NULL)} [code=30000, state=21000] 
 TEST454; 1 tuple) ]

","Windows xp, derby, db2",,,,,,,,,,,,,,,,,,,,,20/Sep/06 01:30;ghongell;failureEntities.jar;https://issues.apache.org/jira/secure/attachment/12341172/failureEntities.jar,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-02-01 01:25:44.661,,,no_permission,,,,,,,,,,,160391,,,Thu Feb 01 01:25:44 UTC 2007,,,,,,,0|i0z6kn:,203367,,,,,,,,"20/Sep/06 01:29;ghongell;removed testcase references.
run on version 443432.

EJBQL:
select e from EmpBean e where e.empid not in (select e.no from DeptBean e) 
 
OPENJPA ERROR OR SQL PUSHDOWN:
Scalar subquery is only allowed to return a single row. {prepstmnt 241176160 SELECT t0.empid, t0.bonus, t2.deptno, t2.budget, t2.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t3.street, t3.city, t3.state, t3.zip, t0.isManager, t0.name, t0.salary, t4.street, t4.city, t4.state, t4.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t2 ON t0.dept_deptno = t2.deptno LEFT OUTER JOIN AddressBean t3 ON t0.home_street = t3.street LEFT OUTER JOIN AddressBean t4 ON t0.work_street = t4.street WHERE (NOT (t0.empid = (SELECT t1.deptno FROM DeptBean t1)) AND t0.empid IS NOT NULL)} [code=30000, state=21000] 
 
SUGGESTED SQL PUSHDOWN:
select t0.empid, t0.bonus, t2.deptno, t2.budget, t2.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t3.street, t3.city, t3.state, t3.zip, t0.isManager, t0.name, t0.salary, t4.street, t4.city, t4.state, t4.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t2 ON t0.dept_deptno = t2.deptno LEFT OUTER JOIN AddressBean t3 ON t0.home_street = t3.street LEFT OUTER JOIN AddressBean t4 ON t0.work_street = t4.street WHERE (NOT (t0.empid = ALL (select t1.deptno FROM DeptBean t1)) AND t0.empid IS NOT NULL)

",20/Sep/06 01:30;ghongell;entity java files and derby ddl script to use to recreate this issue,01/Feb/07 01:25;wisneskid;already fixed,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
" bad sql pushdown for nested subselects, missing nested subselect",OPENJPA-53,12350214,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ghongell,ghongell,19/Sep/06 01:20,01/Mar/07 02:20,14/Mar/19 03:02,01/Mar/07 02:20,,,,,,,,,,0.9.7,,,,,query,,,,,,0,,"536 bad sql pushdown for nested subselects
 TEST536; select e from EmpBean e where (e.salary = (select max(e.salary) from EmpBean e where e.salary > some (select f.salary from EmpBean f where f.dept.mgr.empid=e.dept.mgr.empid)) ) 
Syntax error: Encountered "")"" at line 1, column 504. {SELECT t0.empid, t0.bonus, t5.deptno, t5.budget, t5.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t7.street, t7.city, t7.state, t7.zip, t0.isManager, t0.name, t0.salary, t8.street, t8.city, t8.state, t8.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t5 ON t0.dept_deptno = t5.deptno LEFT OUTER JOIN AddressBean t7 ON t0.home_street = t7.street LEFT OUTER JOIN AddressBean t8 ON t0.work_street = t8.street WHERE (t0.salary = (SELECT MAX(t1.salary) FROM EmpBean t1 WHERE (t1.salary > ANY(()))))} [code=30000, state=42X01] 
s/b
select  q1.""EMPID"",  q1.""SALARY"",  q1.""DEPT_DEPTNO"" from EMPVO q1 where  ( q1.""SALARY"" =  ( select  max( q2.""SALARY"") from EMPVO q2, DEPTVO q3, EMPVO q4 where  ( q2.""SALARY"" > ANY  ( select  q5.""SALARY"" from EMPVO q5, DEPTVO q6, EMPVO q7 where  ( q7.""EMPID"" =  q4.""EMPID"")  and  ( q6.""DEPTNO"" =  q5.""DEPT_DEPTNO"")  and  ( q7.""EMPID"" =  q6.""MGR_EMPID"") ) )  and  ( q3.""DEPTNO"" =  q2.""DEPT_DEPTNO"")  and  ( q4.""EMPID"" =  q3.""MGR_EMPID"") ) )

  [ FAILED 536- bucket = fvtfull, query = select e from EmpBean e where (e.salary = (select max(e.salary) from EmpBean e where e.salary > some (select f.salary from EmpBean f where f.dept.mgr.empid=e.dept.mgr.empid)) )  : 
   DIFFERENCE-locations based on expected-(
diff at line 2 position 295 EXPECTED [ ]  ACTUAL [e] 
                                                                                                                                                                                                                                                                                                                                      e                                                                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                                                      e                                                                                                                                                                                                                                                                                                       
) 
   EXPECTED(
 TEST536; select e from EmpBean e where (e.salary = (select max(e.salary) from EmpBean e where e.salary > some (select f.salary from EmpBean f where f.dept.mgr.empid=e.dept.mgr.empid)) ) 
                                                                                                                                                                                                                                                                                                                                      e                                                                                                                                                                                                                                                                                                                                       
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DB2 SQL error: SQLCODE: -104, SQLSTATE: 42601, SQLERRMC: );E (t1.salary > ANY((;<query_expr_body> {prepstmnt 605037584 SELECT t0.empid, t0.bonus, t5.deptno, t5.budget, t5.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t7.street, t7.city, t7.state, t7.zip, t0.isManager, t0.name, t0.salary, t8.street, t8.city, t8.state, t8.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t5 ON t0.dept_deptno = t5.deptno LEFT OUTER JOIN AddressBean t7 ON t0.home_street = t7.street LEFT OUTER JOIN AddressBean t8 ON t0.work_street = t8.street WHERE (t0.salary = (SELECT MAX(t1.salary) FROM EmpBean t1 WHERE (t1.salary > ANY(()))))} [code=-104, state=42601] 
 TEST536; 1 tuple) 
   ACTUAL(
 TEST536; select e from EmpBean e where (e.salary = (select max(e.salary) from EmpBean e where e.salary > some (select f.salary from EmpBean f where f.dept.mgr.empid=e.dept.mgr.empid)) ) 
                                                                                                                                                                                                                                                                                                      e                                                                                                                                                                                                                                                                                                       
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
Syntax error: Encountered "")"" at line 1, column 504. {SELECT t0.empid, t0.bonus, t5.deptno, t5.budget, t5.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t7.street, t7.city, t7.state, t7.zip, t0.isManager, t0.name, t0.salary, t8.street, t8.city, t8.state, t8.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t5 ON t0.dept_deptno = t5.deptno LEFT OUTER JOIN AddressBean t7 ON t0.home_street = t7.street LEFT OUTER JOIN AddressBean t8 ON t0.work_street = t8.street WHERE (t0.salary = (SELECT MAX(t1.salary) FROM EmpBean t1 WHERE (t1.salary > ANY(()))))} [code=30000, state=42X01] 
 TEST536; 1 tuple) ]

","Windows xp, derby, db2",,,,,,,,,,,,,,,,,,,,,20/Sep/06 01:52;ghongell;failureEntities.jar;https://issues.apache.org/jira/secure/attachment/12341174/failureEntities.jar,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-02-01 01:26:42.523,,,no_permission,,,,,,,,,,,160390,,,Thu Feb 01 01:26:42 UTC 2007,,,,,,,0|i0z6l3:,203369,,,,,,,,"20/Sep/06 01:51;ghongell;removed testcase references.
run on version 443432.

EJBQL:
select e from EmpBean e where (e.salary = (select max(e.salary) from EmpBean e where e.salary > some (select f.salary from EmpBean f where f.dept.mgr.empid=e.dept.mgr.empid)) ) 

OPENJPA ERROR OR SQL PUSHDOWN:
Syntax error: Encountered "")"" at line 1, column 504. {SELECT t0.empid, t0.bonus, t5.deptno, t5.budget, t5.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t7.street, t7.city, t7.state, t7.zip, t0.isManager, t0.name, t0.salary, t8.street, t8.city, t8.state, t8.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t5 ON t0.dept_deptno = t5.deptno LEFT OUTER JOIN AddressBean t7 ON t0.home_street = t7.street LEFT OUTER JOIN AddressBean t8 ON t0.work_street = t8.street WHERE (t0.salary = (SELECT MAX(t1.salary) FROM EmpBean t1 WHERE (t1.salary > ANY(()))))} [code=30000, state=42X01] 
 
SUGGESTED SQL PUSHDOWN:
similar to
select  q1.""EMPID"",  q1.""SALARY"",  q1.""DEPT_DEPTNO"" from EMPVO q1 where  ( q1.""SALARY"" =  ( select  max( q2.""SALARY"") from EMPVO q2, DEPTVO q3, EMPVO q4 where  ( q2.""SALARY"" > ANY  ( select  q5.""SALARY"" from EMPVO q5, DEPTVO q6, EMPVO q7 where  ( q7.""EMPID"" =  q4.""EMPID"")  and  ( q6.""DEPTNO"" =  q5.""DEPT_DEPTNO"")  and  ( q7.""EMPID"" =  q6.""MGR_EMPID"") ) )  and  ( q3.""DEPTNO"" =  q2.""DEPT_DEPTNO"")  and  ( q4.""EMPID"" =  q3.""MGR_EMPID"") ) )


",20/Sep/06 01:52;ghongell;entity java files and derby ddl script to use to recreate this issue,01/Feb/07 01:26;wisneskid;not a problem anymore,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"bad sql pushdown, sub select is missing from clause",OPENJPA-51,12350212,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,ghongell,ghongell,19/Sep/06 01:12,21/Sep/16 14:21,14/Mar/19 03:02,14/Jul/08 04:10,1.0.0,1.0.1,1.0.2,1.0.3,1.0.4,1.1.0,1.2.0,,,1.0.3,1.2.0,,,,query,,,,,,1,,"451 - bad sql pushdown sub select is missing from clause
 TEST451; select e from EmpBean e where e.empid > any (select e1.empid from DeptBean d, in(d.emps) e1 where d.no = 200) 
28344  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 295440796> [0 ms] executing prepstmnt 81790176 SELECT t0.empid, t0.bonus, t2.deptno, t2.budget, t2.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t3.street, t3.city, t3.state, t3.zip, t0.isManager, t0.name, t0.salary, t4.street, t4.city, t4.state, t4.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t2 ON t0.dept_deptno = t2.deptno LEFT OUTER JOIN AddressBean t3 ON t0.home_street = t3.street LEFT OUTER JOIN AddressBean t4 ON t0.work_street = t4.street WHERE (t0.empid = ANY((SELECT t1.deptno FROM DeptBean t1)))
s/b
select t1.empid  FROM DeptBean t0 INNER JOIN EmpBean t1 ON t0.deptno = t1.dept_deptno LEFT OUTER JOIN DeptBean t3 ON t1.dept_deptno = t3.deptno WHERE t1.empid > ANY((SELECT t5.empid FROM DeptBean t4 INNER JOIN EmpBean t5 ON t4.deptno = t5.dept_deptno  WHERE (CAST(t4.deptno AS BIGINT) = ?))) {int 200}

<0|false|0.0.0> org.apache.openjpa.persistence.PersistenceException: Syntax error: Encountered ""WHERE"" at line 1, column 520. {SELECT t2.empid, t2.bonus, t3.deptno, t3.budget, t3.name, t2.execLevel, t2.hireDate, t2.hireTime, t2.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t2.isManager, t2.name, t2.salary, t5.street, t5.city, t5.state, t5.zip FROM DeptBean t0 INNER JOIN EmpBean t1 ON t0.deptno = t1.dept_deptno LEFT OUTER JOIN DeptBean t3 ON t2.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t2.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t2.work_street = t5.street WHERE (t2.empid > ANY((SELECT t1.empid FROM  WHERE (CAST(t0.deptno AS BIGINT) = CAST(? AS BIGINT)))))} [code=30000, state=42X01]
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3713)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:94)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:80)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:56)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.handleCheckedException(SelectResultObjectProvider.java:152)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:37)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1161)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:936)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:746)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:716)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:712)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:512)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:216)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.createAndRunQuery(JFLoopQueryTestcase.java:187)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testFileQuery(JFLoopQueryTestcase.java:536)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testRunQueryLoopImpl(JFLoopQueryTestcase.java:591)
	at com.ibm.ws.query.tests.JFLoopQueryTest.testRunQueryLoop(JFLoopQueryTest.java:265)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.extensions.jfunc.TestletWrapper.runBare(TestletWrapper.java:116)
	at junit.extensions.jfunc.TestletWrapper$1.protect(TestletWrapper.java:106)
	at junit.framework.TestResult.runProtected(Unknown Source)
	at junit.extensions.jfunc.TestletWrapper.run(TestletWrapper.java:109)
	at junit.framework.TestSuite.runTest(Unknown Source)
	at junit.framework.TestSuite.run(Unknown Source)
	at junit.extensions.jfunc.JFuncSuite.run(JFuncSuite.java:134)
	at junit.extensions.jfunc.textui.JFuncRunner.doRun(JFuncRunner.java:76)
	at junit.extensions.jfunc.textui.JFuncRunner.start(JFuncRunner.java:398)
	at junit.extensions.jfunc.textui.JFuncRunner.main(JFuncRunner.java:218)
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: Syntax error: Encountered ""WHERE"" at line 1, column 520. {SELECT t2.empid, t2.bonus, t3.deptno, t3.budget, t3.name, t2.execLevel, t2.hireDate, t2.hireTime, t2.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t2.isManager, t2.name, t2.salary, t5.street, t5.city, t5.state, t5.zip FROM DeptBean t0 INNER JOIN EmpBean t1 ON t0.deptno = t1.dept_deptno LEFT OUTER JOIN DeptBean t3 ON t2.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t2.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t2.work_street = t5.street WHERE (t2.empid > ANY((SELECT t1.empid FROM  WHERE (CAST(t0.deptno AS BIGINT) = CAST(? AS BIGINT)))))} [code=30000, state=42X01]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:193)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$6(LoggingConnectionDecorator.java:189)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:217)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:137)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1305)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:149)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:463)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:443)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:322)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:295)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:397)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:208)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:198)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:91)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:31)
	... 26 more
NestedThrowables:
ERROR 42X01: Syntax error: Encountered ""WHERE"" at line 1, column 520.
	at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)
	at org.apache.derby.impl.sql.compile.ParserImpl.parseStatement(Unknown Source)
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(Unknown Source)
	at org.apache.derby.impl.sql.GenericStatement.prepare(Unknown Source)
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.<init>(Unknown Source)
	at org.apache.derby.jdbc.Driver30.newEmbedPreparedStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)
	at org.apache.commons.dbcp.DelegatingConnection.prepareStatement(DelegatingConnection.java:185)
	at org.apache.commons.dbcp.PoolingDataSource$PoolGuardConnectionWrapper.prepareStatement(PoolingDataSource.java:278)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:162)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:214)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:137)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1305)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:149)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:463)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:443)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:322)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:295)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:397)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:208)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:198)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:91)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:31)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1161)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:936)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:746)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:716)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:712)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:512)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:216)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.createAndRunQuery(JFLoopQueryTestcase.java:187)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testFileQuery(JFLoopQueryTestcase.java:536)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testRunQueryLoopImpl(JFLoopQueryTestcase.java:591)
	at com.ibm.ws.query.tests.JFLoopQueryTest.testRunQueryLoop(JFLoopQueryTest.java:265)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.extensions.jfunc.TestletWrapper.runBare(TestletWrapper.java:116)
	at junit.extensions.jfunc.TestletWrapper$1.protect(TestletWrapper.java:106)actual  TEST451; select e from EmpBean e where e.empid > any (select e1.empid from DeptBean d, in(d.emps) e1 where d.no = 200) 
                                                                                                                                                                                                                                                                                                                                         e                                                                                                                                                                                                                                                                                                                                           
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
Syntax error: Encountered ""WHERE"" at line 1, column 520. {SELECT t2.empid, t2.bonus, t3.deptno, t3.budget, t3.name, t2.execLevel, t2.hireDate, t2.hireTime, t2.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t2.isManager, t2.name, t2.salary, t5.street, t5.city, t5.state, t5.zip FROM DeptBean t0 INNER JOIN EmpBean t1 ON t0.deptno = t1.dept_deptno LEFT OUTER JOIN DeptBean t3 ON t2.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t2.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t2.work_street = t5.street WHERE (t2.empid > ANY((SELECT t1.empid FROM  WHERE (CAST(t0.deptno AS BIGINT) = CAST(? AS BIGINT)))))} [code=30000, state=42X01] 
 TEST451; 1 tuple

expected and actual line lengths do NOT match for line 2
  [ FAILED 451- bucket = fvtfull, query = select e from EmpBean e where e.empid > any (select e1.empid from DeptBean d, in(d.emps) e1 where d.no = 200)  : 
   DIFFERENCE-locations based on expected-(
diff at line 2 position 1 EXPECTED [[]  ACTUAL [ ] 
[( class com.dw.test.EmpBean  empid=4 name=george salary=0.0 dept=200)]
                                                                                                                                                                                                                                                                                                                                         e                                                                                                                                                                                                                                                                                                                                           
) 
   EXPECTED(
 TEST451; select e from EmpBean e where e.empid > any (select e1.empid from DeptBean d, in(d.emps) e1 where d.no = 200) 
[( class com.dw.test.EmpBean  empid=4 name=george salary=0.0 dept=200)]
[( class com.dw.test.EmpBean  empid=9 name=harry salary=0.0 dept=210)]
[( class com.dw.test.EmpBean  empid=10 name=Catalina Wei salary=0.0 dept=0)]
[( class com.dw.test.EmpBean  empid=5 name=ritika salary=0.0 dept=220)]
[( class com.dw.test.EmpBean  empid=6 name=ahmad salary=0.0 dept=100)]
[( class com.dw.test.EmpBean  empid=7 name=charlene salary=0.0 dept=210)]
[( class com.dw.test.EmpBean  empid=8 name=Tom Rayburn salary=0.0 dept=100)]
 TEST451; 7 tuples ) 
   ACTUAL(
 TEST451; select e from EmpBean e where e.empid > any (select e1.empid from DeptBean d, in(d.emps) e1 where d.no = 200) 
                                                                                                                                                                                                                                                                                                                                         e                                                                                                                                                                                                                                                                                                                                           
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
Syntax error: Encountered ""WHERE"" at line 1, column 520. {SELECT t2.empid, t2.bonus, t3.deptno, t3.budget, t3.name, t2.execLevel, t2.hireDate, t2.hireTime, t2.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t2.isManager, t2.name, t2.salary, t5.street, t5.city, t5.state, t5.zip FROM DeptBean t0 INNER JOIN EmpBean t1 ON t0.deptno = t1.dept_deptno LEFT OUTER JOIN DeptBean t3 ON t2.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t2.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t2.work_street = t5.street WHERE (t2.empid > ANY((SELECT t1.empid FROM  WHERE (CAST(t0.deptno AS BIGINT) = CAST(? AS BIGINT)))))} [code=30000, state=42X01] 
 TEST451; 1 tuple) ]

","Windows xp, db2, derby ",,,,,,,,,,,,,,,,,,,,,14/May/07 20:03;fancy;SelectImpl.java.patch;https://issues.apache.org/jira/secure/attachment/12357307/SelectImpl.java.patch,02/May/07 17:51;fancy;SelectImpl.java.patch;https://issues.apache.org/jira/secure/attachment/12356650/SelectImpl.java.patch,20/Sep/06 01:14;ghongell;failureEntities.jar;https://issues.apache.org/jira/secure/attachment/12341169/failureEntities.jar,22/Jun/07 01:11;fancy;openjpa-51.patch;https://issues.apache.org/jira/secure/attachment/12360336/openjpa-51.patch,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2007-04-26 07:42:00.682,,,no_permission,,,,,,,,,,,160388,,,Fri Aug 07 21:24:05 UTC 2009,,,,,,,0|i0z13b:,202479,,,,,,,,"20/Sep/06 01:13;ghongell;removed testcase references.
run on version 443432.

EJBQL:
select e from EmpBean e where e.empid > any (select e1.empid from DeptBean d, in(d.emps) e1 where d.no = 200) 

OPENJPA ERROR OR SQL PUSHDOWN:
 <0|false|0.0.0> org.apache.openjpa.persistence.PersistenceException: Syntax error: Encountered ""WHERE"" at line 1, column 520. {SELECT t2.empid, t2.bonus, t3.deptno, t3.budget, t3.name, t2.execLevel, t2.hireDate, t2.hireTime, t2.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t2.isManager, t2.name, t2.salary, t5.street, t5.city, t5.state, t5.zip FROM DeptBean t0 INNER JOIN EmpBean t1 ON t0.deptno = t1.dept_deptno LEFT OUTER JOIN DeptBean t3 ON t2.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t2.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t2.work_street = t5.street WHERE (t2.empid > ANY((SELECT t1.empid FROM  WHERE (CAST(t0.deptno AS BIGINT) = CAST(? AS BIGINT)))))} [code=30000, state=42X01]
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3713)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:94)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:80)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:56)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.handleCheckedException(SelectResultObjectProvider.java:152)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:37)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1161)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:936)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:746)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:716)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:712)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:512)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:216)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.createAndRunQuery(JFLoopQueryTestcase.java:187)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testFileQuery(JFLoopQueryTestcase.java:536)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testRunQueryLoopImpl(JFLoopQueryTestcase.java:591)
	at com.ibm.ws.query.tests.JFLoopQueryTest.testRunQueryLoop(JFLoopQueryTest.java:265)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.extensions.jfunc.TestletWrapper.runBare(TestletWrapper.java:116)
	at junit.extensions.jfunc.TestletWrapper$1.protect(TestletWrapper.java:106)
	at junit.framework.TestResult.runProtected(Unknown Source)
	at junit.extensions.jfunc.TestletWrapper.run(TestletWrapper.java:109)
	at junit.framework.TestSuite.runTest(Unknown Source)
	at junit.framework.TestSuite.run(Unknown Source)
	at junit.extensions.jfunc.JFuncSuite.run(JFuncSuite.java:134)
	at junit.extensions.jfunc.textui.JFuncRunner.doRun(JFuncRunner.java:76)
	at junit.extensions.jfunc.textui.JFuncRunner.start(JFuncRunner.java:398)
	at junit.extensions.jfunc.textui.JFuncRunner.main(JFuncRunner.java:218)
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: Syntax error: Encountered ""WHERE"" at line 1, column 520. {SELECT t2.empid, t2.bonus, t3.deptno, t3.budget, t3.name, t2.execLevel, t2.hireDate, t2.hireTime, t2.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t2.isManager, t2.name, t2.salary, t5.street, t5.city, t5.state, t5.zip FROM DeptBean t0 INNER JOIN EmpBean t1 ON t0.deptno = t1.dept_deptno LEFT OUTER JOIN DeptBean t3 ON t2.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t2.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t2.work_street = t5.street WHERE (t2.empid > ANY((SELECT t1.empid FROM  WHERE (CAST(t0.deptno AS BIGINT) = CAST(? AS BIGINT)))))} [code=30000, state=42X01]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:193)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$6(LoggingConnectionDecorator.java:189)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:217)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:137)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1305)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:149)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:463)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:443)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:322)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:295)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:397)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:208)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:198)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:91)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:31)
	... 26 more
NestedThrowables:
ERROR 42X01: Syntax error: Encountered ""WHERE"" at line 1, column 520.
	at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)
	at org.apache.derby.impl.sql.compile.ParserImpl.parseStatement(Unknown Source)
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(Unknown Source)
	at org.apache.derby.impl.sql.GenericStatement.prepare(Unknown Source)
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.<init>(Unknown Source)
	at org.apache.derby.jdbc.Driver30.newEmbedPreparedStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)
	at org.apache.commons.dbcp.DelegatingConnection.prepareStatement(DelegatingConnection.java:185)
	at org.apache.commons.dbcp.PoolingDataSource$PoolGuardConnectionWrapper.prepareStatement(PoolingDataSource.java:278)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:162)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:214)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:137)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1305)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:149)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:463)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:443)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:322)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:295)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:397)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:208)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:198)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:91)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:31)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1161)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:936)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:746)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:716)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:712)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:512)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:216)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.createAndRunQuery(JFLoopQueryTestcase.java:187)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testFileQuery(JFLoopQueryTestcase.java:536)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testRunQueryLoopImpl(JFLoopQueryTestcase.java:591)
	at com.ibm.ws.query.tests.JFLoopQueryTest.testRunQueryLoop(JFLoopQueryTest.java:265)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.extensions.jfunc.TestletWrapper.runBare(TestletWrapper.java:116)
	at junit.extensions.jfunc.TestletWrapper$1.protect(TestletWrapper.java:106)


SUGGESTED SQL PUSHDOWN:
select t0.empid, t0.bonus, t2.deptno, t2.budget, t2.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t3.street, t3.city, t3.state, t3.zip, t0.isManager, t0.name, t0.salary, t4.street, t4.city, t4.state, t4.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t2 ON t0.dept_deptno = t2.deptno LEFT OUTER JOIN AddressBean t3 ON t0.home_street = t3.street LEFT OUTER JOIN AddressBean t4 ON t0.work_street = t4.street WHERE t0.empid > ANY((select t5.empid FROM DeptBean t4 INNER JOIN EmpBean t5 ON t4.deptno = t5.dept_deptno  WHERE (CAST(t4.deptno AS BIGINT) = ?))) {int 200}

",20/Sep/06 01:14;ghongell;entity java files and derby ddl script to use to recreate this issue,"26/Apr/07 07:42;fancy;Abe, 
I am working on issue OPENJPA-51 for David Wisneski.
I need some education before attempting to resolve this issue.
How aliases in the subqueries are created and resolved ?
Consider the following 2 queries:
    1. select o from Customer c, in(c.orders)o where o.amount > (select sum(o2.amount) from c.orders o2)
     2. select o from Order where o.amount > (select sum(o2.amount) from Customer c, in(c.orders) o2)

Aside from the semantic difference, in the 2 queries, the syntax difference is where ""Customer c "" is defined.
When Customer c is defined in the subquery, the generated SQL has syntax error, essentially the FROM clause is missing the body and t2 in the selections is undefined:
SELECT t2.oid, t2.version, t2.amount, t2.customer_countryCode, t2.customer_id, t2.delivered 
FROM TCUSTOMER t0 INNER JOIN TORDER t1 ON t0.countryCode = t1.customer_countryCode AND t0.id = t1.customer_id WHERE (t2.amount > (SELECT SUM(t1.amount) FROM  ))

Under the debugger, it shows in which SelectImpl the aliases/tables are created/defined:

    Query 1:                            _aliases                          _tables
       SelectImpl (main):    TCUSTOMER=0              0=TCUSTOMER t0
                                           TORDER=1                      1=TORDER t1
                                           ""oders.o""
       SelectImpl(subQ):    TORDER=2                       2=TORDER t2
                                           ""orders""
                                           TORDER=3
                                           ""jpqlalias1:""

   Query 2 (all aliase/tables are in the main SelectImpl, null in subQ's SelectImpl)
     SelectImpl(main):       TCUSTOMER=0                  0=TCUSTOMER t0
                                           ""jpqlalias1:""
                                           TORDER=1                          1=TORDER t1
                                           ""jpqlalias1:.orders.o2""
                                           TORDER=2                           2=TORDER t2
                                            
      
It seems to me that openjpa assumes the alias defined in subquery is always derived from (i.e. correlated to) the main select.
Correct me if I am wrong.
I have tried changing the method in SelectImpl.findAlias(Table....)
 to call  recordTableAlias() for subselect when the alias was found in parent select by the following code fragment:
          if (!fromParent && _parent != null) {
            boolean removeFromParent = key.toString().contains("":"");  //+
            alias = _parent.findAlias(table, key, removeFromParent, this);  //false => removeFromParent
            if (alias != null) {
                if (removeFromParent)                     //+
                    recordTableAlias(table, key, alias);  //+
                return alias;
            }
        }

after this change, the SQL generates OK, but I do not think it is correct, because the subselect is missing the join predicate (missing where clause) for the path c.orders.
In debugging, I saw selectJoins for c.order s were created; one for the parent select and one for the subselect. But somehow the one created for subselect disappeared 
( or never got set in SelectImpl's _join field for subselect), the main SelectImpl's _join field seems to have the selectJoin for c.orders 
( but no SQL predicate was generated out of this selectJoin). 
Should the selectionJoin on the parent be moved to subselect ? How/When should this be done? 
Am I on the right track of resolving this issue? 
Your input is much appreciated.

Catalina
","02/May/07 01:27;fancy;Abe,
Could you please verify and comment on the patch I am providing for this issue.
Thanks.","02/May/07 16:02;awhite;I don't remember how any of that stuff works at all.  However, the following line in findAlias is suspect:

_removeAliasFromParent = key.toString().contains("":"");

findAlias is called a lot with different keys.  Setting a member field that is used in other methods based
on whether the latest key happens to match a certain criteria seems like it could lead to arbitrary
results in different circumstances.  If there is a continuous thread of logic that links the last call to
findAlias with the other methods where _removeAliasFromParent is used, it needs to be make more
explicit.","02/May/07 17:51;fancy;Abe,
Based on your comment, I have revised my patch. 
Please verify if the new patch is a better solution.
Thanks.","02/May/07 18:44;awhite;No, this is no better.  And now you've changed the meaning of the code.  Before, the remove-from-parent
logic was based on the key to the last call to findAlias.  Now it's based on the key to any previous call to findAlias
(so long as 0 <= alias <= 16 ??!!).  The fact that you changed the meaning of the patch seemingly without intent
and still feel it is correct doesn't give me any confidence in it.

p.s. The boolean array is pointless since you never flip the
boolean values -- you only ever set to true that I see, and then test if any index is true later.  So you could just as 
easily get by with a single boolean where you ""|="" its value each time.

p.p.s. I notice that you also have a ""boolean removed = false"" 
local declared in one method and you never change its value, making the local pointless too, unless
you meant to assign it a new value based on something somewhere.","02/May/07 19:59;fancy;Abe,
I make some mistake in my previous patch, attaching a revised version.
your conceren about removedAliasFromParent[] flag once set, was never reset;  that is purposely done.
In case any flag (base on number of aliases created so far) is on, there is potentially duplicate joins in the parent select (those joins were initially created for aliases initially attached in parent which was removed from parent, and now attached on subselect),  we need to remove the duplicate joins on the parent, since there is one also created for subselect. The duplicate joins once removed, will never be seen on the next call to removeJoinsFromParent().
The local boolean flag is set when joins are indeed removed from parent. Otherwise the normal processing of removing duplcate joins from subselect is performed.

I think there is a much better solution to this issue, that is to create SelectImpl when a ""SELECT"" is encountered, rather than delaying it later as it is currently done. 
Current code creates aliases for the subselect to come later -- in the middle of alias creating for subselect, there isn't a SelectImpl created for subselect yet.. So the alias is temporarily attached under the parent SelectImpl.  (This could be based on the assumption that any alias defined in subselect is correated to outer subselect). ","02/May/07 20:28;awhite;OK, I see.  You still shouldn't be using a fixed array.  Use a BitSet.  

As to the rest... as I said before, I don't remember how this stuff works.  So it could be wrong
and I wouldn't know it without doing more code-diving than I have time for.  It's our fault for 
not having enough tests checked into OpenJPA.  So after changing it to use a BitSet, 
assuming it passes all your tests, I'd vote to commit it.  Once that happens we'll see how it
fairs against our more extensive Kodo test suite.",02/May/07 21:41;wisneskid;fixed in r534623,"04/May/07 15:44;awhite;I have to reopen this, as the fix is causing a regression in our test suite.  Given an entity EntityA with a field ""b"" of type EntityB, the following JPQL:

select a from EntityA a where 
  exists (select b from a.b b where b.intfield = 1) 
    or 
  exists (select b from a.b b where b.intfield = 0)

is getting translated to:

SELECT t1.ID, t1.TYP, t1.A FROM ENTITYA t1 WHERE (
  EXISTS (SELECT t0.ID FROM ENTITYB t0 WHERE t0.INTFIELD = 1 AND t1.B = t0.ID))
   OR
  EXISTS (SELECT t2.ID FROM ENTITYB t2, ENTITYA t3 WHERE t2.INTFIELD = 0 AND t3.B = t2.ID))
)

Notice that the first correlated subselect is fine, but the second has lost its correlation -- it creates a new alias for  EntityA's table. ","04/May/07 18:27;fancy;Abe,
Is it really a regression?  I replaced the copy of SelectImpl with revision 52881 (the original without my fixes),
the similar query I ran gets ""missing FROM body"":

1078  demo  TRACE  [main] openjpa.Query - Executing query: select c from Customer c where exists(select o from c.orders o where o.oid = 1) or exists(select o from c.orders o where o.oid = 2)
1156  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1643274738> executing prepstmnt 2138865532 SELECT t0.countryCode, t0.id, t0.version, t0.city, t0.state, t0.street, t0.zip, t0.name FROM  WHERE (EXISTS (SELECT t2.oid FROM TORDER t2 WHERE (CAST(t2.oid AS BIGINT) = CAST(? AS BIGINT) AND t1.oid = t2.oid) AND t0.countryCode = t1.customer_countryCode AND t0.id = t1.customer_id ) OR EXISTS (SELECT t3.oid FROM TORDER t3 WHERE (CAST(t3.oid AS BIGINT) = CAST(? AS BIGINT) AND t1.oid = t3.oid) AND t0.countryCode = t1.customer_countryCode AND t0.id = t1.customer_id ))  [params=(long) 1, (long) 2]
1172  demo  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 1643274738> [16 ms] spent
1172  demo  TRACE  [main] openjpa.jdbc.JDBC - <t 1094861122, conn 0> [0 ms] close
Exception: <0.0.0 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: DB2 SQL error: SQLCODE: -104, SQLSTATE: 42601, SQLERRMC: (;t0.name FROM  WHERE;WHERE {prepstmnt 2138865532 SELECT t0.countryCode, t0.id, t0.version, t0.city, t0.state, t0.street, t0.zip, t0.name FROM  WHERE (EXISTS (SELECT t2.oid FROM TORDER t2 WHERE (CAST(t2.oid AS BIGINT) = CAST(? AS BIGINT) AND t1.oid = t2.oid) AND t0.countryCode = t1.customer_countryCode AND t0.id = t1.customer_id ) OR EXISTS (SELECT t3.oid FROM TORDER t3 WHERE (CAST(t3.oid AS BIGINT) = CAST(? AS BIGINT) AND t1.oid = t3.oid) AND t0.countryCode = t1.customer_countryCode AND t0.id = t1.customer_id ))  [params=(long) 1, (long) 2]} [code=-104, state=42601]SQLCA OUTPUT[Errp=SQLNP012, Errd=[-2145779603, 0, 0, 0, -705, 0]]
<0.0.0 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: DB2 SQL error: SQLCODE: -104, SQLSTATE: 42601, SQLERRMC: (;t0.name FROM  WHERE;WHERE {prepstmnt 2138865532 SELECT t0.countryCode, t0.id, t0.version, t0.city, t0.state, t0.street, t0.zip, t0.name FROM  WHERE (EXISTS (SELECT t2.oid FROM TORDER t2 WHERE (CAST(t2.oid AS BIGINT) = CAST(? AS BIGINT) AND t1.oid = t2.oid) AND t0.countryCode = t1.customer_countryCode AND t0.id = t1.customer_id ) OR EXISTS (SELECT t3.oid FROM TORDER t3 WHERE (CAST(t3.oid AS BIGINT) = CAST(? AS BIGINT) AND t1.oid = t3.oid) AND t0.countryCode = t1.customer_countryCode AND t0.id = t1.customer_id ))  [params=(long) 1, (long) 2]} [code=-104, state=42601]SQLCA OUTPUT[Errp=SQLNP012, Errd=[-2145779603, 0, 0, 0, -705, 0]]

Are you sure your query ever worked before this fix ?
","07/May/07 16:02;awhite;Yes, the test was passing before.  Have you tried against a to-one relation rather than a to-many?
Perhaps it was never working against a to-many.","07/May/07 21:34;fancy;Abe,
You are right, the code before theispatch  (SelectImpl.java revision 52881) worked for to-one relation, 
but never worked for to-many relation.

Do you have any idea of fixing this problem?","09/May/07 22:02;mprudhom;This patch caused 17 TCK tests to start failing, so it needs to be reverted as soon as possible.","14/May/07 20:03;fancy;Abe,
Could you please verify if this patch regress your tests ?
thanks.",22/Jun/07 01:11;fancy;The attached patch  passed TCK on derby.,"14/Jul/08 04:10;fancy;A sub-task OPENJPA-658 is opened for outstanding issues remaining in subqueries.
Fix committed under r676467 is for  subqueries that are not correlated to its outer select,
examples:

   1.     ""select o.oid from Order o where o.customer.name ="" +
                "" (select max(o2.customer.name) from Order o2"" +
                "" where o.customer.cid.id = o2.customer.cid.id)"",
    2.    ""select o from Order o where o.customer.name ="" +
                "" (select max(o2.customer.name) from Order o2"" +
                "" where o.customer.cid.id = o2.customer.cid.id)"",
",14/Jul/08 17:05;fancy;fix in 1.0.3 and 1.2.0,"15/Jul/08 02:17;fancy;The query string with the following subquery resulting a SQL with syntax error:
""select o1.oid from Order o1 where o1.oid in "" +
            "" (select distinct o.oid from OrderItem i, Order o"" +
            "" where i.quantity > 10 and o.amount > 1000 and i.lid = o.oid)""

This kind of subquery is more like a SQL style subquery, and subquery is not correlated to its outer query.

Rather than creating yet another sub-task (OPENJPA-658, sub-task of this issue addressing some outstanding subquery problems),
the fix for this subquery problem is checked in under this issue, - svn  revision : r676787.
","07/Aug/09 21:24;dezzio;From trunk, merged fix to 1.1.x branch at 802200",,,,,,,,,,,,,,,,
"bad sql pushdown, cast changes datatype",OPENJPA-50,12350211,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ghongell,ghongell,19/Sep/06 01:08,01/Mar/07 02:20,14/Mar/19 03:02,01/Mar/07 02:20,,,,,,,,,,0.9.7,,,,,query,,,,,,0,,"444 - bad sql pushdown, cast changes datatype
 TEST444; select e from EmpBean e where e.salary > 5 and abs(e.salary) > 12
28203  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 295440796> [0 ms] executing prepstmnt 1712481810 SELECT t0.empid, t0.bonus, t1.deptno, t1.budget, t1.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t2.street, t2.city, t2.state, t2.zip, t0.isManager, t0.name, t0.salary, t3.street, t3.city, t3.state, t3.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno LEFT OUTER JOIN AddressBean t2 ON t0.home_street = t2.street LEFT OUTER JOIN AddressBean t3 ON t0.work_street = t3.street WHERE (CAST(t0.salary AS DOUBLE) > CAST(? AS DOUBLE) AND CAST(ABS(t0.salary) AS BIGINT) > CAST(? AS BIGINT)) [params=(long) 5, (long) 12]
select t0.empid, t0.salary  FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno WHERE (CAST(t0.salary AS DOUBLE) > ?) AND (CAST(ABS(t0.salary) AS BIGINT) > ?) {long 5, long 12}

why CAST(ABS(t0.salary) AS BIGINT)?????????
select t0.empid, t0.salary  FROM EmpBean t0 WHERE (CAST(t0.salary AS DOUBLE) > ?) AND (CAST(ABS(t0.salary) AS BIGINT) > ?) {long 5, long 12}
s/b
select t0.empid, t0.salary  FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno WHERE (CAST(t0.salary AS DOUBLE) > ?) AND (CAST(ABS(t0.salary) AS DOUBLE) > ?) {long 5, long 12}

  [ FAILED 444- bucket = fvtfull, query = select e from EmpBean e where e.salary > 5 and abs(e.salary) > 12 : 
   EXPECTED(
 TEST444; select e from EmpBean e where e.salary > 5 and abs(e.salary) > 12
EmpBean 
~~~~~~~ 
  [1]   
  [2]   
  [3]   
 TEST444; 3 tuples) 
   ACTUAL(
 TEST444; select e from EmpBean e where e.salary > 5 and abs(e.salary) > 12
EmpBean 
~~~~~~~ 
  [2]   
  [3]   
 TEST444; 2 tuples) ]


","Windows xp, db2, derby",,,,,,,,,,,,,,,,,,,,,19/Sep/06 23:50;ghongell;failureEntities.jar;https://issues.apache.org/jira/secure/attachment/12341164/failureEntities.jar,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-02-01 01:52:54.933,,,no_permission,,,,,,,,,,,160387,,,Thu Feb 01 01:52:54 UTC 2007,,,,,,,0|i0z6jr:,203363,,,,,,,,"19/Sep/06 23:49;ghongell;removed testcase references.
run on version 443432.

EJBQL:
select e from EmpBean e where e.salary > 5 and abs(e.salary) > 12
 
OPENJPA ERROR OR SQL PUSHDOWN:
returns 2 entitie instances but should return 3

28203  TRACE  [main] openjpa.jdbc.SQL - <t 1094861122, conn 295440796> [0 ms] executing prepstmnt 1712481810 SELECT t0.empid, t0.bonus, t1.deptno, t1.budget, t1.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t2.street, t2.city, t2.state, t2.zip, t0.isManager, t0.name, t0.salary, t3.street, t3.city, t3.state, t3.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno LEFT OUTER JOIN AddressBean t2 ON t0.home_street = t2.street LEFT OUTER JOIN AddressBean t3 ON t0.work_street = t3.street WHERE (CAST(t0.salary AS DOUBLE) > CAST(? AS DOUBLE) AND CAST(ABS(t0.salary) AS BIGINT) > CAST(? AS BIGINT)) [params=(long) 5, (long) 12]
select t0.empid, t0.salary  FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno WHERE (CAST(t0.salary AS DOUBLE) > ?) AND (CAST(ABS(t0.salary) AS BIGINT) > ?) {long 5, long 12}

why CAST(ABS(t0.salary) AS BIGINT)?????????

SUGGESTED SQL PUSHDOWN:
select t0.empid, t0.bonus, t1.deptno, t1.budget, t1.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t2.street, t2.city, t2.state, t2.zip, t0.isManager, t0.name, t0.salary, t3.street, t3.city, t3.state, t3.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno LEFT OUTER JOIN AddressBean t2 ON t0.home_street = t2.street LEFT OUTER JOIN AddressBean t3 ON t0.work_street = t3.street  WHERE (CAST(t0.salary AS DOUBLE) > ?) AND (CAST(ABS(t0.salary) AS DOUBLE) > ?) {long 5, long 12}

",19/Sep/06 23:50;ghongell;entity java files and derby ddl script to use to recreate this issue,01/Feb/07 01:52;wisneskid;fixed in recent code,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 parsing error - cast of subselect does not work,OPENJPA-48,12350208,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ghongell,ghongell,19/Sep/06 00:47,01/Mar/07 02:20,14/Mar/19 03:02,01/Mar/07 02:20,,,,,,,,,,0.9.7,,,,,query,,,,,,0,,"163 - parsing error - cast of subselect does not work
 TEST163; select e from EmpBean e where e.salary + 100 > all (select e1.salary  from EmpBean e1 left join e1.dept d where d.no = 20)
Syntax error: Encountered ""ALL"" at line 1, column 484. {SELECT t0.empid, t0.bonus, t3.deptno, t3.budget, t3.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t0.isManager, t0.name, t0.salary, t5.street, t5.city, t5.state, t5.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t3 ON t0.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t0.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t0.work_street = t5.street WHERE ((CAST(t0.salary AS DOUBLE) + CAST(? AS DOUBLE)) > CAST(ALL((SELECT t1.salary FROM EmpBean t1, DeptBean t2 WHERE (CAST(t2.deptno AS BIGINT) = CAST(? AS BIGINT)) AND t1.dept_deptno = t2.deptno)) AS DOUBLE))} [code=30000, state=42X01] 
  {double 100, int 20}

this works
select t0.empid, t0.salary FROM EmpBean t0 LEFT OUTER JOIN DeptBean t3 ON t0.dept_deptno = t3.deptno WHERE ((CAST(t0.salary AS DOUBLE) + CAST(? AS DOUBLE)) > ALL (SELECT t1.salary FROM EmpBean t1, DeptBean t2 WHERE (CAST(t2.deptno AS BIGINT) = CAST(? AS BIGINT)) AND t1.dept_deptno = t2.deptno))  {double 100, int 20}

<0|false|0.0.0> org.apache.openjpa.persistence.PersistenceException: Syntax error: Encountered ""ALL"" at line 1, column 484. {SELECT t0.empid, t0.bonus, t3.deptno, t3.budget, t3.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t0.isManager, t0.name, t0.salary, t5.street, t5.city, t5.state, t5.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t3 ON t0.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t0.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t0.work_street = t5.street WHERE ((CAST(t0.salary AS DOUBLE) + CAST(? AS DOUBLE)) > CAST(ALL((SELECT t1.salary FROM EmpBean t1, DeptBean t2 WHERE (CAST(t2.deptno AS BIGINT) = CAST(? AS BIGINT)) AND t1.dept_deptno = t2.deptno)) AS DOUBLE))} [code=30000, state=42X01]
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3713)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:94)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:80)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:56)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.handleCheckedException(SelectResultObjectProvider.java:152)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:37)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1161)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:936)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:746)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:716)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:712)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:512)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:216)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.createAndRunQuery(JFLoopQueryTestcase.java:187)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testFileQuery(JFLoopQueryTestcase.java:536)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testRunQueryLoopImpl(JFLoopQueryTestcase.java:591)
	at com.ibm.ws.query.tests.JFLoopQueryTest.testRunQueryLoop(JFLoopQueryTest.java:265)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.extensions.jfunc.TestletWrapper.runBare(TestletWrapper.java:116)
	at junit.extensions.jfunc.TestletWrapper$1.protect(TestletWrapper.java:106)
	at junit.framework.TestResult.runProtected(Unknown Source)
	at junit.extensions.jfunc.TestletWrapper.run(TestletWrapper.java:109)
	at junit.framework.TestSuite.runTest(Unknown Source)
	at junit.framework.TestSuite.run(Unknown Source)
	at junit.extensions.jfunc.JFuncSuite.run(JFuncSuite.java:134)
	at junit.extensions.jfunc.textui.JFuncRunner.doRun(JFuncRunner.java:76)
	at junit.extensions.jfunc.textui.JFuncRunner.start(JFuncRunner.java:398)
	at junit.extensions.jfunc.textui.JFuncRunner.main(JFuncRunner.java:218)
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: Syntax error: Encountered ""ALL"" at line 1, column 484. {SELECT t0.empid, t0.bonus, t3.deptno, t3.budget, t3.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t0.isManager, t0.name, t0.salary, t5.street, t5.city, t5.state, t5.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t3 ON t0.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t0.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t0.work_street = t5.street WHERE ((CAST(t0.salary AS DOUBLE) + CAST(? AS DOUBLE)) > CAST(ALL((SELECT t1.salary FROM EmpBean t1, DeptBean t2 WHERE (CAST(t2.deptno AS BIGINT) = CAST(? AS BIGINT)) AND t1.dept_deptno = t2.deptno)) AS DOUBLE))} [code=30000, state=42X01]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:193)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$6(LoggingConnectionDecorator.java:189)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:217)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:137)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1305)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:149)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:463)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:443)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:322)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:295)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:397)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:208)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:198)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:91)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:31)
	... 26 more
NestedThrowables:
ERROR 42X01: Syntax error: Encountered ""ALL"" at line 1, column 484.
	at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)
	at org.apache.derby.impl.sql.compile.ParserImpl.parseStatement(Unknown Source)
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(Unknown Source)
	at org.apache.derby.impl.sql.GenericStatement.prepare(Unknown Source)
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.<init>(Unknown Source)
	at org.apache.derby.jdbc.Driver30.newEmbedPreparedStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)
	at org.apache.commons.dbcp.DelegatingConnection.prepareStatement(DelegatingConnection.java:185)
	at org.apache.commons.dbcp.PoolingDataSource$PoolGuardConnectionWrapper.prepareStatement(PoolingDataSource.java:278)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:162)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:214)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:137)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1305)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:149)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:463)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:443)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:322)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:295)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:397)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:208)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:198)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:91)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:31)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1161)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:936)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:746)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:716)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:712)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:512)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:216)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.createAndRunQuery(JFLoopQueryTestcase.java:187)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testFileQuery(JFLoopQueryTestcase.java:536)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testRunQueryLoopImpl(JFLoopQueryTestcase.java:591)
	at com.ibm.ws.query.tests.JFLoopQueryTest.testRunQueryLoop(JFLoopQueryTest.java:265)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.extensions.jfunc.TestletWrapper.runBare(TestletWrapper.java:116)
	at junit.extensions.jfunc.TestletWrapper$1.protect(TestletWrapper.java:106)
	at junit.framework.TestResult.runProtected(Unknown Source)
	at junit.extensions.jfunc.TestletWrapper.run(TestletWrapper.java:109)
	at junit.framework.TestSuite.runTest(Unknown Source)
	at junit.framework.TestSuite.run(Unknown Source)
	at junit.extensions.jfunc.JFuncSuite.run(JFuncSuite.java:134)
	at junit.extensions.jfunc.textui.JFuncRunner.doRun(JFuncRunner.java:76)
	at junit.extensions.jfunc.textui.JFuncRunner.start(JFuncRunner.java:398)
	at junit.extensions.jfunc.textui.JFuncRunner.main(JFuncRunner.java:218)
 TEST163; select e from EmpBean e where e.salary + 100 > all (select e1.salary  from EmpBean e1 left join e1.dept d where d.no = 20)
                                                                                                                                                                                                                                                                                                                                                                     e                                                                                                                                                                                                                                                                                                                                                                      
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
Syntax error: Encountered ""ALL"" at line 1, column 484. {SELECT t0.empid, t0.bonus, t3.deptno, t3.budget, t3.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t0.isManager, t0.name, t0.salary, t5.street, t5.city, t5.state, t5.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t3 ON t0.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t0.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t0.work_street = t5.street WHERE ((CAST(t0.salary AS DOUBLE) + CAST(? AS DOUBLE)) > CAST(ALL((SELECT t1.salary FROM EmpBean t1, DeptBean t2 WHERE (CAST(t2.deptno AS BIGINT) = CAST(? AS BIGINT)) AND t1.dept_deptno = t2.deptno)) AS DOUBLE))} [code=30000, state=42X01] 
 TEST163; 1 tuple

","Windows xp, derby and db2",,,,,,,,,,,,,,,,,,,,,19/Sep/06 23:11;ghongell;failureEntities.jar;https://issues.apache.org/jira/secure/attachment/12341162/failureEntities.jar,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-02-01 01:49:54.348,,,no_permission,,,,,,,,,,,160385,,,Thu Feb 01 01:49:54 UTC 2007,,,,,,,0|i0z6e7:,203338,,,,,,,,"19/Sep/06 23:10;ghongell;removed testcase references.
run on version 443432.

EJBQL:
select e from EmpBean e where e.salary + 100 > all (select e1.salary  from EmpBean e1 left join e1.dept d where d.no = 20)
 
OPENJPA ERROR OR SQL PUSHDOWN:
<0|false|0.0.0> org.apache.openjpa.persistence.PersistenceException: Syntax error: Encountered ""ALL"" at line 1, column 484. {SELECT t0.empid, t0.bonus, t3.deptno, t3.budget, t3.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t0.isManager, t0.name, t0.salary, t5.street, t5.city, t5.state, t5.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t3 ON t0.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t0.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t0.work_street = t5.street WHERE ((CAST(t0.salary AS DOUBLE) + CAST(? AS DOUBLE)) > CAST(ALL((SELECT t1.salary FROM EmpBean t1, DeptBean t2 WHERE (CAST(t2.deptno AS BIGINT) = CAST(? AS BIGINT)) AND t1.dept_deptno = t2.deptno)) AS DOUBLE))} [code=30000, state=42X01]
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3713)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:94)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:80)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:56)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.handleCheckedException(SelectResultObjectProvider.java:152)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:37)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1161)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:936)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:746)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:716)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:712)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:512)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:216)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.createAndRunQuery(JFLoopQueryTestcase.java:187)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testFileQuery(JFLoopQueryTestcase.java:536)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testRunQueryLoopImpl(JFLoopQueryTestcase.java:591)
	at com.ibm.ws.query.tests.JFLoopQueryTest.testRunQueryLoop(JFLoopQueryTest.java:265)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.extensions.jfunc.TestletWrapper.runBare(TestletWrapper.java:116)
	at junit.extensions.jfunc.TestletWrapper$1.protect(TestletWrapper.java:106)
	at junit.framework.TestResult.runProtected(Unknown Source)
	at junit.extensions.jfunc.TestletWrapper.run(TestletWrapper.java:109)
	at junit.framework.TestSuite.runTest(Unknown Source)
	at junit.framework.TestSuite.run(Unknown Source)
	at junit.extensions.jfunc.JFuncSuite.run(JFuncSuite.java:134)
	at junit.extensions.jfunc.textui.JFuncRunner.doRun(JFuncRunner.java:76)
	at junit.extensions.jfunc.textui.JFuncRunner.start(JFuncRunner.java:398)
	at junit.extensions.jfunc.textui.JFuncRunner.main(JFuncRunner.java:218)
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: Syntax error: Encountered ""ALL"" at line 1, column 484. {SELECT t0.empid, t0.bonus, t3.deptno, t3.budget, t3.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t0.isManager, t0.name, t0.salary, t5.street, t5.city, t5.state, t5.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t3 ON t0.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t0.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t0.work_street = t5.street WHERE ((CAST(t0.salary AS DOUBLE) + CAST(? AS DOUBLE)) > CAST(ALL((SELECT t1.salary FROM EmpBean t1, DeptBean t2 WHERE (CAST(t2.deptno AS BIGINT) = CAST(? AS BIGINT)) AND t1.dept_deptno = t2.deptno)) AS DOUBLE))} [code=30000, state=42X01]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:193)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$6(LoggingConnectionDecorator.java:189)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:217)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:137)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1305)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:149)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:463)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:443)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:322)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:295)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:397)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:208)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:198)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:91)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:31)
	... 26 more
NestedThrowables:
ERROR 42X01: Syntax error: Encountered ""ALL"" at line 1, column 484.
	at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)
	at org.apache.derby.impl.sql.compile.ParserImpl.parseStatement(Unknown Source)
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(Unknown Source)
	at org.apache.derby.impl.sql.GenericStatement.prepare(Unknown Source)
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.<init>(Unknown Source)
	at org.apache.derby.jdbc.Driver30.newEmbedPreparedStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)
	at org.apache.commons.dbcp.DelegatingConnection.prepareStatement(DelegatingConnection.java:185)
	at org.apache.commons.dbcp.PoolingDataSource$PoolGuardConnectionWrapper.prepareStatement(PoolingDataSource.java:278)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:162)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:214)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:137)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:160)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1305)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:149)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:463)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:443)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:322)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:295)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:397)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:208)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:198)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:91)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:31)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1161)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:936)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:746)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:716)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:712)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:512)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:216)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.createAndRunQuery(JFLoopQueryTestcase.java:187)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testFileQuery(JFLoopQueryTestcase.java:536)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testRunQueryLoopImpl(JFLoopQueryTestcase.java:591)
	at com.ibm.ws.query.tests.JFLoopQueryTest.testRunQueryLoop(JFLoopQueryTest.java:265)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.extensions.jfunc.TestletWrapper.runBare(TestletWrapper.java:116)
	at junit.extensions.jfunc.TestletWrapper$1.protect(TestletWrapper.java:106)
	at junit.framework.TestResult.runProtected(Unknown Source)
	at junit.extensions.jfunc.TestletWrapper.run(TestletWrapper.java:109)
	at junit.framework.TestSuite.runTest(Unknown Source)
	at junit.framework.TestSuite.run(Unknown Source)
	at junit.extensions.jfunc.JFuncSuite.run(JFuncSuite.java:134)
	at junit.extensions.jfunc.textui.JFuncRunner.doRun(JFuncRunner.java:76)
	at junit.extensions.jfunc.textui.JFuncRunner.start(JFuncRunner.java:398)
	at junit.extensions.jfunc.textui.JFuncRunner.main(JFuncRunner.java:218)
 
SUGGESTED SQL PUSHDOWN:
select t0.empid, t0.bonus, t3.deptno, t3.budget, t3.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp, t4.street, t4.city, t4.state, t4.zip, t0.isManager, t0.name, t0.salary, t5.street, t5.city, t5.state, t5.zip FROM EmpBean t0 LEFT OUTER JOIN DeptBean t3 ON t0.dept_deptno = t3.deptno LEFT OUTER JOIN AddressBean t4 ON t0.home_street = t4.street LEFT OUTER JOIN AddressBean t5 ON t0.work_street = t5.street WHERE ((CAST(t0.salary AS DOUBLE) + CAST(? AS DOUBLE)) >  ALL (SELECT t1.salary FROM EmpBean t1, DeptBean t2 WHERE (CAST(t2.deptno AS BIGINT) = CAST(? AS BIGINT)) AND t1.dept_deptno = t2.deptno))  {double 100, int 20}



",19/Sep/06 23:11;ghongell;entity java files and derby ddl script to use to recreate this issue,01/Feb/07 01:49;wisneskid;fixed in recent code,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"true, false not case insensitive, gets null pointer exception",OPENJPA-46,12350202,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,ghongell,ghongell,18/Sep/06 23:59,09/Mar/10 18:35,14/Mar/19 03:02,08/Mar/07 14:32,,,,,,,,,,,,,,,query,,,,,,0,,"140 - true,false should be case insensitive - gets npe
  [ FAILED 140- bucket = fvtfull, query = select e from EmpBean e where (e.isManager = True)  : 
   EXPECTED(
 TEST140; select e from EmpBean e where (e.isManager = True) 
[( class com.dw.test.EmpBean  empid=2 name=andrew salary=13.1 dept=210)]
[( class com.dw.test.EmpBean  empid=1 name=david salary=12.1 dept=210)]
 TEST140; 2 tuples ) 
   ACTUAL(
 TEST140; select e from EmpBean e where (e.isManager = True) 
 e   
~~~~ 
null 
 TEST140; 1 tuple) ]

	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:672)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:934)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:746)
	... 23 more
<4|false|0.0.0> org.apache.openjpa.persistence.ArgumentException: null
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:755)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:716)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:712)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:512)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:216)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.createAndRunQuery(JFLoopQueryTestcase.java:187)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testFileQuery(JFLoopQueryTestcase.java:536)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testRunQueryLoopImpl(JFLoopQueryTestcase.java:591)
	at com.ibm.ws.query.tests.JFLoopQueryTest.testRunQueryLoop(JFLoopQueryTest.java:265)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.extensions.jfunc.TestletWrapper.runBare(TestletWrapper.java:116)
	at junit.extensions.jfunc.TestletWrapper$1.protect(TestletWrapper.java:106)
	at junit.framework.TestResult.runProtected(Unknown Source)
	at junit.extensions.jfunc.TestletWrapper.run(TestletWrapper.java:109)
	at junit.framework.TestSuite.runTest(Unknown Source)
	at junit.framework.TestSuite.run(Unknown Source)
	at junit.extensions.jfunc.JFuncSuite.run(JFuncSuite.java:134)
	at junit.extensions.jfunc.textui.JFuncRunner.doRun(JFuncRunner.java:76)
	at junit.extensions.jfunc.textui.JFuncRunner.start(JFuncRunner.java:398)
	at junit.extensions.jfunc.textui.JFuncRunner.main(JFuncRunner.java:218)
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.initialize(PCPath.java:362)
	at org.apache.openjpa.jdbc.kernel.exps.CompareEqualExpression.initialize(CompareEqualExpression.java:78)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.initialize(SelectConstructor.java:166)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.newSelect(SelectConstructor.java:115)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.evaluate(SelectConstructor.java:69)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.createWhereSelects(JDBCStoreQuery.java:324)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeQuery(JDBCStoreQuery.java:165)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:672)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:934)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:746)
	... 23 more

141 same
 TEST141; select e from EmpBean e where (e.isManager = fAlSe) 

","windows xp, derby, db2 ",,,,,,,,,,,,,,,,,,,,,19/Sep/06 22:49;ghongell;failureEntities.jar;https://issues.apache.org/jira/secure/attachment/12341158/failureEntities.jar,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160383,,,Tue Sep 19 22:49:36 UTC 2006,,,,,,,0|i1dp2f:,288158,,,,,,,,"19/Sep/06 22:48;ghongell;removed testcase references.

EJBQL:
select e from EmpBean e where (e.isManager = True) 

OPENJPA ERROR OR SQL PUSHDOWN:
 	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:672)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:934)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:746)
	... 23 more
<4|false|0.0.0> org.apache.openjpa.persistence.ArgumentException: null
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:755)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:716)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:712)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:512)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:216)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.createAndRunQuery(JFLoopQueryTestcase.java:187)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testFileQuery(JFLoopQueryTestcase.java:536)
	at com.ibm.ws.query.utils.JFLoopQueryTestcase.testRunQueryLoopImpl(JFLoopQueryTestcase.java:591)
	at com.ibm.ws.query.tests.JFLoopQueryTest.testRunQueryLoop(JFLoopQueryTest.java:265)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.extensions.jfunc.TestletWrapper.runBare(TestletWrapper.java:116)
	at junit.extensions.jfunc.TestletWrapper$1.protect(TestletWrapper.java:106)
	at junit.framework.TestResult.runProtected(Unknown Source)
	at junit.extensions.jfunc.TestletWrapper.run(TestletWrapper.java:109)
	at junit.framework.TestSuite.runTest(Unknown Source)
	at junit.framework.TestSuite.run(Unknown Source)
	at junit.extensions.jfunc.JFuncSuite.run(JFuncSuite.java:134)
	at junit.extensions.jfunc.textui.JFuncRunner.doRun(JFuncRunner.java:76)
	at junit.extensions.jfunc.textui.JFuncRunner.start(JFuncRunner.java:398)
	at junit.extensions.jfunc.textui.JFuncRunner.main(JFuncRunner.java:218)
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.initialize(PCPath.java:362)
	at org.apache.openjpa.jdbc.kernel.exps.CompareEqualExpression.initialize(CompareEqualExpression.java:78)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.initialize(SelectConstructor.java:166)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.newSelect(SelectConstructor.java:115)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.evaluate(SelectConstructor.java:69)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.createWhereSelects(JDBCStoreQuery.java:324)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeQuery(JDBCStoreQuery.java:165)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:672)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:934)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:746)
	... 23 more",19/Sep/06 22:49;ghongell;entity java files and derby ddl script to use to recreate this issue,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
metadata-complete element in orm.xml is ignored,OPENJPA-44,12349669,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,mprudhom,mprudhom,11/Sep/06 23:08,09/Mar/10 18:32,14/Mar/19 03:02,28/Jul/08 22:50,,,,,,,,,,1.2.0,,,,,jpa,,,,,,0,,"The ""metadata-complete"" element of the orm.xml file, described in section 10.1.3.1 of the specification, is silently ignored by OpenJPA.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160381,,,2006-09-11 23:08:07.0,,,,,,,0|i1dp2v:,288160,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Simple orm.xml file causes exception (NPE),OPENJPA-42,12349437,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mprudhom,trisberg,trisberg,07/Sep/06 22:26,09/Mar/10 18:35,14/Mar/19 03:02,10/Sep/06 23:22,,,,,,,,,,,,,,,,,,,,,0,,"This simple orm.xml file causes a NPE - 

<?xml version=""1.0"" encoding=""UTF-8""?>

<entity-mappings xmlns=""http://java.sun.com/xml/ns/persistence/orm""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
    xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence/orm http://java.sun.com/xml/ns/persistence/orm_1_0.xsd""
    version=""1.0"">

  <package>springdeveloper.domain</package>

  <entity class=""Client"" metadata-complete=""false"" access=""FIELD""></entity>
  <entity class=""Manager"" metadata-complete=""false"" access=""FIELD"">
    <attribute-override name=""description"">
      <column name=""DESCR"" length=""2000""/>
    </attribute-override>
  </entity>

</entity-mappings>

I have attached a test case - plainJpa.zip

Same code runs fine with the RI.

This is the output from my run:

/System/Library/Frameworks/JavaVM.framework/Versions/1.5/Home/bin/java -Dfile.encoding=MacRoman -classpath /System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/deploy.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/dt.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/jce.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/plugin.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/sa-jdi.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/charsets.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/classes.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/jconsole.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/jsse.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/laf.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/ui.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ext/apple_provider.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ext/dnsns.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ext/localedata.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ext/sunjce_provider.jar:/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ext/sunpkcs11.jar:/Users/trisberg/Projects/plainJpa/classes:/Users/trisberg/Projects/plainJpa/lib/openjpa-jdbc-0.9.0-incubating-SNAPSHOT.jar:/Users/trisberg/Projects/plainJpa/lib/openjpa-persistence-0.9.0-incubating-SNAPSHOT.jar:/Users/trisberg/Projects/plainJpa/lib/openjpa-lib-0.9.0-incubating-SNAPSHOT.jar:/Users/trisberg/Projects/plainJpa/lib/openjpa-kernel-5-0.9.0-incubating-SNAPSHOT.jar:/Users/trisberg/Projects/plainJpa/lib/commons-collections-3.2.jar:/Users/trisberg/Projects/plainJpa/lib/geronimo-jta_1.0.1B_spec-1.0.1.jar:/Users/trisberg/Projects/plainJpa/lib/geronimo-j2ee-connector_1.5_spec-1.0.1.jar:/Users/trisberg/Projects/plainJpa/lib/commons-pool-1.3.jar:/Users/trisberg/Projects/plainJpa/lib/serp-1.11.0.jar:/Users/trisberg/Projects/plainJpa/lib/hsqldb.jar:/Users/trisberg/Projects/plainJpa/lib/persistence-api-1.0.jar:/Users/trisberg/Projects/plainJpa/lib/commons-logging-1.0.4.jar:/Users/trisberg/Projects/plainJpa/lib/commons-dbcp-1.2.1.jar:/Users/trisberg/Projects/plainJpa/lib/openjpa-persistence-jdbc-0.9.0-incubating-SNAPSHOT.jar:/Users/trisberg/Projects/plainJpa/lib/commons-lang-2.1.jar:/Users/trisberg/Projects/plainJpa/lib/openjpa-kernel-0.9.0-incubating-SNAPSHOT.jar:/Users/trisberg/Projects/plainJpa/lib/openjpa-jdbc-5-0.9.0-incubating-SNAPSHOT.jar springdeveloper.TestApp
OPenJPAVersion:
OpenJPA 0.9.0-incubating-SNAPSHOT
version id: 0.9.0-incubating-SNAPSHOT-r0
revision: 0

os.name: Mac OS X
os.version: 10.4.7
os.arch: ppc

java.version: 1.5.0_06
java.vendor: Apple Computer, Inc.

java.class.path:
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/deploy.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/dt.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/jce.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/plugin.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/sa-jdi.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/charsets.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/classes.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/jconsole.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/jsse.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/laf.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/ui.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ext/apple_provider.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ext/dnsns.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ext/localedata.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ext/sunjce_provider.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ext/sunpkcs11.jar
	/Users/trisberg/Projects/plainJpa/classes
	/Users/trisberg/Projects/plainJpa/lib/openjpa-jdbc-0.9.0-incubating-SNAPSHOT.jar
	/Users/trisberg/Projects/plainJpa/lib/openjpa-persistence-0.9.0-incubating-SNAPSHOT.jar
	/Users/trisberg/Projects/plainJpa/lib/openjpa-lib-0.9.0-incubating-SNAPSHOT.jar
	/Users/trisberg/Projects/plainJpa/lib/openjpa-kernel-5-0.9.0-incubating-SNAPSHOT.jar
	/Users/trisberg/Projects/plainJpa/lib/commons-collections-3.2.jar
	/Users/trisberg/Projects/plainJpa/lib/geronimo-jta_1.0.1B_spec-1.0.1.jar
	/Users/trisberg/Projects/plainJpa/lib/geronimo-j2ee-connector_1.5_spec-1.0.1.jar
	/Users/trisberg/Projects/plainJpa/lib/commons-pool-1.3.jar
	/Users/trisberg/Projects/plainJpa/lib/serp-1.11.0.jar
	/Users/trisberg/Projects/plainJpa/lib/hsqldb.jar
	/Users/trisberg/Projects/plainJpa/lib/persistence-api-1.0.jar
	/Users/trisberg/Projects/plainJpa/lib/commons-logging-1.0.4.jar
	/Users/trisberg/Projects/plainJpa/lib/commons-dbcp-1.2.1.jar
	/Users/trisberg/Projects/plainJpa/lib/openjpa-persistence-jdbc-0.9.0-incubating-SNAPSHOT.jar
	/Users/trisberg/Projects/plainJpa/lib/commons-lang-2.1.jar
	/Users/trisberg/Projects/plainJpa/lib/openjpa-kernel-0.9.0-incubating-SNAPSHOT.jar
	/Users/trisberg/Projects/plainJpa/lib/openjpa-jdbc-5-0.9.0-incubating-SNAPSHOT.jar
	/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/.compatibility/14compatibility.jar

user.dir: /Users/trisberg/Projects/plainJpa

TestApp!
119  INFO   [main] openjpa.Runtime - Starting OpenJPA 0.9.0-incubating-SNAPSHOT
Exception in thread ""main"" <0|false|0.9.0-incubating-SNAPSHOT> org.apache.openjpa.persistence.PersistenceException: null
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:183)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:139)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:171)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:124)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:50)
	at springdeveloper.TestApp.run(TestApp.java:53)
	at springdeveloper.TestApp.main(TestApp.java:27)
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.meta.ClassMetaData.getSuperclassField(ClassMetaData.java:820)
	at org.apache.openjpa.meta.ClassMetaData.resolveDefinedSuperclassFields(ClassMetaData.java:1115)
	at org.apache.openjpa.meta.ClassMetaData.defineSuperclassFields(ClassMetaData.java:1091)
	at org.apache.openjpa.jdbc.meta.MappingRepository.prepareMapping(MappingRepository.java:314)
	at org.apache.openjpa.meta.MetaDataRepository.loadMapping(MetaDataRepository.java:605)
	at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:505)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:300)
	at org.apache.openjpa.jdbc.meta.MappingRepository.getMapping(MappingRepository.java:279)
	at org.apache.openjpa.jdbc.meta.MappingTool.getMapping(MappingTool.java:660)
	at org.apache.openjpa.jdbc.meta.MappingTool.buildSchema(MappingTool.java:731)
	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:630)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:160)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:126)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:164)
	... 6 more

Process finished with exit code 1

","Mac OS X
Java 5 SE
Resource Local

OpenJPA build from SVN  rev. 441247",,,,,,,,,,,,,,,,,,,,,07/Sep/06 22:26;trisberg;ASF.LICENSE.NOT.GRANTED--plainJpa.zip;https://issues.apache.org/jira/secure/attachment/12340421/ASF.LICENSE.NOT.GRANTED--plainJpa.zip,12/Sep/06 02:19;trisberg;OPENJPA-42.zip;https://issues.apache.org/jira/secure/attachment/12340616/OPENJPA-42.zip,03/Oct/06 17:55;mprudhom;orm.xml;https://issues.apache.org/jira/secure/attachment/12342200/orm.xml,,,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2006-09-10 23:22:50.0,,,no_permission,,,,,,,,,,,160379,,,Tue Oct 03 17:55:33 UTC 2006,,,,,,,0|i0z107:,202465,,,,,,,,"10/Sep/06 23:22;mprudhom;The error message is a bad one (which I've committed a fix for), but the cause of it is that the orm.xml file is in error: as I mentioned in OPENJPA-40, the attribute-override element is, AFAIK, only meant to be used to redfine a field declared in a superclass entity. Since Manager doesn't actually have any Entity superclass, OpenJPA's assumption was causing an NPE. A better error message will now be thrown.","11/Sep/06 15:15;trisberg;You are right about the <attribute-override> - got to read the spec more carefully :)

I have been testing the recent MVN version 442043.  I can run without an orm.xml file included but as soon as I include some additional mappings in an orm.xml file I get errors.

Here is some recent output:

This is the command I use to execute:

java -javaagent:./lib/openjpa-kernel-5-0.9.0-incubating-SNAPSHOT.jar -Dfile.encoding=MacRoman -classpath ./classes:./lib/openjpa-jdbc-0.9.0-incubating-SNAPSHOT.jar:./lib/openjpa-persistence-0.9.0-incubating-SNAPSHOT.jar:./lib/openjpa-lib-0.9.0-incubating-SNAPSHOT.jar:./lib/openjpa-kernel-5-0.9.0-incubating-SNAPSHOT.jar:./lib/commons-collections-3.2.jar:./lib/geronimo-jta_1.0.1B_spec-1.0.1.jar:./lib/geronimo-j2ee-connector_1.5_spec-1.0.1.jar:./lib/commons-pool-1.3.jar:./lib/serp-1.11.0.jar:./lib/hsqldb.jar:./lib/persistence-api-1.0.jar:./lib/commons-logging-1.0.4.jar:./lib/commons-dbcp-1.2.1.jar:./lib/openjpa-persistence-jdbc-0.9.0-incubating-SNAPSHOT.jar:./lib/commons-lang-2.1.jar:./lib/openjpa-kernel-0.9.0-incubating-SNAPSHOT.jar:./lib/openjpa-jdbc-5-0.9.0-incubating-SNAPSHOT.jar springdeveloper.TestApp


persistence.xml:
================
<?xml version=""1.0"" encoding=""UTF-8""?>
<persistence xmlns=""http://java.sun.com/xml/ns/persistence"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
             xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"" version=""1.0"">

    <persistence-unit name=""main"" transaction-type=""RESOURCE_LOCAL"">

      <provider>org.apache.openjpa.persistence.PersistenceProviderImpl</provider>

    </persistence-unit>

</persistence>

orm.xml:
========
<?xml version=""1.0"" encoding=""UTF-8""?>

<entity-mappings xmlns=""http://java.sun.com/xml/ns/persistence/orm""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
    xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence/orm http://java.sun.com/xml/ns/persistence/orm_1_0.xsd""
    version=""1.0"">

  <package>springdeveloper.domain</package>

  <entity class=""Client"" metadata-complete=""false"" access=""FIELD"">
  </entity>
  <entity class=""Manager"" metadata-complete=""false"" access=""FIELD"">
    <attributes>
      <basic name=""description"">
        <column name=""DESCR""/>
      </basic>
    </attributes>
  </entity>

</entity-mappings>

run:
====
739  INFO   [main] openjpa.MetaData - Found 2 classes with metadata in 17 milliseconds.
TestApp!
364  INFO   [main] openjpa.Runtime - Starting OpenJPA 0.9.0-incubating-SNAPSHOT
2353  INFO   [main] openjpa.MetaData - Parsing resource ""file:/Users/trisberg/Projects/plainJpa/classes/META-INF/orm.xml"".
2787  INFO   [main] openjpa.MetaData - Parsing class ""springdeveloper.domain.Client"".
2874  WARN   [main] openjpa.Enhance - An exception was thrown while attempting to perform class file transformation on ""springdeveloper/domain/Manager"":
java.lang.ClassCircularityError: springdeveloper/domain/Manager
        at java.lang.Class.getDeclaredFields0(Native Method)
        at java.lang.Class.privateGetDeclaredFields(Class.java:2232)
        at java.lang.Class.getDeclaredFields(Class.java:1715)
        at org.apache.openjpa.meta.AbstractMetaDataDefaults.populateFromReflection(AbstractMetaDataDefaults.java:176)
        at org.apache.openjpa.meta.AbstractMetaDataDefaults.populate(AbstractMetaDataDefaults.java:128)
        at org.apache.openjpa.persistence.PersistenceMetaDataDefaults.populate(PersistenceMetaDataDefaults.java:182)
        at org.apache.openjpa.meta.MetaDataRepository.addMetaData(MetaDataRepository.java:736)
        at org.apache.openjpa.persistence.XMLPersistenceMetaDataParser.startClass(XMLPersistenceMetaDataParser.java:720)
        at org.apache.openjpa.lib.meta.CFMetaDataParser.startElement(CFMetaDataParser.java:101)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.startElement(XMLMetaDataParser.java:427)
        at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:533)
        at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.startElement(XMLSchemaValidator.java:708)
        at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:330)
        at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(XMLDocumentFragmentScannerImpl.java:1693)
        at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:368)
        at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:834)
        at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:764)
        at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:148)
        at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1242)
        at javax.xml.parsers.SAXParser.parse(SAXParser.java:375)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parseNewResource(XMLMetaDataParser.java:371)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:312)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:289)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:263)
        at org.apache.openjpa.persistence.PersistenceMetaDataFactory.parseXML(PersistenceMetaDataFactory.java:237)
        at org.apache.openjpa.persistence.PersistenceMetaDataFactory.load(PersistenceMetaDataFactory.java:188)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:432)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:287)
        at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:164)
        at org.apache.openjpa.enhance.PCClassFileTransformer.transform(PCClassFileTransformer.java:115)
        at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
        at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:56)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:242)
        at org.apache.openjpa.meta.MetaDataRepository.classForName(MetaDataRepository.java:1156)
        at org.apache.openjpa.meta.MetaDataRepository.loadPersistentTypes(MetaDataRepository.java:1144)
        at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:144)
        at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:126)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:164)
        at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:139)
        at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:171)
        at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:124)
        at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:50)
        at springdeveloper.TestApp.run(TestApp.java:48)
        at springdeveloper.TestApp.main(TestApp.java:22)
3663  TRACE  [main] openjpa.jdbc.SQL - <t 2202705, conn 10336536> [0 ms] executing prepstmnt 9136910 SELECT SEQUENCE_SCHEMA, SEQUENCE_NAME FROM INFORMATION_SCHEMA.SYSTEM_SEQUENCES
3784  TRACE  [main] openjpa.jdbc.SQL - <t 2202705, conn 2205493> [5 ms] executing stmnt 4450231 CREATE TABLE Client (id BIGINT NOT NULL, description VARCHAR(255), version INTEGER, manager_id BIGINT, PRIMARY KEY (id))
3788  TRACE  [main] openjpa.jdbc.SQL - <t 2202705, conn 6550654> [1 ms] executing stmnt 9974682 CREATE TABLE Manager (id BIGINT NOT NULL, DESCR VARCHAR(255), PRIMARY KEY (id))
3799  TRACE  [main] openjpa.jdbc.SQL - <t 2202705, conn 4102499> [7 ms] executing stmnt 14712126 CREATE INDEX I_CLIENT_MANAGER ON Client (manager_id)
EM Open? true
Exception in thread ""main"" <4|true|0.9.0-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: Could not locate metadata for the class using alias ""Manager"". Registered alias mappings: ""{Manager=null}""
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:361)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getClassMetaData(JPQLExpressionBuilder.java:166)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.resolveClassMetaData(JPQLExpressionBuilder.java:144)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:213)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:183)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateType(JPQLExpressionBuilder.java:176)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.access$500(JPQLExpressionBuilder.java:63)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.populate(JPQLExpressionBuilder.java:1666)
        at org.apache.openjpa.kernel.jpql.JPQLParser.populate(JPQLParser.java:52)
        at org.apache.openjpa.kernel.ExpressionStoreQuery.populateFromCompilation(ExpressionStoreQuery.java:145)
        at org.apache.openjpa.kernel.QueryImpl.newCompilation(QueryImpl.java:599)
        at org.apache.openjpa.kernel.QueryImpl.compileForCompilation(QueryImpl.java:581)
        at org.apache.openjpa.kernel.QueryImpl.compileForExecutor(QueryImpl.java:608)
        at org.apache.openjpa.kernel.QueryImpl.getOperation(QueryImpl.java:1421)
        at org.apache.openjpa.kernel.DelegatingQuery.getOperation(DelegatingQuery.java:120)
        at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:205)
        at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
        at springdeveloper.MyTest.runQuery(MyTest.java:13)
        at springdeveloper.TestApp.run(TestApp.java:53)
        at springdeveloper.TestApp.main(TestApp.java:22)
samoa:~/Projects/plainJpa trisberg$ 
","11/Sep/06 23:30;mprudhom;Hmm ... the ClassCircularityError should have been resolved by my fix for OPENJPA-40. Can you make sure you re-built and deployed the built jars to your Spring installation? Just to be sure, you may want to update to the latest svn revision (442386).

If it still fails, can you attach a new test case (just like the one for OPENJPA-40) and I'll try to reproduce?","12/Sep/06 02:19;trisberg;Marc,

I saw your fix for the circular reference and I don't see the error message right now after checking out the latest (now at rev. 442412). I'm getting an error building, but the jars seem to be created anyway.  This is the last part of the build messages:

[INFO] [jar:jar]
[INFO] Building jar: /Users/trisberg/Projects/OpenJPA/openjpa-all/target/openjpa-all-0.9.0-incubating-SNAPSHOT.jar
[INFO] ----------------------------------------------------------------------------
[INFO] Building OpenJPA Distribution
[INFO]    task-segment: [clean, package]
[INFO] ----------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ------------------------------------------------------------------------
[INFO] 'attached' was specified in an execution, but not found in the plugin
[INFO] ------------------------------------------------------------------------
[INFO] For more information, run Maven with the -e switch
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2 minutes 5 seconds
[INFO] Finished at: Mon Sep 11 21:57:00 EDT 2006
[INFO] Final Memory: 16M/59M
[INFO] ------------------------------------------------------------------------

Anyway, I still get an exception executing my test - see attached zip file.  Is this related to OPENJPA-44 since I do use the ""metadata-complete"" attribute? 

Exception in thread ""main"" <4|true|0.9.0-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: Could not locate metadata for the class using alias ""Manager"". Registered alias mappings: ""{Manager=null}""
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:362)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getClassMetaData(JPQLExpressionBuilder.java:166)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.resolveClassMetaData(JPQLExpressionBuilder.java:144)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:213)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:183)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateType(JPQLExpressionBuilder.java:176)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.access$500(JPQLExpressionBuilder.java:63)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.populate(JPQLExpressionBuilder.java:1666)
        at org.apache.openjpa.kernel.jpql.JPQLParser.populate(JPQLParser.java:52)
        at org.apache.openjpa.kernel.ExpressionStoreQuery.populateFromCompilation(ExpressionStoreQuery.java:145)
        at org.apache.openjpa.kernel.QueryImpl.newCompilation(QueryImpl.java:599)
        at org.apache.openjpa.kernel.QueryImpl.compileForCompilation(QueryImpl.java:581)
        at org.apache.openjpa.kernel.QueryImpl.compileForExecutor(QueryImpl.java:608)
        at org.apache.openjpa.kernel.QueryImpl.getOperation(QueryImpl.java:1421)
        at org.apache.openjpa.kernel.DelegatingQuery.getOperation(DelegatingQuery.java:120)
        at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:205)
        at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
        at springdeveloper.MyTest.runQuery(MyTest.java:13)
        at springdeveloper.TestApp.run(TestApp.java:53)
        at springdeveloper.TestApp.main(TestApp.java:22)
","12/Sep/06 02:48;mprudhom;I'm surprised by the build error ... I haven't seen it before. However, I agree that it sounds like the jars are being built OK.

As for the ""Could not locate metadata for the class.."" error, that means that OpenJPA didn't load the class for some reason. If you change your query to query the full class name (e.g., change ""select x from Manager x"" to ""select x from org.mypackage.Manager x""), do you get the same error? A better error message might result.

Also, if you want to attach the new test case, I can take a look.","12/Sep/06 03:03;trisberg;Marc,

I did attach a test case - OPENJPA-32.zip

This is the output and mapping files - fully qualified name did not work either.

persistence.xml:
================
<?xml version=""1.0"" encoding=""UTF-8""?>
<persistence xmlns=""http://java.sun.com/xml/ns/persistence"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
             xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"" version=""1.0"">

    <persistence-unit name=""main"" transaction-type=""RESOURCE_LOCAL"">

      <provider>org.apache.openjpa.persistence.PersistenceProviderImpl</provider>

    </persistence-unit>

</persistence>

orm.xml:
========
<?xml version=""1.0"" encoding=""UTF-8""?>

<entity-mappings xmlns=""http://java.sun.com/xml/ns/persistence/orm""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
    xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence/orm http://java.sun.com/xml/ns/persistence/orm_1_0.xsd""
    version=""1.0"">

  <package>springdeveloper.domain</package>

  <entity class=""Client"" metadata-complete=""false"" access=""FIELD""></entity>
  <entity class=""Manager"" metadata-complete=""false"" access=""FIELD"">
    <attributes>
      <basic name=""description"">
        <column name=""DESCR"" length=""2000""/>
      </basic>
    </attributes>
  </entity>

</entity-mappings>

run:
====
TestApp!
172  INFO   [main] openjpa.Runtime - Starting OpenJPA 0.9.0-incubating-SNAPSHOT
5019  TRACE  [main] openjpa.jdbc.SQL - <t 14360544, conn 635451> [1 ms] executing prepstmnt 514941 SELECT SEQUENCE_SCHEMA, SEQUENCE_NAME FROM INFORMATION_SCHEMA.SYSTEM_SEQUENCES
5186  TRACE  [main] openjpa.jdbc.SQL - <t 14360544, conn 5597932> [17 ms] executing stmnt 2898188 CREATE TABLE Client (id BIGINT NOT NULL, description VARCHAR(255), version INTEGER, manager_id BIGINT, PRIMARY KEY (id))
5190  TRACE  [main] openjpa.jdbc.SQL - <t 14360544, conn 4491208> [1 ms] executing stmnt 7717566 CREATE TABLE Manager (id BIGINT NOT NULL, DESCR VARCHAR(2000), PRIMARY KEY (id))
5204  TRACE  [main] openjpa.jdbc.SQL - <t 14360544, conn 9035974> [11 ms] executing stmnt 7059006 CREATE INDEX I_CLIENT_MANAGER ON Client (manager_id)EM Open? true
Exception in thread ""main"" <4|true|0.9.0-incubating-SNAPSHOT> org.apache.openjpa.persistence.ArgumentException: The type ""class springdeveloper.domain.Manager"" has not been enhanced.
        at org.apache.openjpa.meta.ClassMetaData.resolveMeta(ClassMetaData.java:1544)
        at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1518)
        at org.apache.openjpa.meta.MetaDataRepository.processBuffer(MetaDataRepository.java:660)
        at org.apache.openjpa.meta.MetaDataRepository.resolveMeta(MetaDataRepository.java:567)
        at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:500)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:301)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getClassMetaData(JPQLExpressionBuilder.java:164)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.resolveClassMetaData(JPQLExpressionBuilder.java:133)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:213)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:183)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateType(JPQLExpressionBuilder.java:176)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.access$500(JPQLExpressionBuilder.java:63)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.populate(JPQLExpressionBuilder.java:1666)
        at org.apache.openjpa.kernel.jpql.JPQLParser.populate(JPQLParser.java:52)
        at org.apache.openjpa.kernel.ExpressionStoreQuery.populateFromCompilation(ExpressionStoreQuery.java:145)
        at org.apache.openjpa.kernel.QueryImpl.newCompilation(QueryImpl.java:599)
        at org.apache.openjpa.kernel.QueryImpl.compileForCompilation(QueryImpl.java:581)
        at org.apache.openjpa.kernel.QueryImpl.compileForExecutor(QueryImpl.java:608)
        at org.apache.openjpa.kernel.QueryImpl.getOperation(QueryImpl.java:1421)
        at org.apache.openjpa.kernel.DelegatingQuery.getOperation(DelegatingQuery.java:120)
        at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:205)
        at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:254)
        at springdeveloper.MyTest.runQuery(MyTest.java:13)
        at springdeveloper.TestApp.run(TestApp.java:53)
        at springdeveloper.TestApp.main(TestApp.java:22)
","03/Oct/06 17:54;mprudhom;We've committed a number of fixes to the class loading framework when using the class transformer, which appears to make this work.

Note, though, there are some errors in your orm.xml: you didn't declare the <mapped-superclass class=""Person""/>, and you put overridden attributes in the <attributes> section, rather than the <attribute-override> section (which the spec mandates). I'll attach the corrected orm.xml to this report.",03/Oct/06 17:55;mprudhom;Corrected orm.xml file.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
transforming classes doesn't work,OPENJPA-41,12349362,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mprudhom,costin,costin,07/Sep/06 06:06,01/Mar/07 02:20,14/Mar/19 03:02,01/Mar/07 02:20,,,,,,,,,,0.9.7,,,,,jpa,,,,,,0,,"I've tried several versions of OpenJPA including the most recent one(svn 4409856) to run Spring's Petclinic with class level LoadTimeWeaver on OpenJPA.
I have attached the stacktrace that I get. The same example works fine with Toplink.

I have attached petclinic w/o some of the libs to gain space; basically add the OpenJPA libs and deploy the war into Tomcat. Note that you'll also have to place spring-tomcat-weaver.jar under Tomcat's server/lib (this should be enough - if you have problems let me know or take a look at the Spring reference documentation).
When the webapp starts, the exception pops up.
","WinXP, Tomcat 5.5.17, Spring 2.0-RC4",,,,,,,,,,,,,,,,,,,,,07/Sep/06 06:06;costin;ASF.LICENSE.NOT.GRANTED--petclinic.zip;https://issues.apache.org/jira/secure/attachment/12340325/ASF.LICENSE.NOT.GRANTED--petclinic.zip,07/Sep/06 06:06;costin;ASF.LICENSE.NOT.GRANTED--spring-tomcat-weaver.jar;https://issues.apache.org/jira/secure/attachment/12340326/ASF.LICENSE.NOT.GRANTED--spring-tomcat-weaver.jar,07/Sep/06 06:06;costin;ASF.LICENSE.NOT.GRANTED--stacktrace.txt;https://issues.apache.org/jira/secure/attachment/12340324/ASF.LICENSE.NOT.GRANTED--stacktrace.txt,05/Oct/06 06:00;costin;stacktrace-2.txt;https://issues.apache.org/jira/secure/attachment/12342301/stacktrace-2.txt,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2006-09-28 23:48:40.0,,,no_permission,,,,,,,,,,,160378,,,Tue Jan 09 16:58:19 UTC 2007,,,,,,,0|i0z127:,202474,,,,,,,,"28/Sep/06 23:48;mprudhom;The problem seems to be coming from reentrant re-use of the same XMLMetaDataParser, which winds up calling reset() on the parser in the reentrant call, which messes it up when its continued use is attempted from the parent call. While this could be worked around by just using a new XMLMetaDataParser, the problem runs deeper: why is the reentrancy happening at all? Specifically, it looks like there is a reentrant construction of a PCEnhancer(), which probably shouldn't be happening.


        at org.apache.openjpa.lib.meta.XMLMetaDataParser.reset(XMLMetaDataParser.java:538)
        at org.apache.openjpa.lib.meta.CFMetaDataParser.reset(CFMetaDataParser.java:253)
        at org.apache.openjpa.persistence.XMLPersistenceMetaDataParser.reset(XMLPersistenceMetaDataParser.java:409)
        at org.apache.openjpa.persistence.jdbc.XMLPersistenceMappingParser.reset(XMLPersistenceMappingParser.java:116)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parseNewResource(XMLMetaDataParser.java:378)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:312)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:289)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:263)
        at org.apache.openjpa.persistence.PersistenceMetaDataFactory.parseXML(PersistenceMetaDataFactory.java:239)
        at org.apache.openjpa.persistence.PersistenceMetaDataFactory.load(PersistenceMetaDataFactory.java:190)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:428)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:283)
        at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:164)
        at org.apache.openjpa.enhance.PCClassFileTransformer.transform(PCClassFileTransformer.java:115)
        at org.apache.openjpa.persistence.PersistenceProviderImpl$ClassTransformerImpl.transform(PersistenceProviderImpl.java:127)
        at org.springframework.orm.jpa.ClassFileTransformerAdapter.transform(ClassFileTransformerAdapter.java:56)
        at org.springframework.instrument.classloading.WeavingTransformer.transformIfNecessary(WeavingTransformer.java:84)
        at org.springframework.instrument.classloading.WeavingTransformer.transformIfNecessary(WeavingTransformer.java:77)
        at org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader.findResourceInternal(TomcatInstrumentableClassLoader.java:66)
        at org.apache.catalina.loader.WebappClassLoader.findClassInternal(WebappClassLoader.java:1749)
        at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:866)
        at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1319)
        at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1198)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:242)
        at serp.util.Strings.toClass(Strings.java:209)
        at org.apache.openjpa.lib.meta.CFMetaDataParser.classForName(CFMetaDataParser.java:303)
        at org.apache.openjpa.lib.meta.CFMetaDataParser.classForName(CFMetaDataParser.java:282)
        at org.apache.openjpa.persistence.XMLPersistenceMetaDataParser.classForName(XMLPersistenceMetaDataParser.java:1638)
        at org.apache.openjpa.persistence.XMLPersistenceMetaDataParser.startClass(XMLPersistenceMetaDataParser.java:702)
        at org.apache.openjpa.lib.meta.CFMetaDataParser.startElement(CFMetaDataParser.java:103)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.startElement(XMLMetaDataParser.java:427)
        at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:533)
        at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.startElement(XMLSchemaValidator.java:708)
        at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:330)
        at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(XMLDocumentFragmentScannerImpl.java:1693)
        at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:368)
        at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:834)
        at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:764)
        at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:148)
        at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1242)
        at javax.xml.parsers.SAXParser.parse(SAXParser.java:375)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parseNewResource(XMLMetaDataParser.java:371)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:312)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:289)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:263)
        at org.apache.openjpa.persistence.PersistenceMetaDataFactory.parseXML(PersistenceMetaDataFactory.java:239)
        at org.apache.openjpa.persistence.PersistenceMetaDataFactory.load(PersistenceMetaDataFactory.java:190)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:428)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:283)
        at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:164)
        at org.apache.openjpa.enhance.PCClassFileTransformer.transform(PCClassFileTransformer.java:115)
        at org.apache.openjpa.persistence.PersistenceProviderImpl$ClassTransformerImpl.transform(PersistenceProviderImpl.java:127)
        at org.springframework.orm.jpa.ClassFileTransformerAdapter.transform(ClassFileTransformerAdapter.java:56)
        at org.springframework.instrument.classloading.WeavingTransformer.transformIfNecessary(WeavingTransformer.java:84)
        at org.springframework.instrument.classloading.WeavingTransformer.transformIfNecessary(WeavingTransformer.java:77)
        at org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader.findResourceInternal(TomcatInstrumentableClassLoader.java:66)
        at org.apache.catalina.loader.WebappClassLoader.findClassInternal(WebappClassLoader.java:1749)
        at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:866)
        at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1319)
        at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1198)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
        at java.lang.Class.getDeclaredMethods0(Native Method)
        at java.lang.Class.privateGetDeclaredMethods(Class.java:2365)
        at java.lang.Class.getDeclaredMethods(Class.java:1763)
        at java.beans.Introspector$1.run(Introspector.java:1265)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.beans.Introspector.getPublicDeclaredMethods(Introspector.java:1263)
        at java.beans.Introspector.getTargetMethodInfo(Introspector.java:1129)
        at java.beans.Introspector.getBeanInfo(Introspector.java:387)
        at java.beans.Introspector.getBeanInfo(Introspector.java:159)
        at org.springframework.beans.CachedIntrospectionResults.<init>(CachedIntrospectionResults.java:142)
        at org.springframework.beans.CachedIntrospectionResults.forClass(CachedIntrospectionResults.java:83)
        at org.springframework.beans.BeanWrapperImpl.setIntrospectionClass(BeanWrapperImpl.java:239)
        at org.springframework.beans.BeanWrapperImpl.setWrappedInstance(BeanWrapperImpl.java:197)
        at org.springframework.beans.BeanWrapperImpl.setWrappedInstance(BeanWrapperImpl.java:180)
        at org.springframework.beans.BeanWrapperImpl.<init>(BeanWrapperImpl.java:133)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:535)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:375)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:242)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:141)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:239)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:155)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:300)
        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:346)
        at org.springframework.web.context.support.AbstractRefreshableWebApplicationContext.refresh(AbstractRefreshableWebApplicationContext.java:156)
        at org.springframework.web.context.ContextLoader.createWebApplicationContext(ContextLoader.java:246)
        at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:184)
        at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:49)
        at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:3729)
        at org.apache.catalina.core.StandardContext.start(StandardContext.java:4187)
        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:759)
        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:739)
        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:524)
        at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:904)
        at org.apache.catalina.startup.HostConfig.deployDirectories(HostConfig.java:867)
        at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:474)
        at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1122)
        at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:310)
        at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119)
        at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1021)
        at org.apache.catalina.core.StandardHost.start(StandardHost.java:718)
        at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1013)
        at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:442)
        at org.apache.catalina.core.StandardService.start(StandardService.java:450)
        at org.apache.catalina.core.StandardServer.start(StandardServer.java:709)
        at org.apache.catalina.startup.Catalina.start(Catalina.java:551)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:294)
        at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:432)
","29/Sep/06 01:13;mprudhom;Even after fixing the parser to handle reentrancy, the next problem is a similar ClassCircularityError that was reported in OPENJPA-40. The fix may have to be that we batch enhancement of classes better somehow, rather than recursively enhancing as we load and resolve superclasses/relations.

Caused by: java.lang.ClassCircularityError: org/springframework/samples/petclinic/Specialty
        at java.lang.Class.getDeclaredMethods0(Native Method)
        at java.lang.Class.privateGetDeclaredMethods(Class.java:2365)
        at java.lang.Class.getDeclaredMethods(Class.java:1763)
        at org.apache.openjpa.meta.AbstractMetaDataDefaults.populateFromReflection(AbstractMetaDataDefaults.java:195)
        at org.apache.openjpa.meta.AbstractMetaDataDefaults.populate(AbstractMetaDataDefaults.java:145)
        at org.apache.openjpa.persistence.PersistenceMetaDataDefaults.populate(PersistenceMetaDataDefaults.java:188)
        at org.apache.openjpa.meta.MetaDataRepository.addMetaData(MetaDataRepository.java:732)
        at org.apache.openjpa.persistence.XMLPersistenceMetaDataParser.startClass(XMLPersistenceMetaDataParser.java:720)
        at org.apache.openjpa.lib.meta.CFMetaDataParser.startElement(CFMetaDataParser.java:101)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.startElement(XMLMetaDataParser.java:427)
        at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:533)
        at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.startElement(XMLSchemaValidator.java:708)
        at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:330)
        at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(XMLDocumentFragmentScannerImpl.java:1693)
        at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:368)
        at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:834)
        at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:764)
        at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:148)
        at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1242)
        at javax.xml.parsers.SAXParser.parse(SAXParser.java:375)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parseNewResource(XMLMetaDataParser.java:371)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:312)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:289)
        at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:263)
        at org.apache.openjpa.persistence.PersistenceMetaDataFactory.parseXML(PersistenceMetaDataFactory.java:239)
        at org.apache.openjpa.persistence.PersistenceMetaDataFactory.load(PersistenceMetaDataFactory.java:190)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:428)
        at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:283)
        at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:164)
        at org.apache.openjpa.enhance.PCClassFileTransformer.transform(PCClassFileTransformer.java:123)
        ... 57 more
",04/Oct/06 17:49;mprudhom;I believe this is fixed by the fix for OPENJPA-42.,"05/Oct/06 06:00;costin;I've updated and rebuilt OpenJPA - the issue seems to be gone though I'm now running into another one (not sure if it's a side effect or a different issue).
Attached the stacktrace as stracktrace-2 - basically, it seems that the superclass fields/methods are ignored.","05/Oct/06 07:33;mprudhom;Did you fix the orm.xml to use the one I attached to OPENJPA-42? That should resolve this problem (which comes, I believe, from attributes like ""firstName"" being declared in the <attributes> section, rather than in the <attribute-override> section, as per the spec).","05/Oct/06 11:28;costin;For some reason the JIRA comment was not email to me. Anyway, using the 'fixed' orm.xml seemed to do the trick.
I've got some errors now about the HSQLDB columns not found but I think that's related to the dialect and the ddl used.

TopLink seems to run fine with both property tags apparently...
Consider the issue fixed for now.

Thanks!",09/Jan/07 16:58;kwsutter;Housecleaning...,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
In-memory Delete operation fails with active DataCache,OPENJPA-35,12348773,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,,ppoddar@apache.org,ppoddar@apache.org,28/Aug/06 23:36,09/Mar/10 18:32,14/Mar/19 03:02,10/Mar/07 15:18,0.9.0,0.9.6,,,,,,,,0.9.7,,,,,datacache,query,,,,,0,,"Delete through query such as 
		Query query = em.createQuery(""DELETE FROM Node n"");
		query.executeUpdate();

fails with following exception (only when DataCache is active)
Exception in thread ""main"" <4|false|0.0.0> org.apache.openjpa.persistence.ArgumentException: org.apache.openjpa.datacache.QueryCacheStoreQuery
	at org.apache.openjpa.kernel.QueryImpl.deleteInMemory(QueryImpl.java:1029)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeDelete(ExpressionStoreQuery.java:665)
	at org.apache.openjpa.datacache.QueryCacheStoreQuery$QueryCacheExecutor.executeDelete(QueryCacheStoreQuery.java:348)
	at org.apache.openjpa.kernel.QueryImpl.delete(QueryImpl.java:1012)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:768)
	at org.apache.openjpa.kernel.QueryImpl.deleteAll(QueryImpl.java:831)
	at org.apache.openjpa.kernel.QueryImpl.deleteAll(QueryImpl.java:827)
	at org.apache.openjpa.kernel.DelegatingQuery.deleteAll(DelegatingQuery.java:544)
	at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:299)
	at control.Test.clear(Test.java:87)
	at control.Test.run(Test.java:37)
	at control.Test.main(Test.java:178)
Caused by: java.lang.ClassCastException: org.apache.openjpa.datacache.QueryCacheStoreQuery
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:651)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:949)
	at org.apache.openjpa.kernel.QueryImpl.deleteInMemory(QueryImpl.java:1018)
	... 11 more
","Only happens when DataCache is active
			<property name=""openjpa.DataCache""                value=""true""/>
			<property name=""openjpa.RemoteCommitProvider""     value=""sjvm""/>
",,,,,,,,,,,,,,,,,,,,,28/Feb/07 21:35;ppoddar@apache.org;openjpa-35.test.zip;https://issues.apache.org/jira/secure/attachment/12352271/openjpa-35.test.zip,28/Feb/07 23:50;ppoddar@apache.org;openjpa-35.trace.txt;https://issues.apache.org/jira/secure/attachment/12352277/openjpa-35.trace.txt,,,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-02-28 21:58:15.098,,,no_permission,,,,,,,,,,,160372,,,Thu Mar 08 09:35:00 UTC 2007,,,,,,,0|i0yw0n:,201657,,,,,,,,"28/Feb/07 21:34;ppoddar@apache.org;I am not seeing this particular error anymore -- but I am seeing something else that does not appear right. 

a) When datacache is active, even after an instance is deleted via query, the entitymanager is committed and cleared, EntityManager find() finds the instance -- not from its L1 cache but from its L2 cache.

If this is a known limitation -- it should be documented (could not find it in OpenJPA User's guide)

b) When openjpa.datacache=false, the application can still obtain a non-null reference to StoreCache, however its delegate is null.
What should OpenJPAEntityManagerFactory.getStoreCache() return when  openjpa.datacache=false ?

c) delete directly i.e. em.remove() does the 'right' thing i.e. subsequent em.find() returns null. 

d) Setting ""openjpa.BrokerImpl"" to ""EvictFromDataCache=true"" did not change the behavior (nor was expected)

The observations are based on the attached TestCase","28/Feb/07 21:35;ppoddar@apache.org;Attached test case shows that after deleting via query, L2 cache still maintains a copy and em.find() finds the instance. ",28/Feb/07 21:58;pcl;What happens if the user modifies the object or if the user obtains a read lock on the instance?,"28/Feb/07 23:50;ppoddar@apache.org;Added a trace output of the test case that is failing. 

shows that the deleted instance (PObject-4501) is in L2 Cache.

Please note the instance was locked and modified *after* delete by query (as we still has its reference).
Does that give the cache a chance to heal?

Please note that PObject-4501 has a DetachedStateManager when we lock/modify it after delete.
","28/Feb/07 23:58;pcl;I haven't looked at your test, but I'm guessing that since it has a DetachedStateManager, it's the same instance that you had been using earlier.

I would expect that if you deleted some instances with a bulk delete, then looked up an instance that had been deleted via a data cache hit, then tried to do anything involving a lock with that instance, you'd get a failure at commit time (assuming optimistic transactions and a @Version column).","28/Feb/07 23:59;pcl;... to finish that thought, I'd then expect that the instance would get cleared from the cache due to the optimistic lock failure, and a second transaction involving the instance (a newly-looked-up copy) would succeed.","01/Mar/07 00:44;ppoddar@apache.org;Right -- a newly looked up copy (the copy comes out of L2 cache and not from the database where it really do not exist anymore) -- is essentially not usable i.e. any commit set containing that object fails. The L2 cache heals as soon as the commit fails.  

So let me summarize 
a) delete via query leaves a copy in the L2 cache
b) the cached copy can be located via em.find()
c) however, any modify operation on this ghost copy will fail
d) this failure will signal to clear the copy from the L2 cache.

Do you think, it is worth mentioning in the doc?
   ","01/Mar/07 00:56;pcl;Well, I think that it's worth *fixing*, and shouldn't really be all that hard, either. But, assuming that we can't prioritize it appropriately to fix it, we should document it prior to the next release, yes.","01/Mar/07 01:25;clr;I agree this bug is worth fixing and pending the fix, worth documenting as a bug. I'd be against documenting it as a ""feature"".","08/Mar/07 09:35;pcl;> b) When openjpa.datacache=false, the application can still obtain a 
> non-null reference to StoreCache, however its delegate is null.
> What should OpenJPAEntityManagerFactory.getStoreCache() return
> when  openjpa.datacache=false ?

I think that this is fine behavior. You generally shouldn't need to get the StoreCache's delegate. The current behavior is nice because user code doesn't need to check whether or not a cache is active; instead, user code can just perform cache operations. Sure, they're no-ops when the cache isn't on, but that's fine.",,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem detecting parent's access type with runtime enhancement.,OPENJPA-34,12348645,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,mikedd,mikedd,25/Aug/06 15:57,17/Apr/07 18:38,14/Mar/19 03:02,04/Oct/06 16:12,,,,,,,,,,,,,,,,,,,,,0,,"I have a small hierarchy of entities specified in an xml descriptor (orm.xml), Employee, PartTimeEmployee and FullTimeEmployee. PartTimeEmployee and FullTimeEmployee extend Employee which is a MappedSuperclass. 

If I don't explicitly set the access type for either PartTimeEmployee or FullTimeEmployee in orm.xml and I use the static enhancer (org.apache.openjpa.enhance.PCEnhancer) everything works fine.  If I use runtime enhancement I get a warning like this : 

184  INFO   [main] openjpa.MetaData - Found 3 classes with metadata in 7 milliseconds.
88  INFO   [main] openjpa.Runtime - Starting OpenJPA 0.0.0
180  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.DerbyDictionary"".
277  INFO   [main] openjpa.MetaData - Found 4 classes with metadata in 1 milliseconds.
985  INFO   [main] openjpa.MetaData - Parsing resource ""file:/home/mikedd/workspaces/openjpa/mdd/target/classes/META-INF/orm.xml"".
1307  INFO   [main] openjpa.MetaData - Parsing class ""mdd.entities.descriptor.Employee"".
1356  INFO   [main] openjpa.MetaData - Parsing class ""mdd.entities.descriptor.Employee"".
1356  INFO   [main] openjpa.MetaData - Parsing package ""mdd.entities.descriptor.Employee"".
1385  INFO   [main] openjpa.MetaData - Parsing class ""mdd.entities.descriptor.PartTimeEmployee"".
1385  INFO   [main] openjpa.MetaData - Parsing class ""mdd.entities.descriptor.PartTimeEmployee"".
1389  INFO   [main] openjpa.MetaData - Parsing class ""mdd.entities.descriptor.FullTimeEmployee"".
1390  INFO   [main] openjpa.MetaData - Parsing class ""mdd.entities.descriptor.FullTimeEmployee"".
1394  INFO   [main] openjpa.MetaData - Parsing class ""mdd.entities.descriptor.AbstractPersonnel"".
1422  WARN   [main] openjpa.Enhance - An exception was thrown while attempting to perform class file transformation on ""mdd/entities/descriptor/FullTimeEmployee"":
<4|false|0.0.0> org.apache.openjpa.util.UserException: Detected the following possible violations of the restrictions placed on property access persistent types:
The member for for persistent property ""mdd.entities.descriptor.FullTimeEmployee.salary"" was not a method: ""private float mdd.entities.descriptor.FullTimeEmployee.salary"".
	at org.apache.openjpa.enhance.PCEnhancer.processViolations(PCEnhancer.java:520)
	at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:287)
	at org.apache.openjpa.enhance.PCClassFileTransformer.transform(PCClassFileTransformer.java:122)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:141)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:174)
	at java.lang.ClassLoader.defineClassImpl(Native Method)


From what I can tell after running the debugger the error occurs because the runtime enhancer isn't able to find the parent's metadata (and from that the access type). 

I don't think the spec is very clear in this regard. Access isn't a required attribute for entities, but the spec doesn't indicate what should happen if it isn't present (or if it does I didn't find it). 

I don't know whether this is a limitation of runtime enhancement (again I didn't see it documented anywhere, but maybe I didn't look hard enough). There are also plenty of solutions, specifying a default access type in orm.xml, or just adding access=""PROPERTY"" to the entity will work. 

If it's not an architectural limitation though, I think we should try to get runtime enhancement to work in the same manner as static enhancement. 

In case it helps here's my javaagent setting : 
-javaagent:/home/mikedd/.m2/repository/org/apache/openjpa/openjpa-kernel-5/0.9.0-SNAPSHOT/openjpa-kernel-5-0.9.0-SNAPSHOT.jar=scanDevPath=true,MetaDataFactory=jpa

I've attached the source that I've used to produce the problem, include the eclipse .project and .classpath files (you'll probably have to update these). There's also a pom.xml which can be used to compile or at least set up the classpath in eclipse. I don't know how to toggle between runtime and static enhancement with maven so I haven't used it to run the tests. ",,,,,,,,,,,,,,,,,,,,,,25/Aug/06 15:57;mikedd;ASF.LICENSE.NOT.GRANTED--employee-project.zip;https://issues.apache.org/jira/secure/attachment/12339578/ASF.LICENSE.NOT.GRANTED--employee-project.zip,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2006-10-04 17:48:47.0,,,no_permission,,,,,,,,,,,160371,,,Wed Oct 04 17:48:47 UTC 2006,,,,,,,0|i1doun:,288123,,,,,,,,04/Oct/06 16:12;mikedd;Appears to be resolved (not sure which change fixed it though). ,04/Oct/06 17:48;mprudhom;I suspect the fixes for OPENJPA-41 and OPENJPA-42 also addressed this problem.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unnecessary dependencies in poms,OPENJPA-32,12348518,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,bnoll,bnoll,23/Aug/06 22:59,09/Mar/10 18:35,14/Mar/19 03:02,24/Aug/06 07:32,,,,,,,,,,,,,,,,,,,,,0,,"This dependency currently exists in the /openjpa-lib/ module and is not needed.

        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.5</version>
            <scope>compile</scope>
        </dependency>",Windows XP,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-08-24 07:32:44.0,,,no_permission,,,,,,,,,,,160369,,,Thu Aug 24 14:49:37 UTC 2006,,,,,,,0|i0yz7z:,202176,,,,,,,,24/Aug/06 07:32;pcl;Resolved in svn revision 434330.,"24/Aug/06 14:49;bnoll;After creating this JIRA, I noticed the following in the assembly configurations under openjpa-project:

<!-- only required for persistence server -->
<exclude>javax.servlet:servlet-api</exclude>

Maybe it is needed for something I don't know about?",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Named query with @NamedNativeQuery  annotation does not work,OPENJPA-31,12348515,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,,anouri,anouri,23/Aug/06 22:41,09/Mar/10 18:35,14/Mar/19 03:02,27/Sep/06 08:31,,,,,,,,,,,,,,,query,,,,,,0,,"Creating namedQuery with @namedNativeQuery using  resultClass  or  SqlResultSetMapping caused mapping tool error and run-time exception. Details in Attachment.
 
 ","IBM Thinkpad laptop, Windows XP/sp2, DB2 8.1.7, openjpa",,,,,,,,,,,,,,,,,,,,,23/Aug/06 22:41;anouri;ASF.LICENSE.NOT.GRANTED--NamedNativeQueryBug.txt;https://issues.apache.org/jira/secure/attachment/12339450/ASF.LICENSE.NOT.GRANTED--NamedNativeQueryBug.txt,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2006-09-27 08:31:05.0,,,no_permission,,,,,,,,,,,160368,,,Wed Sep 27 08:31:05 UTC 2006,,,,,,,0|i0yvnz:,201600,,,,,,,,"27/Sep/06 08:31;mprudhom;This should be fixed as of last week.

Note that there was also a workaround for the bug: the named native query would have been found if some persistence operation had been performed on the declaring class before the attempt was made to create the native query (e.g., em.find(ClassThatDeclaresNativeQuery.class, 1)).

In any case, it should be working now, so the workaround should not be necessary.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groupby clause of a subquery incorrectly duplicated in the main query in the generated SQL,OPENJPA-28,12348353,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,fancy,fancy,21/Aug/06 19:10,09/Mar/10 18:32,14/Mar/19 03:02,01/Aug/08 23:44,,,,,,,,,,1.2.0,1.3.0,,,,query,,,,,,0,,"JPquery: select e.name, e.salary from EmpBean e where (e.name = Any(select e1.name from EmpBean e1 group by e1.name )) order by e.name 
generated pushdown SQL:
SELECT t0.name, t0.salary, t1.name FROM EmpBean t0 JOIN EmpBean t1 ON (1 = 1) WHERE (t0.name = ANY((SELECT t2.name FROM EmpBean t2 GROUP BY t2.name))) GROUP BY t1.name ORDER BY t0.name ASC

correct pushdown SQL should be:
SELECT t0.name, t0.salary, t1.name FROM EmpBean t0 JOIN EmpBean t1 ON (1 = 1) WHERE (t0.name = ANY((SELECT t2.name FROM EmpBean t2 GROUP BY t2.name))) ORDER BY t0.name ASC",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160365,,,2006-08-21 19:10:27.0,,,,,,,0|i0zb3z:,204102,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Incorrect SQL generated for queries involving more than one AbstractSchemaNames, generated SQL FROM clause is missing 'Table alias'",OPENJPA-25,12348347,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,fancy,fancy,21/Aug/06 18:12,01/Mar/07 02:20,14/Mar/19 03:02,01/Mar/07 02:20,,,,,,,,,,0.9.7,,,,,query,,,,,,0,,"select e, d from EmpBean e, DeptBean d generates following SQL where t2 is undefined:
          SELECT t1.empid, t2.deptno FROM EmpBean t0 JOIN EmpBean t1 ON (1 = 1)
 'DeptBean t2' is missing in the FROM clause.
Similar problem occurs to the following query:
  select d from EmpBean e left join e.dept d, ProjectBean p where e.salary = p.budget ==> incorrect SQL (t3 is undefined): 
SELECT t1.deptno, t1.budget, t1.mgr_empid, t1.name, t1.reportsTo_deptno FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno JOIN EmpBean t2 ON (1 = 1) WHERE (t2.salary = t3.budget) ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-02-01 01:27:21.942,,,no_permission,,,,,,,,,,,41558,,,Thu Feb 01 01:27:21 UTC 2007,,,,,,,0|i0z6en:,203340,,,,,,,,01/Feb/07 01:27;wisneskid;not a problem anymore,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Allow OpenJPA to be extensible,OPENJPA-24,12348334,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,21/Aug/06 13:27,01/Mar/07 02:20,14/Mar/19 03:02,01/Mar/07 02:20,,,,,,,,,,0.9.7,,,,,kernel,,,,,,0,,"The current OpenJPA architecture is not extendable to other implementations.  For example, if somebody wanted to provide their own PersistenceProvider implementation, simply extending the org.apache.openjpa.PersistenceProviderImpl would not suffice due to the dependencies in the ConfigurationProviderImpl.  The discussion for this improvement was started on the dev mailing list.  Once it was determined that there was more to this request than a simple conditional or two, we decided to open a JIRA report.

The complete history of this request can be found in the OpenJPA dev mailing list.  The first message was posted by me (Kevin Sutter) on August 14, titled ""Extending the OpenJPA Implementation"".  I will attempt to paraphrase the current state of the problem...

We have three main players in this issue.  The PersistenceProvider, the ConfigurationProvider, and the ProductDerivation (along with the various implementations of these interfaces).  Currently, the ConfigurationProvider is in the lib and is unaware of any specific persistence requirements.  The ProductDerivation is in the kernel and, unfortunately, is aware of persistence requirements, specifically the spec and store types.  Abe's postings have indicated that we need to make these two interfaces more aware of each other and work with each other.  We need to start with either making ConfigurationProvider more persistence-aware and move it into kernel, or make ProductDerivations less persistence-aware and move it into lib.  The latter approach is preferred.

After we get this re-organization of the base framework complete, we still have a couple of other issues ot resolve:

    *  Still need the ability to extend EMF's through a ProductDerivation.  This should be doable by adding a new PluginValue to indicate what class of EMF to load.

    *  There is still a question as to whether we will need to provide a custom PersistenceProviderImpl and ConfigurationProviderImpl pair.  I still think this will be necessary.   And, one of Abe's posts indicated that this might help with class loading issues when multiple versions of OpenJPA-based implementations are available in the same system.

I also posted these questions last Friday.  (Abe has responded with some answers, but I wanted to get this JIRA report created before trying to paraphrase his answers.)

    *  You mention in several places about separating away the notion of specs and stores.  In a general sense, I understand what these are.  But, can you elaborate on how these types are used in the ConfigurationProvider and ProductDerivation interfaces?

    * I've moved the ProductDerivation interface to the lib and added the ""load"" methods from the ConfigurationProvider (as described in your previous notes).  And, I've started to clean up the implementations that depend on these interfaces.  But, concerning the implementation of the load methods...  Now that we need to return a ConfigurationProvider, would you expect that we just new up a ConfigurationProviderImpl and then just call across to the ""load"" methods on the implementation?  Since we want to keep the ProductDerivations stateless, I'm not sure how else you were expecting to create a ConfigurationProvider to return on these ""load"" methods.

    * Now that ConfigurationProvider is bare, the ConfigurationTestConfigurationProvider doesn't have much function.  I'll need to take a look to see if this is even required any longer.

    * Can you shed a bit more light on the Configurations class?  It doesn't implement nor extend any interfaces or classes, but it seems to provide many of the same methods as ConfigurationProvider, but as statics.  And, it's dependent on having a Provider.  Can you explain the relationship of this class in the bigger picture and how you think it might be affected by thes changes?

That's enough for the initial JIRA report.  We will now track this problem here instead of the dev mailing list.  Thanks.

Kevin
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-09-01 20:04:19.0,,,no_permission,,,,,,,,,,,160362,,,Tue Jan 09 16:58:53 UTC 2007,,,,,,,0|i0z6cv:,203332,,,,,,,,"21/Aug/06 15:57;kwsutter;Abe's responses to my questions posted previously (from the dev mailing list)...

>   - You mention in several places about separating away the notion of
> specs and stores.  In a general sense, I understand what these
> are.  But, can you elaborate on how these types are used in the
> ConfigurationProvider and ProductDerivation interfaces?

What I meant was that the ProductDerivation interface has methods and
constants that imply knowledge of what a ""spec"" is and what a ""store""
is: afterSepcificationSet(), TYPE_STORE, etc.  These methods and
constants become meaningless when the interface is moved from kernel
to lib, because lib is code that is completely ignorant of what's
built on top of it.  OpenJPA kernel understands that there might be
different spec facades built on it, and that there might be different
data stores plugged in, but lib code shouldn't be aware of those
concepts.

Actually, I wouldn't mind moving the
OpenJPAConfiguration.setSpecification() method to the base
Configuration interface and giving lib the notion of a spec, because
that's a sufficiently general idea.  But lib certainly shouldn't know
anything about data stores -- that concept is very persistence-
specific.  So I believe that at the very least, the TYPE_STORE stuff
has to be moved out of ProductDerivation and into something in the
kernel if ProductDerivation itself moves into lib.  As I mentioned in
my original email, it might seem odd to maintain the strict
neutrality of lib code given that it's only used for OpenJPA, but we
do in fact build on that code with some non-persistence-aware Kodo
stuff, and as long as there is a separation of modules within
OpenJPA, I'd like to maintain the meaning of lib-as-neutral vs.
kernel-as-persistence-aware.

> Now that we need to return a ConfigurationProvider, would you
> expect that we just new up a ConfigurationProviderImpl and then
> just call  across to the ""load"" methods on the implementation?  Since we
> want to keep the ProductDerivations stateless, I'm not sure how else you were
> expecting to create a ConfigurationProvider to return on these ""load"" methods.

I would expect the ProductDerivation itself to do most of the load
work and to populate a new ConfigurationProvider with the parsed
state.  The ProductDerivation itself would remain stateless, but
would contain the load logic.  We can probably have just one
ConfigurationProviderImpl that will work for most derivations (i.e.
ConfigurationProviderImpl will probably not have to be JPA-specific
anymore, and can move into lib's conf package or somewhere where it
can be used by JDO, etc as well).  I bet a slight rework of
MapConfigurationProvider would do the trick.

>   - Now that ConfigurationProvider is bare, the
> ConfigurationTestConfigurationProvider doesn't have much
> function.  I'll need to take a look to see if this is even required any longer.

Yeah, I'm sure tests will need updating.

>   - Can you shed a bit more light on the Configurations class?  It
> doesn't implement nor extend any interfaces or classes, but it
> seems to provide many of the same methods as ConfigurationProvider, but as
> statics.  And, it's dependent on having a Provider.  Can you explain the
> relationship of this class in the bigger picture and how you think it might be
> affected by these changes?

It's a utility class.  Aside from the low-level utils it provides,
it's mainly there so that its static configuration methods can be
invoked without worrying about what services the system is configured
with.  Configurations does the work of looking up the right
ConfigurationProvider using the services framework and applying it.
Otherwise, each component that used a ConfigurationProvider would
have to invoke the Services utilities itself to figure out which
ConfigurationProvider to use.

When ProductDerivation takes over, Configurations will change to use
ProductDerivations instead, and will subsume the functionality of
kernel's conf.ProductDerivations utility class.","01/Sep/06 19:18;kwsutter;I'm finally getting back to this exercise and I will have to admit that this is quite difficult not understanding the general architecture of thse ConfigurationProviders and ProductDerivations.  Instead of jumping right in and attempting to make Abe's suggested changes, I'm trying to understand the current architecture.  Here's what I am finding...

The application attempts to create an EMF via Persistence.createEntityManagerFactory().  This eventually gets us to the PersistenceProviderImpl.createEntityManagerFactory() methods, which creates the ConfigurationProviderImpl instance.  We then use this ConfigurationProviderImpl instance  to load the resources and create the PersistenceUnitInfo object.

The last thing we do in createEntityManagerFactory is to create the appropriate BrokerFactory.  We do this by calling Bootstrap.newBrokerFactory passing in the ConfigurationProvider instance and associated Loader.

Within this processing, I see where we are looping through the ProductDerivation services (sorted on Type).

This, in turn, creates the new JDBCBrokerFactory instance, which creates the corresponding JDBCConfigurationImpl.  After initializing the properties in the constructor, we attempt to load the global settings by calling Configurations.loadGlobals static method (via the ConfigurationImpl.loadGlobals method).  This is where it gets confusing.  Within this method, we create new instances of the ConfigurationProviderImpl and we use these instances to load resources (again?).

So, I am seeing where we loop through ConfigurationProviders, eventually creating and looping thorugh ProductDerivations, and then we create and process new instances of ConfigurationProviders.

Granted, I've only spent a couple of hours looking at this today, but I think I need some background on how these Services were working previously before attempting to correct it.  Maybe this was part of the reason why Abe wanted to get rid of the ConfigurationProvider service and drive everything through the ProductDerivations.  It's kind of confusing.

Thanks,
Keivn","01/Sep/06 20:04;awhite;Globals are configuration properties that are always loaded before any explicit configuration supplied by the user, both when using dev tools and at runtime.  Each configuration provider decides on whether and how it uses globals.  The JPA configuration provider does not use globals.  Kodo's JDO configuration provider looks for a ""kodo.properties"" resource in the classpath and loads anything in it.  A Kodo user could theoretically have a kodo.properties with JDO properties, but request an EntityManagerFactory through Persistence.  

Thus the loading of globals is independent of the runtime ConfigurationProvider created by PersistenceProviderImpl or any other bootstrapping mechanism.  That is reflected in the behavior Kevin noted: when loading globals we loop through all the ConfigurationProviders in the system until we find one that loads successfully, regardless of how the user is bootstrapping his runtime.","01/Sep/06 20:07;awhite;Correction: the JPA configuration provider does use globals.  It looks for an openjpa.xml resource for global configuration.  Just as a Kodo user could have a kodo.properties but bootstrap his runtime through JPA, he could also use openjpa.xml but bootstrap his runtime through JDO.  Again, the loading of globals is independent of the runtime bootstrapping mechanism.","01/Sep/06 20:57;logemann;Just to get it right too. You can bootstrap OpenJPA by the means of PersistenceProviderImpl but still obtain a JDO persistenceManager. But the important question is, where to put things which were formerly in kodo.properties? Or is PersistenceProviderImpl able to load from kodo.properties?","06/Sep/06 01:04;ppoddar@apache.org;One use case for extension of OpenJPA implementations is backward compatibility of Kodo 4.1 with Kodo 4.0. In Kodo 4.0, we have published interfaces such as kodo.persistence.KodoEntityManagerFactory/KodoEntityManager. The applications compiled with Kodo 4.0 API to work with Kodo 4.1 runtime (based on OpenJPA), we would be supporting KodoEntityManagerFactory and other published interfaces.
The published Kodo 4.0 interfaces would be redefined to extend openjpa interfaces for Kodo 4.1. 
 
I'm working on some related code for backwards-compatibility of Kodo, which turns out to be a similar problem to extensibility of OpenJPA. Let's compare notes, and see where we're overlapping and how we can help each other out.
","07/Sep/06 14:54;kwsutter;Concerning the ProductDerivation types...

Of the types defined in ProductDerivation, it looks like only TYPE_SPEC, TYPE_STORE, and TYPE_SPEC_STORE are being used.  (I don't find any references to TYPE_PRODUCT, TYPE_PRODUCT_STORE, or TYPE_FEATURE.  Must be for future extensions?)  I'm assuming that any re-factoring of these types should continue to include these types that are not currently being utilized.

One of Abe's earlier comments indicated that if we move ProductDerivation into lib, then we should remove the concept of SPEC and STORE from that interface since lib is persistence-neutral.  (Later on, Abe indicated that maybe we could leave the concept of SPEC since that is pretty general, but STORE is definitely specific to persistence.)  These removed concepts needed to be re-introduced into the kernel, possibly as a derived OpenJPAProductDerivation.

This would imply that the getType() method and the associated constants for the TYPE_* values should be removed from the ProductDerivation interface.

But, if we go that route, then we're screwed with our proposed looping through the list of ProductDerivations since it relies on the ProductDerivation.getType() method.

So, it would seem that we still need the getType() method and associated TYPE_* constants at the ProductDerivation interface.  It seems that it would be okay for the interface to define the various types, and let the implementations deal with the SPEC and/or STORE implications.

What am I missing?

Kevin","07/Sep/06 16:08;awhite;The ProductDerivation interface can have a getType() and can order on that type without having to define all the type constants itself.  My usual strategy is to define the constants that make sense for the base type, leaving big ""holes"" so that subclasses can insert their own constants for proper ordering:

public interface ProductDerivation {
    public static final int BASETYPE1 = 10;
    public static final int BASETYPE2 = 20;
    ...
}

It's somewhat delicate (I usually Javadoc the base constants with their values and the fact that they shouldn't be changed), but it's simple and IMO it's better than the base interface containing a bunch of meaningless (to it) constants.",19/Sep/06 13:06;kwsutter;It looks like Pinaki has dropped some code via revision r447664 that provides at least some of the infrastructure needed for this JIRA report.  I will need to compare his changes with the changes I was experimenting with to see if this report is now resolved or not.  Any additional changes will be logged via this JIRA report.,"19/Sep/06 16:01;ppoddar@apache.org;I had made certain changes for extending OpenJPA with alternative implementaions via ProductDerivations mechanics. Let me present my understanding of this issue raised orginally by Kevin on this discussion thread. 

org.apache.openjpa.lib.conf.Configuration carries the properties that determines configurable behaviour e.g. which concrete PersistenceProvider to create or whether to synchronize the object schema with that of the database or whether to apply JPA or JDO style mapping primitives and so on. It is a rich and powerful construct with support for Plugin.  

The purpose of OpenJPA configuration subsystem is to create one such Configuration instance that is essential for any particular instantiation of the generic kernel known as BrokerFactory. In fact, BrokerFactory and Configuration enjoy a 1:1 till-detah-do-us-apart sort of relationship.    

ProductDerivation, ProductDerivations, ConfigurationProvider, Configurations are abstractions that participate in creating this Configuration instance. Let us see the roles played by each of them.

ConfigurationProvider locates where the configuration information is and then reads it. The information can be in a META-INF/persistence.xml file inside a jar, a kodo.properties file available in classpath, a -Dxyz=myValue style Java system property, in a Map instance constructed programatically - the possibilities are not constrained by design. Because OpenJPA -- notwithstanding its name -- is by design capable of supporting multiple specifications that differs in configuration grammar -- multiple ConfigurationProvider classes are provided. Given the varied nature of how configuration information can be made available to the runtime, the basic interface org.apache.openjpa.lib.conf.ConfigurationProvider provides the discipline of reading configuration from 'global' or 'default' or named resources. Of course, each concrete implementation would interpret what 'global' or 'default' would mean. ConfigurationProvider after locating the information resource, reads its content and temporarilly stores in an internal name-value map. Eventually it pours this content into a Configuration instance via ConfigurationProvider.setInto(Configuration conf) method. 

ProductDerivation faciliates how Configuration will deal with this content -- which MetaDataFactory to set, which EntityManagerFactory (or PersistenceManagerFactory) to instantiate as a facade to the kernel according to active specification and so on. This tunning is accomplished by hooks during the life of a Configuration before being put to active duty i.e. before a Configuration instance is constructed, before the content carried by ConfigurationProvider is poured in Configuration and after a Configuration is set to represent a specification. For example, the spec-agnostic core configuration implementation ConfigurationImpl nor its derivation OpenJPAConfigurationImpl declares a plugin for which concrete EntityManagerFactory to construct as a facade. But PersistenceProductDerivation inserts org.apache.openjpa.persistence.EntityManagerFactoryImpl as the concrete implementation class for EMF in beforeConfigurationConstruct() hook and adds a EMF-plugin value via beforeConfigurationLoaded() hook i.e. before ConfigurationProvider pours its content into a Configuration. This allows the PersistenceProviderImpl to instantiate a org.apache.openjpa.persistence.EntityManagerFactoryImpl as a facade to BrokerFactory.  

Given that OpenJPA supports an extensive set of configurable parameters it is logical to separate them into categories such as SPEC, PRODUCT, STORE etc -- and that lead to a host of ProductDerivation classes each tunning the configuration from its own perspective. org.apache.openjpa.lib.conf.ProductDerivations is the harness that locates each ProductDerivation available to the system, order them up sequentially to give a chance to modify Configuration/ConfigurationProvider. ProductDerivations finds ProductDerivation by looking up one or more ""org.apache.openjpa.lib.conf.ProductDerivation"" resources in the classpath and interpreting each line of this simple text-based resource as a class name for a particular org.apache.openjpa.lib.conf.ProductDerivation implementation. 

Configurations hold a bunch of static utility methods to instantiate plugin, pour system properties into Configuration and so on. I have not looked into this class due dilligence and it may even be a candidate for being refactored out completely later. 


Given this scheme, the most visible (and mechanical) change is to drive the loading of configuration data by the ConfigurationProvider via ProductDerivations. It used to be such that different ConfigurationProvider were activated by Configurations and different ProductDerivation were activated by ProductDerivations. Now ProductDerivations is the only driver of configuration subsystem. Each ProductDerivation can supply its own ConfigurationProvider to locate/parse/read configuration information and supplying a null imply that this ProductDerivation does not read resource at all. In fact, most of them don't. 

This ProductDerivation-as-driver-of-ConfigurationProvider notion is coded into AbstractProductDerivation.  

The other change as outlined by Abe is to move ProductDerivations/ProductDerivation/Configuration to lib and factor out STORE specifc details in kerenl.OpenJPAProductDerivation. 

With all these machinery and refactoring -- now let us go back to the issue Kevin originally raised -- how does one extend OpenJPA?
The use case became real when we needed a backward compatibility support for Kodo 4.0. Kodo 4.0 was released few months ago in pre-OpenJPA era. Obviously, a mechanism is needed such that applications written on Kodo 4.0 but running on Kodo 4.1 based on OpenJPA must be able to use the old API of kodo.persistence.PersistenceProviderImpl instead of org.apache.... 
In my next post, I will describe how that was done with ProductDerivation, I have to now attend to booth duty at BEAWorld. 
 

        
 ","20/Sep/06 01:46;mikedd;It looks like creating an extension is fairly straight forward. With the changes Pinaki committed yesterday I was able to create a simple test extension. All I did was create three classes, a ProductDerivation, a PersistenceProvider, and a ConfigurationProvider. I extended PersistenceProductDerivation, PersistenceProviderImpl and ConfigurationImpl respectively, although I suppose one could write their own if they really wanted/needed to.  

To get a fairly simple wrapper extension working all I had to do was override : ProductDerivation.newConfigurationProvider() , and
ConfigurationProvider.getPersistenceProviderName(). 

I didn't see any methods in PersistenceProviderImpl that I needed to change. 

The last thing I did was register the ProductDerivation and PersistenceProvider as services, and update persistence.xml (specifying the new PersistenceProvider for my persistent unit). 

After that the new PersistenceProvider, etc. were used and generated the configuration appropriately (as far as I can tell). Each ProductDerivation is called to load a ConfigurationProvider until the first non-null ConfigurationProvider is found. The ConfigProvider and PersistenceProvider need to match and so forth. 

Is there anything glaring that I missed? Admittedly all I did was a proof of concept. For a real world extension like Kodo 4.1 there will be other bits to change, changing the default properties in ConfigurationProvider.loadGlobals() for example. I'm sure Pinaki will have a more information and a more robust example. 

One other thing I wasn't clear on is the type for the extension (TYPE_SPEC, TYPE_PRODUCT,etc). My first guess is that any extensions would use TYPE_PRODUCT (value 100), but I could see it being TYPE_PRODUCT_STORE as well. 

PersistenceProductDerivation is TYPE_SPEC (value 0) and the ProductDerivations are sorted in ascending order. If extensions are of TYPE_PRODUCT then the default Apache derivation will always be checked first.  If we assume that when an extension is present it will be used more often than the default we might want to have any extensions' derivations called first. 

That's all I found. I didn't mean to steal Pinaki's thunder, just wanted to show that someone else has had some success. ","20/Sep/06 02:10;awhite;I've committed some additional work on this as I reviewed Pinaki's work.  You should now be able to extend OpenJPA by creating a ProductDerivation like so:

public class MyProductDerivation 
    extends AbstractProductDerivation {

    public int getType() {
        return TYPE_PRODUCT;
    }

    public boolean beforeConfigurationLoad(Configuration conf) {
        Value emf = conf.getValue(EntityManagerFactoryValue.KEY);
        if (emf == null)
            return false;
        emf.setDefault(MyEntityManagerFactoryClass.class.getName());
        emf.setClassName(MyEntityManagerFactoryClass.getName());
        return true;
    }
}

With your custom EntityManagerFactory class (which must extend EntityManagerFactoryImpl), you can also override newEntityManagerImpl(Broker) to subclass the EntityManager, and using your EntityManager subclass I believe you can act as a factory for custom QueryImpl, etc extensions.  In addition to the PersistenceProvider.createEMF methods, the static toEntitymanagerFactory/toEntityManager methods in OpenJPAPersistence will also correctly return your custom subclasses.

So you shouldn't need a custom ConfigurationProvider or a custom PersistenceProvider anymore.  I'll be doing some more review of this later to be sure it actually works, barring someone else testing it and telling me it does.","20/Sep/06 19:41;mikedd;Thanks Abe, I was able to load a custom EMF with your changes. I might have more questions when I get a chance to experiment a little more. ","10/Oct/06 13:54;kwsutter;With Pinaki's and Abe's assistance, this JIRA report was resolved.  Thank you.",09/Jan/07 16:58;kwsutter;Housecleaning...,,,,,,,,,,,,,,,,,,,,,,
-418 sqlexception using DB2 and EJB QL with SQRT or MOD,OPENJPA-23,12348117,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mprudhom,wisneskid,wisneskid,16/Aug/06 23:35,09/Mar/10 18:32,14/Mar/19 03:02,01/Mar/07 12:10,,,,,,,,,,0.9.7,,,,,,,,,,,0,,"generated SQL is missing CAST function to indicate type of ?
 EJB QL :  select e from EmpBean e where mod(e.empid,5)=0 

DB2 SQL error: SQLCODE: -418, SQLSTATE: 42610, SQLERRMC: null {prepstmnt 1046232668 
SELECT t0.empid, t0.bonus, t1.deptno, t1.budget, t1.name, t0.execLevel, t0.hireDate, t0.hireTime, t0.hireTimestamp,
t0.home, t0.isManager, t0.name, t0.salary, t0.work FROM EmpBean t0 LEFT OUTER JOIN DeptBean t1 ON t0.dept_deptno = t1.deptno
WHERE (MOD(t0.empid, ?) = ?)


db2 sql compiler is not able to resolve type of expression (MOD(t0.empid, ?) = ?.  This expression should be 
MOD(t0.empid, cast((?) as integer) ) = ?.    or 
MOD(t0.empid, 5) = 0 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-03-01 12:10:24.588,,,no_permission,,,,,,,,,,,160361,,,Thu Mar 01 12:10:24 UTC 2007,,,,,,,0|i0zb33:,204098,,,,,,,,01/Mar/07 12:10;mprudhom;I am fairly certain this was fixed a while ago (around change #497715).,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"locate & substring queries fail both db2 & derby, cannot use parameter markers in expression ?-?",OPENJPA-22,12348116,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,wisneskid,wisneskid,wisneskid,16/Aug/06 23:32,09/Mar/10 18:32,14/Mar/19 03:02,10/Mar/07 00:36,,,,,,,,,,0.9.7,,,,,query,,,,,,0,,"EJB Q::   SELECT d.name FROM DeptBean d WHERE SUBSTRING(d.name,1,10) = 'Dept' 
                                                                                                                   
DB2 SQL error: SQLCODE: -417, SQLSTATE: 42609, SQLERRMC: null {prepstmnt 1662018320 SELECT t0.name FROM DeptBean t0
WHERE (SUBSTR(CAST((t0.name) AS VARCHAR(1000)), CAST(((? - ?)) AS INTEGER) + 1, CAST(((? + (? - ?))) AS INTEGER) - CAST(((?
- ?)) AS INTEGER)) = ?) [params=(long) 1, (int) 1, (long) 10, (long) 1, (int) 1, (long) 1, (int) 1, (String) Dept]}
[code=-417, state=42609]


EJB QL SELECT e.name FROM EmpBean e WHERE LOCATE('10',e.name,5) > 0 
            DB2 SQL error: SQLCODE: -417, SQLSTATE: 42609, SQLERRMC: null {prepstmnt 1217808534 SELECT t0.name FROM EmpBean t0 WHERE
(((LOCATE(CAST((?) AS VARCHAR(1000)), CAST((t0.name) AS VARCHAR(1000)), CAST(((? - ?)) AS INTEGER) + 1) - 1) + ?) >
?) [params=(String) 10, (long) 5, (int) 1, (int) 1, (long) 0]} [code=-417, state=42609]
 TEST411; 1 tuple


I am not sure why OpenJPA generates the sql expression ?-?.  The proper SQL should be 

SELECT t0.name FROM DeptBean t0  WHERE  substr (to.name, CAST ((?) as INTEGER),  CAST ((?) as INTEGER)   with parm values ( Integer 1,  Integer 10)

Although it helps query reuse to replace literals with parm markers and then pass the literal values as parm values,  this is not always 
best in a system like DB2 which uses distribution statistics and cost based optimization to compute the sql access path.  The better sql would 
simply be 
SELECT t0.name FROM DeptBean t0  WHERE  substr (to.name,1, 10)



",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160360,,,Sat Mar 10 00:36:42 UTC 2007,,,,,,,0|i0zb47:,204103,,,,,,,,10/Mar/07 00:36;wisneskid;fixed in r516624,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Time is missing from list of mutable classes.,OPENJPA-21,12348112,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,wisneskid,wisneskid,16/Aug/06 23:13,09/Mar/10 18:32,14/Mar/19 03:02,31/Jan/07 02:34,,,,,,,,,,0.9.7,,,,,docs,,,,,,0,,   section 1.6   java.sql.Time is missing from list of mutable classes.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-01-31 02:34:24.698,,,no_permission,,,,,,,,,,,160359,,,Wed Jan 31 02:34:24 UTC 2007,,,,,,,0|i1dovb:,288126,,,,,,,,31/Jan/07 02:34;pcl;Resolved with r501693.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Query can return embeddable class,OPENJPA-20,12348111,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,wisneskid,wisneskid,16/Aug/06 23:11,09/Mar/10 18:32,14/Mar/19 03:02,28/Jul/08 17:52,,,,,,,,,,1.2.0,1.3.0,,,,docs,,,,,,0,," part 2 , chapter 4 of user manual on Entity, states that embeddable classes are never returned from a query.  
This is not true as in the query
   select e.address from EmpBean e

address could be defined as as embeddable class.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-03-01 01:57:54.51,,,no_permission,,,,,,,,,,,160358,,,Thu Mar 01 18:28:08 UTC 2007,,,,,,,0|i1dovj:,288127,,,,,,,,"01/Mar/07 01:57;pcl;I think of this as a feature, not a bug. Thoughts?","01/Mar/07 07:52;mprudhom;Or, alternately, a bug in the documentation. The current documentation phrasing is meant to point out that if entity Address is embedded in entity Company, then ""select a from Address a"" will never return the Company's embedded address. This could be clarified to say something like ""Embedded classes are never returned directly from a query unless the query uses a projection on owning class to the embedded instance"".","01/Mar/07 18:28;clr;I agree with Marc that it's a bug in the doc. The doc could also be reworded like ""Embedded classes cannot be used as the first entity in the FROM clause of a query. They can only be returned by projecting from an entity that embeds them.""
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE in createQuery for EJB QL with nested correlated subqueries,OPENJPA-16,12348107,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,wisneskid,wisneskid,16/Aug/06 23:01,01/Mar/07 02:20,14/Mar/19 03:02,01/Mar/07 02:20,,,,,,,,,,0.9.7,,,,,query,,,,,,0,," EJBQL:select c from Customer c where  exists ( select o from Order o where o.cutomer = c and o.delivered=false  and  
exists ( select l1 from LineItem l, in(o.lineitems) as l2  where l1=l2 )) 

partial stack trace is 

Caused by: java.lang.NullPointerException
	at org.apache.openjpa.jdbc.kernel.exps.PCPath.initialize(PCPath.java:359)
	at org.apache.openjpa.jdbc.kernel.exps.CompareEqualExpression.initialize(CompareEqualExpression.java:64)
	at org.apache.openjpa.jdbc.kernel.exps.ContainsExpression.initialize(ContainsExpression.java:56)
	at org.apache.openjpa.jdbc.kernel.exps.BindVariableAndExpression.initialize(BindVariableAndExpression.java:49)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.initializeJoins(SelectConstructor.java:222)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.newJoinsSelect(SelectConstructor.java:166)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.evaluate(SelectConstructor.java:88)
	at org.apache.openjpa.jdbc.kernel.exps.SubQ.appendTo(SubQ.java:198)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160354,,,Thu Feb 01 01:17:00 UTC 2007,,,,,,,0|i0z9g7:,203833,,,,,,,,01/Feb/07 01:17;wisneskid;This problem has been fixed,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
EJBQL grammar needs to be updated to relfect JPA specification,OPENJPA-15,12348106,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,wisneskid,wisneskid,16/Aug/06 22:46,09/Mar/10 18:35,14/Mar/19 03:02,30/Aug/06 18:13,,,,,,,,,,,,,,,query,,,,,,0,,"when used in subquery, SELECT has different grammar than in top most query.  SELECT NEW is not allowed.  FROM in subuqery has different syntax than in top most query.  For example    ""FROM d.employees as e "" in subquery where it would be invalid in top query.   Expression syntax in HAVING clause needs to allow  ""HAVING min(e.salary) > 10 "" is valid  provided that e.salary is a grouping field.  ",,,,,,,,,,,,,,,,,,,,,,30/Aug/06 17:30;fancy;openjpa-15.openjpa-kernel.patch;https://issues.apache.org/jira/secure/attachment/12339890/openjpa-15.openjpa-kernel.patch,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2006-08-19 03:17:25.0,,,no_permission,,,,,,,,,,,160353,,,Wed Aug 30 18:13:58 UTC 2006,,,,,,,0|i0zb8v:,204124,,,,,,,,"21/Aug/06 17:32;fancy;JPQL.txt -- patch file for JPQL grammar fixes
JPQLExpressionBuilder.txt -- path file to support grammar changes","21/Aug/06 21:54;kwsutter;Catalina and I are still having some problems with properly generating the patch file.  I'm not sure if it's due to SVN, or Eclipse, or the .jjt file type, or some combination.  We'll re-post the desired patch when we get it working right.  Sorry for the confusion.","22/Aug/06 21:04;fancy;This patch is applied successfully against openjpa-kenel.
please ignore the previous attachments.","25/Aug/06 21:32;fancy;fixed JPQL.jjt grammar for conforming EJB3.0 spec.
queries such as the following used to fail with SYNTAX errors, worked OK with this fix:
select d.no from DeptBean d where d.name < 'Department1' or d.name > 'Department1'  	
select e from EmpBean e join e.dept d join d.emps e1 left join e1.dept d1 where d.name = d1.name	
 select e from EmpBean e left join e.dept d where e.salary <= all (select max(e1.salary) from EmpBean e1 left join e1.dept d1 where d.no = d1.no)
select e.empid,e.hireTime  from EmpBean e where e.hireTime < '12:01:00'	
select d from DeptBean d  where d.name between 'Depaatment1' and 'Depaztment1'
select d from DeptBean d where size(d.emps) +1 > 10
select d.no, max(e.salary) from DeptBean d, in(d.emps) e where e.salary > 0.0 and d.name = 'Sales'group by d.no having count(e.salary) > 1 order by d.no","26/Aug/06 05:06;clr;Thanks very much for contributing this patch. 

My review is a style and readability code review, not necessarily a content code review of the patch as of Friday 9:50 PM PDT. 

If you were wondering where I got these comments, openjpa does have coding standards borrowed from Geronimo. The coding standards referenced by our web site has moved to http://cwiki.apache.org/confluence/display/GMOxDEV/Coding+standards [ I need to update the web site to reflect this.]

1. Tabs are an issue. The convention we agreed to was not to use tabs and to indent 4 spaces instead.

2. 80 characters are the limit for code lines. Please look at the coding conventions for how to break lines.

3. if/else statements should use opening and closing braces, even for one line statements. 

4. Please use block comments instead of line end comments for multiple line comments.",28/Aug/06 17:32;fancy;The attached patch fixes java source coding/comment styles.,"30/Aug/06 13:36;kwsutter;It looks like Abe committed some changes to JPQLExpressionBuilder last night, so Catalina's patch is out of date (again).  We'll regen the patch and re-post later today.  Thanks.",30/Aug/06 17:30;fancy;attched patch in sync with latest code in svn,30/Aug/06 18:13;mprudhom;Applied patch and it passes all our internal tests. I've gone ahead and committed the changes and am marking this issue resolved.,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PCEnhancer ant task requires openjpa jars to be on the system classpath or passed into ant with '-lib',OPENJPA-14,12348082,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,pcl,bnoll,bnoll,16/Aug/06 17:44,25/Aug/06 07:39,14/Mar/19 03:02,24/Aug/06 18:21,,,,,,,,,,,,,,,lib,,,,,,0,,"Ideally, one should be able to run 'ant openjpac'  (openjpac would be a target defined in the build script that would use the PCEnhancer task) without having to put the openjpa jars on the system classpath or having to pass them into ant vie the '-lib' argument.  Currently this is not possible.  The root of the issue can be seen from by looking at the public static String[] getImplementors(String serviceName, ClassLoader loader) method of the Services class. Basically, the call to 

loader = Thread.currentThread().getContextClassLoader();

returns a ClassLoader with the $ANT_HOME\lib\*.jar and $JAVA_HOME\lib\tools.jar in it... which obviously doesn't contain 'META-INF/services/org.apache.openjpa.conf.ProductDerivation'

The exception seen when encountering this issue:

java.lang.ExceptionInInitializerError
        at org.apache.openjpa.conf.OpenJPAConfigurationImpl.<init>(OpenJPAConfigurationImpl.java:510)
        at org.apache.openjpa.conf.OpenJPAConfigurationImpl.<init>(OpenJPAConfigurationImpl.java:160)
        at org.apache.openjpa.conf.OpenJPAConfigurationImpl.<init>(OpenJPAConfigurationImpl.java:151)
        at org.apache.openjpa.ant.PCEnhancerTask.newConfiguration(PCEnhancerTask.java:77)
        at org.apache.openjpa.lib.ant.AbstractTask.execute(AbstractTask.java:170)
        at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
        at org.apache.tools.ant.Task.perform(Task.java:364)
        at org.apache.tools.ant.Target.execute(Target.java:341)
        at org.apache.tools.ant.Target.performTasks(Target.java:369)
        at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)
        at org.apache.tools.ant.Project.executeTarget(Project.java:1185)
        at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:40)
        at org.apache.tools.ant.Project.executeTargets(Project.java:1068)
        at org.apache.tools.ant.Main.runBuild(Main.java:668)
        at org.apache.tools.ant.Main.startAnt(Main.java:187)
        at org.apache.tools.ant.launch.Launcher.run(Launcher.java:251)
        at org.apache.tools.ant.launch.Launcher.main(Launcher.java:72)
Caused by: java.util.MissingResourceException: Your system is missing product derivations.  Product derivations provide configuration options for supported data stores and specifications.  You must have a META-INF/services/org.apache.openjpa.conf.ProductDerivation file in your classpath listing the available derivation classes, and some listed class must be instantiable.  Typically this file is bundled as part of the distribution.  Have you unbundled it, or unbundled its listed classes?
        at org.apache.openjpa.conf.ProductDerivations.<clinit>(ProductDerivations.java:53)
        ... 17 more
",Windows XP,,,,,,,,,,,,,,,,,,,,,17/Aug/06 22:14;bnoll;OPENJPA-14.patch1;https://issues.apache.org/jira/secure/attachment/12339052/OPENJPA-14.patch1,17/Aug/06 22:21;bnoll;OPENJPA-14.patch2;https://issues.apache.org/jira/secure/attachment/12339053/OPENJPA-14.patch2,17/Aug/06 22:54;bnoll;OPENJPA-14.patch3;https://issues.apache.org/jira/secure/attachment/12339057/OPENJPA-14.patch3,17/Aug/06 23:17;bnoll;OPENJPA-14.patch4;https://issues.apache.org/jira/secure/attachment/12339058/OPENJPA-14.patch4,,,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2006-08-17 22:27:23.0,,,no_permission,,,,,,,,,,,160352,,,Fri Aug 25 07:39:54 UTC 2006,,,,,,,0|i0z9gv:,203836,,,,,,,,"17/Aug/06 22:14;bnoll;Attaching patch named: OPENJPA-14.patch1

So, the issue reported originally was not a problem with the code, but a known problem with ant, as can be seen here: http://ant.apache.org/faq.html#delegating-classloader-1.6

The real fix for this is better documentation, which I will throw together.  I updated the 'no-product-derivations' in the 'openjpa-kernel/src/main/resources/org/apache/openjpa/conf/localizer.properties' file to provide a hint to people who would've run into the same issue I did.


The rest of the patch is to deal with another issue in the same realm as this one, ant that is the fact that the PCEnhancerTask would throw a NPE if you didn't have 'META-INF/persistence.xml' on your system classpath, in $ANT_HOME/lib or supply the dir it was in via the 'ant -lib' argument.  To resolve this, I created a new required attribute for the PCEnhancerTask, named 'configFile'... that allows the location of the config file to be declared when running the task.

Please provide feedback on the patch if you think I didn't grasp the context of what was going on at a higher level and potentially screwed something else up.","17/Aug/06 22:21;bnoll;Attaching patch named: OPENJPA-14.patch2

Ignore 'OPENJPA-14.patch1 ', I forgot to make the test class I added as part of it.  That's the only difference between this one and that.","17/Aug/06 22:27;pcl;Why is the new ant task attribute a required task setting (instead of optional)? It would seem that it's only necessary when the system does not have a persistence unit available, or to narrow the choice when there are multiple persistence units available whose settings conflict.","17/Aug/06 22:34;awhite;Note that we already have an available way to set the config file or resource location:

<any-openjpa-task>
    <config propertiesFile=""...""/>
    -- or --
    <config properties=""...""/>
</any-openjpa-task>

The <config> element also lets you specify any property directly, like:
<config connectionURL=""...""/>

This works b/c our AbstractTask has a createConfig() method that returns the Configuration instance (in this case, an OpenJPAConfiguration or JDBCConfiguration subclass instance depending on the task), so all bean methods are settable. 

The <config> element isn't required, but I agree with Patrick that it shouldn't be, given that we'll detect persistence.xml if it's available in the classpath.  IMO, it would be better to fix the NPE to have a good error message than to require an explicit config file declaration.","17/Aug/06 22:39;bnoll;I thought about making it optional, but it just seemed odd to me that you'd have to have 'META-INF/persistence.xml' in one of the places I mentioned earlier...

1) system classpath
2)$ANT_HOME/lib
3) ant -lib dir_where_META_INF_is
4) I forgot about this before... but a 4th would be ${user.home}/.ant/lib

...in particular, the first two options seem like a round peg in a square hole.  Making it optional would be easy, but I just thought making it required would save users the problem of having to get that on their classpath.

Maybe I'm not seeing the use case?  Like I said though, changing it to optional is trivial.","17/Aug/06 22:54;bnoll;Attaching patch file: OPENJPA-14.patch3

Ignore patch1 and patch2....

Thanks for pointing out the 'properties' and 'propertiesFile' values... that's exactly what I thought was missing and what I needed.  The patch is a simple update to give someone a hint about where their jars need to go so they don't get the original MissingResourceException.","17/Aug/06 23:17;bnoll;Attaching patch: OPENJPA-14.patch4

This throws a MetaDataException now instead of an NPE.",24/Aug/06 18:21;awhite;Applied patch (with minor corrections). ,"25/Aug/06 07:39;pcl;Use the class's classloader in environments when service lookups should be looking in the OpenJPA distribution. This imposes the restriction that OpenJPA will only find services in the same classloader as the OpenJPA jars themselves, which is a much better restriction than requiring that the classes be in the thread's context classloader.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,
GenerationType.IDENTITY problem with MS SQL Server,OPENJPA-13,12347935,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,,megan.kim@gmail.com,megan.kim@gmail.com,14/Aug/06 22:09,09/Mar/10 18:35,14/Mar/19 03:02,04/Oct/06 21:42,,,,,,,,,,,,,,,jpa,,,,,,0,,"Cannot persist entity with identity column.   To reproduce, create a simple object with identity column

@Entity
@Table(name=""JpaType"")
public class JpaType implements Serializable
{
  @Id
  @GeneratedValue(strategy=GenerationType.IDENTITY)
  @Column(name=""Id"")
  private Integer id = null;
  
  @Column(name=""Name"")
  private String name = null;
  
  public Integer getId() { return id; }

  public String getName() { return name;  }
  public void setName(String name) { this.name = name; }
}

create table JpaType (
    Id int identity(1, 1) not null
  , Name varchar(50) null
  , constraint JpaType_PK primary key (Id)
)

JpaType jpa = new JpaType();
jpa.setName(""Test 1"");
em.persist(jpa);
em.flush();

It works OK if I remove identity column (and set ID myself).

Stack trace
<0|true|0.9.0> org.apache.openjpa.persistence.PersistenceException: java.math.BigDecimal
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1576)
	at org.apache.openjpa.kernel.DelegatingBroker.flush(DelegatingBroker.java:927)
	at org.apache.openjpa.persistence.EntityManagerImpl.flush(EntityManagerImpl.java:421)
	at mytest.domain.JpaTest.testJpa(JpaTest.java:30)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.junit.internal.runners.TestMethodRunner.executeMethodBody(TestMethodRunner.java:99)
	at org.junit.internal.runners.TestMethodRunner.runUnprotected(TestMethodRunner.java:81)
	at org.junit.internal.runners.BeforeAndAfterRunner.runProtected(BeforeAndAfterRunner.java:34)
	at org.junit.internal.runners.TestMethodRunner.runMethod(TestMethodRunner.java:75)
	at org.junit.internal.runners.TestMethodRunner.run(TestMethodRunner.java:45)
	at org.junit.internal.runners.TestClassMethodsRunner.invokeTestMethod(TestClassMethodsRunner.java:71)
	at org.junit.internal.runners.TestClassMethodsRunner.run(TestClassMethodsRunner.java:35)
	at org.junit.internal.runners.TestClassRunner$1.runUnprotected(TestClassRunner.java:42)
	at org.junit.internal.runners.BeforeAndAfterRunner.runProtected(BeforeAndAfterRunner.java:34)
	at org.junit.internal.runners.TestClassRunner.run(TestClassRunner.java:52)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:38)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
Caused by: java.lang.ClassCastException: java.math.BigDecimal
	at mytest.domain.model.JpaType.pcReplaceField(JpaType.java)
	at org.apache.openjpa.kernel.StateManagerImpl.replaceField(StateManagerImpl.java:2824)
	at org.apache.openjpa.kernel.StateManagerImpl.storeObjectField(StateManagerImpl.java:2284)
	at org.apache.openjpa.kernel.StateManagerImpl.storeField(StateManagerImpl.java:2380)
	at org.apache.openjpa.kernel.StateManagerImpl.storeField(StateManagerImpl.java:723)
	at org.apache.openjpa.kernel.StateManagerImpl.store(StateManagerImpl.java:719)
	at org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy.setAutoAssignedValue(HandlerFieldStrategy.java:361)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:119)
	at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:68)
	at org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager.flushPrimaryRow(OperationOrderUpdateManager.java:199)
	at org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:86)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:88)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:68)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:512)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:127)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1876)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1772)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1567)
	... 23 more

","Microsoft SQL Server 2000
Windows XP
Java SE 1.5 
OpenJPA - source downloaded today (Aug 14, 2006)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-08-15 20:15:05.0,,,no_permission,,,,,,,,,,,160351,,,Wed Oct 04 21:42:45 UTC 2006,,,,,,,0|i0yvyn:,201648,,,,,,,,"15/Aug/06 20:15;mprudhom;If you change the type of the ""id"" field from Integer to BigDecimal (or just Number), does it work? It may be that we just aren't coercing the return type correctly, and setting it to Number might work around the problem.","15/Aug/06 22:11;megan.kim@gmail.com;I tried to change the type of the ""id"" field from Integer to BigDecimal (and Number) but openjpac fails.

enhance:
 [openjpac] 80  INFO   [main] openjpa.Tool - No targets were given.  Running on all classes listed in org.apache.openjpa.PersistentClasses, or all metadata files in classpath directories if the property is not specified.
 [openjpac] 1261  INFO   [main] openjpa.Tool - Enhancer running on type ""class mytest.domain.model.JpaType"".
 [openjpac] <4|true|0.9.0> org.apache.openjpa.util.MetaDataException: Type ""class mytest.domain.model.JpaType"" declares field ""id"" as a primary key, but keys of type ""java.math.BigDecimal"" are not supported.
 [openjpac] 	at org.apache.openjpa.meta.ClassMetaData.validateAppIdClass(ClassMetaData.java:1676)
 [openjpac] 	at org.apache.openjpa.meta.ClassMetaData.validateIdentity(ClassMetaData.java:1655)
 [openjpac] 	at org.apache.openjpa.meta.ClassMetaData.validateMeta(ClassMetaData.java:1572)
 [openjpac] 	at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1462)
 [openjpac] 	at org.apache.openjpa.meta.MetaDataRepository.processBuffer(MetaDataRepository.java:641)
 [openjpac] 	at org.apache.openjpa.meta.MetaDataRepository.resolveMeta(MetaDataRepository.java:548)
 [openjpac] 	at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:493)
 [openjpac] 	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:294)
 [openjpac] 	at org.apache.openjpa.enhance.PCEnhancer.<init>(PCEnhancer.java:163)
 [openjpac] 	at org.apache.openjpa.enhance.PCEnhancer.run(PCEnhancer.java:3473)
 [openjpac] 	at org.apache.openjpa.ant.PCEnhancerTask.executeOn(PCEnhancerTask.java:86)
 [openjpac] 	at org.apache.openjpa.lib.ant.AbstractTask.execute(AbstractTask.java:166)
 [openjpac] 	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
 [openjpac] 	at org.apache.tools.ant.Task.perform(Task.java:364)
 [openjpac] 	at org.apache.tools.ant.Target.execute(Target.java:341)
 [openjpac] 	at org.apache.tools.ant.Target.performTasks(Target.java:369)
 [openjpac] 	at org.apache.tools.ant.Project.executeTarget(Project.java:1214)
 [openjpac] 	at org.apache.tools.ant.Project.executeTargets(Project.java:1062)
 [openjpac] 	at org.apache.tools.ant.Main.runBuild(Main.java:673)
 [openjpac] 	at org.apache.tools.ant.Main.startAnt(Main.java:188)
 [openjpac] 	at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196)
 [openjpac] 	at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55)

BUILD FAILED
C:\appd\renux\mytest.domain\build.xml:31: <4|true|0.9.0> org.apache.openjpa.util.MetaDataException: Type ""class mytest.domain.model.JpaType"" declares field ""id"" as a primary key, but keys of type ""java.math.BigDecimal"" are not supported.
","15/Aug/06 22:18;megan.kim@gmail.com;Changing the type of the ""id"" field from Integer to ""int"" worked.  Thank you.

@Id
@GeneratedValue(strategy=GenerationType.IDENTITY)
@Column(name=""Id"")
private int id;
","04/Oct/06 20:14;bnoll;So... after looking into this issue for a bit, the problem is this:

Assumptions:
-----------------
Driver: jtds-1.2.jar
Column Type defined as: [ID] [int] IDENTITY (1, 1) NOT NULL

The ClassCastException is coming from this line of the generated code in the PersistenceCapable class...

id = (Integer)pcStateManager.replaceObjectField(this, i);

As a result of the previous method call, we eventually arrive at the 'org.apache.openjpa.jdbc.sql.DBDictionary.getGeneratedKey' method, where there is this line of code...

Object key = rs.getObject(1);

When examining this 'key' object at runtime, its type is java.math.BigDecimal, so... the jtds driver is returning this '[int] IDENTITY (1, 1)' type as a BigDecimal.

This problem does not occur when using a primitive 'int' as the type of the @Id mapping because the org.apache.openjpa.jdbc.meta.strats.PrimitiveFieldStrategy.setAutoAssignedValue method simply up-casts the 'autoInc' value to a Number (legally because it is a BigDecimal), and then calls the 'intValue' method (all of this inside the 'case JavaTypes.INT' section of the switch statement).  The corresponding class that has the setAutoAssignedValue method for the non-primitive types is HandlerFieldStrategy.


The same problem occurs with MySQL when attempting to use a 'java.lang.Integer' as the type of the @Id field, because the value is returned by the driver as a 'java.lang.Long' (driver: mysql-connector-java-3.1.11.jar, colum type of 'int(11) - auto_increment').  This doesn't seem as hinky, because using a Long as the @Id type seems more reasonable than having to use a primitive or a BigDecimal.


I've thought of a couple of ways to go about resolving this, none of which I really like, and am hoping one of the people more familiar with the code base can point me in the right direction.

- Modify the bytecode enhancement so that it is try-catching for a ClassCastException, then instead of casting, explicitly construct the wrapper type that you need, in this case Integer, by casting to a Number, and then calling methods on that.

- Override the getGeneratedKey method in the SQLServerDictionary class to return a cast-safe value.  Not good at all, because I don't see, as its modeled now, that this object is capable of finding out at runtime in a dynamic way what exactly it needs to return.  As a hack, I had it return an Integer, but that only worked because I knew the @Id field was mapped as an Integer.

- In the StateManager, add methods that correspond to the replace<Primitive>Field (replaceIntField gets called in the enhanced code when the @Id type is int), such as replaceIntegerWrapperField, replaceLongWrapperField, etc... instead of just having replaceObjectField.

- Maybe someone can point out somewhere in the object hierarchy (thinking somewhere around HandlerFieldStrategy.setAutoAssignedValue) where we can get to the information in the PersistenceCapable implementor using the fieldName or index so we can find out what type it is supposed to be, and construct it there from the BigDecimal (or whatever it is, Long with MySQL for instance).

- Don't change any code, and document somewhere what we know about what a person can and cannot use for auto-increment @Id types for different databases.  This one seems good enough for MySQL.


Thoughts... suggestions?","04/Oct/06 20:48;awhite;I just committed a possible fix for this issue by changing HandlerStrategies.setAutoAssignedValue to conver the DB-produced auto-assigned value to the Java type the field expects for the given column.  Bryan, can you test with your SQLServer and/or MySQL driver?","04/Oct/06 21:34;bnoll;Looks like it's fixed to me (for reference, Abe's commit that fixed it was 'svn commit: r453016')


SQL Server
@Id type of int - did work before, still works
@Id type of Integer - did NOT work before, works now
@Id type of Long - did NOT work before, works now

MySQL
@Id type of int - did work before, still works
@Id type of Integer - did NOT work before, works now
@Id type of Long - did work before, still works
","04/Oct/06 21:42;awhite;Resolved by converting DB-generated autoassign value to expected Java type for column, as mapped by object field.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PCEnhancer not processing multiple PU's defined within a single persistence.xml file,OPENJPA-9,12347611,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,,kwsutter,kwsutter,09/Aug/06 15:03,09/Jul/12 10:18,14/Mar/19 03:02,16/Nov/07 01:16,,,,,,,,,,1.1.0,,,,,jpa,,,,,,0,,"From a discussion with Patrick on the dev mailing list...

=========================================================================
Me:  According to the JPA spec, we can define multiple persistence-units in a single persistence.xml file.  But, when I try to use this persistence.xml file as input to the PCEnhancer, it is only processing the first persistence-unit that is defined.  I traced through the code and found that this is the case.  When the persistence.xml file is processed, a ""null"" name is passed in for the desired persistence-unit (in the ConfigurationProviderImpl.load method) and, thus, only the first one defined is returned and used by the PCEnhancer.

Patrick:  IMO, the correct behavior should be:

- PCEnhancer run with no arguments should load all the PUs in the
classpath, find the OpenJPA (or unspecified) PUs, and run against all
the classes defined by those PUs (including auto-scanning for PUs so
configured).

- The developer should not need to specify META-INF/persistence.xml when
invoking the PCEnhancer.

- We may want to provide a means to specify specific PUs to process. For
example:

 java ...PCEnhancer -p META-INF/persistence.xml#foo

or maybe just

 java ...PCEnhancer -p #foo

for shorthand.

Regardless, the current behavior seems wrong, and it seems that the best
initial change would be to make PCEnhancer load all the PUs (the first
bullet above), which means manually loading the META-INF/persistence.xml
resources and finding the ones that are OpenJPA PUs, rather than relying
on the javax.persistence.Persistence helper method to load them.
=========================================================================

Writing this bug report so as not to lose track of this problem.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-11-16 01:16:46.942,,,no_permission,,,,,,,,,,,49598,,,Thu Oct 06 12:56:17 UTC 2011,,,,,,,0|i1dowv:,288133,,,,,,,,16/Nov/07 01:16;pcl;I changed a number of other command-line scripts to loop over multiple PUs as well. I have not exhaustively tested all the command-line scripts.,"06/Oct/11 12:56;mspiro;Is this issue really fixed? I'm using the PCEnhancerTask with Ant and OpenJPA version 2.1.0 and the bug is still there. This line:

        PersistenceUnitInfoImpl pinfo = parseResources(parser, urls, name, loader);

(Class PersistenceProductDerivation , line 525) seems to be the point where it begins to go wrong. This following method (beginning in the line 554) generates an internal list of all persistence units, but returns only one of them losing infromation about the rest:

    private PersistenceUnitInfoImpl parseResources(ConfigurationParser parser,
        List<URL> urls, String name, ClassLoader loader)
        throws IOException {
        List<PersistenceUnitInfoImpl> pinfos = new ArrayList<PersistenceUnitInfoImpl>();
        for (URL url : urls) {
            parser.parse(url);
            pinfos.addAll((List<PersistenceUnitInfoImpl>) parser.getResults());
        }
        return findUnit(pinfos, name, loader);
    }

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Link to wiki is incorrect in site,OPENJPA-7,12347347,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,clr,clr,clr,05/Aug/06 02:50,09/Mar/10 18:35,14/Mar/19 03:02,05/Aug/06 04:06,,,,,,,,,,,,,,,,,,,,,0,,"The wiki link on the homepage is:

http://wiki.apache.org/incubator/OpenJPA%20wiki

and should be

http://wiki.apache.org/incubator/OpenJPA

Contributed by Dion Gillard",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,160346,,,Sat Aug 05 04:06:52 UTC 2006,,,,,,,0|i1doxb:,288135,,,,,,,,05/Aug/06 02:59;clr;The site was updated. Waiting for rsync to resolve/close this issue.,"05/Aug/06 04:06;clr;svn commit -m ""OPENJPA-7 Fixed broken link to wiki""
Sending        site/docs/index.html
Sending        site/xdocs/index.xml
Transmitting file data ..
Committed revision 428945.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
properties tests fail on windows,OPENJPA-3,12347016,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,brettporter,brettporter,01/Aug/06 03:05,09/Mar/10 18:35,14/Mar/19 03:02,01/Aug/06 05:02,,,,,,,,,,,,,,,,,,,,,0,,the unit tests fail due to the use of \n instead of the line separator. Patch to follow.,,,,,,,,,,,,,,,,,,,,,,01/Aug/06 03:05;brettporter;OPENJPA-3.diff;https://issues.apache.org/jira/secure/attachment/12337851/OPENJPA-3.diff,,,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2006-08-01 05:02:19.0,,,no_permission,,,,,,,,,,,160342,,,Tue Aug 01 05:02:19 UTC 2006,,,,,,,0|i0zbkn:,204177,,,,,,,,01/Aug/06 05:02;pcl;Resolved in revision 427444. Modified original patch to conform to the currently-unenforced 80-character maximum rule.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
