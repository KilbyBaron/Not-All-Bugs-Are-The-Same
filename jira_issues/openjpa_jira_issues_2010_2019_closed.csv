Summary,Issue key,Issue id,Issue Type,Status,Project key,Project name,Project type,Project lead,Project description,Project url,Priority,Resolution,Assignee,Reporter,Creator,Created,Updated,Last Viewed,Resolved,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Component/s,Component/s,Component/s,Due Date,Votes,Labels,Labels,Labels,Labels,Labels,Labels,Labels,Description,Environment,Original Estimate,Remaining Estimate,Time Spent,Work Ratio,Σ Original Estimate,Σ Remaining Estimate,Σ Time Spent,Security Level,Outward issue link (Blocker),Outward issue link (Cloners),Outward issue link (Duplicate),Outward issue link (Incorporates),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Regression),Outward issue link (Required),Outward issue link (dependent),Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Custom field (Attachment count),Custom field (Blog - New Blog Administrators),Custom field (Blog - New Blog PMC),Custom field (Blog - Write access),Custom field (Blog Administrator?),Custom field (Blogs - Admin for blog),Custom field (Blogs - Email Address),Custom field (Blogs - Existing Blog Access Level),Custom field (Blogs - Existing Blog Name),Custom field (Blogs - New Blog Write Access),Custom field (Blogs - Username),Custom field (Bug Category),Custom field (Bugzilla - Email Notification Address),Custom field (Bugzilla - List of usernames),Custom field (Bugzilla - PMC Name),Custom field (Bugzilla - Project Name),Custom field (Bugzilla Id),Custom field (Change Category),Custom field (Complexity),Custom field (Date of First Response),Custom field (Discovered By),Custom field (Docs Text),Custom field (Enable Automatic Patch Review),Custom field (Epic Link),Custom field (Existing GitBox Approval),Custom field (External issue URL),Custom field (Flags),Custom field (Git Notification Mailing List),Custom field (Git Repository Import Path),Custom field (Git Repository Name),Custom field (Git Repository Type),Custom field (GitHub Options),Custom field (Github Integration),Custom field (Github Integrations - Other),Custom field (Global Rank),Custom field (INFRA - Subversion Repository Path),Custom field (Initial Confluence Contributors),Custom field (Last public comment date),Custom field (Machine Readable Info),Custom field (New-TLP-TLPName),Custom field (Patch Info),Custom field (Priority),Custom field (Project),Custom field (Protected Branch),Custom field (Rank),Custom field (Rank (Obsolete)),Custom field (Severity),Custom field (Severity),Custom field (Space Description),Custom field (Space Key),Custom field (Space Name),Custom field (Test and Documentation Plan),Custom field (Testcase included),Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment
OpenJPA Trunk Build Failure: org/apache/karaf/tooling/features/GenerateDescriptorMojo : Unsupported major.minor version 52.0,OPENJPA-2707,13089058,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,fyrewyld,fyrewyld,21/Jul/17 14:38,27/Jul/17 20:29,14/Mar/19 03:03,27/Jul/17 20:29,3.0.0,,,,,,,,,,,,,build / infrastructure,,,,0,,,,,,,,"Observing the following failure during the Apache OpenJPA build cleanup effort:

INFO] ---* karaf-maven-plugin:4.1.1*:features-generate-descriptor (compile) @ openjpa-features ---
Jul 20, 2017 10:01:58 PM org.sonatype.guice.bean.reflect.Logs$JULSink warn
WARNING: Error injecting: org.apache.karaf.tooling.features.GenerateDescriptorMojo
WARNING: Error injecting: org.apache.karaf.tooling.features.GenerateDescriptorMojo
java.lang.TypeNotPresentException: Type org.apache.karaf.tooling.features.GenerateDescriptorMojo not present
	at org.sonatype.guice.bean.reflect.URLClassSpace.loadClass(URLClassSpace.java:109)
	at org.sonatype.guice.bean.reflect.NamedClass.load(NamedClass.java:45)
	at org.sonatype.guice.bean.reflect.AbstractDeferredClass.get(AbstractDeferredClass.java:45)
	at com.google.inject.internal.ProviderInternalFactory.provision(ProviderInternalFactory.java:84)
	at com.google.inject.internal.InternalFactoryToInitializableAdapter.provision(InternalFactoryToInitializableAdapter.java:52)
	at com.google.inject.internal.ProviderInternalFactory$1.call(ProviderInternalFactory.java:70)
	at com.google.inject.internal.ProvisionListenerStackCallback$Provision.provision(ProvisionListenerStackCallback.java:100)
	at org.sonatype.guice.plexus.lifecycles.PlexusLifecycleManager.onProvision(PlexusLifecycleManager.java:138)
	at com.google.inject.internal.ProvisionListenerStackCallback$Provision.provision(ProvisionListenerStackCallback.java:108)
	at com.google.inject.internal.ProvisionListenerStackCallback.provision(ProvisionListenerStackCallback.java:55)
	at com.google.inject.internal.ProviderInternalFactory.circularGet(ProviderInternalFactory.java:68)
	at com.google.inject.internal.InternalFactoryToInitializableAdapter.get(InternalFactoryToInitializableAdapter.java:45)
	at com.google.inject.internal.InjectorImpl$3$1.call(InjectorImpl.java:965)
	at com.google.inject.internal.InjectorImpl.callInContext(InjectorImpl.java:1011)
	at com.google.inject.internal.InjectorImpl$3.get(InjectorImpl.java:961)
	at com.google.inject.Scopes$1$1.get(Scopes.java:59)
	at org.sonatype.guice.bean.locators.LazyBeanEntry.getValue(LazyBeanEntry.java:83)
	at org.sonatype.guice.plexus.locators.LazyPlexusBean.getValue(LazyPlexusBean.java:49)
	at org.codehaus.plexus.DefaultPlexusContainer.lookup(DefaultPlexusContainer.java:253)
	at org.codehaus.plexus.DefaultPlexusContainer.lookup(DefaultPlexusContainer.java:245)
	at org.apache.maven.plugin.internal.DefaultMavenPluginManager.getConfiguredMojo(DefaultMavenPluginManager.java:455)
	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:92)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:320)
	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)
	at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)
	at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)
	at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)
	at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)
	at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)
Caused by: java.lang.UnsupportedClassVersionError: org/apache/karaf/tooling/features/GenerateDescriptorMojo : Unsupported major.minor version 52.0
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:800)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:71)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
	at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClassFromSelf(ClassRealm.java:386)
	at org.codehaus.plexus.classworlds.strategy.SelfFirstStrategy.loadClass(SelfFirstStrategy.java:42)
	at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClass(ClassRealm.java:244)
	at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClass(ClassRealm.java:230)
	at org.sonatype.guice.bean.reflect.URLClassSpace.loadClass(URLClassSpace.java:101)
	... 41 more

It looks like it is using Apache Karaf 4.1.1, which looking at https://svn.apache.org/repos/asf/karaf/site/production/download.html requires Java 8+.  Presently, Jenkins builds for Trunk are Java 7.  Apache Karaf 4.0.x supports Java 7/8, so Trunk should probably be using that level, since the EE7 spec that JPA 2.1 is part of is at the JDK 7 level.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2017-07-24 15:21:06.204,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Thu Jul 27 20:29:15 UTC 2017,,,,,,,0|i3hunb:,9223372036854775807,,,,,,,,"24/Jul/17 15:21;struberg;trunk currently targets JPA-2.1. 
But as noted in the board minutes it would probably make sense to directly target JPA-2.2 and thus Java8 anyway.

Will bring this to the list.","26/Jul/17 13:03;jira-bot;Commit 1803043 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1803043 ]

OPENJPA-2707 set Java version to 1.8",27/Jul/17 20:29;fyrewyld;Trunk builds are now green.,,,,,,,,,,,,,,,,,,,,,,,,
Persistence entities not recognized in Wildfly 10 if in a JAR,OPENJPA-2684,13028389,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ilgrosso,ilgrosso,ilgrosso,15/Dec/16 14:25,03/Jan/17 07:37,14/Mar/19 03:03,15/Dec/16 14:34,2.3.0,2.4.1,,,,,,,2.4.2,3.0.0,,,,kernel,,,,0,,,,,,,,"OPENJPA-2229 added basic (reflection-based) support for JBoss' {{vfs:/}} protocol.
The current code, however, does not work with JAR files, only directories.",Wildfly 10,,,,,,,,,,,,,OPENJPA-2229,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2016-12-15 14:26:30.683,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Tue Jan 03 07:37:34 UTC 2017,,,,,,,0|i37n4v:,9223372036854775807,,,,,,,,"15/Dec/16 14:26;jira-bot;Commit 1774471 from [~ilgrosso] in branch 'openjpa/branches/2.4.x'
[ https://svn.apache.org/r1774471 ]

[OPENJPA-2684] Adding support for JAR files via ZipStreamMetaDataIterator","15/Dec/16 14:34;jira-bot;Commit 1774477 from [~ilgrosso] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1774477 ]

[OPENJPA-2684] Adding support for JAR files via ZipStreamMetaDataIterator",03/Jan/17 07:37;ilgrosso;Bulk close for 2.4.2,,,,,,,,,,,,,,,,,,,,,,,,
openjpa relies on default locale,OPENJPA-2676,13013779,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,kal0ian,kal0ian,20/Oct/16 07:55,03/Jan/17 07:37,14/Mar/19 03:03,08/Nov/16 18:19,2.4.1,,,,,,,,2.4.2,3.0.0,,,,,,,,0,,,,,,,,"In openjpa there are classes which is not using proper toLower()/toUpper(). The issue is that if the server relies on the default locale and if the process was started with some non English compatible locale such as Turkish, toUpper/Lower will yield an incorrect result. For instance ""URI"".toLowerCase() will result in ""urı"" instead of ""uri"". The same applies to toUpperCase -> ""uri"".toUpperCase() will become ""URİ"" and checks like ""string.toUpperCase().equals(someConstant)"" will fail.

Classes:
AbstractMetaDataDefaults:220
ConfigurationImpl:842
DBIdentifierUtilImpl:309
JDBCConfigurationImpl:987
JDBCStoreQuery:812,815,818,821,823
OracleDictionary:794
PersistenceMetaDataDefaults:243
SQLFormatter:169
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2016-11-05 13:44:05.916,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Tue Jan 03 07:37:32 UTC 2017,,,,,,,0|i354zj:,9223372036854775807,,,,,,,,"05/Nov/16 13:44;struberg;A few things should hardcoded use Locale.ENGLISH. E.g. all the configuration and spec parts. 
I'm not sure though whether we can apply english to for example attribute names as well.

Fixed so far:
* JDBCConfigurationImpl
* ConfigurationImpl
* DBCPDriverDataSource
* Schemas
* DBDictionaryFactory
* IdentifierUtilImpl
* various DbDictionaries



","08/Nov/16 18:19;struberg;using Locale.ENGLISH for all sql spec related parts. I did NOT touch any code which works on attribute or table names or values as those might be locale specific.

I'm closing this ticket for now as it surely improves the handling. For any further changes we would probably need to introduce a way to configure the locale which should be used for e.g.
* attribute and table names
* values

But even that might theoretically be not enough as 1 table might store turkish text and another an english one. If you like to go down that rabbit hole then feel free to open a follow-up ticket which refers to this one.",03/Jan/17 07:37;ilgrosso;Bulk close for 2.4.2,,,,,,,,,,,,,,,,,,,,,,,,
Missing check for null parameter in equals(),OPENJPA-2675,13013777,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,kal0ian,kal0ian,20/Oct/16 07:49,03/Jan/17 07:37,14/Mar/19 03:03,05/Nov/16 11:30,2.4.1,,,,,,,,2.4.2,3.0.0,,,,,,,,0,,,,,,,,"In classes CandidatePath at line 184,CriteriaQueryImpl at line 738, Extensions at line 440 and StoreFacadeTypeRegistry at line 108 there is equals method that there is no check for null parameter. 
According javadoc for Object equals method:
For any non-null reference value x, x.equals(null) should return false.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2016-11-05 11:25:31.077,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Tue Jan 03 07:37:36 UTC 2017,,,,,,,0|i354z3:,9223372036854775807,,,,,,,,"05/Nov/16 11:25;jira-bot;Commit 1768191 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1768191 ]

OPENJPA-2675 implement null-check for CriteriaQueryImpl#equals

txs to Kaloyan Spiridonov for the catch!",05/Nov/16 11:30;struberg;txs for the catch!,"05/Nov/16 11:44;jira-bot;Commit 1768200 from [~struberg] in branch 'openjpa/branches/2.4.x'
[ https://svn.apache.org/r1768200 ]

OPENJPA-2675 implement null-check for CriteriaQueryImpl#equals

txs to Kaloyan Spiridonov for the catch!",03/Jan/17 07:37;ilgrosso;Bulk close for 2.4.2,,,,,,,,,,,,,,,,,,,,,,,
JarFile is not closed,OPENJPA-2674,13013140,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,kal0ian,kal0ian,18/Oct/16 11:48,03/Jan/17 07:37,14/Mar/19 03:03,05/Nov/16 11:33,2.4.1,,,,,,,,2.4.2,3.0.0,,,,,,,,0,,,,,,,,"In InstrumentationFactory class at line 375 JarFile is not closed.
{code}
 private static boolean validateAgentJarManifest(File agentJarFile, Log log,
        String agentClassName) {
        try {
            JarFile jar = new JarFile(agentJarFile);
            Manifest manifest = jar.getManifest();
            if (manifest == null) {
                return false;
            }
            Attributes attributes = manifest.getMainAttributes();
            String ac = attributes.getValue(""Agent-Class"");
            if (ac != null && ac.equals(agentClassName)) {
                return true;
            }
        } catch (Exception e) {
            if (log.isTraceEnabled() == true) {
                log.trace(_name
                    + "".validateAgentJarManifest() caught unexpected ""
                    + ""exception "" + e.getMessage());
            }
        }
        return false;
    }
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2016-10-18 12:06:31.321,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Tue Jan 03 07:37:36 UTC 2017,,,,,,,0|i35127:,9223372036854775807,,,,,,,,"18/Oct/16 12:06;ilgrosso;In [1], if you close the JarFile instance created on line 375, you will end up by closing the underlying agentJarFile: I would rather close it at the end of the getAgentJar() method in the same class.

WDYT?

[1] https://github.com/apache/openjpa/blob/2.4.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java","05/Nov/16 11:29;jira-bot;Commit 1768194 from [~struberg] in branch 'openjpa/branches/2.4.x'
[ https://svn.apache.org/r1768194 ]

OPENJPA-2674 properly close JarFile

txs to Kaloyan Spiridonov for the catch!",05/Nov/16 11:33;struberg;txs for the catch!,"05/Nov/16 11:51;jira-bot;Commit 1768201 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1768201 ]

OPENJPA-2674 properly closing JarFile

txs to Kaloyan Spiridonov for the catch!",03/Jan/17 07:37;ilgrosso;Bulk close for 2.4.2,,,,,,,,,,,,,,,,,,,,,,
ConfigurationImpl.loadGlobals() has java.util.ConcurrentModificationException vulnerability,OPENJPA-2672,13011101,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,fyrewyld,fyrewyld,10/Oct/16 16:42,03/Jan/17 07:37,14/Mar/19 03:03,06/Nov/16 20:38,2.2.3,2.4.1,,,,,,,2.2.3,2.4.2,3.0.0,,,lib,,,,0,,,,,,,,"The following block in the loadGlobals() method:

        // let system properties override other globals
        try {
            fromProperties(new HashMap(
                AccessController.doPrivileged(
                    J2DoPrivHelper.getPropertiesAction())));

retrieves a Properties object from System.getProperties(), which is passed to HashMap's ctor.  The ctor interacts with an enumerator associated with the Properties object to populate the new HashMap instance.  However, if another thread mutates the JVM's System Properties, it can result in a ConcurrentModificationException as observed below:

Caused by: java.util.ConcurrentModificationException
    at java.util.Hashtable$Enumerator.next(Hashtable.java:1256)
    at java.util.HashMap.putAllForCreate(HashMap.java:566)
    at java.util.HashMap.<init>(HashMap.java:310)
    at org.apache.openjpa.lib.conf.ConfigurationImpl.loadGlobals(ConfigurationImpl.java:189)
",,,,,,,,,,,,,,,,,,,10/Oct/16 16:44;fyrewyld;OPENJPA_22X-2672.patch;https://issues.apache.org/jira/secure/attachment/12832498/OPENJPA_22X-2672.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2016-10-10 18:04:58.279,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Tue Jan 03 07:37:33 UTC 2017,,,,,,,0|i34olj:,9223372036854775807,,,,,,,,"10/Oct/16 18:04;jira-bot;Commit 1764159 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1764159 ]

OPENJPA-2672: ConfigurationImpl.loadGlobals() has java.util.ConcurrentModificationException vulnerability","10/Oct/16 20:21;jira-bot;Commit 1764177 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1764177 ]

OPENJPA-2672: ConfigurationImpl.loadGlobals() has java.util.ConcurrentModificationException vulnerability","11/Oct/16 07:37;ilgrosso;It seems to me that the same issue affects both 2.4.x and trunk, and that the changes above are relevant there as well: am I correct?","11/Oct/16 18:30;jira-bot;Commit 1764316 from [~fyrewyld] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1764316 ]

OPENJPA-2672: ConfigurationImpl.loadGlobals() has java.util.ConcurrentModificationException vulnerability","12/Oct/16 06:35;jira-bot;Commit 1764389 from [~ilgrosso] in branch 'openjpa/branches/2.4.x'
[ https://svn.apache.org/r1764389 ]

OPENJPA-2672: ConfigurationImpl.loadGlobals() has java.util.ConcurrentModificationException vulnerability",12/Oct/16 06:35;ilgrosso;Re-opening to add 2.4.x,"06/Nov/16 11:56;struberg;Not quite sure if it really has to do with this change, but since then our build is broken on Linux. 
https://builds.apache.org/job/OpenJPA-2.4.x/8/
It builds fine on OSX though. Will try to reproduce on my local Fedora workstation.",06/Nov/16 20:38;struberg;seems to have nothing to do with that. It seems to be the old story with the multiple 'Entity1' tables which results in timing issues on fast computers. Will merge over the changes I did on trunk to fix this problem.,03/Jan/17 07:37;ilgrosso;Bulk close for 2.4.2,,,,,,,,,,,,,,,,,,
IDs of entities are incorrectly assigned when @SqlResultSetMapping is used with inheritance and a ManyToOne relationship.,OPENJPA-2651,12995760,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,jpaheath,jpaheath,jpaheath,08/Aug/16 21:13,21/Sep/16 20:17,14/Mar/19 03:03,15/Aug/16 18:18,2.2.2,2.3.0,2.4.1,,,,,,2.2.3,2.4.0,2.4.2,,,sql,,,,0,,,,,,,,"I have discovered an issue with using @SqlResultSetMapping when inheritance and ManyToOne relationships are used.  To explain the issue, take this entity and @SqlResultSetMapping:

@Entity
@SqlResultSetMapping(name = ""MyResMap"", entities = { @EntityResult(entityClass = CrtRequisicaoChequePersEntity.class, fields = {
    @FieldResult(name = ""crtOperacaoByOperacaoRecepcaoServCent.id"", column = ""opRecepcaoServCentraisId""),
    @FieldResult(name = ""crtOperacaoByOperacaoRecepcaoServCent.dataHora"", column = ""opRecepcaoServCentraisDataHora"") 
    }) 
})
public class CrtRequisicaoChequePersEntity extends CrtRequisicaoEntity {
.......
    @ManyToOne
    @javax.persistence.JoinColumn(name = ""OPERACAO_RECEPCAO_SERV_CENT"", referencedColumnName = ""ID"")
    private CrtOperacaoEntity crtOperacaoByOperacaoRecepcaoServCent;


As you can see, this entity extends 'CrtRequisicaoEntity' and has a ManyToOne relationship to 'CrtOperacaoEntity', with name 'crtOperacaoByOperacaoRecepcaoServCent'.  As you can see, the @FieldResult in the @SqlResultSetMapping references the fields in 'CrtOperacaoEntity'.   These two entities are defined as follows:


@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public class CrtRequisicaoEntity {
.....
    @Id
    private long id;
.....


@Entity
public class CrtOperacaoEntity implements Serializable {
.....
    @Id
    private long id;

    @Basic
    private Timestamp dataHora;



With these entities, take an SQL select which uses an AS (the entire SQL is to long to add here, see provided recreate/test attached):


String sqlCust = ""SELECT t0.ID"" +
.........
"",t2.DATA_HORA as opRecepcaoServCentraisDataHora"" +
"",t2.ID as opRecepcaoServCentraisId"" +
....
""FROM CrtRequisicaoChequePersEntity t0""
....                
""INNER JOIN CrtOperacaoEntity t2""
....


With this SQL, the two IDs will be populated with the ID from CrtRequisicaoChequePersEntity, rather than the ID corresponding to each entity.

Thanks,

Heath",,,,,,,,,,,,,,,,,,,10/Aug/16 16:06;jpaheath;OPENJPA-2651-2.2.x.patch;https://issues.apache.org/jira/secure/attachment/12823077/OPENJPA-2651-2.2.x.patch,08/Aug/16 21:19;jpaheath;SqlResultSetMappingIssue.zip;https://issues.apache.org/jira/secure/attachment/12822663/SqlResultSetMappingIssue.zip,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2016-08-09 08:55:44.152,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Tue Aug 16 06:42:25 UTC 2016,,,,,,,0|i3221j:,9223372036854775807,,,,,,,,"08/Aug/16 21:19;jpaheath;I am attaching a crude/unpolished test which can be used to recreate the reported issue.  The entities involved and SQL involved are rather large.  As such I am not able to boil down this test into something suitable for a JUnit.....maybe some day.....
To run the test you can edit the .classpath to suit your environment.  The .zip contains a file named create.sql to set up the database (this is for DB2).  You can then import the .zip into Eclipse, or your favorite IDE, and run the test named MainStocks.  

Thanks,

Heath","09/Aug/16 01:18;jpaheath;Attaching proposed fix.

Thanks,

Heath Thomann",09/Aug/16 08:55;ilgrosso;LGTM: are you keen to provide a test case too?,"10/Aug/16 16:06;jpaheath;OK, Francesco Chicchiriccò request for a test prompted me to take the time to boil down the test I previous provided in the .zip to a JUnit test which could be committed.  :)  I'm attaching a full patch, named OPENJPA-2651-2.2.x.patch, with test to recreate the issue and fix.  

Thanks,

Heath","11/Aug/16 06:51;ilgrosso;Thanks for this: it's always a good chance for me to get a bit more acquainted with the (huge) OpenJPA codebase ;-)

Anyway, the patch looks good, I've applied locally and been able to build OpenJPA 2.2.x with it.

Are you also going to provide patches for 2.3.x and trunk as well?

Finally, why is not the ""affected versions"" above set to 2.2.2, 2.3.0 and 2.4.1? I would also set ""fix for versions"" to 2.2.3, 2.3.1 and 2.4.2.

Thanks again.
","11/Aug/16 20:40;jira-bot;Commit 1756046 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1756046 ]

OPENJPA-2651: Fix for issue where @SqlResultSetMapping is used with inheritance and a ManyToOne relationship.","11/Aug/16 20:43;jira-bot;Commit 1756047 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1756047 ]

OPENJPA-2651: Fix for issue where @SqlResultSetMapping is used with inheritance and a ManyToOne relationship.  Merged 2.2.x commit to trunk.","12/Aug/16 06:50;jira-bot;Commit 1756081 from [~ilgrosso] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1756081 ]

[OPENJPA-2651] Applying Heath Thomann's patch for 2.2.x to 2.3.x","12/Aug/16 06:52;ilgrosso;I went ahead and applied your patch to 2.3.x, after verifying it was working fine.
Shall we resolve this issue, then?

I also created https://builds.apache.org/view/OpenJPA/job/OpenJPA-23x which appeared to be missing.

Regards.
","15/Aug/16 18:17;jpaheath;Hi Francesco!  Let me answer your questions:

Q1) Are you also going to provide patches for 2.3.x and trunk as well?

A1) I applied to 2.2.x and trunk.  I don't use 2.3.x and was thinking others did so I let the interested parties put stuff into 2.3.x as they see fit.  I don't know, maybe no one is using 2.3.x these days??  

Q2) Finally, why is not the ""affected versions"" above set to 2.2.2, 2.3.0 and 2.4.1? I would also set ""fix for versions"" to 2.2.3, 2.3.1 and 2.4.2.

A2) Your question is an interesting one......one could spend all day updating ""affected versions"".  Personally, I use the versions I test on, which is always the latest version of a particular branch.  For example, the testing I was doing was on 2.2.x, and therefore I was using the latest code, which is 2.2.3.  If I was on 1.2.x I'd be using 1.2.4, and as such list it.  Continuing with 1.2.4, I'd take the testing and fix forward to 2.0.x, 2.1.x, 2.2.x, and trunk; where applicable.  As such, I'd list those as the affected versions.

Q3) Shall we resolve this issue, then? 

A3) Yes, was getting around to it.

I hope this helps.

Thanks,

Heath","16/Aug/16 06:42;ilgrosso;{quote}
I don't know, maybe no one is using 2.3.x these days?
{quote}

The Syncope maintenance branch 1_2_X [1] is doing that, here's why I've gladly applied your patch :-)

{quote}
For example, the testing I was doing was on 2.2.x, and therefore I was using the latest code, which is 2.2.3. If I was on 1.2.x I'd be using 1.2.4, and as such list it. Continuing with 1.2.4, I'd take the testing and fix forward to 2.0.x, 2.1.x, 2.2.x, and trunk; where applicable. As such, I'd list those as the affected versions.
{quote}

You've been actually testing on (and providing patches for) 2.2.3-SNAPSHOT and 2.4.2-SNAPSHOT, hence the fix will be delivered when we'll release 2.2.3 and 2.4.2: here's why the fix-for-version is important to correctly include 2.2.3 and 2.4.2, to get through to appropriate release notes.

Thanks again for your work.

[1] https://git-wip-us.apache.org/repos/asf?p=syncope.git;a=shortlog;h=refs/heads/1_2_X",,,,,,,,,,,,,,,,
"When SchemaFactory and useSchemaName=false is set, a schema name is incorrectly used.",OPENJPA-2650,12989655,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jpaheath,jpaheath,jpaheath,15/Jul/16 03:23,21/Sep/16 20:17,14/Mar/19 03:03,18/Aug/16 07:06,2.2.3,2.3.0,2.4.2,,,,,,2.2.3,2.4.0,2.4.2,,,jdbc,sql,,,0,,,,,,,,"When ""openjpa.jdbc.SchemaFactory=native(ForeignKeys=true)"" is set, this tells OpenJPA to do up-front schema validation, and allows OpenJPA to be able to learn about any schemas it can ""see"".  When this happens, OpenJPA will use the schema when generating SQL statements.  For example, if OpenJPA finds table A under schema Y, when generating SQL on table A, schema Y will be appended to the generated SQL (e.g. SELECT a.id from Y.A a....).  Without this property, OpenJPA doesn't otherwise use a schema name if it is not specified (i.e. as per the number of ways defined by the JPA spec, or the OpenJPA  proprietary options, e.g. openjpa.jdbc.Schema).  OpenJPA offers a way to tell it to not use a schema name by using this property:  

""openjpa.jdbc.DBDictionary=useSchemaName=false""

When this property is set, OpenJPA will not append the schema to generated SQL (e.g. SELECT a.id from A a....).  However, I have found a case where OpenJPA incorrectly applies the schema name.  To explain, take this Entity, note the TableGenerator:

@Entity
public class MyEntityTable implements Serializable {
       
    @Id
    @TableGenerator(name = ""TABLE_GENERATOR"", table = ""MY_ID_TABLE"", 
        pkColumnName = ""MY_PK_COLUMN"",
        pkColumnValue=""MY_PK_NAME"",
        valueColumnName = ""MY_VALUE_COLUMN"")
    @GeneratedValue(strategy = GenerationType.TABLE, generator = ""TABLE_GENERATOR"")
......


With this Entity and TableGenerator, the SQL to select and update the generated value should be:

SELECT MY_VALUE_COLUMN FROM MY_ID_TABLE WHERE MY_PK_COLUMN = ?

UPDATE MY_ID_TABLE SET MY_VALUE_COLUMN = ? WHERE MY_PK_COLUMN = ? AND MY_VALUE_COLUMN = ?

However, with the above SchemaFactory, and 'useSchemaName=false' settings, the table 'MY_ID_TABLE' would have the schema name appended to it (e.g. if the schema name is Y, the SQL would contain ""Y.MY_ID_TABLE"").  For SQL statements on 'MyEntityTable' itself, the schema name is not added to the SQL.  The issue is limited to SQL statements against the table 'MY_ID_TABLE'.  This is do to a hole in the OpenJPA code that generates SQL for the 'MY_ID_TABLE'.  That is, the particular area of code does not take into consideration the value of 'useSchemaName'. 

Thanks,

Heath Thomann",,,,,,,,,,,,,,,,,,,15/Jul/16 03:55;jpaheath;OPENJPA-2650-2.2.x.patch;https://issues.apache.org/jira/secure/attachment/12818095/OPENJPA-2650-2.2.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2016-08-16 18:07:40.053,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Fri Aug 26 17:11:56 UTC 2016,,,,,,,0|i310dj:,9223372036854775807,,,,,,,,"15/Jul/16 03:55;jpaheath;Attaching a patch which contains a proposed fix and test.

Thanks,

Heath Thomann","16/Aug/16 18:07;jira-bot;Commit 1756538 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1756538 ]

OPENJPA-2650: When SchemaFactory and useSchemaName=false is set, a schema name is incorrectly used.","16/Aug/16 18:08;jira-bot;Commit 1756539 from hthomann@apache.org in branch 'openjpa/trunk'
[ https://svn.apache.org/r1756539 ]

OPENJPA-2650: When SchemaFactory and useSchemaName=false is set, a schema name is incorrectly used.  Merged 2.2.x commit to trunk.","18/Aug/16 07:05;jira-bot;Commit 1756728 from [~ilgrosso] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1756728 ]

[OPENJPA-2650] Applying the patch provided to the neglected 2.3.x branch",18/Aug/16 07:06;ilgrosso;Reopening to apply the same patch to the neglected 2.3.x branch,"26/Aug/16 17:07;jira-bot;Commit 1757893 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1757893 ]

OPENJPA-2650: Made a very simple test update to the test created for this JIRA.","26/Aug/16 17:09;jira-bot;Commit 1757894 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1757894 ]

OPENJPA-2650: Made a very simple test update to the test created for this JIRA.","26/Aug/16 17:11;jira-bot;Commit 1757895 from [~jpaheath] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1757895 ]

OPENJPA-2650: Made a very simple test update to the test created for this JIRA.",,,,,,,,,,,,,,,,,,,
Cannot use custom DBDictionary with Maven plugin,OPENJPA-2640,12958112,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ilgrosso,ilgrosso,ilgrosso,12/Apr/16 13:21,03/Jan/17 07:37,14/Mar/19 03:03,13/May/16 06:50,2.4.1,,,,,,,,2.4.2,,,,,tooling,,,,0,,,,,,,,"Since the custom {{DBDictionary}} is not part of standard OpenJPA class loader, the {{MappingTool}} will fail to find it.

The class loader is already extended by the {{AbstractOpenJpaMappingToolMojo}}, but such extended class loader is not passed to the {{MappingTool}}.",,,,,,,,,,,,,,,,,,,12/Apr/16 13:46;ilgrosso;OPENJPA-2640.diff;https://issues.apache.org/jira/secure/attachment/12798268/OPENJPA-2640.diff,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2016-05-12 16:17:13.213,,,no_permission,,,,Patch,,,,,,,,9223372036854775807,,,Tue Jan 03 07:37:35 UTC 2017,,,Patch Available,,,,0|i2vzxj:,9223372036854775807,,,,,,,,12/May/16 16:17;struberg;looks good!,"13/May/16 06:50;jira-bot;Commit 1743607 from [~ilgrosso] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1743607 ]

[OPENJPA-2640] Applying provided patch",03/Jan/17 07:37;ilgrosso;Bulk close for 2.4.2,,,,,,,,,,,,,,,,,,,,,,,,
mysql master/slave replication configuration with openjpa DataSource,OPENJPA-2638,12956186,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,abhishekbafna,abhishekbafna,05/Apr/16 15:37,06/Jun/18 17:10,14/Mar/19 03:03,11/Apr/16 05:47,2.2.2,,,,,,,,,,,,,jpa,,,,0,,,,,,,,"Here is the setup/code I am using to connect with mysql in replication mode, using openjpa datasource. How do I solve this problem.

mysql expects the master/slave hosts in a comma (,) separated format. [Configuring Master/Slave Replication|https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-master-slave-replication-connection.html]

While the *openjpa.ConnectionProperties* is also comma (,) separated and mapped to the DataSource instance. [opejpa JDBC|http://openjpa.apache.org/builds/1.2.3/apache-openjpa/docs/ref_guide_dbsetup.html].

That is reason, url which reaches to the mysql have only one host. I have attached a debugging screen shot.

{code}
    String driver =""com.mysql.jdbc.ReplicationDriver"";
    String url = ""jdbc:mysql:replication://master:3306,slave:3306/db"";
    String user = ""abc"";
    String password = ""123"";
    String connProps = ""DriverClassName={0},Url={1},Username={2},Password={3}"";

    public void method() {
        connProps = MessageFormat.format(connProps, driver, url, user, password);
        Properties props = new Properties();
        props.setProperty(""openjpa.ConnectionProperties"", connProps);
        props.setProperty(""openjpa.ConnectionDriverName"", ""org.apache.commons.dbcp.BasicDataSource"");
        EntityManagerFactory factory = Persistence.createEntityManagerFactory(""mysql"", props);
        EntityManager manager = factory.createEntityManager();
    }
{code}

Exception:
{noformat}
Exception in thread ""main"" <openjpa-2.4.1-r422266:1730418 fatal general error> org.apache.openjpa.persistence.PersistenceException: Cannot create PoolableConnectionFactory (Must specify at least one slave host to connect to for master/slave replication load-balancing functionality)
	at org.apache.openjpa.jdbc.sql.DBDictionaryFactory.newDBDictionary(DBDictionaryFactory.java:106)
	at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getDBDictionaryInstance(JDBCConfigurationImpl.java:603)
	at org.apache.openjpa.jdbc.meta.MappingRepository.endConfiguration(MappingRepository.java:1520)
	at org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:533)
	at org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:458)
	at org.apache.openjpa.lib.conf.PluginValue.instantiate(PluginValue.java:121)
	at org.apache.openjpa.conf.MetaDataRepositoryValue.instantiate(MetaDataRepositoryValue.java:68)
	at org.apache.openjpa.lib.conf.ObjectValue.instantiate(ObjectValue.java:83)
	at org.apache.openjpa.conf.OpenJPAConfigurationImpl.newMetaDataRepositoryInstance(OpenJPAConfigurationImpl.java:967)
	at org.apache.openjpa.conf.OpenJPAConfigurationImpl.getMetaDataRepositoryInstance(OpenJPAConfigurationImpl.java:958)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.makeReadOnly(AbstractBrokerFactory.java:642)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:202)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:154)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:226)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:153)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:59)
	at ExampleJPA.method(ExampleJPA.java:22)
	at ExampleJPA.main(ExampleJPA.java:27)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
Caused by: org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (Must specify at least one slave host to connect to for master/slave replication load-balancing functionality)
	at org.apache.commons.dbcp.BasicDataSource.createPoolableConnectionFactory(BasicDataSource.java:1549)
	at org.apache.commons.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1388)
	at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044)
	at org.apache.openjpa.lib.jdbc.DelegatingDataSource.getConnection(DelegatingDataSource.java:110)
	at org.apache.openjpa.lib.jdbc.DecoratingDataSource.getConnection(DecoratingDataSource.java:86)
	at org.apache.openjpa.jdbc.sql.DBDictionaryFactory.newDBDictionary(DBDictionaryFactory.java:90)
	... 22 more
Caused by: java.sql.SQLException: Must specify at least one slave host to connect to for master/slave replication load-balancing functionality
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:957)
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:896)
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:885)
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:860)
	at com.mysql.jdbc.NonRegisteringDriver.connectReplicationConnection(NonRegisteringDriver.java:414)
	at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:313)
	at org.apache.commons.dbcp.DriverConnectionFactory.createConnection(DriverConnectionFactory.java:38)
	at org.apache.commons.dbcp.PoolableConnectionFactory.makeObject(PoolableConnectionFactory.java:582)
	at org.apache.commons.dbcp.BasicDataSource.validateConnectionFactory(BasicDataSource.java:1556)
	at org.apache.commons.dbcp.BasicDataSource.createPoolableConnectionFactory(BasicDataSource.java:1545)
	... 27 more
{noformat}
",,,,,,,,,,,,,,,,,,,05/Apr/16 15:42;abhishekbafna;screenshot-1.png;https://issues.apache.org/jira/secure/attachment/12797094/screenshot-1.png,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2016-04-06 14:52:37.364,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Wed Jun 06 17:10:11 UTC 2018,,,,,,,0|i2vo2f:,9223372036854775807,,,,,,,,"06/Apr/16 14:52;allee8285;Have you tried quoting the value that contains ','. e.g.

String connProps = ""DriverClassName={0},Url=\""{1}\"",Username={2},Password={3}"";","07/Apr/16 08:48;abhishekbafna;Thanks [~allee8285]. It did the trick. Would it be possible for you to point me exactly, what class/method performs this split of the *ConnectionProperties*.","06/Jun/18 17:10;struberg;tickets are all resolved since at least 2012, so closing them finally",,,,,,,,,,,,,,,,,,,,,,,,
"Custom plugins (e.g. JDBCListener, DBDictionary) can cause Classloader leaks.",OPENJPA-2636,12954855,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jpaheath,jpaheath,jpaheath,31/Mar/16 04:10,11/Apr/16 15:54,14/Mar/19 03:03,11/Apr/16 15:54,2.2.3,2.4.2,,,,,,,2.2.3,2.4.2,,,,jdbc,,,,0,,,,,,,,"When a customer creates a plugin, for example a JDBCListener, there exists the possibility for the custom JDBCListener to retain a reference to a Classloader, which in turn will not allow the Classloader to be GC'd.  For example, when the JDBCListener is part of a JEE application and the application is restarted, the JDBCListener class can be listed as as a leak suspect, as follows in this leak suspect stack:

75,675,296 (59.45%) [32] 67 class org/apache/openjpa/kernel/AbstractBrokerFactory 0x1027f7e8
|- 75,637,832 (59.42%) [32] 40 class org/apache/openjpa/lib/conf/Configurations 0xf370b48
   |- 75,637,552 (59.42%) [64] 2 org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap 0x1110fa40
      |- 75,637,464 (59.42%) [64] 3 array of org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap$Entry 0x11115620
         |- 75,514,544 (59.32%) [48] 4 org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap$WeakEntry 0x1111edb0
            |- 75,514,496 (59.32%) [48] 1 java/util/concurrent/ConcurrentHashMap 0x111f47b8
               |- 75,514,448 (59.32%) [80] 16 array of java/util/concurrent/ConcurrentHashMap$Segment 0x111f47e8
                  |- 75,505,976 (59.32%) [32] 2 java/util/concurrent/ConcurrentHashMap$Segment 0x111f48d0
                     |- 75,505,912 (59.32%) [24] 1 array of java/util/concurrent/ConcurrentHashMap$HashEntry 0x110d8f08
                        |- 75,505,888 (59.32%) [24] 2 java/util/concurrent/ConcurrentHashMap$HashEntry 0x110d8f18
                           |- 75,505,752 (59.32%) [32] 18 class listener/MyJDBCListener 0x10296078
                              |- 75,505,600 (59.31%) [48] 1 java/util/HashMap 0x11113f88
                                 |- 75,505,552 (59.31%) [65,552] 6,411 array of java/util/HashMap$Entry 0x1401ed10


As can be seen in this stack, my JDBCListener (class MyJDBCListener) is part of the leak suspect, with a retained Configurations class.  When looking at the Configurations class, it can be seen that the Configurations class has a ConcurrentReferenceHashMap which contains a Classloader to Map, where the Map contains the JDBCListener class (MyJDBCListener).  It is these two maps which causes the leak.  

Thanks,

Heath ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2016-04-01 15:03:06.948,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Fri Apr 01 15:50:33 UTC 2016,,,,,,,0|i2vfv3:,9223372036854775807,,,,,,,,"01/Apr/16 15:03;jira-bot;Commit 1737410 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1737410 ]

OPENJPA-2636: Updated a Map in Configurations to avoid a ClassLoader leak.","01/Apr/16 15:50;jira-bot;Commit 1737411 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1737411 ]

OPENJPA-2636: Updated a Map in Configurations to avoid a ClassLoader leak.  Ported 2.2.x changes to trunk.",,,,,,,,,,,,,,,,,,,,,,,,,
select new not working if result class is not in same classloader,OPENJPA-2632,12946975,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,rsandtner,rsandtner,04/Mar/16 13:42,03/Jan/17 07:37,14/Mar/19 03:03,14/Mar/16 21:58,2.4.1,,,,,,,,2.4.2,,,,,jdbc,,,,0,,,,,,,,"in my case i'm using an ear with multiple war files.

the entities are located in ear/lib and my select new result class and the service which loads it are located in a war (doesn't matter if in WEB-INF/lib or WEB-INF/classes)

openJPA uses the CL stored in QueryImpl but this one can not load my class.

imo if the class can not be loaded with the stored class loader, we can try to use the TCCL to load the class.",,,,,,,,,,,,,,,,,,,10/Mar/16 10:15;rsandtner;OPENJPA-2632.patch;https://issues.apache.org/jira/secure/attachment/12792483/OPENJPA-2632.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2016-03-04 13:47:14.71,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Tue Jan 03 07:37:36 UTC 2017,,,,,,,0|i2u5nr:,9223372036854775807,,,,,,,,"04/Mar/16 13:47;githubbot;GitHub user rsandtner opened a pull request:

    https://github.com/apache/openjpa/pull/4

    OPENJPA-2632 use TCCL as fallback

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/rsandtner/openjpa OPENJPA-2632

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/openjpa/pull/4.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #4
    
----
commit b44db2f7754c785da44f084849e7caac9ff216e9
Author: rsandtner <rsandtner@apache.org>
Date:   2016-03-04T13:44:25Z

    OPENJPA-2632 use TCCL as fallback

----
","04/Mar/16 13:57;rsandtner;pull request is also available here https://github.com/apache/openjpa/pull/4
patch was made with git

i've no idea how to add a unit test for this issue. you can reproduce the issue with https://github.com/struberg/was_bugs/tree/master/was_bug19

{{mvn clean install tomee:run}} in was_bug19_ear
browse to http://localhost:8080/was_bug19
click 'Insert Data' -> 1000 entries will be inserted
click the 'Load Data' -> kawumm...

after appliing the patch just do the same with {{-Dopenjpa.version=2.4.2-SNAPSHOT}} and it should work","04/Mar/16 14:01;romain.manni-bucau;[~rsandtner]not sure i get it, if entities are in a parent classloader it should work.Falling back on tccl can create a mess in OSGi and it shoudlnt be done since the broker should be limited to one classloader and not drag all classes (suppose you have 2 wars with the same class names)

To add a test propably just create a hierarchic classloader (you can take batchee url class loader first impl).","04/Mar/16 17:56;rsandtner;[~rmannibucau] my problem is, that the class for my 'select new' can not be found by the CL stored in query impl. {{Strings.toClass(name, _loader)}} blows up with a {{ClassNotFoundException}} which is catched away by {{catch (Throwable t)}} and wrapped in an {{IllegalArgumentException(t.toString())}}.

missed to write the exact problem in the issue description... 

but of course i think the fallback in the provided patch is in the wrong place... maybe it is better to load the result class from TCCL as fallback where we try to find the constructor in {{JPQLExpressionBuilder}}? and if that fails too, then throw the 'no-constructor' exception.","04/Mar/16 18:27;romain.manni-bucau;[~rsandtner] can you try to describe or draw the classloader hierarchy you have (making explicit where is the entity and the broker classloaders). I understand you do a em.createxxxQuery(..., Foo.class) with Foo in WEB-INF/* and em in lib/META-INF/persistence.xml so it sounds normal it fails. Do I miss something?","07/Mar/16 07:56;rsandtner;hey,

my ear looks like this (simplified for the sample - see also https://github.com/struberg/was_bugs/tree/master/was_bug19)

{noformat}
ear
| - lib
|    | - myjar
|    |      | - TheEntity.class
|    |      | - persistence.xml
| - mywar
|    | - WEB-INF
|    |      | - classes
|    |      |      | - Result.class
|    |      |      | - ServiceUsingResult.class
{noformat}

as i understand, the entity gets loaded via the ear-CL and this did not know the {{Result.class}}. i've not found any restrictions in the spec that the result class must be in the same classloader as the entity. ","07/Mar/16 08:47;romain.manni-bucau;[~rsandtner] you are right no restriction but it is an open door to leak - in particular with the enhancement the spec implies in some cases. What about adding your patch if a flag is set in the persistence unit properties? If not set or false then keep current behavior, if set to true use your patch. wdyt?
",07/Mar/16 09:01;rsandtner;[~rmannibucau] sounds good... but let me try to resolve the class via TCCL only for {{select new}}. i think this way it is more secure.,"07/Mar/16 10:19;rsandtner;[~rmannibucau] can you take a look to the second patch pls.
{{OPENJPA-2632_onlySelectNew.patch}}

but this one neither makes me happy - maybe you have a better idea?",07/Mar/16 10:22;romain.manni-bucau;Think the flag is a good compromise (in particular cause openjpa is used in OSGi). Also take care Thread.currentThread().getContextClassLoader() can be null and IIRC openjpa has a utility method for that going through security manager if needed.,07/Mar/16 12:58;rsandtner;[~rmannibucau] can you pls take a another look if the 'fix' is acceptable now? https://github.com/rsandtner/openjpa/tree/OPENJPA-2632,07/Mar/16 13:01;romain.manni-bucau;looks good,07/Mar/16 13:16;rsandtner;what is the next step now? pull request or a patch?,"14/Mar/16 16:03;struberg;+1 looks good.

Smallish things to check:

+                        if (System.getSecurityManager() == null) {

shouldn't that be != null? 

We also need to add the new flag to our documentation openjpa.option.UseTCCLinSelectNew","14/Mar/16 17:07;jira-bot;Commit 1734966 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1734966 ]

OPENJPA-2632 fallback to TCCL for select new if class cannot be found

That might happen if the entities are loaded within a shared ear lib
but the actual ""select new"" is performed from another ClassLoader (e.g. WAR)
Contributed by Reinhard Sandtner (apacheId: rsandtner). Txs for the patch!","14/Mar/16 21:58;struberg;patch applied, txs Reinhard!
Will just add some docs for it.","16/Mar/16 07:27;jira-bot;Commit 1735190 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1735190 ]

OPENJPA-2632 add documentation for the new UseTCCLinSelectNew config switch",03/Jan/17 07:37;ilgrosso;Bulk close for 2.4.2,,,,,,,,,
ClassCastException occurs when an equals comparison query is executed on an entity with an @EmbeddedId that contains more than one field.,OPENJPA-2631,12938647,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,jpaheath,jpaheath,11/Feb/16 23:28,20/Jul/17 20:33,14/Mar/19 03:03,24/Jun/16 03:44,2.1.2,2.2.3,2.4.1,,,,,,2.1.2,2.2.1.1,2.2.3,2.4.2,,criteria,query,sql,,0,,,,,,,,"Take the following entity:

@Entity
public class Subject implements Serializable {

	@EmbeddedId
	private SubjectKey key;
.......

Where SubjectKey is as follows:

@Embeddable
public class SubjectKey implements Serializable {
	private Integer subjectNummer;

	private String subjectTypeCode;
......


As you can see we have a composite primary key.  With this, take this query:

TypedQuery<Subject> query = em.createQuery(""select s from Subject s where s = :subject"", Subject.class);
query.setParameter(""subject"", s);
Subject s2 = query.getSingleResult();

This query will yield the following exception:

java.lang.ClassCastException: org.apache.openjpa.persistence.embed.compositepk.SubjectKey cannot be cast to 
[Ljava.lang.Object;]
at org.apache.openjpa.jdbc.kernel.exps.Param.appendTo(Param.java:149)


If we execute a corresponding 'em.find' of Subject, this exception doesn't occur.  Furthermore, if you execute the same query for an entity with an @EmbeddedId that only contains one field, all will work as expected.  The issue here is with an equals query where the entity contains an @EmbeddableId with more than two fields.

While investigating/debugging this issue, I've found further issues when creating the query using CriteriaBuilder; both with an @Embeddable and @IdClass composite PKs.  I will leave it as an exercise for the reader to view the attached test case to see how each issue can occur.  Each test method details what issue it recreated before the fixes to this issue.  I'm also attaching a patch with a proposed fix for the issues.  

Thanks,

Heath Thomann",,,,,,,,,,,,OPENJPA-1307,,,,,,,08/Jun/16 03:46;jpaheath;OPENJPA-2631-2.1.x.patch;https://issues.apache.org/jira/secure/attachment/12808830/OPENJPA-2631-2.1.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2016-06-08 07:05:45.468,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Thu Jul 20 20:33:59 UTC 2017,,,,,,,0|i2squv:,9223372036854775807,,,,,,,,"12/Feb/16 04:18;jpaheath;For posterity's sake, and given this was a complex issue to debug/fix, I'd like to document some of the steps I took to debug this....sorry, it might be a bit awkward but better than nothing should I/we ever need to revisit this issue.  :)  This debug assumes knowledge of the attached test.  The issue occurs here:

    public void appendTo(Select sel, ExpContext ctx, ExpState state, 
        SQLBuffer sql, int index) {
        ParamExpState pstate = (ParamExpState) state;
        if (pstate.otherLength > 1)
            sql.appendValue(((Object[]) pstate.sqlValue)[index],    <------ line 149
                pstate.getColumn(index), this);

Note that I added a system out in this 'if' block, then I ran the OpenJPA JUnit bucket.  I found that ONLY one test method ever hits this 'if' statement.....so it seems this 'if' block is very rarely executed (which I suppose explains why we have yet to see this issue).  Anyway, in the debugger I notice that 'pstate.otherLength' was 2, which is the size of the number of columns in my PK (SubjectKey), yet 'pstate.sqlValue' contained 'Subject' (the entity in the attacked test).  So I suspected that this code expected to get at the column values of the PK (SubjectKey), not the entity (Subject) itself.  So I walked backwards to see where 'otherLength' and 'sqlValue' where set.  I found that here in Param:

    public void calculateValue(Select sel, ExpContext ctx, ExpState state, 
        Val other, ExpState otherState) {
        super.calculateValue(sel, ctx, state, other, otherState);
        Object val = getValue(ctx.params);
        ParamExpState pstate = (ParamExpState) state;
        if (other != null && !_container) {
            pstate.sqlValue = other.toDataStoreValue(sel, ctx, otherState, val);
            pstate.otherLength = other.length(sel, ctx, otherState);


other.toDataStoreValue calls to ClassMapping.toDataStoreValue....here is that code (note the javadoc):

    /**
     * Return the given column value(s) for the given object. The given
     * columns will be primary key columns of this mapping, but may be in
     * any order. If there is only one column, return its value. If there
     * are multiple columns, return an object array of their values, in the
     * same order the columns are given.
     */
    public Object toDataStoreValue(Object obj, Column[] cols, JDBCStore store) {
        Object ret = (cols.length == 1) ? null : new Object[cols.length];

        // in the past we've been lenient about being able to translate objects
        // from other persistence contexts, so try to get sm directly from
        // instance before asking our context
        OpenJPAStateManager sm;
        if (ImplHelper.isManageable(obj)) {
        	PersistenceCapable pc = ImplHelper.toPersistenceCapable(obj,
                    getRepository().getConfiguration());
            sm = (OpenJPAStateManager) pc.pcGetStateManager();
            if (sm == null) {
            	ret = getValueFromUnmanagedInstance(obj, cols, true);


In my scenario 'sm' is null so we take the block to 'ret = getValueFromUnmanagedInstance'.  Again, note that I added a system out in this 'if' block, then I ran the OpenJPA test bucket and only one test method ever hits this 'if' statement (again, nearly dead code).  :)  When I ran my test, I notice that 'ret' is assigned 'Subject' after a call to 'getValueFromUnmanagedInstance, not the PK values as promised by the javadoc listed above.  So I set off to figure out how to get the PKs columns from Subject, and their values.  To do this, I thought ""if we execute this query as a 'find' instead, how does that path extract the PK columns and values.""  When running in a debugger, I saw that we go into this code in SelectImpl.where:

join = mapping.assertJoinable(toCols[i]);
val = pks[mapping.getField(join.getFieldIndex()).
    getPrimaryKeyIndex()];
val = join.getJoinValue(val, toCols[i], store);

For a finder, this is where we get the PK of SubjectKey and get its individual values of the SubjectKey.....this is where I took my idea for the fix attached to this JIRA.  

Thanks,

Heath
","01/Mar/16 00:29;jpaheath;I'm attaching a patch which contains the proposed final fix and tests.

Thanks,

Heath","08/Jun/16 07:05;ilgrosso;Honestly, both the problem and the fix were not easy to understand, but I think I finally managed to do it :-)

AFAICT, the patch looks very good and solves a very nasty problem.

I have also applied your patch to trunk and verified that all tests are passing.

One question, though: I see this commented block in TestCompositePrimaryKeys:

        // This works:
        // Predicate subjectPredicate1 = builder.equal(subjectRoot.get(Subject_.key).get(SubjectKey_.subjectNummer),
        // subject.getKey().getSubjectNummer());
        // Predicate subjectPredicate2 = builder.equal(subjectRoot.get(Subject_.key).get(SubjectKey_.subjectTypeCode),
        // subject.getKey().getSubjectTypeCode());
        // Predicate subjectPredicate = builder.and(subjectPredicate1,subjectPredicate2);

Can you explain why you have left it there? Or, alternatively, why haven't you uncommented it?

Finally, minor stuff which can be easily adjusted:

2013  test  WARN   [main] openjpa.MetaData - The composite identity class ""class org.apache.openjpa.persistence.embed.compositepk.SubjectIdClass"" for entity ""class org.apache.openjpa.persistence.embed.compositepk.SubjectWithIdClass"" is not serializable.
2520  test  WARN   [main] openjpa.MetaData - The composite identity class ""class org.apache.openjpa.persistence.embed.compositepk.SubjectIdClass"" for entity ""class org.apache.openjpa.persistence.embed.compositepk.SubjectWithIdClass"" is not serializable.

Thanks!","24/Jun/16 02:51;jpaheath;Thanks for the review and comments Francesco!  Regarding that commented out code, it was deliberately commented out.  Prior to this fix, it was a work around.  In other words, if you created a Criteria which selected the individual fields of the PK then the test would work.  For history sake I left that commented code in the test case, but given your confusing I've added better comments about why I left it in there.
Finally, I made SubjectIdClass Serializable.  Thanks again for the detailed review!

Thanks,

Heath","24/Jun/16 03:28;jira-bot;Commit 1750036 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1750036 ]

OPENJPA-2631: Fix for CriteriaBuilder issue with an @EmbeddedId that contains more than one field.","24/Jun/16 03:31;jira-bot;Commit 1750037 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1750037 ]

OPENJPA-2631: Fix for CriteriaBuilder issue with an @EmbeddedId that contains more than one field.  Ported 2.1.x commit to 2.2.x","24/Jun/16 03:33;jira-bot;Commit 1750038 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1750038 ]

OPENJPA-2631: Fix for CriteriaBuilder issue with an @EmbeddedId that contains more than one field.  Ported 2.1.x commit to trunk","24/Jun/16 03:43;jira-bot;Commit 1750039 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1750039 ]

OPENJPA-2631: Fix for CriteriaBuilder issue with an @EmbeddedId that contains more than one field.  Ported 2.1.x commit to 2.2.1","24/Jun/16 07:32;ilgrosso;You're welcome! Glad that you applied the patch to all recent branches, thanks.",03/Jan/17 07:37;ilgrosso;Bulk close for 2.4.2,11/Jul/17 20:29;dazeydev;I believe this fix introduced a failure. org.apache.openjpa.jdbc.meta.ClassMapping throws an ArrayOutOfBoundsException if using an @EmbeddedId. getPrimaryKeyFieldMappings() on the Entity with the EmbeddedId will return an array with length = 0. A length check needs to be added.,20/Jul/17 20:33;dazeydev;Opened https://issues.apache.org/jira/browse/OPENJPA-2705 to fix this issue,,,,,,,,,,,,,,,
Please delete old releases from mirroring system,OPENJPA-2628,12936155,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ilgrosso,sebb@apache.org,sebb@apache.org,02/Feb/16 22:37,15/Sep/16 14:34,14/Mar/19 03:03,15/Sep/16 14:34,1.2.3,2.3.0,,,,,,,,,,,,,,,,0,,,,,,,,"

To reduce the load on the ASF mirrors, projects are required to delete old releases [1]

Please can you remove all non-current releases?

i.e. the ones listed as affected.

Thanks!

Also, if you have a release guide, perhaps you could add a cleanup stage to it?

[1] http://www.apache.org/dev/release.html#when-to-archive
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2016-09-03 11:17:44.808,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Thu Sep 15 14:34:14 UTC 2016,,,,,,,0|i2sbqf:,9223372036854775807,,,,,,,,14/Mar/16 19:11;sebb@apache.org;PING,"02/Sep/16 23:18;sebb@apache.org;Is anyone there?

Please can you tidy up the dist area:

https://dist.apache.org/repos/dist/release/openjpa/

It's not fair to expect 3rd party mirrors to carry old releases","03/Sep/16 11:17;ilgrosso;AFAICT, the following releases are available from the dist area:

* 1.2.3
* 2.2.2
* 2.3.0
* 2.4.1

which are all the most recent versions available from their respective branches, and linked from http://openjpa.apache.org/downloads.html
I am not sure about 1.2.3, but other releases should stay.

I would anyway clean up some downloads from the page above, or anyway point to archive.apache.org.

Moreover, http://openjpa.apache.org/release-management.html might be updated with some explicit clean up steps.","03/Sep/16 11:33;sebb@apache.org;Only currently maintained releases are supposed to be published via the 3rd party mirrors.

There have been no updates to 2.2.2/2.3.0 since 2013, so they are not active.

Older releases can still be linked from a download page, but the links should point to the archive server.

Remember that 3rd party mirrors give their services for free.
They should not be expected to carry more releases than is necessary.

","03/Sep/16 11:57;ilgrosso;> There have been no updates to 2.2.2/2.3.0 since 2013, so they are not active.

Bad assumption.

https://svn.apache.org/repos/asf/openjpa/branches/2.2.x and https://svn.apache.org/repos/asf/openjpa/branches/2.3.x had recently some commits (last ones date Aug 19th and 26th, respectively), and several issues fixed since there.

> Older releases can still be linked from a download page, but the links should point to the archive server.

This is exactly what I am saying above.

> Remember that 3rd party mirrors give their services for free.
> They should not be expected to carry more releases than is necessary.

Completely agree. At the moment OpenJPA is occupying 271 MB.","03/Sep/16 12:40;struberg;We could remove 2.3.0 for sure. I also think the 1.x branch is not actively maintained anymore. That is a spec from the 2005 area...
","03/Sep/16 12:44;ilgrosso;Ok, so the tasks are:

# keep only 2.2.2 and 2.4.1 in the dist area
# update links in http://openjpa.apache.org/downloads.html (for all but 2.2.2 and 2.4.1) with archive.apache.org
# update http://openjpa.apache.org/release-management.html might be updated with explicit clean up steps

Correct / complete?","03/Sep/16 14:18;struberg;Sounds good to me. Francesco, do you like to take over?",03/Sep/16 16:36;ilgrosso;Sure :-),"03/Sep/16 17:03;ilgrosso;Well, I wish to but it seems I do not have the necessary authorizations when removing 1.2.3 and 2.3.0 from https://dist.apache.org/repos/dist/release/openjpa

{code}
svn: E195023: Commit failed (details follow):
svn: E195023: Changing directory '/home/ilgrosso/openjpa/1.2.3' is forbidden by the server
svn: E175013: Access to '/repos/dist/!svn/txr/15148-cya/release/openjpa/1.2.3' forbidden
svn: E175002: Additional errors:
svn: E175002: DELETE of '/repos/dist/!svn/txr/15148-cya/release/openjpa/1.2.3': 403 Forbidden
{code}","03/Sep/16 17:11;jira-bot;Commit 1759112 from [~ilgrosso] in branch 'site/trunk'
[ https://svn.apache.org/r1759112 ]

[OPENJPA-2628] Linking all downloads but 2.4.1 / 2.2.2 from archive.apache.org","03/Sep/16 17:29;jira-bot;Commit 1759115 from [~ilgrosso] in branch 'site/trunk'
[ https://svn.apache.org/r1759115 ]

[OPENJPA-2628] Update how to publish to the /dist area (including cleaning up older releases)","03/Sep/16 17:31;ilgrosso;All done except the effective clean up of the /dist area, because of missing authorizations as reported above: [~struberg] could you help?","04/Sep/16 08:23;struberg;I was thinking about 1.x and the rest.
How often are they really used? We still have them in our archives anyway. So they don't go away, just don't get mirrored to all our volunteers.
And many mirrors also only add with rsync but do not remove. 
Heath, are you good with that solution?","04/Sep/16 17:32;sebb@apache.org;By default only LDAP committee members [1] can update the dist/release trees.

[The PMC can vote to ask Infra change this to all committers if they wish.]

[1] http://home.apache.org/phonebook.html?ctte=openjpa","04/Sep/16 17:34;sebb@apache.org;""And many mirrors also only add with rsync but do not remove.""

They are not supposed to do that, and I am not aware of any that keep old releases.
","04/Sep/16 19:45;struberg;Oki, some remove old versions, others don't
http://apache.belnet.be/openwebbeans/
http://apache.lauf-forum.at/openwebbeans/

Anyway, our archive still have them.","05/Sep/16 07:10;ilgrosso;Understand, thanks [~sebb@apache.org] for information.
[~struberg] I guess it's up to you to do some clean up, then.","05/Sep/16 07:12;ilgrosso;http://openjpa.apache.org/downloads.html#older-incubating-releases points to some broken links (as people.apache.org was decomissioned) and I could not find such versions in http://archive.apache.org/dist/openjpa/

What shall we do?","05/Sep/16 07:17;struberg;I think we can let go the incubating releases. 
Most users want the latest, the one used in TomEE and the one used in WebSphere8/9. 
Of course some limited interest might be in the version used in WAS7. 
Incubator versions are imo of no interest anymore. 
Imo we should remove them from the download section alltogether. We still have the tags in SVN.","05/Sep/16 07:20;jira-bot;Commit 1759204 from [~ilgrosso] in branch 'site/trunk'
[ https://svn.apache.org/r1759204 ]

[OPENJPA-2628] Removing incubating releases","15/Sep/16 14:34;ilgrosso;Trying out my fresh PMC privileges by cleaning up the dist area, as indicated.",,,,,
Sporadic ClassCastException occurs under heavy load when QuerySQLCache is enabled.,OPENJPA-2609,12902522,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,jpaheath,jpaheath,jpaheath,05/Oct/15 21:56,19/Jul/16 20:05,14/Mar/19 03:03,19/Oct/15 02:11,2.2.3,2.4.0,,,,,,,2.1.2,2.2.1.1,2.2.3,2.4.1,,query,,,,0,,,,,,,,"HI!  I have a customer hitting the following (root) exception:

Caused by: java.lang.ClassCastException: java.lang.String incompatible with java.lang.Integer
	at org.apache.openjpa.jdbc.kernel.PreparedSQLStoreQuery$PreparedSQLExecutor.toParameterArray(PreparedSQLStoreQuery.java:160)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:857)
	... 23 more

For the reader's convenience, here is the 'PreparedSQLStoreQuery$PreparedSQLExecutor.toParameterArray':

public synchronized Object[] toParameterArray(StoreQuery q, Map userParams) {
........
        Set<Map.Entry<Object,Object>> userSet = userParams.entrySet();
            for (Map.Entry<Object,Object> userEntry : userSet) {
                int idx = ((Integer)userEntry.getKey()).intValue();  <----- line 160

This exception only occurs sporadically, and typically under a heavy load (many threads).  After many days of heads down debug with a debugger (and LOTS of luck), I was able to recreate (simulate) the issue by placing strategic break points in my test.....in other words it is a manual recreate and not one I can automate.  Let me take you on my debug journey for posterity sake.

The first question to ask ourselves is: ""how do we get into the PreparedSQLStoreQuery$PreparedSQLExecutor.toParameterArray code"".  The second question to ask is:  ""how do we get a String when an Integer is expect (i.e. incorrect 'userParams')"".  The first question isn't too hard to answer, the second question is the very hard, time consuming part.  To get a PreparedSQLStoreQuery$PreparedSQLExecutor, we must execute a query at least twice where query SQL caching (QuerySQLCache) is enabled.  In other words, lets take this query from my test:

q = em.createQuery(""select o from MyEntity o where upper(o.comment) like :mrn"");
q.setParameter(""mrn"", ""test"");
q.getResultList();

The first time we execute this query the ""store query"" will be 'ExpressionStoreQuery$DataStoreExecutor', the second time it will be a 'PreparedSQLStoreQuery$PreparedSQLExecutor.  This is only the case when QuerySQLCache=true (which is the default).  Set it to false and query SQL cache is disabled and we'd only see a 'ExpressionStoreQuery$DataStoreExecutor'.  Consequently to resolve the ClassCastException simply disable the query SQL cache (not a great option I realize, but a work around nonetheless.)

Now that we understand how to repeatedly invoke the 'PreparedSQLStoreQuery$PreparedSQLExecutor.toParameterArray', lets move on to the more daunting task: determining the circumstances under which the 'userParams' contains a set of Strings rather than Integers.  To start, if we put a breakpoint in 'toParameterArray' we see this stack in the debugger:

PreparedSQLStoreQuery$PreparedSQLExecutor.toParameterArray(StoreQuery, Map) line: 165	
QueryImpl.execute(int, Map) line: 862	
QueryImpl.execute(Map) line: 794	
DelegatingQuery.execute(Map) line: 542	
QueryImpl<X>.execute() line: 286	
QueryImpl<X>.getResultList() line: 302	
.......

Using this info we can walk the stack to determine where the 'params' come from.  Walking down the stack to QueryImpl.execute, line 286, we can see the 'params' are created/manipulated here:

private Object execute() {
.......
	    lock();
            Map params = getParameterValues();
            boolean registered = preExecute(params);
            Object result = _query.execute(params);
            if (registered) {
                postExecute(result);

As you can see, 'params' is created and then passed to 'preExecute' and 'execute' (take it on faith that nothing relevant happens in getParameterValues).  The real interesting operations occur in 'preExecute', and then later in 'postExecute'.  In 'preExecute', a call is made to PreparedQueryCacheImpl.register:

    public Boolean register(String id, Query query, FetchConfiguration hints) {
.........
        PreparedQuery cached = get(id);
        if (cached != null)
            return null; // implies that it is already cached
        
        PreparedQuery newEntry = new PreparedQueryImpl(id, query); 
        return cache(newEntry);

But a breakpoint on 'return' and notice here that two threads can each create a PreparedQuery (pq).  Next, allow both threads to move in lock-step.  Doing this you will see that in the 'cache' method both threads go after a lock:

public boolean cache(PreparedQuery q) {
lock(false);
try {
String id = q.getIdentifier();
.....

_delegate.put(id, q);
.....

return true;
} finally {
unlock(false);

One thread wins and get the lock, adds to the cache (_delegate) and then returns 'true' (i.e. indicating that the register occurred).  Once the first thread gives up the lock, obviously the waiting thread gets the lock and notice that it is going to blindly add its pq to the cache.  So we have a classic race condition and this is the first problem (note I said FIRST problem).  Solution: we need to check the cache and simply return (and return false) if there already exists and entry for the given id.  Despite what I'm about to say, we need this solution no matter what.  
The fun doesn't end here, we still haven't figured out how/where/why the 'params' are messed up, so lets continue.  At this point, the last thread added its pq into the cache and again, true is returned.  The fact that true is returned for both threads sets in motion state which can effect down stream operations.  That is, look again at the 'execute' method listed above.  Notice that when 'registered' is true, we take the 'postExecute' method.  I think the intentions are to take 'postExecute' only once, and only for the thread that actually 'registered' (put into the cache) a pq.  Clearly though at this point we have two threads taking 'postExecute' for what should be the same id/pq.  Here is where things get interesting w.r.t the 'params'.  In 'postExecute' we are going to 'initialize' the pq and in so doing we make our way to PreparedQueryImpl.setUserParameterPositions:

void setUserParameterPositions(List list) {
    _userParamPositions = new HashMap<Object, Integer[]>();
    List<Integer> positions = new ArrayList<Integer>();
    for (int i = 1; list != null && i < list.size(); i += 2) {
........
    _userParamPositions.put(key, positions.toArray(new Integer[positions.size()]));


Uh oh!!  Red flag!!  Notice here that both threads can (and do) operated on '_userParamPositions', and notice '_userParamPosistion' is a (non-threadsafe) HashMap!  Obviously multiple threads can stomp on each other with the use of '_userParamPositions''.  Enough said.
Now, we are closer to understand where the 'params' get messed up, but I still haven't shown how the CCEx can occur.  For that, we need to let the above query run to completion, and then run it a second time (with the same EMF/EM of course).  When it is executed a second time, the above 'preExecute' method is called and this time it finds a cached pq (rather than registering one as was done in the first iteration).  Furthermore, in 'preExecute' we take this block of code:

if (pq.isInitialized()) {
try {
Map rep = pq.reparametrize(params, _em.getBroker());
params.clear();
params.putAll(rep);
} catch (UserException ue) {
invalidatePreparedQuery();
return false;

Notice that 'reparametrize' operates on 'params', and notice that there is a try/catch bock around this code because 'reparametrize' can throw a UserEx for a multitude of reasons.....see the method code for details, but note that it uses '_userParamPositions'.  Now, imagine a case where many threads are using HashMap '_userParamPositions'.  A situation can occur where the HashMap gets messed up to the point it causes 'reparametrize' to throw a UserEx!  In this case, you can see that params.clear() and params.putAll(rep) above are skipped!  Effectively we have a case where the params may not get ""reparametrize"" as expected.  
For those still with me I have now demonstrated how/why/where 'params' can get messed up.  As one can hopefully see, there is a lot going on here and many things have to aline just right for the CCEx to occur.  To round this out, if we assume that 'reparametrize' causes a UserEx (I've ""simulated"" it using a debugger), when the execution of the query occurs the second time, and when query SQL cache is enabled, the 'params' passed to 'PreparedSQLStoreQuery$PreparedSQLExecutor.toParameterArray' have effectively not been 'reparametrize' (i.e. they contain a map of String->Object, rather than Integer->Object), hence the CCEx!

Having said all of that, I don't have a clear fix to this.  I've spoken with Jody Grassel about this and he is at the same point as I.  Ultimately code needs to be added to make '_userParamPositions' thread safe.  However, this could be a really large undertaking and not a change I would want to add in service.  We definitely know that we need to make the PreparedQueryCacheImpl.cache method avoid a race condition as I mentioned above.  To do this, we need to check the cache for an existing pq as I mentioned above.  Doing this would ensure that only one thread would register and initialize a pq instance for a given id (query).  My feeling is this will fix the CCEx as we will not have multiple threads creating/initializing a pq, and thus not creating, and adding to the, '_userParamPositions'.  I know I'm kicking the can down the road a bit, but like I said I'm not comfortable with reworking the PreparedQueryImpl in service, especially when we haven't seen other issues in this area (tick tick tick........
If you have thoughts or if I'm missing something obvious please let me know.

Thanks,

Heath Thomann",,,,,,,,,,,,,,OPENJPA-2646,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-10-18 19:38:43.276,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Sun Oct 18 19:52:11 UTC 2015,,,,,,,0|i2mlxj:,9223372036854775807,,,,,,,,"18/Oct/15 19:38;jira-bot;Commit 1709309 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1709309 ]

OPENJPA-2609: Sporadic ClassCastException occurs under heavy load when QuerySQLCache is enabled.","18/Oct/15 19:48;jira-bot;Commit 1709310 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1709310 ]

OPENJPA-2609: Sporadic ClassCastException occurs under heavy load when QuerySQLCache is enabled.  Merged 2.1.x changes to 2.2.1.x.","18/Oct/15 19:50;jira-bot;Commit 1709311 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1709311 ]

OPENJPA-2609: Sporadic ClassCastException occurs under heavy load when QuerySQLCache is enabled.  Merged 2.1.x changes to 2.2.x.","18/Oct/15 19:52;jira-bot;Commit 1709312 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1709312 ]

OPENJPA-2609: Sporadic ClassCastException occurs under heavy load when QuerySQLCache is enabled.  Merged 2.1.x changes to trunk.",,,,,,,,,,,,,,,,,,,,,,,
DelegatingConnection.unwrap() doesn't adhere to java.sql.Wrapper.unwrap() contract,OPENJPA-2605,12854226,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,fyrewyld,fyrewyld,11/Aug/15 18:36,09/Nov/15 18:57,14/Mar/19 03:03,09/Nov/15 18:57,2.2.2,2.4.0,,,,,,,2.2.3,2.4.1,,,,lib,,,,0,,,,,,,,"The implementation of DelegatingConnection.unwrap() checks if the delegate is assignable to the class type provided in the unwrap argument() and returns null if it is not.  The negative result is not consistent with the unwrap() contract as specified by the Wrapper.unwrap() contract, as specified:

""Returns an object that implements the given interface to allow access to non-standard methods, or standard methods not exposed by the proxy. If the receiver implements the interface then the result is the receiver or a proxy for the receiver. If the receiver is a wrapper and the wrapped object implements the interface then the result is the wrapped object or a proxy for the wrapped object. Otherwise return the the result of calling unwrap recursively on the wrapped object or a proxy for that result. If the receiver is not a wrapper and does not implement the interface, then an SQLException is thrown.""

Since DelegatingConnection is effectively a wrapper, it should check if the delegate is assignable to the type specified by the argument and return the delegate if it is, otherwise it should call the delegate's unwrap() method with the type argument provided as the argument to the underlying unwrap() call.",,,,,,,,,,,,,,,,,,,11/Aug/15 18:54;fyrewyld;OJ-2605.2.2.x.patch;https://issues.apache.org/jira/secure/attachment/12749908/OJ-2605.2.2.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2015-11-09 16:43:27.772,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Mon Nov 09 18:54:52 UTC 2015,,,,,,,0|i2ill3:,9223372036854775807,,,,,,,,11/Aug/15 18:54;fyrewyld;Proposed patch.,"09/Nov/15 16:43;jira-bot;Commit 1713475 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1713475 ]

OPENJPA-2605: DelegatingConnection.unwrap() doesn't adhere to java.sql.Wrapper.unwrap() contract","09/Nov/15 18:54;jira-bot;Commit 1713509 from [~fyrewyld] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1713509 ]

OPENJPA-2605: DelegatingConnection.unwrap() doesn't adhere to java.sql.Wrapper.unwrap() contract",,,,,,,,,,,,,,,,,,,,,,,,
Merging an unmanaged entity multiple (3) times leads to an exception.,OPENJPA-2603,12852374,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jpaheath,jpaheath,jpaheath,05/Aug/15 20:32,19/Oct/15 02:12,14/Mar/19 03:03,19/Oct/15 02:12,2.1.2,2.2.1.1,2.2.3,2.4.1,,,,,2.1.2,2.2.1.1,2.2.3,2.4.1,,jpa,,,,0,,,,,,,,"I have a scenario, albeit a very odd one, where by doing multiple 'merge' calls on the same unmanaged entity causes an exception.  I say that it is an 'odd' case because of the fact that an 'unmanaged' entity is being merged multiple times.  The proper way to handle the scenario is to merge the managed instance.  I'll attach a test to recreate/demonstrate the issue, but for now here are code snippets we can use to explain the issue:

@Entity
@IdClass( LineItemPK.class )
public class LineItem {
	@Id
	@Column( name = ""ORDER_ID"", nullable = false )
	private Long orderId;
	
	@Id
	@Column( name = ""ITEM_ID"", nullable = false )
	private Long itemId;
......

@Embeddable
public class LineItemPK implements Serializable {
	@Column( name = ""ORDER_ID"", nullable = false )
	private Long orderId;
	
	@Column( name = ""ITEM_ID"", nullable = false )
	private Long itemId;
......

@Entity
@Table( name = ""ORDER_TABLE"" )
public class Order {
      @Id 
      @Column( name = ""ID"", nullable = false )
      private Long id; 

      @OneToMany( fetch = FetchType.EAGER, cascade = CascadeType.ALL )
      @JoinColumn( name = ""ORDER_ID"", referencedColumnName = ""ID"" )
      private List<LineItem> items;
......


With these classes, take this test:

em.getTransaction().begin();
Order order = new Order( 1l );
        
LineItem item = new LineItem( ""my product"", 44, 4.99f );
order.addItem(item);

//NOTE: Notice that throughout the rest of the test the unmanaged order is //merged.  Throughout the rest of the test we should do a 
//'order = em.merge(order)', or something to that effect (i.e. use the //'managed' order).  However, technically speaking merging the unmanaged //order is not wrong, albeit odd and potentially error prone.        
em.merge(order);
em.getTransaction().commit();

em.getTransaction().begin();
LineItem additional = new LineItem( ""My second product"", 1, 999.95f );
order.addItem(additional);
order.setOrderEntry( new Date( System.currentTimeMillis() ) );
em.merge(order);
//NOTE: do a flush here and all works fine:
//em.flush();
em.merge(order);
em.getTransaction().commit();

As you can see, the unmanaged order is merged.  As my comments above suggest this is odd, but technically not wrong.  What makes this case interesting is that if we change LineItem to use a single PK rather than a compound PK, all works fine!    The issue can also be resolve by performing a strategic 'flush' as commented above.  Furthermore, the exception the above test yields is:

Caused by: <openjpa-2.1.2-SNAPSHOT-r422266:1686894M fatal general error> org.apache.openjpa.persistence.PersistenceException: Column 'ORDER_ID'  cannot accept a NULL value. {prepstmnt 27085446 UPDATE ITEM_TABLE SET ORDER_ID = ? WHERE ORDER_ID = ? [params=(null) null, (long) 1]} [code=20000, state=23502]

This is rather meaningless and is caused because OpenJPA executes this SQL when doing the third merge:

openjpa.jdbc.SQL - <t 3968441, conn 30267242> executing prepstmnt 27085446 UPDATE ITEM_TABLE SET ORDER_ID = ? WHERE ORDER_ID = ? [params=(null) null, (long) 1]

Given the odd message, and the fact that things work for the same exact scenario when a single PK is used, and the fact that it can be resolved iwth a 'flush', it makes sense to fix this issue.  

Finally, I can't stress enough that the proper way to perform the above test is to use the MANAGED version of the 'order'.  In other words, replace all 'em.merge(order)' with 'order = em.merge(order)'.  The above scenario creates far more SQL statements because of merging an unmanaged entity than if you merged a managed entity.

Thanks,

Heath",,,,,,,,,,,,,,,,,,,05/Aug/15 21:43;jpaheath;OPENJPA-2603-2.1.x.patch;https://issues.apache.org/jira/secure/attachment/12748936/OPENJPA-2603-2.1.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2015-10-17 18:29:12.64,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Sat Oct 17 18:37:37 UTC 2015,,,,,,,0|i2idwv:,9223372036854775807,,,,,,,,"17/Oct/15 18:29;jira-bot;Commit 1709201 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1709201 ]

OPENJPA-2603: Merging an unmanaged entity multiple (3) times leads to an exception.","17/Oct/15 18:33;jira-bot;Commit 1709202 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1709202 ]

OPENJPA-2603: Merging an unmanaged entity multiple (3) times leads to an exception.  Merged 2.1.x changes to 2.2.1.x.","17/Oct/15 18:35;jira-bot;Commit 1709203 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1709203 ]

OPENJPA-2603: Merging an unmanaged entity multiple (3) times leads to an exception.  Merged 2.1.x changes to 2.2.x.","17/Oct/15 18:37;jira-bot;Commit 1709205 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1709205 ]

OPENJPA-2603: Merging an unmanaged entity multiple (3) times leads to an exception.  Merged 2.1.x changes to trunk.",,,,,,,,,,,,,,,,,,,,,,,
Incorrect relationship data returned when QueryCache and FetchPlans are used.,OPENJPA-2586,12830023,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,jpaheath,jpaheath,jpaheath,15/May/15 00:04,21/Sep/16 14:37,14/Mar/19 03:03,12/Oct/15 20:44,2.1.2,2.2.1.1,2.2.2,2.4.1,,,,,2.0.2,2.1.2,2.2.1.1,2.2.3,2.4.1,datacache,jdbc,,,0,,,,,,,,"I have found a scenario that the wrong data is returned when the DataCache, QueryCache, and FetchPlans are used.  To explain, take these very simple entities and relationship:

@Entity
public class Entity1 {
    @Id
    private int id;

    @OneToOne(fetch = FetchType.LAZY)
    private Entity2 ent2;
........

@Entity
public class Entity2 {
    @Id
    private Long id;
......

Given these two entities, take this scenario:

Query q = em.createQuery(""Select e1 from Entity1 e1"");
FetchPlan fetchPlan = q.unwrap(OpenJPAQuery.class).getFetchPlan();
fetchPlan.addField(Entity1.class, ""ent2"");
List<Entity1> results = (List<Entity1>) q.getResultList();

em.clear();

assertNotNull(""No results returned!"", results);
for (Entity1 e1 : results) {
    assertNotNull(""An 'Entity2' should have been returned!"", e1.getEnt2());
}


With this code, assume the DataCache and QueryCache are both enabled, and assume there is an Entity1 with an Entity2 in the database.  When we execute this code all works fine.  However, if we execute the code back to back using the same EntityManagerFactory, an Entity1 will be returned but its Entity2 will be null!  If on the other hand, we execute the code 3 times in a row, where there is a time lag between the 2nd and 3rd execution greater than the DataCache timeout, the correct data will be returned during the 3rd execution.  This shows that there is a problem when the DataCache, QueryCache, and a FetchPlan are used.  For more details please see the patch I've attached which contains a test to recreate this issue as well as a proposed fix.

Thanks,

Heath Thomann
",,,,,,,,,,,,,,,,,,,15/May/15 20:44;jpaheath;OPENJPA-2586-2.2.x.patch;https://issues.apache.org/jira/secure/attachment/12733246/OPENJPA-2586-2.2.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2015-09-10 00:26:27.899,,,no_permission,,,,Patch,,,,,,,,9223372036854775807,,,Thu Sep 10 01:53:29 UTC 2015,,,,,,,0|i2erbr:,9223372036854775807,,,,,,,,"10/Sep/15 00:26;jira-bot;Commit 1702137 from [~jpaheath] in branch 'openjpa/branches/2.0.x'
[ https://svn.apache.org/r1702137 ]

OPENJPA-2586: Fix to return proper relationship data when QueryCache and FetchPlans are used.","10/Sep/15 01:36;jira-bot;Commit 1702142 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1702142 ]

OPENJPA-2586: Fix to return proper relationship data when QueryCache and FetchPlans are used.","10/Sep/15 01:45;jira-bot;Commit 1702143 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1702143 ]

OPENJPA-2586: Fix to return proper relationship data when QueryCache and FetchPlans are used.","10/Sep/15 01:49;jira-bot;Commit 1702145 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1702145 ]

OPENJPA-2586: Fix to return proper relationship data when QueryCache and FetchPlans are used.","10/Sep/15 01:53;jira-bot;Commit 1702147 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1702147 ]

OPENJPA-2586: Fix to return proper relationship data when QueryCache and FetchPlans are used.",,,,,,,,,,,,,,,,,,,,,,
fix broken JavaDoc,OPENJPA-2576,12818810,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,struberg,struberg,07/Apr/15 06:09,06/Jun/15 14:25,14/Mar/19 03:03,16/Apr/15 21:24,2.3.0,,,,,,,,2.4.0,,,,,build / infrastructure,,,,0,,,,,,,,"Our code is full with broken JavaDocs. I already removed @return statements without any further description. 
We should also get rid of @param without any comments and wrong @param declarations. We have about 500 such issues and JavaDoc is totally freaking out. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-04-07 10:37:17.326,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Thu Apr 16 21:24:32 UTC 2015,,,,,,,0|i2cw07:,9223372036854775807,,,,,,,,"07/Apr/15 10:37;jira-bot;Commit 1671792 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1671792 ]

OPENJPA-2576 remove @nonjava which is actually not a javadoc tag","16/Apr/15 20:57;struberg;I've also fixed the creation of javadoc during a release. When releasing we create javadoc separately for each jar. 
If we build javadoc for publishing the site we have a -Pjavadoc-profile which builds one aggregated javadoc jar though.","16/Apr/15 21:24;jira-bot;Commit 1674154 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1674154 ]

OPENJPA-2576 fix broken JavaDocs",16/Apr/15 21:24;struberg;Fixed quite a bit. Still many things pen still. We need a follow up ticket.,,,,,,,,,,,,,,,,,,,,,,,
"org.apache.openjpa.persistence.InvalidStateException: Attempt to set column ""X to two different values... on trunk/2.4.0",OPENJPA-2573,12782204,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,romain.manni-bucau,romain.manni-bucau,16/Mar/15 14:15,06/Jun/15 14:25,14/Mar/19 03:03,16/Mar/15 21:57,,,,,,,,,2.4.0,,,,,,,,,0,,,,,,,,same as OPENJPA-2335 but for trunk - 2.3 fix was not ported over here,,,,,,,,,,,,OPENJPA-2335,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-03-16 21:57:43.883,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Mon Mar 16 21:57:43 UTC 2015,,,,,,,0|i26t2n:,9223372036854775807,,,,,,,,16/Mar/15 21:57;struberg;merged over to trunk in r1667136.,,,,,,,,,,,,,,,,,,,,,,,,,,
Criteria Builder query generates extra alias when using multiselect.,OPENJPA-2571,12777706,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,jpaheath,jpaheath,jpaheath,25/Feb/15 23:42,04/May/15 20:39,14/Mar/19 03:03,04/May/15 17:00,2.2.3,2.4.0,,,,,,,2.1.2,2.2.1.1,2.2.3,2.4.0,,criteria,,,,0,,,,,,,,"I have a scenario (see attached .test file) where an extra alias is generated for a query created by CriteriaBuilder.  For the given test, this SQL is generated:

SELECT t0.empl_cnt FROM
T_FACT_WORK_ASGNMT t0, T_DIM_DAY t1, T_DIM_DAY t3 
WHERE (t0.CLNT_OBJ_ID = ? AND t1.ROLL_13_MNTH_IND = ? AND t0.pers_obj_id IN (
   SELECT t2.pers_obj_id FROM T_FACT_WORK_ASGNMT t2 WHERE    
   (t2.CLNT_OBJ_ID = ? AND t3.MNTH_STRT_DAY_KY >= ?))) 

Notice that T_DIM_DAY is aliased twice.  
If I do a 'toString' on the CriteriaQuery which the test creates, and then create/execute a query using the string, the generated query is exactly like the above SQL, minus the 'T_DIM_DAY t3'.  This would seem to tell me that we take a different path when creating/executing a query with a 'CriteriaQuery' as opposed to just a JPQL string.

Thanks,

Heath",,,,,,,,,,,,,,,,,,,25/Feb/15 23:44;jpaheath;OPENJPA-2571.test;https://issues.apache.org/jira/secure/attachment/12700907/OPENJPA-2571.test,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2015-04-13 22:23:00.713,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Tue Apr 14 18:59:32 UTC 2015,,,,,,,0|i262av:,9223372036854775807,,,,,,,,"13/Apr/15 22:23;jira-bot;Commit 1673300 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1673300 ]

OPENJPA-2571: Criteria Builder query generates extra alias when using multiselect.","14/Apr/15 18:35;jira-bot;Commit 1673497 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1673497 ]

OPENJPA-2571: Criteria Builder query generates extra alias when using multiselect.","14/Apr/15 18:44;jira-bot;Commit 1673503 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1673503 ]

OPENJPA-2571: Criteria Builder query generates extra alias when using multiselect.","14/Apr/15 18:59;jira-bot;Commit 1673513 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1673513 ]

OPENJPA-2571: Criteria Builder query generates extra alias when using multiselect.",,,,,,,,,,,,,,,,,,,,,,,
FinderCache contains incorrectly cached query with a NULL for a Primary Key.,OPENJPA-2557,12766612,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,,jpaheath,jpaheath,10/Jan/15 02:02,21/Sep/16 20:17,14/Mar/19 03:03,27/Feb/15 03:15,2.1.2,2.2.1.1,2.2.2,2.3.0,2.4.0,,,,2.1.2,2.2.1.1,2.2.3,2.4.0,,query,,,,0,,,,,,,,"Take the following SQL from a finder:

SELECT t1.code, t1.EXTDISCR, t0.field1, t0.field2 FROM TB1 t0 LEFT OUTER JOIN AbstractExtValue t1 ON t0.EXT_USR = t1.code WHERE (t1.EXTDISCR IS NULL OR t1.EXTDISCR IN (?)) AND t0.field1 = ? AND t0.field2 IS NULL

Notice the 't0.field2 IS NULL' part.  Field2 is part of a compound PK of table 'TB1', where the compound PK consists of two fields (field1 and field2).  This will become more apparent when looking at the attached test.  Because the PK field 'IS NULL', this finder query should NOT be added to the FinderQuery cache (i.e. we can't cache something which is ""hard coded"" to 'IS NULL'....in the case where field2 is non-null, the query will never account for that).  However, this query is in fact incorrectly added to the cache.  To understand why this is incorrectly added we must look at two things.  First, if we look at the attached test, we can see that the test uses inheritance and a discriminator value.  In the above SQL the 't1.EXTDISCR' is the discriminator value.  As you can see we are selecting field1 and field2, where field2 IS NULL.  Second, we have to look at the OpenJPA code where we determine if the finder query can be cached.  That is, look here in FinderQueryImpl:

    static FinderQueryImpl newFinder(ClassMapping mapping,
        SelectExecutor select) {
        SelectImpl impl = extractImplementation(select);
        if (impl == null)
            return null;
        SQLBuffer buffer = impl.getSQL();
        Column[] pkCols = mapping.getPrimaryKeyColumns();
        boolean canCache = pkCols.length == buffer.getParameters().size();

As you can see, the last line determines if the query can be cached (i.e. 'canCache').  In this case, OpenJPA compares the pkCols (PK columns) to the parameters.  In most cases, these two should be equal for a finder query.  However, at least in the case where a discriminator is used, the finder will have one extra more parameter in the finder query.  In those cases, the 'canCache' will be false and the query not cached.  However, take the case where one of the compound PKs contains 'IS NULL' (see above SQL at the start of this text).  In this case, 'pkCols.length' will be two, AND the params will be two.  So by the 'canCache' test, it will be true.  However, in this case we should not cache the above query (i.e. in so doing field2 will always be ""NULL"").  
To resolve this issue, I feel that we need to make sure the the columns in the 'buffer'  exactly match that of pkCols.  See the attached test/patch for proposed fix.

Thanks,

Heath Thomann",,,,,,,,,,,,,,,,,,,10/Jan/15 02:09;jpaheath;OPENJPA-2557-2.1.x.patch;https://issues.apache.org/jira/secure/attachment/12691465/OPENJPA-2557-2.1.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2015-01-14 18:16:21.974,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Fri Feb 27 01:46:41 UTC 2015,,,Patch Available,,,,0|i247zb:,9223372036854775807,,,,,,,,"14/Jan/15 18:16;curtisr7;+1

The patch looks good to me.","27/Feb/15 01:27;jira-bot;Commit 1662610 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1662610 ]

OPENJPA-2557: FinderCache contains incorrectly cached query with a NULL for a Primary Key.","27/Feb/15 01:30;jira-bot;Commit 1662611 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1662611 ]

OPENJPA-2557: FinderCache contains incorrectly cached query with a NULL for a Primary Key.","27/Feb/15 01:40;jira-bot;Commit 1662613 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1662613 ]

OPENJPA-2557: FinderCache contains incorrectly cached query with a NULL for a Primary Key.","27/Feb/15 01:46;jira-bot;Commit 1662615 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1662615 ]

OPENJPA-2557: FinderCache contains incorrectly cached query with a NULL for a Primary Key.",,,,,,,,,,,,,,,,,,,,,,
Standard SQL boolean mapping impossible,OPENJPA-2551,12760787,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,ancoron,ancoron,10/Dec/14 15:48,06/Jun/15 14:25,14/Mar/19 03:03,05/Apr/15 08:01,2.2.1,2.2.2,2.3.0,,,,,,2.4.0,,,,,jdbc,,,,0,,,,,,,,"Currently, it is impossible to have a database table column defined as SQL standard type {{BOOLEAN}} (defined in SQL-99) automatically working with a {{java.lang.Boolean}} or {{boolean}} Java type.

I am currently testing with:
# Apache Derby 10.9
# MySQL 5.6
# PostgreSQL 9.3

\\
All three above databases support the column type definition. However, in the case of MySQL, it _magically_ works because the resulting datatype is {{TINYINT(1)}}, which is ""compatible"" with the data type {{bit}} (expected by current OpenJPA) - which makes it work by accident.

For the other two databases, I get the following exception:
{noformat}
<openjpa-2.2.0-rUnversioned directory fatal user error> org.apache.openjpa.persistence.ArgumentException: ""org.ancoron.jpa.test.TestEntity.set"" declares a column that is not compatible with the expected type ""bit"".  Column details:
Full Name: t_test.C_SET
Type: unknown(16)
Size: 1
Default: null
Not Null: false

        at org.apache.openjpa.jdbc.meta.MappingInfo.mergeColumn(MappingInfo.java:775)[218:org.apache.openjpa:2.2.0]
        at org.apache.openjpa.jdbc.meta.MappingInfo.createColumns(MappingInfo.java:593)[218:org.apache.openjpa:2.2.0]
        at org.apache.openjpa.jdbc.meta.ValueMappingInfo.getColumns(ValueMappingInfo.java:178)[218:org.apache.openjpa:2.2.0]
        at org.apache.openjpa.jdbc.meta.strats.HandlerStrategies.map(HandlerStrategies.java:65)[218:org.apache.openjpa:2.2.0]
        at org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy.map(HandlerFieldStrategy.java:82)[218:org.apache.openjpa:2.2.0]
        at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:146)[218:org.apache.openjpa:2.2.0]
        at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:82)[218:org.apache.openjpa:2.2.0]
        at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:496)[218:org.apache.openjpa:2.2.0]
        at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:461)[218:org.apache.openjpa:2.2.0]
        at org.apache.openjpa.jdbc.meta.ClassMapping.resolveNonRelationMappings(ClassMapping.java:895)[218:org.apache.openjpa:2.2.0]
        at org.apache.openjpa.jdbc.meta.MappingRepository.prepareMapping(MappingRepository.java:417)[218:org.apache.openjpa:2.2.0]
        at org.apache.openjpa.meta.MetaDataRepository.preMapping(MetaDataRepository.java:762)[218:org.apache.openjpa:2.2.0]
        at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:651)[218:org.apache.openjpa:2.2.0]
        ... 81 more
{noformat}

\\
Of course, I have applied a workaround using custom Dictionaries, but the main point is that this makes my JPA-only application use implementation-specific configuration, which JPA is supposed to avoid.

Running with EclipseLink instead of OpenJPA works as expected.","Apache Karaf, OSGi, Apache Derby, MySQL, PostgreSQL",,,,,,,,,,,,,,,,,,12/Dec/14 16:18;ancoron;OPENJPA-2551-trunk.patch;https://issues.apache.org/jira/secure/attachment/12686868/OPENJPA-2551-trunk.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2015-04-05 08:01:41.958,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Sun Apr 05 08:01:41 UTC 2015,,,,,,,0|i23aaf:,9223372036854775807,,,,,,,,"12/Dec/14 16:18;ancoron;Attached a patch for trunk: [^OPENJPA-2551-trunk.patch]

This patch changes the default mapping from the Java type boolean to SQL-99 standard data type BOOLEAN when supported by the corresponding database.

Also, conversion should be done properly when an existing database is used that uses data type {{BIT}} or similar. Best example is MySQL here which previously got a boolean field set to data type {{BIT}} and now returns {{TINYINT(1)}}.

At the same time I removed some PostgreSQL-specific workaround code and used a proper definition of standard boolean database support inside the core DBDictionary.

I've also changed some tests to account for that.

I've tested the changes with the following databases:
* MySQL 5.6 (using JDBC driver version 5.1.22 - higher versions produce test failures for datetime comparison)
* PostgreSQL 9.3 (using JDBC driver version 9.1-901-1.jdbc4)
* Derby 10.8.2.2
* H2 database 1.4.182
* HSQLDB 2.3.2

\\
Other database dictionaries have not been touched so that regressions are very unlikely.","05/Apr/15 08:01;struberg;Hi Ancoron!

The problem with changing the default mappings is that we might break many existing installations. Please check OPENJPA-2558 (shipping with 2.4.0 which we currently prepare releasing) which should also solve your problem. With that feature you can freely configure the BooleanRepresentation you like to use for your application.",,,,,,,,,,,,,,,,,,,,,,,,,
Download links for current releases are broken,OPENJPA-2548,12758123,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,curtisr7,sebb@apache.org,sebb@apache.org,27/Nov/14 03:34,06/Jun/18 17:10,14/Mar/19 03:03,16/Dec/14 23:16,,,,,,,,,,,,,,,,,,0,,,,,,,,"The links on the download pages to versions 2.2.2 and 2.3.0 are broken.

This is because release publishing now must use svnpubsub, as per the e-mail from David Nalley dated Oct 24th.

Releases are now published by adding files to the appropriate SVN directory, in this case

https://dist.apache.org/repos/dist/release/openjpa/

However this is empty, and so the ASF dist area is also empty, as are the mirrors.

Existing releases are stored in the archives server, so the currently active releases (i.e. 2.2.2 & 2.3.0) can be copied from there [1] to the SVN dist release area. By default only PMC members have the karma to do this.

[1] http://archive.apache.org/dist/openjpa/
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-12-16 23:16:57.176,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Wed Jun 06 17:10:11 UTC 2018,,,,,,,0|i22u27:,9223372036854775807,,,,,,,,16/Dec/14 21:32;sebb@apache.org;PING,"16/Dec/14 23:16;curtisr7;Committed revision 7439.

I committed the contents of http://archive.apache.org/dist/openjpa/ for 2.2.2 and 2.3.0 over to dist. Please let me know if I did it correctly.

Thanks,
Rick","17/Dec/14 01:31;sebb@apache.org;You also need to add the KEYS file in the top-level openjpa folder.

It looks as though svnpubsub has not actually been set up for OpenJPA - please raise a JIRA against INFRA for that.","17/Dec/14 01:38;sebb@apache.org;Also just noticed that links for release 1.2.3 point to the main dist area.
Unless this is still being actively maintained, please don't copy it to the SVN dist/ area.
Instead please fix the links to point to the archive server.","17/Dec/14 01:42;curtisr7;Added KEYS to /openjpa.

1.2.3 is still actively maintained so I'll add that one soon.

I also opened INFRA-8890 for the svnpubsub problem.","17/Dec/14 01:47;curtisr7;Thinking more about it, I should most likely also add 2.0.1 and 2.1.1 as those are somewhat actively maintained.","17/Dec/14 01:56;sebb@apache.org;Please don't add 2.1.1 and 2.0.1 unless there are definite planned releases.
They have not been updated in over 3 years, so it seems unlikely, and there are other releases that support the same JSR.

Remember that these files are published to every single 3rd party mirror, all of whom provide their bandwidth and storage for free.

If there ever is a new release in the 2.0.x or 2.1.x series, by all means add the new release then.
But please don't upload the existing old releases ""just in case"" - thanks.","06/Jun/18 17:10;struberg;tickets are all resolved since at least 2012, so closing them finally",,,,,,,,,,,,,,,,,,,
"When two threads attempt to get a Pessimistic Lock, one thread gets a 'false' lock.",OPENJPA-2547,12757745,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,,jpaheath,jpaheath,25/Nov/14 16:58,14/Jan/15 22:49,14/Mar/19 03:03,14/Jan/15 22:49,2.1.2,2.2.1.1,2.2.2,2.3.0,2.4.0,,,,2.1.2,2.2.1.1,2.2.2,2.4.0,,jdbc,,,,0,,,,,,,,"I have created a scenario where two threads both attempt to get a pessimistic lock on an object, where one thread legitimately gets the lock, and the other gets a 'false' lock.  To describe this issue, lets look at a test.  I will provide (attache) a full working test, but for now lets look at this snippet of the test which is at the heart of the issue:

PessimisticLockEntity entity = oem.find(PessimisticLockEntity.class, pKey);

            boolean locked = false;
            while (!locked) {
                try {
                    oem.getFetchPlan().setLockTimeout(5000);
                    oem.lock(entity, LockModeType.PESSIMISTIC_READ);
                    locked = true;
                } catch (PessimisticLockException ple) {


With this test, imagine the case where two threads call this code at roughly the same time.  In this case, one thread should receive a lock, and the other thread should receive a PessimisticLockException (PLE).  In my test, this is what happens.....so far so good.  However, the thread with the lock (call it T1) then sleeps for a while, and the thread which got the PLE (call it T2) attempts to get the lock over and over again.  When T2 tries to get a lock while T1 holds the lock, T2 should continue to receive a PLE.  However, I've found that T2 ""gets"" a lock.  That is, a PLE is never thrown because OpenJPA doesn't execute SQL to obtain the lock.  OpenJPA skips that steps and thinks T2 has a lock.  This gives T2 a false lock.

I've found that prior to JIRA OPENJPA-2449, we got the expected results (i.e. T2 continues to get a PLE while T1 holds the lock).  It is only with OPENJPA-2449 that the incorrect behavior occurs.

I will provide a patch which contains a potential fix, and a test that does two things: 1) tests the scenario above and 2) provides a test to verify OPENJPA-2449 (we never provided a test when we committed OPENJPA-2449).  My fix, if correct, simply adds one additional check to the code added via OPENJPA-2449.

Thanks,

Heath",,,,,,,,,,,,,,,,,,,25/Nov/14 19:19;jpaheath;OPENJPA-2547-2.1.x.patch;https://issues.apache.org/jira/secure/attachment/12683631/OPENJPA-2547-2.1.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-12-01 15:15:50.225,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Wed Jan 14 21:56:24 UTC 2015,,,,,,,0|i22rsn:,9223372036854775807,,,,,,,,"25/Nov/14 19:19;jpaheath;I'm attaching a test for this issue, as well as a test for the related JIRA since a test was never provided for that JIRA.  My patch also includes a proposed fix.

Thanks,

Heath","01/Dec/14 15:15;curtisr7;Heath --

You should use the LockLevels constant rather than a zero.

ie: 
List<SQLBuffer> sqls = (sm.getLock() == null || sm.getLock().equals(org.apache.openjpa.kernel.LockLevels.LOCK_NONE ))

Thanks,
Rick","14/Jan/15 20:25;jira-bot;Commit 1651808 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1651808 ]

OPENJPA-2547: When two threads attempt to get a Pessimistic Lock, one thread gets a 'false' lock.  Applied fix to 2.2.1.x.","14/Jan/15 21:48;jira-bot;Commit 1651843 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1651843 ]

OPENJPA-2547: When two threads attempt to get a Pessimistic Lock, one thread gets a 'false' lock.  Applied fix to 2.1.x.","14/Jan/15 21:55;jira-bot;Commit 1651846 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1651846 ]

OPENJPA-2547: When two threads attempt to get a Pessimistic Lock, one thread gets a 'false' lock.  Applied fix to 2.2.x.","14/Jan/15 21:56;jira-bot;Commit 1651847 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1651847 ]

OPENJPA-2547: When two threads attempt to get a Pessimistic Lock, one thread gets a 'false' lock.  Applied fix to trunk.",,,,,,,,,,,,,,,,,,,,,
Using custom openjpa.BrokerFactory not working in OSGi due to ClassLoader,OPENJPA-2542,12754473,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,j0xaf,j0xaf,11/Nov/14 14:51,06/Jun/15 14:25,14/Mar/19 03:03,10/Dec/14 14:12,2.3.0,2.4.0,,,,,,,2.4.0,,,,,osgi,,,,0,,,,,,,,"For reasons discussed on the [openjpa-user MailingList|http://mail-archives.apache.org/mod_mbox/openjpa-users/201411.mbox/%3CCALLZsMnXPQT%2BeQB3VjYe4U05%2BgSR%2Bw37QqXGRdxdvM-kgEXdLw%40mail.gmail.com%3E] I need to use a custom BrokerFactory in an OSGi environment.

My custom BrokerFactory is obviously in my own OSGi bundle, not in the official OpenJPA bundle. Now, due to OPENJPA-1491 {{org.apache.openjpa.kernel.Bootstrap}} (in connection with {{org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceUnitInfo, Map) and org.apache.openjpa.persistence.osgi.PersistenceActivator.getBundleClassLoader()), my BrokerFactories can only live in the official OpenJPA bundle, so that my custom BrokerFactory is not found.

In my opinion it would be better if {{org.apache.openjpa.persistence.osgi.PersistenceActivator.getBundleClassLoader()}} would return a ClassLoader not only delegating to openjpa´s bundle but _in addition_ (as a fallback) to the {{PersistenceUnitInfo}}´s bundle.

That way one would be able to use arbitrary BrokerFactories by importing them if required to the bundle where {{persistence.xml}} is defined.","JBoss Fuse 6.1, Apache Aries JPA 1.0.1.redhat-610379",,,,,,,,,,,,,OPENJPA-2057,OPENJPA-1491,,,,11/Nov/14 15:41;curtisr7;OPENJPA-2542.patch;https://issues.apache.org/jira/secure/attachment/12680802/OPENJPA-2542.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-11-11 15:41:18.179,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Fri Dec 12 15:39:24 UTC 2014,,,,,,,0|i228hb:,9223372036854775807,,,,,,,,"11/Nov/14 15:41;curtisr7;See if the attached patch will resolve the problem you've encountered.

Thanks,
Rick","12/Nov/14 08:04;j0xaf;Hi Rick,

wow, that´s been fast. Thank you. I´ve tested the patch under JBoss Fuse 6.1 / Karaf 2.3.0 and it´s working fine, no more ClassNotFoundExceptions.

Best regards,
Jörn","10/Dec/14 14:11;jira-bot;Commit 1644414 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1644414 ]

OPENJPA-2542: Use bundle classloader AND PersistenceUnitInfo classloader when creating a BrokerFactory.",10/Dec/14 14:12;curtisr7;Committed revision 1644414 to trunk.,"12/Dec/14 15:39;ancoron;Just as a side-note: I've also encountered this issue but I was working around it by providing the custom BrokerFactory and related classes inside an OSGi fragment bundle, attaching to the OpenJPA one.

That way, it's automatically part of the OpenJPA ClassLoader.

Nevertheless, having official support for application-level BrokerFactory customization is really nice, thank you.",,,,,,,,,,,,,,,,,,,,,,
JPQL interpret wrongly for inner join table (without mapped relation),OPENJPA-2539,12750258,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,jpaheath,zechs,zechs,24/Oct/14 02:39,26/Aug/15 21:50,14/Mar/19 03:03,26/Aug/15 21:50,2.1.0,,,,,,,,2.1.2,2.2.1.1,2.2.3,2.4.1,,sql,,,,0,,,,,,,,"I found the following issue after a few months of production of my client.

I write a java batch job to process some account data for my client. 

And I found out that the JPQL interpret wrong randomly and it is not always having the same result for the same of data and code.

JPQL statement:
SELECT B
FROM EntityA_PO A, EntityB_PO B  
WHERE A.deletingDateTime IS NULL and A.statusCode= :app and A.someId in (:ids)  
and B.deletingDateTime IS NULL and B.statusCode= :app2 and A.headerId = B.headerId  
ORDER BY B.someId


translated to unexpected SQL:

SELECT t1.HEADER_ID, t1.SOME_ID 
FROM EntityB t0 JOIN EntityB t1 ON (1 = 1) 
WHERE (t0.DELETING_DATE_TIME IS NULL AND t0.STATUS_CODE = ? AND t0.SOME_ID IN (?)
AND t1.DELETING_DATE_TIME IS NULL AND t1.STATUS_CODE = ? AND t1.HEADER_ID = t0.HEADER_ID) 
ORDER BY t1.SOME_ID ASC


the correct translated SQL:

SELECT t1.HEADER_ID, t1.SOME_ID 
FROM EntityA t0 JOIN EntityB t1 ON (1 = 1) 
WHERE (t0.DELETING_DATE_TIME IS NULL AND t0.STATUS_CODE = ? AND t0.SOME_ID IN (?) 
AND t1.DELETING_DATE_TIME IS NULL AND t1.STATUS_CODE = ? AND t1.HEADER_ID = t0.HEADER_ID) 
ORDER BY t1.SOME_ID ASC 

Detail:
The two EntityA_PO and EntityB_PO do not have any mapped relation. They are joined by a column called headerId in where clause only. 

The problem and correct generated native SQL is different by one is to=Entity A , and other is to=Entity B.

I don't know why the wrong one joining Entity B itself without any Entity A involvement. This situation seems to be existed randomly. I can't catch the pattern of it.

If there is any fix or workaround for this case, please let me know. Thanks",WebSphere v8.0,,,,,,,,,,,,,,,,,,12/Nov/14 01:29;jpaheath;OPENJPA-2539-2.1.x.test;https://issues.apache.org/jira/secure/attachment/12680969/OPENJPA-2539-2.1.x.test,18/Feb/15 04:11;jpaheath;OPENJPA-2539-2.1.x_v2.test;https://issues.apache.org/jira/secure/attachment/12699414/OPENJPA-2539-2.1.x_v2.test,11/Mar/15 23:19;jpaheath;OPENJPA-2539-2.1.x_v3.test;https://issues.apache.org/jira/secure/attachment/12704048/OPENJPA-2539-2.1.x_v3.test,12/Nov/14 01:29;jpaheath;schema_and_testing_sql.txt;https://issues.apache.org/jira/secure/attachment/12680968/schema_and_testing_sql.txt,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2014-10-24 14:07:23.11,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Mon Jun 22 18:31:08 UTC 2015,,,,,,,0|i21j1j:,9223372036854775807,,,,,,,,"24/Oct/14 14:07;curtisr7;For giggles, can you try to disable the QuerySqlCache?

<property name=""openjpa.jdbc.QuerySQLCache"" value=""false"">

If that doesn't work, I'm going to suggest to open a PMR.","28/Oct/14 10:02;zechs;PMR has been opened. I am here to see whether there is any more information 
Is it really related to cached of querySQLCache ?","28/Oct/14 12:25;curtisr7;Honestly I didn't have much time to dig into your issue... The reason I suggested that property is that I seem to remember seeing a number of issues when using 'IS NULL' JPQL and getting different SQL on different executions.

Did you try the property see if it helped your scenario?","29/Oct/14 01:49;zechs;Since my client in banking field, I can't remote the testing machine to test the property easily.  I would like to gather more info so that I am confident enough to do more test on the problem. 

You have mentioned that 'IS NULL' , can you evaluate more on that ? why it is a problem to use ""is null"" ? do there any example or fix on that ? Thank in advance.","30/Oct/14 14:27;curtisr7;After looking a bit closer at the JPQL, I am not certain that this is related to the QuerySQLCache. It's hard to say without more data.

Is this problem fairly easily repeatable? If so, posting a unit-ish test will make it much easier to diagnose the problem.","31/Oct/14 03:10;zechs;This problem is not repeatable easily. I need to loop this SQL about 200k+ times to reproduce it on client machine. 
Since I am using ""in"" in the where clause,  this sql can't be cached as seem in the log of openjpa.
I am not sure the root clause of this behavior and how to reproduce it in easier way.","12/Nov/14 01:29;jpaheath;Hey Rick!  Benson sent to me a ""test"" by other means than this JIRA.  I've ran his test as-is (a simply JSE test packaged with necessary jars).  I was NOT able to recreate the issue described on my Windows machine.  As I understand it, Benson is not able to recreate on Windows either, rather he can occasionally recreate on AIX.  I've taken Benson's test and put it into a standard OpenJPA test which you can apply.  I'm also including an SQL script which you can run to set up the tables and necessary data.  I've ran the SQL against my DB2.  This is what Benson is using as well.  

Benson - can you verify that you can only recreate on AIX??

Thanks,

Heath","13/Nov/14 14:26;curtisr7;I successfully ran the test last night against trunk on osx and mysql. I also modified the test slightly to have multiple threads execute this query in parallel. I'll try to find some time this evening to run the same scenario against 2.1.x.

Benson -- Have you tried to disable the QuerySQLCache as I mentioned before? That might help us narrow in on where the problem is.","13/Nov/14 14:38;zechs;Rick:
I have not tried to disable QuerySQLCache.

As the JPQL has ""in"" statement in where clause, the SQL interpreted can not be cached as stated in openJPA log.","20/Nov/14 03:37;zechs;Hi Rick, Health,

Do you have update for me ? Please let me know your progress. Thanks

Benson",21/Nov/14 01:01;curtisr7;Benson -- Sorry but I have not been able to recreate your issue.,"18/Feb/15 04:11;jpaheath;I have gotten to the bottom of this very tricky issue!  For history sake, or for the curious reader, I will post in great detail the means by which this issue occurs.  The details are very long, so first I'd like to provide a quick summary and get right to what I think is a solution.  For my quick summary, and your convenience, please look at method 'compilationFromCache() ' in QueryImpl here:

http://svn.apache.org/viewvc/openjpa/branches/2.1.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?revision=1035834&view=markup

Notice in this method we do a 'compCache.get(key)'.  In other words, we are getting a Compilation from the cache with a ""key"".  If we do not find a Compilation with the given key, we can see that in this method we will create a Compilation and at the end of the method put it into the 'compCache' using the key.  Now, imagine the case where two threads access the cache at the same time, with the same key, and there is no Compilation for the key.  BOTH threads will create one and put it into the compCache, where the last thread to put its Compilation ""wins"".  This is potentially bad because now you have two threads each with its own Compilation for the same key.  Later on when the ""losing"" thread accesses the cache to get a Compilation, it will get the one from the ""winning"" thread, not the one it had created.  As I understand it, there should only ever be one Compilation per key.  I will explain below why this becomes a problem.
My thinking is that 'compCache' in 'compilationFromCache' needs to be synchronized.

With that shorter introduction, let me dive into the details on why this cache issue would have an effect on generated SQL.  Apply the provided test (OPENJPA-2539-2.1.x_v2.test), and test data (schema_and_testing_sql.txt).  Let me start by looking at the spot where we have a potential race condition.  First, In QueryImpl, put a break point here:

compCache.put(key, comp)


Run the test in debug mode, and with two threads, and you will notice that both threads will break here.  Notice that in the containing method (compilationFromCache()) that we have this code before the compCache.put:


CompilationKey key = new CompilationKey();
......
Compilation comp = (Compilation) compCache.get(key);
        

As you can see, if one thread is running slower than the other, the second thread should get the Compilation from the cache for the same key.  However, since I've deliberately set a break point at compCache.put, both threads break here and they will both put a Compilation into compCache with THE SAME key.  So, the thread which executes the 'put' last effectively wins.  

Now, under most circumstances I don't think this is so bad (although ultimately I think the intentions are that only one Compilation per key would ever be added).  If it was bad we'd likely see more issues.  However, I think we need to have one more 'timing'/race condition to occur, as I'll explain, along with a few other specific things.  To help explain, I would suggest putting the following println after compCache.put:

// START - ALLOW PRINT STATEMENTS
System.out.println(Thread.currentThread() + "": "" + this.getClass() + "".compilationFromCache(), put a comp into the cache.""
                 + "" comp = "" + comp + "" and comp.datastore = "" + comp.datastore);
// STOP - ALLOW PRINT STATEMENTS

This will tell us the Compilation instance added per thread which we will use later.  After adding this println, rerun the test (in debug mode) and take note of which thread added to the cache LAST.

Next, put a break point on this line in QueryImpl, method 'compileForDataStore':

(#1) if (comp.datastore == null){
(#2)    comp.datastore = createExecutor(false);

At this time, both threads should be still stopped at compCache.put.  Allow each thread to run, which should allow them both to break on the break point at the 'if' block in 'compileForDataStore' (i.e. #1).  Notice that comp.datastore will be assigned a value returned by 'createExecutor' (keep this in mind for later).


Next, add the following to compileForExecutor in QueryImpl (likely you'll need to re-run the test and get back to the break point in the 'if' block in 'compileForDataStore'):

    private StoreQuery.Executor compileForExecutor() {
        Compilation comp = compileForCompilation();
        // START - ALLOW PRINT STATEMENTS
 (#3)   System.out.println(Thread.currentThread() + "": "" + this.getClass() 
          + "".compileForExecutor: comp = "" + comp + "", comp.datastore = "" + comp.datastore);
        // STOP - ALLOW PRINT STATEMENTS

Previously I mentioned that we needed to take note of the thread which added to the compCache LAST (call it T0).  Don't run this thread, allow the OTHER thread to run (call it T1).  When you run this thread, 'comp.datastore' will be assigned a value (#2 above), and the println (#3) we just added to 'compileForExecutor' will show that T1 gets from 'compileForCompilation()' (which calls to get the Compilation from the cache) the Compilation that it put into the Compilation cache.  So at this point, T1 has worked with the Compilation it created, and the Compilation.datastore (#2) has been assigned a value.  
Next, continue to allow thread T1 to run again.  Notice that flow will come back to #1 above, thus the break point hit.  Also notice that, the println in #3 will have made a print, meaning we executed 'compileForCompilation()', and thus got a Compilation from the cache.  Comparing the println from this thread (T1) should show that it is using the Compilation from T0!  And we know that thread T0 has just been sitting (breaking) at #1 above, so its 'comp.datastore' is null!  That means, we have to go through the 'createExecutor'!!  If thread T1 got its own Compilation, 'comp.datastore' would be non-null, and we simply would have returned!  This seems to be at the root of the issue.

Now, at this point you might be wondering how in the world this would effect something as far ""downstream"" as SQL generation.  Well, to see this I'm going to skip way ahead in the test to the point where the test causes 'DBDictionary.toSQL92Join'.  Oh, you must run this test with a DB that supports SLQ92 (like DB2).  Put a break point here and let thread T1 run to this point.  In this method you will see that 'join.getTable1()' returns a 'CFP_PLAN_HEADER', but it should be 'CTR_CFP_CURRENT'.  Because of this, we generate 'FROM CFP_PLAN_HEADER t0 JOIN CFP_PLAN_HEADER t1'.  

The latter paragraph described the end results, that is, the point at which we generate the wrong SQL.  The prior part of this post describes the problem at its root with the Compilation cache.  To tie these two together would require far more details.  However, it became an exercise to walk backwards in the code to determine where the value returned by 'join.getTable1()' came from.  Basically this is set as the ""candidate type"" in the PCPath.  In this case, because the test uses a TypedQuery, at the very end of creating a TypedQuery, we set the type.  I don't think this issue exists when the test changes to Query from TypedQuery.  Anyway, the fact that this type was set, and the fact that 'createExecutor' is executed a second time (as described above) ultimately caused the issue.

My proposed fix would be to synchronize the compCache as follows:

    protected Compilation compilationFromCache() {
+        Compilation comp = null;
        Map compCache = _broker.getConfiguration().getQueryCompilationCacheInstance();

        if (compCache == null || !isParsedQuery()) {
            return newCompilation();
        } else {
+            synchronized (compCache) {
                .......<remained of method removed for brevity>......
+            }
        }
        return comp;
    }

Thanks,

Heath","11/Mar/15 23:19;jpaheath;For history sake, I'm adding a final version of the test (OPENJPA-2539-2.1.x_v3.test).  Before running the test, run the schema_and_testing_sql.txt file to create the tables/data.  

Thanks,

Heath Thomann ","22/Jun/15 16:27;jira-bot;Commit 1686894 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1686894 ]

OPENJPA-2539: Query Compilation causing inner join table to be randomly generated incorrectly.","22/Jun/15 18:17;jira-bot;Commit 1686910 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1686910 ]

OPENJPA-2539: Query Compilation causing inner join table to be randomly generated incorrectly - ported changes to 2.2.1.x.","22/Jun/15 18:20;jira-bot;Commit 1686911 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1686911 ]

OPENJPA-2539: Query Compilation causing inner join table to be randomly generated incorrectly - ported changes to 2.2.x.","22/Jun/15 18:31;jira-bot;Commit 1686913 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1686913 ]

OPENJPA-2539: Query Compilation causing inner join table to be randomly generated incorrectly - ported changes to trunk.",,,,,,,,,,
FetchGroup is not returning lazy fields.,OPENJPA-2536,12747887,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,curtisr7,jpaheath,jpaheath,14/Oct/14 00:00,28/Jan/15 15:28,14/Mar/19 03:03,28/Jan/15 04:58,2.1.2,2.2.1.1,2.2.3,2.3.0,2.4.0,,,,2.1.2,2.2.1.1,2.2.2,2.4.0,,kernel,,,,0,,,,,,,,"I have found an issue with FetchGroups not returning 'lazy' fields.  To describe, take this entity:

@Entity
@FetchGroup(name = ""HardwareSimple"", attributes = { @FetchAttribute(name = ""status""),
    @FetchAttribute(name = ""statusActive"") })
public class HardwareStatus implements Serializable {

    @Id
    private String status;
    private String statusActive;
    private String condition;
    private int connection;
...............


With this Entity, take the following scenario:

OpenJPAEntityManager openJpaEm = OpenJPAPersistence.cast(em);
openJpaEm.getFetchPlan().resetFetchGroups().removeFetchGroup(""default"").addFetchGroups(""HardwareSimple"");

HardwareStatus h1 = em.find(HardwareStatus.class, ""Lost"");
//h1.status contains ""Lost"" in the db.
assertEquals(""Lost"",h1.getStatus());  //this assert passes
//h1.connection contains '2' in the db.        
assertEquals(2, h1.getConnection());  //this assert fails, 0 is returned by the getter.
//h1.condition contains ""Used"" in the db.
assertEquals(""Used"", h1.getCondition());  //this assert fails, null is returned by the getter.

The latter two h1.get* do not return the correct values.  These fields are 'lazy' (i.e. not part of the FetchGroup) but should be fetched when requested.  See the attached test for full details.

Thanks,

Heath


",,,,,,,,,,,,,,,,,,,24/Oct/14 14:02;curtisr7;OPENJPA-2536.patch;https://issues.apache.org/jira/secure/attachment/12676910/OPENJPA-2536.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-10-17 20:50:36.528,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Wed Jan 28 15:28:42 UTC 2015,,,,,,,0|i214pj:,9223372036854775807,,,,,,,,"17/Oct/14 20:50;curtisr7;Attaching a patch that fixes the reported problem. I'm not entirely happy with the change yet, but it is in the right area. I'll try to take a closer look at this one again next week.","28/Jan/15 04:40;jira-bot;Commit 1655218 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1655218 ]

OPENJPA-2536: FetchGroup is not returning lazy fields.  Applied Rick Curtis' fix to 2.1.x.","28/Jan/15 04:46;jira-bot;Commit 1655220 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1655220 ]

OPENJPA-2536: FetchGroup is not returning lazy fields.  Applied Rick Curtis' fix to 2.2.1.x.","28/Jan/15 04:52;jira-bot;Commit 1655221 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1655221 ]

OPENJPA-2536: FetchGroup is not returning lazy fields.  Applied Rick Curtis' fix to 2.2.x.","28/Jan/15 15:28;jira-bot;Commit 1655360 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1655360 ]

OPENJPA-2536: FetchGroup is not returning lazy fields.  Applied Rick Curtis' fix to trunk.",,,,,,,,,,,,,,,,,,,,,,
A boolean is not converted correct when using the hint 'UseLiteralInSQL'.,OPENJPA-2534,12746427,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,struberg,jpaheath,jpaheath,07/Oct/14 15:50,21/Sep/16 20:17,14/Mar/19 03:03,12/Jan/15 22:49,2.1.2,2.2.1.1,2.2.3,2.3.0,2.4.0,,,,2.1.2,2.2.1.1,2.2.3,2.4.0,,sql,,,,0,,,,,,,,"The hint, 'openjpa.hint.UseLiteralInSQL', is not properly converting a boolean to an int.  To illustrate this, lets take this entity:

public class MyEntity implements Serializable {
 @Id
 private Integer pk;

 private boolean flag;
..........


With this entity, lets take this test:

Query q = em.createQuery(""SELECT f FROM MyEntity f WHERE f.flag = true"");
q.setHint(""openjpa.hint.UseLiteralInSQL"", ""false"");  //false is the default
q.getResultList();


With this code, the following SQL will be generated:

SELECT t0.pk, t0.code, t0.code2, t0.flag FROM MyEntity t0 WHERE (t0.flag = ?)  [params=(int) 1]


Next, lets take this code:

Query q = em.createQuery(""SELECT f FROM MyEntity f WHERE f.flag = true"");
q.setHint(""openjpa.hint.UseLiteralInSQL"", ""true"");
q.getResultList();


With this code, the following SQL will be generated:

SELECT t0.pk, t0.code, t0.code2, t0.flag FROM MyEntity t0 WHERE (t0.flag = true)


However, in the latter case where UseLiteralInSQL=true, the following SQL should be generated:

SELECT t0.pk, t0.code, t0.code2, t0.flag FROM MyEntity t0 WHERE (t0.flag = '1')

Thanks,

Heath",,,,,,,,,,,,,,,,,,,11/Jan/15 19:56;struberg;OPENJPA-2534.patch;https://issues.apache.org/jira/secure/attachment/12691564/OPENJPA-2534.patch,15/Oct/14 19:31;curtisr7;OPENJPA-2534.patch;https://issues.apache.org/jira/secure/attachment/12675090/OPENJPA-2534.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2014-10-15 19:31:54.752,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Tue Apr 14 18:58:09 UTC 2015,,,,,,,0|i20vxz:,9223372036854775807,,,,,,,,"07/Oct/14 22:03;jpaheath;Attaching a test to replicate the issue described.

Thanks,

Heath",15/Oct/14 19:31;curtisr7;Attaching a test case and code fix for review.,"03/Nov/14 22:41;jira-bot;Commit 1636464 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1636464 ]

OPENJPA-2534: A boolean is not converted correct when using the hint 'UseLiteralInSQL' - applied Rick's patch to 2.1.x.","03/Nov/14 23:28;jira-bot;Commit 1636472 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1636472 ]

OPENJPA-2534: A boolean is not converted correct when using the hint 'UseLiteralInSQL' - applied Rick's patch to 2.2.1.x.","03/Nov/14 23:46;jira-bot;Commit 1636473 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1636473 ]

OPENJPA-2534: A boolean is not converted correct when using the hint 'UseLiteralInSQL' - applied Rick's patch to 2.2.x.","03/Nov/14 23:48;jira-bot;Commit 1636474 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1636474 ]

OPENJPA-2534: A boolean is not converted correct when using the hint 'UseLiteralInSQL' - applied Rick's patch to trunk.","10/Jan/15 17:32;struberg;I actually find this very hint not really useful at all. 

I currently face a pretty similar issue. My customer doesn't have boolean values represented as NUMBER(1) in his database but as CHAR(1) containing '1' and '0'. 

Of course I also have seen 'Y'/'N' and 'T'/'F' as well already! The problem is that Oracle didn't define any native datatype for boolean for a very long time.

I'm tempted to add it to DBDictionary and add an enum for those values

BOOLEAN_INT_01
BOOLEAN_STRING_01
BOOLEAN_STRING_YN
BOOLEAN_STRING_TF

and use them in DBDictionary#setBoolean.
Wdyt? Any better ideas?

PS: imo we cannot just have an Object booleanTrueRepresentation and Object booleanFalseRepresentation as we really need to invoke different methods on the PreparedStatement.","10/Jan/15 19:57;allee8285;Rather than introducing the BOOLEAN_* type, have you considered using @Externalizer to attribute <-> db column conversion.

http://ci.apache.org/projects/openjpa/trunk/docbook/manual.html#ref_guide_pc_extern

Just a thought.","10/Jan/15 20:39;struberg;I know @Externalizer and also @ExternalValue and both are not an option. That would require us to annotate each and every boolean field. The point is that our current DBDictionary hardcoded uses (int) 0/1 and doesn't support native boolean at all. This is imo fundamentally false. Some databases which are SQL99 compatible support Boolean as own native type. For those we should imo use PreparedStatement.setBoolean() and not setInt() as we currently do! ExternalValue does not help much as Boolean always ends up as setInt atm.
And for Oracle and others who don't know any native Boolean it is basically up to each installation on how they represent boolean in their db schema. I've seen the ones I mentioned above but I'm sure there are others as well.

So I would probably also add BOOLEAN_BOOLEAN. This should of course be able to get changed via our normal ways: properties, specialized DBDictionary, etc.
","10/Jan/15 21:06;struberg;Another small note:
In Oracle it's even not that easy to see that you got hit by that. Usually Oracle parses the (int) 1 in the query and converts it automatically to the target column type.
There are of course 2 very nasty issues with this:
1.) It gets much slower. Despite having an Index correctly set up it will simply not be used. Because of the required toNumber().  Most times you don't even see this in the explain.
2.) Some queries even blow up completely. Somehow Oracle manages the coercion halfway decent with normal queries - but if you use case statements it simply blows up complaining about a parameter mismatch.","10/Jan/15 22:36;struberg;Oh and a clarification. When I said:
> Of course I also have seen 'Y'/'N' and 'T'/'F' as well already!
then I meant other installations / other customers. Usually a single installation only uses one of the possible representations. If they mix it that then they really need to use @ExternalValue (or map it in orm.xml). ","11/Jan/15 19:53;jira-bot;Commit 1650957 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1650957 ]

OPENJPA-2534 cleanup DBDictionary alias handling

use class.getName() to prevent typos - no functional change yet.","11/Jan/15 19:56;struberg;This patch implements an interface for a BooleanRepresentation + config.
It also enhances the DBDictionary to make use of it. 

Tested with an external test app so far. Will write unit tests and commit all this stuff within the next days.",12/Jan/15 15:51;struberg;I've created OPENJPA-2558 to handle the BooleanRepresentation in a separate report.,"12/Jan/15 22:47;jpaheath;The issue described in this JIRA is fixed, as such I will close this JIRA.  I should have done so sooner.  Mark's idea's should be taken up in a different/new (but related?) JIRA.  Sorry for not closing this sooner.

Thanks,

Heath","14/Apr/15 18:28;jira-bot;Commit 1673491 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1673491 ]

OPENJPA-2534: A boolean is not converted correct when using the hint 'UseLiteralInSQL' - made test update.","14/Apr/15 18:31;jira-bot;Commit 1673495 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1673495 ]

OPENJPA-2534: A boolean is not converted correct when using the hint 'UseLiteralInSQL' - made test update.","14/Apr/15 18:42;jira-bot;Commit 1673502 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1673502 ]

OPENJPA-2534: A boolean is not converted correct when using the hint 'UseLiteralInSQL' - made test update.","14/Apr/15 18:58;jira-bot;Commit 1673509 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1673509 ]

OPENJPA-2534: A boolean is not converted correct when using the hint 'UseLiteralInSQL' - made test update.",,,,,,,,
Table name defined in XML mapping file is not used when executing a named query.,OPENJPA-2533,12746303,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,curtisr7,jpaheath,jpaheath,07/Oct/14 00:28,28/Jan/15 19:40,14/Mar/19 03:03,28/Jan/15 19:40,2.2.2,2.3.0,2.4.0,,,,,,2.2.3,2.4.0,,,,query,,,,0,,,,,,,,"Take this simple entity:

@Entity
@javax.persistence.NamedQuery(name = ""TableNameInXmlEntity.findAll"", query = ""SELECT t FROM TableNameInXmlEntity t"")
public class TableNameInXmlEntity implements Serializable {
    @Id
    private int myid;
.......

Take this simple XML mapping entry:

<entity-mappings..........
    <entity class=""org.apache.openjpa.persistence.xml.TableNameInXmlEntity"">
        <table name=""TableNameInXml""/>
    </entity>
</entity-mappings>

With this code, take the following test to execute the named query:

        Query q = em.createNamedQuery(""TableNameInXmlEntity.findAll"");
        q.getResultList();

The following SQL will be generated:

SELECT t0.myid FROM TableNameInXmlEntity t0

Notice that 'TableNameInXmlEntity' is used, rather than 'TableNameInXml' (i.e. the name defined in the XML mapping file).

Rather than executing a named query, if we execute a query like the following:

Query q = em.createQuery(""SELECT t FROM TableNameInXmlEntity t"");
q.getResultList();

The following (correct) SQL will be executed:

SELECT t0.myid FROM TableNameInXml t0

Finally, if we executed the above query, and THEN execute the named query, all will work as expected.

I have a test I'll upload shortly which recreates the issue.

Thanks,

Heath
",,,,,,,,,,,,,,,,,,,07/Oct/14 15:32;jpaheath;OPENJPA-2533-2.2.x.test;https://issues.apache.org/jira/secure/attachment/12673372/OPENJPA-2533-2.2.x.test,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-10-17 18:35:04.754,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Thu Dec 11 22:03:21 UTC 2014,,,,,,,0|i20v6v:,9223372036854775807,,,,,,,,"07/Oct/14 15:32;jpaheath;Providing a test to recreate the issue.

Thanks,

Heath","17/Oct/14 18:35;jira-bot;Commit 1632647 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1632647 ]

OPENJPA-2533: Reorder MetaDataRepository call to fix a bug in orm resloution.",17/Oct/14 18:35;curtisr7;Committed revision 1632647 to trunk.,"11/Dec/14 22:03;jira-bot;Commit 1644778 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1644778 ]

OPENJPA-2533: Table name defined in XML mapping file is not used when executing a named query.  Back ported to 2.2.x Rick Curtis' trunk commit.",,,,,,,,,,,,,,,,,,,,,,,
Use of JoinColumn(.. referencedColumnName= ..) targets to another joinColumn key exposed as an attribute will cause a ConstrainViolation exception on persist,OPENJPA-2525,12736206,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,22/Aug/14 23:58,21/Sep/16 20:17,14/Mar/19 03:03,23/Sep/14 18:35,2.2.2,,,,,,,,2.2.3,2.4.0,,,,jdbc,,,,0,,,,,,,,"Using the following entities, when a simple single entry aCase -> aText -> aEvident instances are created, a ConstraintViolationException will be observed when this object tree is persisted

@Entity
public class ACase {
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private int id;

    @OneToOne(fetch=FetchType.LAZY, mappedBy=""aCase"", cascade=CascadeType.MERGE)
    private AText aText;
}

@Entity
public class AText {
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private int id;

    @OneToOne(fetch=FetchType.LAZY, cascade=CascadeType.MERGE)
    @JoinColumn(name=""ACASE_ID"", nullable=false)
    private ACase aCase;

    @OneToMany(targetEntity=AEvident.class, mappedBy=""aText"", cascade=CascadeType.MERGE)
    private Set<AEvident> aEvidents = new HashSet<AEvident>();

    @Column(name=""ACASE_ID"", insertable=false, updatable=false, unique=true)
    private int aCaseId;        // <<< this field is not updated to the associated aCase.id value after aText instance is persisted/merged.
}

@Entity
public class AEvident {
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private int id;

    @ManyToOne(fetch=FetchType.LAZY, cascade=CascadeType.MERGE)
    @JoinColumn(name=""ACASE_ID"", referencedColumnName=""ACASE_ID"")  // <<< when aEvident instance is persisted in the same transaction, the INSERT used the default value (0) in aText.aCaseId, which does not exist, hence the ConstraintViolationException is thrown.
    public AText getAText() {
}


INSERT INTO ACase (name) VALUES (?) [params=(String) Case_A]
VALUES(IDENTITY_VAL_LOCAL())
INSERT INTO AText (ACASE_ID, name) VALUES (?, ?) [params=(int) 15, (String) Text_A]
VALUES(IDENTITY_VAL_LOCAL())
INSERT INTO AEvident (name, ACASE_ID) VALUES (?, ?) [params=(String) Evident_A, (int) 0]

Caused by: <openjpa-2.2.3-SNAPSHOT-rsvn: E155036: The working copy at '/cygdrive/c/Watson/oea/workspace/openjpa.22x' fatal general error> org.apache.openjpa.persistence.PersistenceException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
FailedObject: org.apache.openjpa.persistence.relations.AEvident@a33283dc
    at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2352)
    at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2190)
    at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2087)
    at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:2005)
    at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
    at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1529)
    at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:933)
    at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:570)
    ... 23 more
Caused by: <openjpa-2.2.3-SNAPSHOT-rsvn: E155036: The working copy at '/cygdrive/c/Watson/oea/workspace/openjpa.22x' fatal general error> org.apache.openjpa.persistence.PersistenceException: INSERT on table 'AEVIDENT' caused a violation of foreign key constraint 'SQL140820224303470' for key (0).  The statement has been rolled back. {prepstmnt -198000009 INSERT INTO AEvident (name, ACASE_ID) VALUES (?, ?) [params=(String) Evident_A, (int) 0]} [code=20000, state=23503]
FailedObject: org.apache.openjpa.persistence.relations.AEvident@a33283dc
    at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4985)
    at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4951)
    at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:137)
    at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:78)
    at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:144)
    at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushAndUpdate(BatchingPreparedStatementManagerImpl.java:79)
    at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:100)
    at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:88)
    at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:357)
    at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flushGraph(ConstraintUpdateManager.java:349)
    at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:97)
    at org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager.flush(BatchingConstraintUpdateManager.java:59)
    at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:105)
    at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:78)
    at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:732)
    at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:131)
    ... 30 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: INSERT on table 'AEVIDENT' caused a violation of foreign key constraint 'SQL140820224303470' for key (0).  The statement has been rolled back. {prepstmnt -198000009 INSERT INTO AEvident (name, ACASE_ID) VALUES (?, ?) [params=(String) Evident_A, (int) 0]} [code=20000, state=23503]
    at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:219)
    at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:195)
    at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$4(LoggingConnectionDecorator.java:194)
    at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:1134)
    at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:275)
    at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1792)
    at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.executeUpdate(PreparedStatementManagerImpl.java:268)
    at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:119)
    ... 41 more

",,,,,,,,,,,,,,,,,,,25/Aug/14 18:51;allee8285;OPENJPA-2525.patch;https://issues.apache.org/jira/secure/attachment/12664187/OPENJPA-2525.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-08-25 19:44:11.428,,,no_permission,,,,,,,,,,,,9223372036854775807,,,Thu Oct 02 19:20:32 UTC 2014,,,Patch Available,,,,0|i1z96f:,9223372036854775807,,,,,,,,"25/Aug/14 19:44;jira-bot;Commit 1620419 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1620419 ]

OPENJPA-2525: Use of JoinColumn targets to another joinColumn key exposed as an attribute will cause a ConstrainViolation exception on persist","25/Aug/14 19:45;jira-bot;Commit 1620420 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1620420 ]

OPENJPA-2525: Use of JoinColumn targets to another joinColumn key exposed as an attribute will cause a ConstrainViolation exception on persist","23/Sep/14 17:03;jira-bot;Commit 1627091 from [~fyrewyld] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1627091 ]

OPENJPA-2525: Use of JoinColumn targets to another joinColumn key exposed as an attribute will cause a ConstrainViolation exception on persist","23/Sep/14 18:34;jira-bot;Commit 1627112 from [~fyrewyld] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1627112 ]

OPENJPA-2525: Use of JoinColumn targets to another joinColumn key exposed as an attribute will cause a ConstrainViolation exception on persist","02/Oct/14 19:19;jira-bot;Commit 1629047 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1629047 ]

OPENJPA-2525: Change new test entities to use AUTO instead of IDENTITY pk generation","02/Oct/14 19:20;jira-bot;Commit 1629048 from [~fyrewyld] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1629048 ]

OPENJPA-2525: Change new test entities to use AUTO instead of IDENTITY pk generation","02/Oct/14 19:20;jira-bot;Commit 1629049 from [~fyrewyld] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1629049 ]

OPENJPA-2525: Change new test entities to use AUTO instead of IDENTITY pk generation",,,,,,,,,,,,,,,,,,,,
Incorrect the time unit of query timeout value.,OPENJPA-2517,12727288,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,mskb,mskb,15/Jul/14 08:50,21/Mar/16 14:54,14/Mar/19 03:03,12/Oct/15 20:51,2.2.0,2.2.1,2.2.2,2.3.0,,,,,2.2.3,2.4.1,,,,jdbc,,,,0,,,,,,,,"The value of the ""javax.persistence.query.timeout"" property have been passed to the java.sql.Statement.setQueryTimeout(int) in milliseconds rather than seconds.

The query timeout milliseconds should be converted to seconds.
",,,,,,,,,,,,,,,,,,,18/Aug/15 00:04;jpaheath;OPENJPA-2517-2.2.x.patch;https://issues.apache.org/jira/secure/attachment/12750933/OPENJPA-2517-2.2.x.patch,15/Jul/14 09:06;mskb;OPENJPA-2517.patch;https://issues.apache.org/jira/secure/attachment/12655723/OPENJPA-2517.patch,15/Jul/14 09:02;mskb;openjpa-querytimeout-bug.zip;https://issues.apache.org/jira/secure/attachment/12655722/openjpa-querytimeout-bug.zip,11/Jun/15 19:53;jpaheath;openjpa-querytimeout-working.zip;https://issues.apache.org/jira/secure/attachment/12739111/openjpa-querytimeout-working.zip,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2014-07-16 13:33:50.159,,,no_permission,,,,,,,,,,,,405394,,,Mon Mar 21 14:54:42 UTC 2016,,,Patch Available,,,,0|i1xrjj:,405419,,,,,,,,"15/Jul/14 09:02;mskb;Attached Maven project for bug reproduction (openjpa-querytimeout-bug.zip).
Please run command 'mvn clean test'.",16/Jul/14 13:33;curtisr7;I took a look at your fix and it looks good. I'll try to take some time to work this into trunk sometime later this week. Is there a particular release that you need this fix committed into?,"18/Jul/14 01:11;mskb;Thank you, Rick.

The release of my project is planned still ahead, so I don't immediately need this fix.
","23/Jul/14 12:39;curtisr7;I dug into this one a bit and it appears that the root issue is that when we implemented this support, it was against a non-final version of the JPA-2.0 spec. If you take a look at OPENJPA-878, you'll see the following comment :

Support default query hint for query timeout as defined in section 3.6.4 of the spec.
A new hint can be supplied for Java SE and Java EE environments -
javax.persistence.query.timeout // query timeout in seconds

I looked back through some non-final revisions of the spec, and this property did indeed change from seconds to milliseconds.

That being said, I'm somewhat afraid to just fix this problem as users of OpenJPA could be unknowingly relying on this behavior(bug). In addition to fixing the bug, I believe that we'll need to add a compatibility switch to support running with javax.persistence.query.timeout as seconds.","23/Jul/14 14:05;mskb;I have a good understanding of the root of this problem, and also compatibility issues.

I agree with an idea of compatibility switch.","23/Jul/14 14:57;kwsutter;Just to be clear...  We would change the OpenJPA default processing to be compliant with the spec, and introduce the compatibility switch to use the wrong behavior.  I'm sure Rick understood that approach, but I wanted to be clear in the JIRA.","27/May/15 17:48;jpaheath;HI!  I've been looking at this issue and running my findings by Rick Curtis.  I'll detail my findings, but basically OpenJPA already converts the query timeout from milliseconds to seconds, so things are working as expected.....I think the expectations in the test are incorrect.

I think we have a couple of issues going on:
1) We missed the fact that OpenJPA code does actually convert the timeout to seconds (see DBDictionary.setStatementQueryTimeout) so it is not needed as is proposed in the fix attached to this JIRA.
2) The originator (and those of us initially looking at this JIRA) missed the fact that a 'persist' is used (rather than a query) in the provided test and as such are expecting a query timeout to apply to EM operations.

Let me touch on each of these: First, if you look at TestQueryTimeout [1] you can see that the query timeout is very extensively tested.  So I think this property is tested well and working well.  Next, I found that OpenJPA does convert the timeout from milliseconds to seconds, see here in DBDictionary.setStatementQueryTimeout:

    /**
     * Allow subclasses to provide DB unique override implementations of
     * setting query timeouts, while preserving the default timeout logic
     * in the public setQueryTimeout method.
     * @param stmnt
     * @param timeout in milliseconds
     * @throws SQLException
     */
    protected void setStatementQueryTimeout(PreparedStatement stmnt, 
        int timeout) throws SQLException {
        // JDBC uses seconds, so we'll do a simple round-down conversion here
        stmnt.setQueryTimeout(timeout / 1000);
    }


Given this, I decided to run the test sent into this JIRA.  In doing so, it finally hit me that the test is doing a 'persist' while some other thread has locked the same row in the DB.  So the user is  expecting the query timeout to apply to all EM operations.  However, the query timeout should only apply to a query (the spec implies this).  Again, if you look at  TestQueryTimeout, you'll see a test method with comments:

   /**
     * Scenario being tested: 6) PU Query timeout hints do not affect EM
     * operations like updating Entities returned by EM.find()/findAll()
     * Expected Results: The DELAY function is being called and the update
     * takes 2000+ msecs to complete.
     */
    public void testQueryTimeout6() {


In other words, this method verifies that the 'find', which takes longer than the query timeout, doesn't time out.  So I believe the intentions are to not apply the query timeout to EM find, etc.

I can understand the confusion here because the Spec is not 100% clear here.  I think a person needs to read the spec closely on this property.  Let me point out a few entries which imply the query timeout is limited to the Query interface (and queries).  First, the javax.persistence.query.timeout is defined here: 

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
3.8.9 Query Hints
The following hint is defined by this specification for use in query configuration.

javax.persistence.query.timeout // time in milliseconds

This hint may be used with the Query or TypedQuery setHint method or the NamedQuery and
NamedNativeQuery annotations. It may also be passed as a property to the Persistence.createEntityManagerFactory
method and used in the properties element of the persistence.
xml file.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

This appears to be referred to as the ""query timeout"" throughout the rest of the spec.  Next, If you look at the Query interface (section 3.8.1), it makes reference to a ""query timeout"".....the other hits of ""query timeout"" throughout the spec deal with the Query interface or query operations.  The methods on the EM interface talk about a ""timeout"", but never a ""query timeout"".  
To me, this implies that the query.timeout only applies to the Query methods.

Finally, in working with the test of OJ2517, I added a test where a query is used and verified correctness of the query timeout.  The test works as I'd expect for Derby and H2 (I choose H2 because that is the database in use in the original test sent in).  Let me attach my test, named openjpa-querytimeout-working.zip in case someone wants to look at it or try it out.

I propose this JIRA be closed if folks agree with my findings.

Thanks,

Heath Thomann

[1] https://fisheye6.atlassian.com/browse/openjpa/branches/2.2.x/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestQueryTimeout.java?r=1244807","18/Jun/15 04:13;mskb;Heath, Thank you for a detailed report.

As you pointed out, I misunderstood that 'javax.persistence.query.timeout' will be applied also in 'EntitiManger.persist' method.

I think that there is no problem with closing this issue.

Thanks.","06/Aug/15 03:35;jpaheath;OK, I have talked to Rick Curtis and Kevin Sutter about this some more and I have to add some more details and slightly back track.  This post is going to be extremely long, however, I want to add lots of details for history sake.  In this post I'm also going to do something that is probably very unorthodox, and that is I'm going to explain the way EclipseLink (ECL) handles the 'javax.persistence.query.timeout' (QT for short).  I know, I know, I shouldn't mix the two, however it appears that two major JPA providers are incorrectly handling the QT so I think it is worth pointing this out as it may also help to justify our final proposed handling of QT.  :)

I'd suggest the reader read the email I sent to Rick and Kevin for back ground [1].  This email details what OpenJPA is doing wrong when it comes to handling of the QT during a find/update scenario.  Basically OpenJPA does two things wrong:

1) It applies the ""javax.persistence.query.timeout"" value to a find/update (an EM operation).
2) It uses units of seconds, rather than milliseconds, in the find/update case.

As I explained back on May 27th, the spec is slightly vague about the application of QT.  But after a careful read, you can see that the QT should NOT apply to EM operations, only Query operations.  Therefore, #1 by OpenJPA (and ECL) is incorrect.  However, given that OpenJPA has applied the QT to EM operations since the inception of QT, we feel it is best to continue to do so.  We do not what to fix this and break all users who may directly or indirectly rely on this.  At some point we could add options to enable/disable this (although OpenJPA does allow a user to disable the QT.....actually this is the default value).   Also keep in mind that the JPA 2.0 and 2.1 specs both point out that the QT is just a hint, and a user should not completely depend on it, so I think there is further wiggle room for interpretation and implementation.  Furthermore, customer's have argued that the QT should apply to all operations; both EM and Query.  IMHO I agree with them.....it seems odd that one can control a timeout for a query, but NOT for an exactly same find/update operation.   
Next, given that we are not going to change things, we do feel we should address #2.  We do feel we should do as the originator of this JIRA suggested, that is, to properly convert the QT value in 'ConfiguringConnectionDecorator' to milliseconds, from seconds.  The DBDictionary converts the QT from milliseconds to seconds, the 'ConfiguringConnectionDecorator' should follow suite for consistency.


[1] Email to Kevin Sutter, Rick Curtis, et al.:
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>EMAIL START>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hey Team!  I need help with a likely bug in OpenJPA (and ECL?) with our javax.persistence.query.timeout (QT for short) usage.  I know some of you worked on a QT issue on ECL.....my issue might also apply to ECL.  This issue takes a bit of time to describe so settle in with a cup of coffee or tea.  Basically though the root question is: should the QT apply to a finder+update (EM operation, no Query)?  If so both OJ and ECL have a bug.
To start, you could read my details in OJ2517, and look at the test.  But even these details aren't exactly the same as my latest issue.  In the JIRA the user was expecting the QT to apply to a EM.find/update scenario.  In other words, they expected the QT to apply to ALL EM operations.  However, as I explained in the JIRA the QT should only apply to javax.persistence.Query operations......Kevin's email [removed] seemed to back this up, the spec 'implies' this, and the TestQueryTimout test written by Pinaki would seem to offer further proof.  However, I've found a scenario where both OJ and ECL apply the QT to an EM.find/update.  Let me explain exactly what I mean by a 'EM.find/update' by using a code snippet to describe the scenario:

Thread 1 (T1) uses JDBC to 'lock' a row with id 1, in a table name Bug, and then sleeps, as follows:

int jdbcDelayTime = 9000;
Connection conn = .......     
Statement stmt = conn.createStatement();
stmt.execute(""UPDATE Bug set title = 'a' where bugId = 1"");
System.out.println(""\nJDBC Thread will now sleep for "" + jdbcDelayTime + "" ms"");
// emulate long process to hold lock on the row:
Thread.sleep(jdbcDelayTime); 

Thread 2 (T2) uses JPA to find entity Bug with id=1 and update it while T1 sleeps:

int jpaQueryTimeoutMillis = 6000;
//The QT is in units of milliseconds as per the spec:
props.put(""javax.persistence.query.timeout"", jpaQueryTimeoutMillis);
.....
em.getTransaction().begin();
Bug b = em.find(Bug.class, 1);
b.setTitle(""update by find"");            
//The 'commit' will hang waiting for the lock on the row:
em.getTransaction().commit();


With this test, you can see that the QT is set to 6000ms and T1 will sleep for 9000ms, in other words T1 will sleep longer than QT.  Because we are doing a find/update the QT will have no effect on the scenario (at least the allusion is it doesn't have an effect, as I'll explain in a moment).  Therefore the outcome is that T2 will wait until it gets the row lock (after about 9000ms) and after it gets the lock it will successfully update the entity.  If on the other hand, you change the find/update to something like the follow, On OpenJPA (but not ECL due to bug Bug 456067 ) would get a query timeout type of exception (QTE) after 6000ms:

            Query q = em.createQuery(""UPDATE Bug o SET o.title = 'my title' where o.bugId = 1"");
            q.executeUpdate();            
            em.getTransaction().commit();

So, at this time, all is as expected (assume we all agree that the QT should NOT have an effect on the find/update scenario) - expect for ECL in the query case due to Bug 456067 , however if I update the test to take into account ECL uses seconds I can get a QTE in the ECL case, so once ECL fixes the bug all will be the same for OJ and ECL.  
Next, I will explain why the scenario is giving the ""allusion"" that the find/update is not effected by the QT.  In the above find/update scenario, change 'jdbcDelayTime' from 9000ms to say 9000000ms (i.e. 9000 seconds).  Leave QT at 6000ms.  In this case, we will get a QTE after approx. 6000 seconds.  Yes, 6000 seconds, NOT milliseconds.  In the Query scenario, the results are the same, we'd get a QTE after 6 seconds.  Therefore, for a Query, life is good and the QT is behaving properly.  However, for the find/update scenario, I think we have to ask ourselves two questions:

1) Why is the QT having an effect on the find/update (and should it)?
2) Why is the QT being treated as seconds, rather than ms, in the find/update case.

For #1, I won't go into a ton of details at this time since this note is getting so long, but basically 'ConfiguringConnectionDecorator' does a 'setQueryTimeout' during the prepare and create of a statement.  So the timeout would seem to be set on the statement ALWAYS, regardless of whether a query is performed or find/update.  Furthermore, the value is not divided by 1000 (i.e. not converted from ms, to seconds, so the QT value is treated as seconds in this case).  This would explain why there is the 'allusion' that the QT has no effect on a find/update scenario when the QT is larger than the JDBC sleep time in my scenario.....because we *think* we are setting the QT in millis, yet seconds are actually used by the JDBC driver, it seems like the ST has no effect......it is only when the QT is less than the JDBC sleep time that we see the QT does actually have an effect on the find/update case.  Now, in the case of a Query, there are places where we call 'setQueryTimeout' on the Statement a seconds time.  One such place is the JDBCStoreQuery which calls the dictionary which in turn calls 'setQueryTimeout'.  In this case, the QT is divided by 1000 to convert the JPA spec defined QT units of millis to the JDBC expected units of seconds.  Therefore, in the query case, the QT is properly handled (well at least for OJ, not for ECL).    
In conclusion, I'd say we have a bug here either way and one of the following options needs to be taken (for OpenJPA): 
a) if the QT should not effect the find/update, then we need to detect this path and not call 'setQueryTimeout' in the 'ConfiguringConnectionDecorator'.
b) If the QT should effect the find/update, then we need to convert from millis to seconds.

Phew.....thoughts?  I'd be glad to discuss this on the phone if that would be easier.

Thanks,

Heath
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>EMAIL END>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Thanks,

Heath Thomann","18/Aug/15 00:04;jpaheath;HI!  I'm attaching a test fix which will allow a user to set a property (I've chosen openjpa.jdbc.DBDictionary.allowQueryTimeoutOnFindUpdate) which when set will apply the javax.persistence.query.timeout, in milliseconds, to EntityManager operations.  As I explained in my previous post, today the query.timeout is applied to EM operations in seconds.  Please review and provide feedback.

Thanks,

Heath Thomann  ","02/Sep/15 20:04;jira-bot;Commit 1700884 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1700884 ]

OPENJPA-2517: Option to allow the javax.persistence.query.timeout property to apply to EntityManager operations.","02/Sep/15 20:06;jira-bot;Commit 1700885 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1700885 ]

OPENJPA-2517: Option to allow the javax.persistence.query.timeout property to apply to EntityManager operations.  Ported 2.2.x changes to trunk.",02/Oct/15 05:11;mskb;Hi! I confirmed the commit. No problem. Thank you!,"02/Oct/15 06:21;struberg;Heath, thanks for porting this over to trunk as well. Thus I've added 2.4.1 to the 'fixed in' versions. Could you please add the other branches where you applied this fix as well so we can properly keep track of it in our release notes? txs!","21/Mar/16 14:54;jpaheath;HI!  I've recently taken another look at this issue.  I wanted to try to summarize all the comments made so far, and add some clarification.  Basically, there are three issues with OpenJPA's handling of  javax.persistence.query.timeout (QT for short):

1) OpenJPA applies the QT to all EM operations (e.g find/update).
2) OpenJPA uses seconds as the QT rather than milliseconds in #1.
3) OpenJPA doesn't round up QT values less than 1000.

It is explained in previous comments that, as per the JPA Spec, the QT should only apply to Query operations (methods on the Query interface).  Let me be clear and state that OpenJPA does properly apply the QT to Query operations.  There are no issues for Query operations.  The issues here are with the QT being applied to EM operations (#1).  Given the fact that the QT is applied to EM operations when it shouldn't, #2 and #3 are moot.  However, since it was decided not to remove the QT from EM operations because of the risk of regression, #2 and #3 are not consistent with the way the QT is handled for Query operations.  For Query operations, OpenJPA rounds the QT to 1000 if the user sets the QT to a value less than 1000.  Furthermore, for Query operations OpenJPA converts the milliseconds to seconds and passes that value to the JDBC driver since the driver expects units of seconds.  

The purpose of the fix provider in this JIRA, and the property openjpa.jdbc.DBDictionary.allowQueryTimeoutOnFindUpdate, was to continue to allow #1, but resolve #2 and #3.  In other words, we did not want to run the risk of regressing users by change #1 such that the QT no longer applies to all EM operations.  At a later date, and another JIRA, we could investigate a change to provide a property to fix #1 by restricting the QT to only Query operations.  The fix of this JIRA however fixes #2 and #3 in order to maintain a consistent story between EM operations and Query operations.  In other words, when property openjpa.jdbc.DBDictionary.allowQueryTimeoutOnFindUpdate is set to true, the QT will be converted to milliseconds, and any value less than 1000 will be rounded up to 1000. 

Finally, I would like to note that a user can set the QT to 0 to entirely disable the setting of a timeout.  This would disabled the QT for both Query and EM operations.

Thanks,

Heath",,,,,,,,,,,,
Fix 2.3.x binary downloads,OPENJPA-2515,12726142,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,08/Jul/14 18:07,21/Sep/16 20:17,14/Mar/19 03:03,09/Jul/14 13:24,2.3.0,2.4.0,,,,,,,2.4.0,,,,,build / infrastructure,,,,0,,,,,,,,"OPENJPA-2171 removed a direct dependency on asm, and placed a new dependency on xbean asm4. When that dependency was changed, we didn't update openjpa-project/assembly.xml and openjpa-project/bin-assembly.xml.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-07-08 18:49:03.83,,,no_permission,,,,,,,,,,,,404249,,,Tue Jul 08 21:47:54 UTC 2014,,,,,,,0|i1xkmv:,404289,,,,,,,,"08/Jul/14 18:49;jira-bot;Commit 1608894 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1608894 ]

OPENJPA-2515: Update openjpa-project assemblies to include xbean-asm.","08/Jul/14 18:50;curtisr7;[~struberg], [~romain.manni-bucau] -- Do you want me to merge this change into the 2.3.x branch?",08/Jul/14 20:11;romain.manni-bucau;[~curtisr7] No need on my side. TomEE is already using a fork (more a freeze) of 2.4.0,08/Jul/14 20:14;curtisr7;[~romain.manni-bucau] -- do the TomEE folks no longer care about the 2.3.x branch then?,"08/Jul/14 20:17;romain.manni-bucau;[~curtisr7] exactly, since we need to handle java 8 bytecode we upgraded (that's why we asked a release several times)","08/Jul/14 20:30;curtisr7;Okay, I commited the change so that the nightly downloads are correct. I'm not sure who/when/if someone will cut yet another (correct) release from the 2.3.x branch.

btw -- I opened OPENJPA-2514 a while back that I thought would alleviate all of these issues, but I never heard anything back.","08/Jul/14 20:34;romain.manni-bucau;ok, commenting now","08/Jul/14 21:47;jira-bot;Commit 1608958 from [~curtisr7] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1608958 ]

OPENJPA-2515: Update openjpa-project assemblies to include xbean-asm.",,,,,,,,,,,,,,,,,,,
NullPointerException in OpenJPAConfigurationImpl#getDataCacheMode,OPENJPA-2510,12717862,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,,andyg,andyg,02/Jun/14 07:59,02/Jun/14 08:09,14/Mar/19 03:03,02/Jun/14 08:09,2.4.0,,,,,,,,,,,,,integration,,,,0,,,,,,,,"This could be us (Apache TomEE) and I am only posting the issue to ring the bells, but I get this NP on a few tests and wonder if it is a bug. I have just started to dig in myself, so no sample or patch yet.

Caused by: java.lang.NullPointerException
	at org.apache.openjpa.conf.OpenJPAConfigurationImpl.getDataCacheMode(OpenJPAConfigurationImpl.java:1797)
	at org.apache.openjpa.persistence.PersistenceProductDerivation$ConfigurationProviderImpl.setInto(PersistenceProductDerivation.java:724)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newInstance(JDBCBrokerFactory.java:60)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.openjpa.kernel.Bootstrap.invokeFactory(Bootstrap.java:131)
	at org.apache.openjpa.kernel.Bootstrap.newBrokerFactory(Bootstrap.java:65)",Apache TomEE,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-06-02 08:06:07.506,,,no_permission,,,,,,,,,,,,396064,,,Mon Jun 02 08:09:20 UTC 2014,,,,,,,0|i1w6uf:,396190,,,,,,,,"02/Jun/14 08:06;romain.manni-bucau;This is a bug in TomEE, nothing to do on openjpa side","02/Jun/14 08:09;andyg;Apache TomEE issue, not OpenJPA",,,,,,,,,,,,,,,,,,,,,,,,,
LEFT JOIN FETCH not honored when data cache is enabled,OPENJPA-2508,12717267,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,allee8285,allee8285,29/May/14 14:07,02/Dec/14 19:44,14/Mar/19 03:03,22/Sep/14 19:06,2.2.1.1,2.2.2,2.3.0,2.4.0,,,,,2.1.2,2.2.1.1,2.2.3,2.4.0,,datacache,,,,0,datacache,querycache,,,,,,"In a simple JPQL with left join fetch for a lazy loaded association specified and data cached enabled, first time the query executed, the lazy loaded association get loaded, returned and cached. Subsequent invocation of the same query does NOT ""load"" and return the association from the query invocation.

I'll attach a test case to reproduce the problem.",,,,,,,,,,,,,,,,,,,03/Jun/14 20:20;allee8285;OPENJPA-2508.221x.patch;https://issues.apache.org/jira/secure/attachment/12648215/OPENJPA-2508.221x.patch,29/May/14 14:15;allee8285;OPENJPA-2508.test.zip;https://issues.apache.org/jira/secure/attachment/12647370/OPENJPA-2508.test.zip,04/Jun/14 20:13;allee8285;qcsq.v2.patch;https://issues.apache.org/jira/secure/attachment/12648381/qcsq.v2.patch,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2014-06-03 21:45:34.839,,,no_permission,,,,,,,,,,,,395471,,,Tue Dec 02 19:44:24 UTC 2014,,,,,,,0|i1w37b:,395599,,,,,,,,"29/May/14 14:22;allee8285;The test case call doQuery() twice, i.e. same call path.  The first call executes the SQLs and fetches Dept and Employee from the db. Both dept and employee were cached.  The second call the Employee was fetched from cache but the Employee.dept remains null even the SQL requests to load dept using ""join fetch dept"".

The attached test will pass (Employee.dept is loaded; not null) if either:
1) the Employee.dept is marked FetchType.EAGER, or
2) TestNPE2.doquery().... em.detach(emp) is removed.","03/Jun/14 21:45;curtisr7;I'd prefer to stay away from reflection. I banged something together quickly that seems to work, but there are a few unknowns with my approach.","04/Jun/14 20:13;allee8285;Revised (v2) patch by Rick C.

I have tested it and passed the TestNPE2, JUnit and my application.","05/Jun/14 20:49;jira-bot;Commit 1600757 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1600757 ]

OPENJPA-2508 : Account for JOIN FETCH statements when loading from the Query Cache.","11/Jun/14 22:00;jira-bot;Commit 1602032 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1602032 ]

OPENJPA-2508: Account for JOIN FETCH statements when loading from the Query Cache.  Back ported to 2.2.1.x Rick's trunk commit.","12/Jun/14 00:02;jira-bot;Commit 1602052 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1602052 ]

OPENJPA-2508: Account for JOIN FETCH statements when loading from the Query Cache.  Back ported to 2.2.x Rick's trunk commit.","12/Jun/14 03:55;jira-bot;Commit 1602060 from [~jpaheath] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1602060 ]

OPENJPA-2508: Account for JOIN FETCH statements when loading from the Query Cache.  Back ported to 2.3.x Rick's trunk commit.","02/Dec/14 19:44;jira-bot;Commit 1642995 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1642995 ]

OPENJPA-2508: Account for JOIN FETCH statements when loading from the Query Cache. - APICHK Fix",,,,,,,,,,,,,,,,,,,
Weird EmptyStackException in CriteriaQueryImpl,OPENJPA-2507,12716905,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,kwsutter,ialex,ialex,27/May/14 20:57,06/Jun/15 14:25,14/Mar/19 03:03,09/Jul/14 16:15,2.2.0,2.3.0,2.4.0,,,,,,2.4.0,,,,,criteria,,,,1,criteria_api,openjpa,,,,,,"Using spring-data-jpa with openjpa, I sometimes encounter a strange error (not all the times, but under heavy load it makes its appearance, sparsely though):
....
Caused by: java.util.EmptyStackException
        at java.util.Stack.peek(Stack.java:<arbitrary line>)
        at org.apache.openjpa.persistence.criteria.CriteriaQueryImpl.ctx(CriteriaQueryImpl.java:<arbitrary line>
....

I do not know which behaviour triggers it, however I think it would be an improvement to change (I did not know where exactly to file it, because it is both an improvement and a bug in my opinion), in org.apache.openjpa.persistence.criteria.CriteriaQueryImpl, method: Context ctx(), this:
return _contexts == null || _contexts.isEmpty() ? null :  _contexts.peek();
to something like this:
try {
	return _contexts == null || _contexts.isEmpty() ? null :  _contexts.peek();
} catch (EmptyStackException e) {
    return null;
}

, in order to prevent a case where multiple threads modify the ""_contexts"" between the evaluation of the inline ""if"".



I am not able to reproduce it all the time, thus I can't create a useful test, neither have I created a patch due to the simplicity of the 'fix'. However I believe it is a harmless fix which could be considered a minor improvement.","openjpa 2.2.0 & 2.3.0, spring-data-jpa up to 1.4.2",,,,,,,,,,,,,,,,,,03/Jun/14 12:05;thomasd;OPENJPA-2507-Wrap-ContextStack-in-ThreadLocal.patch;https://issues.apache.org/jira/secure/attachment/12648132/OPENJPA-2507-Wrap-ContextStack-in-ThreadLocal.patch,03/Jun/14 10:47;viadavid;exceptions.txt;https://issues.apache.org/jira/secure/attachment/12648117/exceptions.txt,03/Jun/14 10:47;viadavid;openjpa-exception-demo.zip;https://issues.apache.org/jira/secure/attachment/12648116/openjpa-exception-demo.zip,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2014-05-28 01:14:46.491,,,no_permission,,,,,,,,,,,,395113,,,Wed Jul 09 16:14:37 UTC 2014,,,,,,,0|i1w11j:,395247,,,,,,,,"28/May/14 01:14;kwsutter;Although I understand the logic behind your suggestion -- to prevent the EmptyStackException -- I don't necessarily agree with the reasoning for this change.  If multiple threads are getting into this method, then I think we have bigger issues with this class. None of the instance variables are protected for multiple thread access.  So, if we're having issues with the Stacks, we should be hitting issues with the Maps, and Lists, and other collections.

Given that, I also found an older JIRA (openjpa-2098) which seems to have hit a similar issue.  Pinaki had resolved that issue by putting in the null and isEmpty() checks that you are referencing.  So, it seems we are putting band-aids on this issue without fully understanding the source.

The common link between the two scenarios is the use of the spring-data-jpa feature.  Not pointing fingers at this, just highlighting the common aspect of the two descriptions.","28/May/14 07:02;ialex;I have not seen the source of spring-data very closely to see if it caches CriteriaQueryImpl (even though after your comment I suspect that that is the case, or something of the sort, like modifying the contexts using get/setContexts), but since this class was never intended to be accessed by multiple threads, then there is no reason to protect that part of the class only.

However, Stacks' methods are synchronized and there is only a setter for contexts (these are the main differences from the other Maps/Lists inside CriteriaQueryImpl), perhaps if there is an explanation to the problem would be related to those. I am not saying this is worth the effort, but I am just curious as to why we have a problem with the specific method (Context ctx()) in two tickets which are probably related.

Just to mention it, since I tested the proposed fix myself, I haven't seen something related to CriteriaQueryImpl again.","28/May/14 13:57;kwsutter;Interesting.  The more I look into this default Stack implementation, it doesn't look to be very solid.  Even in the Javadoc for Stack, it recommends the use of Deque instead:

""A more complete and consistent set of LIFO stack operations is provided by the Deque[1] interface and its implementations, which should be used in preference to this class. For example:

   Deque<Integer> stack = new ArrayDeque<Integer>();""

[1]  http://docs.oracle.com/javase/7/docs/api/java/util/Deque.html

And, looking at the Deque's peek operation, it doesn't throw an exception if it's empty, it just returns null.  It might be better to just use the Deque collection instead of Stack...  Of course, this would have a larger ripple effect in the code base...

It's good to know that your proposed hack seems to resolve the issue for you.  Maybe that's what we need to do for the time being and worry about the ""larger fish"" at a later time...  I have also reached out to Pinaki to see if he has any preference.","28/May/14 14:25;ialex;My initial thought was that since the Deque interface was introduced in java 6, there might be compatibility reasons as to why someone would choose Stack over Deque.

Glad to be (even of minor) help :)","03/Jun/14 07:25;oliver.gierke;Just to confirm this: Spring Data JPA is caching {{CriteriaQuery}} instances as - in contrast to {{EntityManager}} and {{EntityManagerFactory}} - there's no hint in the spec about the {{CriteriaQuery}} instances to be allowed to not be thread safe, once constructed and equipped with predicates.","03/Jun/14 10:47;viadavid;I experienced this very bug and created a demo project (see attached {{openjpa-exception-demo.zip}}) - if that helps. Just execute {{LoadTest#parallelTest}} and invariably one of the exceptions in {{exceptions.txt}} will be thrown. One of those is the {{EmptyStackException}}.

It is easy to reproduce this without Spring Data by using this alternative implementation for the {{DemoRepository}} interface from the demo project:

{code:java}
@Component
public class ManualDemoRepository implements DemoRepository {

	@Autowired
	EntityManager entityManager;

	CriteriaQuery<DemoEntity> criteriaQuery;

	@PostConstruct
	public void initQuery() {
		CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
		criteriaQuery = criteriaBuilder.createQuery(DemoEntity.class);

		Root<DemoEntity> demoRoot = criteriaQuery.from(DemoEntity.class);

		criteriaQuery.select(demoRoot).where(criteriaBuilder.equal(demoRoot.get(DemoEntity_.demoNumber), 42));
	}

	@Override
	public DemoEntity findByDemoNumber(int demoNumber) {
		return entityManager.createQuery(criteriaQuery).getSingleResult();
	}
}
{code}","03/Jun/14 12:04;thomasd;Hello,

I just had a look at this and I think a solution that fixes this issue.

I noticed by debugging the provided example app that an instance of {{org.apache.openjpa.persistence.criteria.CriteriaQueryImpl}} is shared between multiple instances of {{org.apache.openjpa.jdbc.kernel.JDBCStoreQuery}}. In {{CriteriaQueryImpl}} the {{_contexts}} field is read and written by multiple threads. 

I think the problem lies in {{org.apache.openjpa.persistence.criteria.CriteriaQueryImpl.getQueryExpressions(ExpressionFactory)}}:
{code:java}
   QueryExpressions getQueryExpressions(ExpressionFactory factory) {
        _contexts = new Stack<Context>();
        Context context = new Context(null, null, null);
        _contexts.push(context);
        return new CriteriaExpressionBuilder().getQueryExpressions(factory, this);
    }   
{code}
Since the (shared) {{_context}} field is modified and read by multiple threads this causes the spurious NPE / EmptyStackExceptions to appear.
One (relatively easy) way to solve this would be to just wrap the {{_context}} in a {{ThreadLocal}} - I added a patch file that does exactly that. Note that we remove the stored ThreadLocal value when we leave {{getQueryExpressions}}

With this fixed I could run the provided example app without any problems. This patch would work for openjpa 2.3.0 as well as 2.4.0.
I tested this with openjpa 2.3.0 directly. I created the patch from the latest svn head for 2.4.0.

Cheers,
Thomas",03/Jun/14 12:05;thomasd;Patch that wraps the _context field in {{org.apache.openjpa.persistence.criteria.CriteriaQueryImpl<T>}} in a ThreadLocal.,"03/Jun/14 13:39;kwsutter;Thank you, Thomas.  I like this approach the best thus far.  I agree with where you think the problem originates.  And, I didn't like the idea of changing the data structure itself due to the ripple effect to other parts. But, wrapping the Stack in a ThreadLocal seems to be an easy, safe mechanism to overcome the problem.  I want to experiment and look at the patch a bit more to ensure that we're removing this ThreadLocal appropriately, otherwise we could end up with a leak.

Thanks, Kevin","10/Jun/14 21:24;kwsutter;With some minor modifications, the patch provided by Thomas looks good.  I've reviewed the code and experimented with it and have not reproduced the problem either.  I plan to commit this change to trunk (2.4.0) shortly.","10/Jun/14 21:47;jira-bot;Commit 1601778 from [~kwsutter] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1601778 ]

OPENJPA-2507.  Committing a variation of Thomas Darimont's patch that utilizes ThreadLocal storage to safeguard the _contexts in CriteriaQueryImpl.",23/Jun/14 09:40;viadavid;That's great news! Are there any plans about when 2.4 will be released?,"09/Jul/14 16:14;kwsutter;No plans currently.  We're working through some issues with Java 7, Java 8, ASM, and Serp on trunk (2.4.0)...  Once these items get addressed, then we could entertain a possible 2.4.0 release.  To be honest, if you require this change in a formal release, you might want to pursue this fix in one of the service streams and pushing for a service release.  Thanks.",,,,,,,,,,,,,,
StoreCache interface doesn't work for many ID types,OPENJPA-2506,12716383,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,23/May/14 17:56,06/Jun/15 14:25,14/Mar/19 03:03,17/Jun/14 18:31,2.0.1,2.1.1,2.2.2,2.3.0,2.4.0,,,,2.1.2,2.2.1.1,2.2.3,2.4.0,,datacache,kernel,,,0,,,,,,,,"While doing some internal testing, it was discovered that the javax.persistence.Cache.contains(Class, Object) method doesn't work for a number of id types. The implementation depends on JPAFacade helper to convert user provided [Class, Object] into a proper OpenJPAId, but it doesn't work in all cases. ",,,,,,,,,,,OPENJPA-2523,,,,,,,,27/May/14 14:01;dalia;patch-FacadeHelperFix.patch;https://issues.apache.org/jira/secure/attachment/12646918/patch-FacadeHelperFix.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-05-27 14:01:38.376,,,no_permission,,,,,,,,,,,,394591,,,Fri May 01 21:37:33 UTC 2015,,,,,,,0|i1vxv3:,394732,,,,,,,,27/May/14 14:01;dalia;I attached a patch where I replaced JPAFacadeHelper's OpenJPAObjectId conversion with one that mimics how BrokerImpl does the conversion. I also fixed TestJPAFacadeHelper because it was testing the wrong behavior and added a few more tests for various Id types. ,"17/Jun/14 18:30;jira-bot;Commit 1603251 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1603251 ]

OPENJPA-2506: Update JPAFacadeHelper to properly create an OpenJPA identity object. Patch contributed by Dalia Abo Sheasha.",17/Jun/14 18:31;curtisr7;Committed revision 1603251 to trunk. Thanks for the patch Dalia!,"29/Dec/14 21:01;jira-bot;Commit 1648430 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1648430 ]

OPENJPA-2506: StoreCache interface doesn't work for many ID types - back ported Dalia's fix to 2.1.x.","30/Dec/14 00:12;jira-bot;Commit 1648450 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1648450 ]

OPENJPA-2506: StoreCache interface doesn't work for many ID types - back ported Dalia's fix to 2.2.1.x.","30/Dec/14 00:42;jira-bot;Commit 1648455 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1648455 ]

OPENJPA-2506: StoreCache interface doesn't work for many ID types - back ported Dalia's fix to 2.2.x.","01/May/15 21:37;jira-bot;Commit 1677238 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1677238 ]

OPENJPA-2506: Add serialVersionUID to ClassMetaData",,,,,,,,,,,,,,,,,,,,
OpenJPA PersistenceException: LongId cannot be cast to MyEntityClass… @OneToMany in combination with FetchType.EAGER,OPENJPA-2505,12714792,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,mw_logentis,mw_logentis,16/May/14 15:55,23/Sep/14 15:57,14/Mar/19 03:03,23/Sep/14 15:57,2.1.0,2.2.2,2.3.0,2.4.0,,,,,2.2.3,2.4.0,,,,jpa,,,,0,,,,,,,,"When I try to get an object from my database via entity manager that includes a further object that is annotated with @OneToMany and the parameter ""fetch = FetchType.EAGER"", I got the following exception (below are more Information about my entities and testcases):

[ERROR 15:50:40] projectNameRestController.catchEmAll(75) | general error occurred
<openjpa-2.2.2-r422266:1468616 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: org.apache.openjpa.util.LongId cannot be cast to de.projectName.domain.test.Parent
FailedObject: select p from Parent p [java.lang.String]
    at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:1027)
    at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:926)
    at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1033)
    at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:280)
    at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2381)
    at org.apache.openjpa.jdbc.meta.strats.RelationToManyInverseKeyFieldStrategy.loadElement(RelationToManyInverseKeyFieldStrategy.java:90)
    at org.apache.openjpa.jdbc.meta.strats.RelationCollectionInverseKeyFieldStrategy.loadElement(RelationCollectionInverseKeyFieldStrategy.java:76)
    at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.processEagerParallelResult(StoreCollectionFieldStrategy.java:313)
    at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.loadEagerParallel(StoreCollectionFieldStrategy.java:247)
    at org.apache.openjpa.jdbc.meta.FieldMapping.loadEagerParallel(FieldMapping.java:916)
    at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1106)
    at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1059)
    at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:636)
    at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:117)
    at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
    at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:3108)
    at org.apache.openjpa.kernel.StateManagerImpl.load(StateManagerImpl.java:446)
    at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:963)
    at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:926)
    at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1033)
    at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:280)
    at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2381)
    at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:274)
    at org.apache.openjpa.jdbc.kernel.InstanceResultObjectProvider.getResultObject(InstanceResultObjectProvider.java:60)
    at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:36)
    at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1251)
    at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1007)
    at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:863)
    at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:794)
    at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
    at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:286)
    at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302)
    at de.projectName.dao.impl.AccountingDaoImpl.getDistributionsByProvider(AccountingDaoImpl.java:217)
    at de.projectName.dao.impl.AccountingDaoImpl.getDistributionsByProvider(AccountingDaoImpl.java:171)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:483)
    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)
    at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:98)
    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:262)
    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)
    at com.sun.proxy.$Proxy27.getDistributionsByProvider(Unknown Source)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:483)
    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)
    at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:98)
    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:262)
    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)
    at com.sun.proxy.$Proxy28.getDistributionsByProvider(Unknown Source)
    at de.projectName.controller.rest.AccountingprojectNameRestController.getAllUnaccountedDistributions(AccountingprojectNameRestController.java:96)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:483)
    at org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:215)
    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132)
    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:749)
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:689)
    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83)
    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:938)
    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:870)
    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:961)
    at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:852)
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:618)
    at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:837)
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:725)
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:301)
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
    at com.opensymphony.module.sitemesh.filter.PageFilter.parsePage(PageFilter.java:118)
    at com.opensymphony.module.sitemesh.filter.PageFilter.doFilter(PageFilter.java:52)
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
    at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:88)
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:108)
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
    at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:108)
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
    at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:61)
    at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108)
    at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137)
    at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
    at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66)
    at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449)
    at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365)
    at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90)
    at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83)
    at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:383)
    at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362)
    at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
    at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:344)
    at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:261)
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:219)
    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106)
    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:503)
    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:136)
    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:74)
    at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:610)
    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88)
    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:526)
    at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1017)
    at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:652)
    at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:222)
    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1575)
    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1533)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:744)
Caused by: java.lang.ClassCastException: org.apache.openjpa.util.LongId cannot be cast to de.projectName.domain.test.Parent
    at de.projectName.domain.test.Child.pcReplaceField(Child.java)
    at org.apache.openjpa.kernel.StateManagerImpl.replaceField(StateManagerImpl.java:3213)
    at org.apache.openjpa.kernel.StateManagerImpl.storeObjectField(StateManagerImpl.java:2643)
    at org.apache.openjpa.kernel.StateManagerImpl.storeObject(StateManagerImpl.java:2633)
    at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.setMappedBy(JDBCStoreManager.java:478)
    at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:404)
    at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:306)
    at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:112)
    at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
    at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1046)
    at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:1004)
    ... 126 more 
________________________________________________

I created 2 new entities for my tests, they look like this:

@Entity
@Table(name = ""parent"")
public class Parent {

@Id
@GeneratedValue(strategy = GenerationType.TABLE, generator = ""parentGen"")
@TableGenerator(name = ""parentGen"", table = ""jpa_sequence"", pkColumnName = ""ID"",
        pkColumnValue = ""parent"", valueColumnName = ""SEQUENCE_VALUE"", allocationSize = 1)
public long oid;

@OneToMany(mappedBy = ""parent"", fetch = FetchType.EAGER)
private List<Child> children;


public long getOid() {
    return oid;
}

public void setOid(long oid) {
    this.oid = oid;
}

public List<Child> getChildren() {
    return children;
}

public void setChildren(List<Child> children) {
    this.children = children;
}
_______________________________________

@Entity
@Table(name = ""child"")
public class Child {

@Id
@GeneratedValue(strategy = GenerationType.TABLE, generator = ""childGen"")
@TableGenerator(name = ""childGen"", table = ""jpa_sequence"", pkColumnName = ""ID"",
        pkColumnValue = ""child"", valueColumnName = ""SEQUENCE_VALUE"")
public long oid;

@ManyToOne
private Parent parent;


public long getOid() {
    return oid;
}

public void setOid(long oid) {
    this.oid = oid;
}

public Parent getParent() {
    return parent;
}

public void setParent(Parent parent) {
    this.parent = parent;
}
____________________________________

Further information:

    My jpql: select p from Parent p
    If I change the FetchType to ""LAZY"" (or leave it just out) I got my result normaly and the children object (the list) is null of course, but if I call the getter of the list now (in the transaction), the object will be filled normaly without this exception.
    Furthermore this exception does not occur when I have just 1 parent with child objects. I can have several parents and children in my tables, but when more than 1 parent have children referenced in the database, this exception will be thrown.
    Also if I change the type of ""oid"" from ""long"" to ""int"" the exception will change, too: ""...LongId cannot be cast... -> ...IntId cannot be cast...""
    I used: Java 8 with jpa 2.1.0 and 2.2.2, Java 6 with jpa 2.2.2
    MySQL Database
    Apache Tomcat
",Java 8 and 6,,,,,,,,,,,,,,,,,,20/Aug/14 13:06;Lucas_Wright;LongId Scenarios.xlsx;https://issues.apache.org/jira/secure/attachment/12663123/LongId+Scenarios.xlsx,24/Jun/14 12:40;jgogstad;bugreport.zip;https://issues.apache.org/jira/secure/attachment/12652186/bugreport.zip,17/Sep/14 22:21;curtisr7;openjpa-2505.patch;https://issues.apache.org/jira/secure/attachment/12669543/openjpa-2505.patch,16/May/14 19:50;curtisr7;openjpa-2505.ut.patch;https://issues.apache.org/jira/secure/attachment/12645313/openjpa-2505.ut.patch,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2014-05-16 17:53:36.167,,,no_permission,,,,,,,,,,,,393105,,,Tue Sep 23 15:35:55 UTC 2014,,,,,,,0|i1voyn:,393272,,,,,,,,16/May/14 17:53;curtisr7;Will you also post the contents of your persistence.xml file?,"16/May/14 19:50;curtisr7;Attaching a unit test that I created, but was unable to recreate the bug. I changed the annotations on the ID fields, but I don't believe that was relevant to the problem. I suspect that I as missing some 'special' persistence.xml properties.","19/May/14 07:14;mw_logentis;<persistence xmlns=""http://java.sun.com/xml/ns/persistence""
             xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
             xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd""
             version=""1.0"">
    <persistence-unit name=""punit"">
        <provider>org.apache.openjpa.persistence.PersistenceProviderImpl</provider>
        <properties>
            <property name=""openjpa.Log"" value=""log4j""/>
            <property name=""openjpa.jdbc.DBDictionary"" value=""db2""/>
        </properties>
    </persistence-unit>
</persistence>","19/May/14 16:06;curtisr7;I haven't been able to create your problem. I tried on trunk and 2.2.x . Would it be possible for you to try to put something together that easily recreates the problem? Also, please take a look at my unit test to see if I'm doing something wrong with setting the data up.

Thanks,
Rick","28/May/14 15:54;jpaheath;Hi Martin!  Have you given any thought to Rick's previous request?  We'd really like to be able to recreate this issue and provide a fix to you asap.

Thanks,

Heath","24/Jun/14 12:45;jgogstad;[~jpaheath], [~curtisr7]: I managed to reproduce the for a OneToMany the the inverse side has a composite primary key. I boiled down the error and attached a bugreport packaged in a maven project. run {{mvn test}} and you'll get the error
{code:none}
Caused by: java.lang.ClassCastException: org.apache.openjpa.util.LongId cannot be cast to org.apache.openjpa.entities.MyUserEntity
        at org.apache.openjpa.entities.AddressEntity.pcReplaceField(AddressEntity.java)
        at org.apache.openjpa.kernel.StateManagerImpl.replaceField(StateManagerImpl.java:3216)
        at org.apache.openjpa.kernel.StateManagerImpl.storeObjectField(StateManagerImpl.java:2643)
        at org.apache.openjpa.kernel.StateManagerImpl.storeObject(StateManagerImpl.java:2633)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.setMappedBy(JDBCStoreManager.java:478)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:404)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:306)
        at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:112)
        at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
        at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1050)
        at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:1008)
{code}

OpenJPA behaves really wierd. Here's some observations:
* You need to select a completely unrelated class from the db in a \@PostConstruct 
** If the class (FooEntity) is selected anywhere else, everything works
** If the FooEntity is not selected at all, everything works
* The error seem only to occur if the inverse side of a OneToMany has a composite key",24/Jun/14 12:49;jgogstad;Verified on 2.2.2 and 2.3.0,"23/Jul/14 16:52;logemann;any news on that?  i am a colleague of Martin and most likely i am on the same spot as Martin. I also tried various things w/o success to solve / circumvent it. Currently i am on 2.2.0. 

Any ideas how to workaround this?

Update: The only sensible workaround is to avoid ""eager"" and use ""join fetch"" instead.


","20/Aug/14 13:05;Lucas_Wright;I have been working on this same issue with IBM for the past eight months or so.  Jostein, I appreciate the test case you provided as it helped me to narrow down the issue much further.  Here are some facts I've gathered that have already been forwarded to IBM.

1.) @PostConstruct does not cause the error.  I was able to use the test case to reproduce the error with and without @PostConstruct.
2.) The statement that a non-related entity must exist is false.  I removed the FooEntity entirely from persistence.xml (along with its entity annotations), and I was still able to reproduce the error.
3.) At least two parents and at least one child record for each parent must exist for the error to occur.  Once you delete one of the remaining two children the error no longer occurs.
4.) An embedded key is not necessary for the error to occur (my entities don’t use them).

I'm going to attach a spreadsheet of actions I performed using the sql data provided in Jostein's test case.

One last thing: I have a theory that the order in which objects are retrieved from the database (asc or desc) is a factor also, but as I'm sure you have all seen it's difficult to pinpoint.",20/Aug/14 13:06;Lucas_Wright;Here is the promised spreadsheet of steps I performed (LongId Scenarios.xlsx).,"21/Aug/14 01:38;curtisr7;Lucas --

I sort of tried out your test project this evening and it worked for me.... with a few modifications. 
 * Your test uses Oracle DB and I don't have that on my system so I changed test-ctx.xml to use MySQL.
 * I had to change your p.xml to use openjpa.jdbc.SynchronizeMappings as I don't have any of the tables for your Entities.
 * I had to modify MyUserEntity to use an AUTO generated ID as MySQL doesn't support native sequences.

Have you tried your test on a DB other than oracle? ","22/Aug/14 12:32;Lucas_Wright;Rick -

I wouldn't think the changes you made would have any affect on the error.  I believe the root cause is that OpenJPA isn't handling the mapping of child entities to parent entities correctly in certain scenarios that are purely data-related.  That's just a theory, but the results seem to support that.

Oracle is the only database I have access to at the moment so I haven't tested on other platforms.  It sounds like the error still occurred for you on MySQL so unless anyone has the need to try it on another database I believe we've narrowed it down to pure data.","11/Sep/14 16:15;Lucas_Wright;I've got some more information that I've found in my testing.  It seems that the issue is related to the entity manager itself in conjunction with JPA.  In my testing I found that when the data already exists in the database, and the retrieval is performed, the error always occurs.  However, if the data is inserted using the entity manager, and then retrieved using the entity manager in the same session the error does not occur.

It almost feels like there is an association that is built by the entity manager when records are inserted using it, but if it wasn't used to insert the records there's some unknown variable in the equation that causes this issue.

I tried the following three scenarios to validate my hypotheses:

1.)	Insert entities using Spring’s entity manager and OpenJPA associations and load entities using OpenJPA (no error)
a.	Delete records from database
b.	Restart JVM

2.)	Insert using Native JDBC and load entities using OpenJPA (error occurs)
a.	Delete records from database
b.	Restart JVM

3.)	Insert manually in database and load entites using OpenJPA (error occurs)
","17/Sep/14 22:21;curtisr7;I was able to fix the reported problem, but I am still having issues trying to recreate it in a simple JUnit. Please give the attached patch a try to ensure that it works in all of your scenarios.

Thanks,
Rick","19/Sep/14 17:59;jira-bot;Commit 1626287 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1626287 ]

OPENJPA-2505 : Properly init MetaDataRepository when obtaining a reference in EntityManagerFactory.getMetaModel.",19/Sep/14 18:00;curtisr7;Committed revision 1626287 to trunk.,"23/Sep/14 15:35;jira-bot;Commit 1627059 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1627059 ]

OPENJPA-2505: Properly init MetaDataRepository when obtaining a reference in EntityManagerFactory.getMetaModel.  Back-ported to 2.2.x Rick Curtis' trunk changes.",,,,,,,,,,
NPE in QueryKey.createKey using criteria with QueryCache enabled,OPENJPA-2502,12713350,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,allee8285,allee8285,09/May/14 17:25,22/Sep/14 19:11,14/Mar/19 03:03,22/Sep/14 19:11,2.2.1,2.2.2,2.3.0,2.4.0,,,,,2.2.1.1,2.2.3,2.4.0,,,criteria,datacache,,,0,,,,,,,,"Running an example in the spec using Criteria API with ""left join fetch"" AND query cache enabled yield the following NPE exception. See the testcase to reproduce the problem and the spec section where the example comes from:

<openjpa-2.2.1.1-SNAPSHOT-r422266:1438134 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Failed to execute query ""null"". Check the query syntax for correctness. See nested exception for details.
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:872)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:794)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:286)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302)
	at com.ibm.ws.persistence.QueryImpl.getResultList(QueryImpl.java:118)
	at test.TestNPE.test(TestNPE.java:62)
......
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.datacache.QueryKey.createKey(QueryKey.java:203)
	at org.apache.openjpa.datacache.QueryKey.newInstance(QueryKey.java:139)
	at org.apache.openjpa.datacache.QueryCacheStoreQuery$QueryCacheExecutor.executeQuery(QueryCacheStoreQuery.java:339)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1005)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:863)
	... 33 more
",,,,,,,,,,,,,,,,,,,18/May/14 05:44;allee8285;OPENJPA-2502.221x.patch;https://issues.apache.org/jira/secure/attachment/12645447/OPENJPA-2502.221x.patch,09/May/14 17:26;allee8285;OPENJPA-2502.test.zip;https://issues.apache.org/jira/secure/attachment/12644133/OPENJPA-2502.test.zip,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2014-05-23 04:04:19.391,,,no_permission,,,,,,,,,,,,391666,,,Thu Jun 12 03:53:22 UTC 2014,,,,,,,0|i1vgen:,391878,,,,,,,,"09/May/14 17:29;allee8285;The NPE comes from the following code fragment in createKey() where q.getAccessPathMetaDatas() returns 
[null, test.Department] and subsequent meta.getDescribedType() on the first element takes the NPE.

        // we can't cache the query if we don't know which classes are in the
        // access path
        ClassMetaData[] metas = q.getAccessPathMetaDatas();
        if (metas.length == 0)
            return null;

        Set<String> accessPathClassNames = new HashSet<String>((int) (metas.length * 1.33 + 1));
        ClassMetaData meta;
        for (int i = 0; i < metas.length; i++) {
            // since the class change framework deals with least-derived types,
            // record the least-derived access path types
            meta = metas[i];
            accessPathClassNames.add(meta.getDescribedType().getName()); <<<< NPE
            while (meta.getPCSuperclass() != null) {
                meta = meta.getPCSuperclassMetaData(); 
            }

            accessPathClassNames.add(meta.getDescribedType().getName());
        }
","18/May/14 05:04;allee8285;The NPE is caused by the CriteriaExpressionBuilder trying to find the metadata for the join fetch field.  Since this field is mostly a collection, the metadata class is of collection type, hence there is no metadata in the repository, hence a null is stored in the metas array.  Subsequently, when the metas array is processed the NPE is surfaced.

I tried the equivalent JPQL as the criteria API and the JPQLExpressionBuilder does not include any metadata for the fetch clause.","23/May/14 04:04;jira-bot;Commit 1597006 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1597006 ]

OPENJPA-2502: NPE in QueryKey.createKey using criteria with QueryCache enabled - committed Albert Lee's patch.","23/May/14 04:08;jira-bot;Commit 1597007 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1597007 ]

OPENJPA-2502: NPE in QueryKey.createKey using criteria with QueryCache enabled - committed Albert Lee's patch to 2.2.1.x","05/Jun/14 15:48;jira-bot;Commit 1600682 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1600682 ]

OPENJPA-2502 : Update accessPath metas in CriteriaExpressionBuilder. Merged changes from 2.2.1.x. Patch contributed by Albert Lee.","11/Jun/14 23:49;jira-bot;Commit 1602050 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1602050 ]

OPENJPA-2502: Update accessPath metas in CriteriaExpressionBuilder. Merged changes from trunk. Patch contributed by Albert Lee.","12/Jun/14 03:53;jira-bot;Commit 1602059 from [~jpaheath] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1602059 ]

OPENJPA-2502: Update accessPath metas in CriteriaExpressionBuilder. Merged changes from trunk. Patch contributed by Albert Lee.",,,,,,,,,,,,,,,,,,,,
A default Schema defined in a PU default (<persistence-unit-defaults>) in an orm.xml file is not being honored.,OPENJPA-2494,12708310,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,jpaheath,jpaheath,14/Apr/14 16:42,20/Jul/17 20:32,14/Mar/19 03:03,22/Sep/14 23:07,2.2.1.1,2.2.3,2.3.0,2.4.0,,,,,2.2.3,2.4.0,,,,jpa,,,,0,,,,,,,,"Take the following entry in an orm.xml file:

	<persistence-unit-metadata>
		<persistence-unit-defaults>
			<schema>schemaInPUDefaults</schema>
		</persistence-unit-defaults>
	</persistence-unit-metadata>

Lets say this is the ONLY schema defined in the entire app, then this schema should be used by default (the spec clearly defines how the defaults in <persistence-unit-defaults> should be used by a provider).  However, this schema is not used by OpenJPA.  I have a test to recreate this issue and I'm working to provide a fix.

Thanks,

Heath Thomann",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-09-22 21:55:33.62,,,no_permission,,,,,,,,,,,,386633,,,Thu Jul 20 20:32:27 UTC 2017,,,,,,,0|i1uls7:,386897,,,,,,,,"22/Sep/14 21:55;jira-bot;Commit 1626903 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1626903 ]

OPENJPA-2494: A default Schema defined in a PU default (<persistence-unit-defaults>) in an orm.xml file is not being honored.","22/Sep/14 23:06;jira-bot;Commit 1626916 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1626916 ]

OPENJPA-2494: A default Schema defined in a PU default (<persistence-unit-defaults>) in an orm.xml file is not being honored.","06/Jul/17 14:20;dazeydev;I believe this fix changed the behavior of the 'openjpa.jdbc.Schema' property. When both the orm.xml default schema and the 'openjpa.jdbc.Schema' property are set, OpenJPA now prefers the orm.xml default over the property. In the past (2.1.x) the persistence property was preferred over the orm.xml configuration, but that seems to have changed with this fix. I believe that it makes more sense to have the persistence property overrule the orm.xml mapping file, not the other way around. I also notice that Heath's tests he included in this fix do not test the 'openjpa.jdbc.Schema' property, so I am guessing this was an unforeseen side effect of the fix.",20/Jul/17 20:32;dazeydev;Opened https://issues.apache.org/jira/browse/OPENJPA-2704 to fix this issue,,,,,,,,,,,,,,,,,,,,,,,
java.sql.SQLException when processing a query result,OPENJPA-2482,12700809,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,11/Mar/14 20:41,06/Jun/15 14:25,14/Mar/19 03:03,16/Jun/14 20:46,2.1.1,2.2.2,2.3.0,2.4.0,,,,,2.1.2,2.2.1.1,2.2.3,2.4.0,,jdbc,,,,0,,,,,,,,"We encountered the following stacktrace[1] when processing the results of a very complex query. 

After much debugging I found that the net of the problem is that in SelectImpl we cache column aliases(cachedColumnAlias_) keyed off a given org.apache.openjpa.jdbc.schema.Column, but a given column might map to multiple aliases(depending on the PathJoins @see SelectImpl.SelectResult.containsInternal). It appears that under normal circumstances it is okay that we continually overwrite aliases, but for this one query we were incorrectly mapping to the wrong alias. I unsuccessfully attempted to write a unit test for a good day and I've given up on providing a unit tests. 

Committers :: please feel free to review this commit to ensure that I'm not regressing an behavior.

[1] <openjpa-2.1.2-SNAPSHOT-r422266:1530146 fatal general error> org.apache.openjpa.persistence.PersistenceException: t1.FK
FailedObject: [....].jpa.people.Person-C-BBHJ897 [java.lang.String]
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4925)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4885)
	at org.apache.openjpa.jdbc.sql.DB2Dictionary.newStoreException(DB2Dictionary.java:603)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:136)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:86)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:338)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.initialize(WsJpaJDBCStoreManager.java:149)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:112)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1027)
	at com.ibm.ws.persistence.kernel.WsJpaBrokerImpl.initialize(WsJpaBrokerImpl.java:257)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:985)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:907)
	at com.ibm.ws.persistence.kernel.WsJpaBrokerImpl.find(WsJpaBrokerImpl.java:199)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1041)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.load(WsJpaJDBCStoreManager.java:112)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:280)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2381)
	at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.loadEagerJoin(RelationFieldStrategy.java:724)
	at org.apache.openjpa.jdbc.meta.FieldMapping.loadEagerJoin(FieldMapping.java:922)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1111)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1067)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:438)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:333)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.initialize(WsJpaJDBCStoreManager.java:149)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:112)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1027)
	at com.ibm.ws.persistence.kernel.WsJpaBrokerImpl.initialize(WsJpaBrokerImpl.java:257)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:985)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:907)
	at com.ibm.ws.persistence.kernel.WsJpaBrokerImpl.find(WsJpaBrokerImpl.java:199)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1041)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.load(WsJpaJDBCStoreManager.java:112)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:280)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2381)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:274)
	at org.apache.openjpa.jdbc.kernel.InstanceResultObjectProvider.getResultObject(InstanceResultObjectProvider.java:59)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.getResultObject(QueryImpl.java:2075)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:36)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1251)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1007)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:863)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:794)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:315)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:331)
	....
Caused by: 
java.sql.SQLException: t1.FK
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.findObject(SelectImpl.java:2507)
	at org.apache.openjpa.jdbc.sql.ResultSetResult.translate(ResultSetResult.java:497)
	at org.apache.openjpa.jdbc.sql.AbstractResult.getString(AbstractResult.java:767)
	at org.apache.openjpa.jdbc.meta.strats.StringFieldStrategy.getPrimaryKeyValue(StringFieldStrategy.java:217)
	at org.apache.openjpa.jdbc.meta.ClassMapping.getObjectId(ClassMapping.java:188)
	at org.apache.openjpa.jdbc.meta.ClassMapping.getObjectId(ClassMapping.java:147)
	at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.load(RelationFieldStrategy.java:754)
	at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:928)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1123)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1067)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:438)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:333)
	... 150 more
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-03-11 21:12:14.515,,,no_permission,,,,,,,,,,,,379152,,,Tue Apr 08 17:34:47 UTC 2014,,,,,,,0|i1tbxj:,379444,,,,,,,,"11/Mar/14 21:12;jira-bot;Commit 1576505 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1576505 ]

OPENJPA-2482: Cache column alias on colum+pathjoins rather than just column.",11/Mar/14 21:12;curtisr7;Committed revision 1576505 to trunk.,"25/Mar/14 16:34;jira-bot;Commit 1581406 from [~fyrewyld] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1581406 ]

OPENJPA-2482: java.sql.SQLException when processing a query result","25/Mar/14 21:06;jira-bot;Commit 1581519 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1581519 ]

OPENJPA-2482: java.sql.SQLException when processing a query result","08/Apr/14 17:34;jira-bot;Commit 1585790 from jgrassel@apache.org in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1585790 ]

OPENJPA-2482: java.sql.SQLException when processing a query result",,,,,,,,,,,,,,,,,,,,,,
Update the website with 2.3.0 release information,OPENJPA-2480,12699402,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,rockymm,rockymm,07/Mar/14 12:19,06/Jun/15 21:19,14/Mar/19 03:03,15/May/14 17:25,,,,,,,,,2.3.0,,,,,site,,,,2,,,,,,,,"I have not realized that 2.3.0 has been released for a while now. This is due to the website not being updated. Surely I am not the only one that checks the website for news and releases.

The most important items to be updated are index.html, downloads.html and documentation.html.

Please treat this with highest importance.",,,,,,,,,,,,,,OPENJPA-2481,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-04-16 16:38:25.712,,,no_permission,,,,,,,,,,,,377749,,,Fri May 16 20:38:27 UTC 2014,,,,,,,0|i1t3a7:,378041,,,,,,,,"16/Apr/14 16:38;kkolinko;The date of the 2.3.0 files on Maven Central is 12-Nov-2013
http://search.maven.org/#browse|1877815231

I do not see proper mention of the release in your board reports.
Neither in 2013-11, nor 2014-02, nor 2014-04 ones.

I do not see any announcements neither on announce@a.o mailing list
https://www.apache.org/foundation/mailinglists.html#foundation-announce

nor on your own users list.

The release is not present at ASF mirrors,
http://www.apache.org/dist/openjpa/

The good thing is that you did have a vote on the dev mailing list in November 2013.

What is going on?","16/Apr/14 21:19;kwsutter;Fair questions, Konstantin.  I have assigned this JIRA to the owner of this release.  We'll try to get these issues resolved quickly.

We knew about the lack of the news/announcements and the lack of presence on the mirrors.  I thought we had announced it via the board reports, but I believe you.

It looks like we dropped the ball on a few things related to this release.  We'll work on getting these resolved.","14/May/14 19:00;kwsutter;Need to get these items resolved...  I am in the process of getting the releases, links, docs, etc cleaned up for the 2.3.0 version.","14/May/14 21:51;kwsutter;Following the Release process as documented here:  http://openjpa.apache.org/apache-nexus-release-process-%281.2.x-2.1.x%29.html

Looks like Mark left off after the 11.1 step of Finalizing the Release...

I just completed steps 11.2, 11.3, and 11.4.  (I could never get our javadoc to build correctly, so I took the copy that Mark had built and posted as part of the 2.3.0 Vote process.)

I've started on steps 12 and onward...","15/May/14 17:25;kwsutter;OpenJPA 2.3.0 has now been announced and posted on index.html, downloads.html and documentation.html.  Sorry for the delay and thank you for your patience.",15/May/14 17:25;kwsutter;Should be all done now...,16/May/14 13:12;curtisr7;Nice job! Thanks for taking care of this one.,16/May/14 20:38;rockymm;Good job!,,,,,,,,,,,,,,,,,,,
Erroneous message from the enhancer when a Mapped Superclass contains an @Id.,OPENJPA-2478,12694802,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jpaheath,jpaheath,jpaheath,12/Feb/14 18:16,21/Sep/16 20:17,14/Mar/19 03:03,05/May/14 17:57,2.1.2,2.2.1.1,2.2.2,2.3.0,2.4.0,,,,2.1.2,2.2.1.1,2.2.3,2.4.0,,Enhance,,,,0,,,,,,,,"HI!  I've discovered an issue which is pretty much as described in JIRA OPENJPA-2463.  That is, when I have a MappedSuperclass with an @Id, I see this error:

openjpa.Enhance: Error: The identity field defined in the com.yyy.zzz.MyEntity Embeddable is not supported.

This error message is erroneously printed because of the fix via JIRA OPENJPA-2233.  This JIRA was well intended for the case where an @Embeddable contains an @Id (a spec violation) but was too over reaching in that it also flagged an error for a MappedSuperclass with an @Id.  I will provide a fix to ensure the error message is only printed when an @Embeddable contains an @Id.

Thanks,

Heath Thomann
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-05-01 15:37:37.54,,,no_permission,,,,,,,,,,,,373310,,,Thu May 01 16:02:29 UTC 2014,,,,,,,0|i1sc0f:,373611,,,,,,,,"01/May/14 15:37;jira-bot;Commit 1591681 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1591681 ]

OPENJPA-2478: Fixed erroneous message from the enhancer when a Mapped Superclass contains an @Id.","01/May/14 15:44;jira-bot;Commit 1591685 from [~jpaheath] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1591685 ]

OPENJPA-2478: Fixed erroneous message from the enhancer when a Mapped Superclass contains an @Id.","01/May/14 15:47;jira-bot;Commit 1591689 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1591689 ]

OPENJPA-2478: Fixed erroneous message from the enhancer when a Mapped Superclass contains an @Id.","01/May/14 15:55;jira-bot;Commit 1591693 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1591693 ]

OPENJPA-2478: Fixed erroneous message from the enhancer when a Mapped Superclass contains an @Id.","01/May/14 16:02;jira-bot;Commit 1591696 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1591696 ]

OPENJPA-2478: Fixed erroneous message from the enhancer when a Mapped Superclass contains an @Id.",,,,,,,,,,,,,,,,,,,,,,
"OptimisticLockEx due to rounding of a Timestamp (either by OJ, or the DB)",OPENJPA-2476,12693951,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jpaheath,jpaheath,jpaheath,07/Feb/14 17:58,07/Mar/19 06:39,14/Mar/19 03:03,05/May/14 17:56,2.1.0,2.2.0,2.2.1.1,2.3.0,2.4.0,,,,2.1.2,2.2.1.1,2.2.3,2.4.0,,jdbc,,,,0,,,,,,,,"HI!  I'm hitting a rather interesting issue and unfortunately to describe it is going to be a bit lengthy......so settle in.  :)  Here is the exception:

<openjpa-2.1.2-SNAPSHOT-r422266:1548248 fatal store error> org.apache.openjpa.persistence.RollbackException: Optimistic locking errors were detected when flushing to the data store.  The following objects may have been concurrently modified in another transaction: [hat.entities.VersionTSEntity-1390400526251]
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:593)
	at hat.tests.PMR57956Test.testupdate(PMR57956Test.java:94)
........
Caused by: <openjpa-2.1.2-SNAPSHOT-r422266:1548248 nonfatal store error> org.apache.openjpa.persistence.OptimisticLockException: Optimistic locking errors were detected when flushing to the data store.  The following objects may have been concurrently modified in another transaction: [hat.entities.VersionTSEntity-1390400526251]
	at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2310)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2158)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2056)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1974)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1498)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:933)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:569)
	... 21 more
Caused by: <openjpa-2.1.2-SNAPSHOT-r422266:1548248 nonfatal store error> org.apache.openjpa.persistence.OptimisticLockException: An optimistic lock violation was detected when flushing object instance ""hat.entities.VersionTSEntity-1390400526251"" to the data store.  This indicates that the object was concurrently modified in another transaction.
FailedObject: hat.entities.VersionTSEntity-1390400526251
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.populateRowManager(AbstractUpdateManager.java:183)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:97)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:78)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:742)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:131)
	... 28 more


To see how this occurs, lets look at the test.  Here is the entity:

@Entity
public class VersionTSEntity implements Serializable {
    @Id
    private Long id;
    
    @Version
    private Timestamp updateTimestamp;

    private Integer someInt;


And here is my test, with pertinent in-line comments:

//This loop is necessary since we need a timestamp which has been //rounded up by either OJ, or the database....usually 1 or 2 loops will cause //the exception.
        for (int i = 0; i < 1000; i++) {

            // Find an existing VersionTSEntity:
            VersionTSEntity t = em.find(VersionTSEntity.class, id);

            tx.begin();
            // Update/dirty VersionTSEntity:   
            t.setSomeInt(t.getSomeInt() + 1);
            t = em.merge(t);

            tx.commit();
            //If this clear is removed the test works fine.
            em.clear();

// Lets say at this point the 'in-memory' timestamp is: 
// 2014-01-22 07:22:11.548778567.  What we actually sent to the DB (via 
// the previous merge) is by default rounded (see 
// DBDictionary.setTimestamp) to the nearest millisecond on Oracle (see 
// DBDictionary.datePrecision) and nearest microsecond on DB2 (see 
// DB2Dictionary.datePrecision) when sending the value to the db.
// Therefore, what we actually send to the db is: 
// 2014-01-22 07:22:11.548779 (for DB2) or 2014-01-22 07:22:11.549 (for 
// Oracle).  
// Notice in either case we rounded up...keep this in mind as it will be 
// important for the remainder of the test......

            // now, do a merge with the unchanged entity
            tx = em.getTransaction();
            tx.begin();

            t = em.merge(t); 
            
            //This 'fixes' the issue:
            //em.refresh(t);
            
// Here is where things get interesting.....an error will happen here when 
// the timestamp has been rounded up, as I'll explain:
// As part of this merge/commit, we select the timestamp from the db to get 
// its value (see method checkVersion below), i.e: 
// 'SELECT t0.updateTimestamp FROM VersionTSEntity t0 WHERE 
//     t0.id = ?'.  
// We then compare the 'in-memory' timestamp to that which we got back 
// from the DB, i.e. on DB2 we compare:
// in-mem:  2014-01-22 07:22:11.548778567
// from db: 2014-01-22 07:22:11.548779
// Because these do not 'compare' properly (the db version is greater), we 
// throw the OptimisticLockEx!!
// For completeness, lets look at an example where the timestamp is as 
// follows after the above update: 2014-01-22 07:22:11.548771234.  We 
// would send to DB2 the following value: 2014-01-22 07:22:11.548771.  
// Then, as part of the very last merge/commit, we'd compare:
// in-mem:  2014-01-22 07:22:11.548771234
// from db: 2014-01-22 07:22:11.548771
// These two would 'compare' properly (the db version is lesser), as such 
// we would not throw an OptLockEx and the test works fine.
   
         tx.commit();


To see where/why the OptLockEx is thrown, we need to look here in VersionColumnStrategy (see //HAT:):

public boolean checkVersion(OpenJPAStateManager sm, JDBCStore store,
        boolean updateVersion)  throws SQLException {
        Column[] cols = vers.getColumns();
        Select sel = store.getSQLFactory().newSelect();
        sel.select(cols);
        sel.wherePrimaryKey(sm.getObjectId(), vers.getClassMapping(), 
                                            store);

        // No need to lock version field (i.e. optimistic), except when version update is required (e.g. refresh) 
        JDBCFetchConfiguration fetch = store.getFetchConfiguration();
        if (!updateVersion && fetch.getReadLockLevel() >= MixedLockLevels.LOCK_PESSIMISTIC_READ) {
            fetch = (JDBCFetchConfiguration) fetch.clone();
            fetch.setReadLockLevel(MixedLockLevels.LOCK_NONE);
        }
        Result res = sel.execute(store, fetch);
        try {
            if (!res.next())
                return false;

            //HAT: here is where we get the timestamp from the db, and 'compare' them:
            Object memVersion = sm.getVersion();
            Object dbVersion  = populateFromResult(res, null);
            
            boolean refresh   = compare(memVersion, dbVersion) < 0;

            if (updateVersion)
                sm.setVersion(dbVersion);
            return !refresh;
        } finally {
            res.close();
        }
    }



Keep in mind here that it seems like the scenario is a bit unique....in other words, if I remove the 'em.clear', we do not deem it necessary to call the 'checkVersion' method (thus we don't go back to the DB to get the timestamp).  So it seems that there are two unique things causing us to hit the issue: 1) merge/clear/merge which causes a 'checkVersion', 2) rounding of timestamps.  I added the 'clear' in my test because it is at this point the customer returns the entity to the caller of an EJB....the caller then sends the entity back to the EJB to merge it.....

Now, there are two existing fixes to this issue on DB2, and one fix for this on Oracle.  As you can see in my test above, if we 'em.refresh' the entity before commit, the in-memory value will match that of the db value.  This fix works regardless of whether or not DB2 or Oracle is used (the customer doesn't really like this idea though).  The next fix, which only works on DB2, is to set DBDictionary.datePrecision=1 (nanosecond precision).  This still doesn't resolve the issue on Oracle.  To see why this is the case, we have to look at the way DB2 and Oracle appear to handle timestamp precision.  Both seem to use microsecond precision by default (for both I think you have the option to go up to nanosecond).  Where they differ is that for precision greater than microsecond, DB2 truncates (no rounding) to a microsec.  However, Oracle rounds to the microsec.  So, lets take the value 2014-01-22 07:22:11.548778567.  If datePrecision=1 we'd send to the DB 2014-01-22 07:22:11.548778567.  On DB2, it would truncate the value to 2014-01-22 07:22:11.548778, but on Oracle, it would round to: 2014-01-22 07:22:11.548779.  So, for DB2, the compare would be:
in-mem:  2014-01-22 07:22:11.548778567
from db: 2014-01-22 07:22:11.548778

This compare passes, so all is well.  For Oracle, we'd compare:
in-mem:  2014-01-22 07:22:11.548778567
from db: 2014-01-22 07:22:11.548779

This compare fails, thus the OptLockEx.  I think setting datePrecision=1 is a fair recommendation/fix for DB2 (others?)......but for Oracle (others?) a fix is needed.  My plan is to provide a fix which rounds the in-memory version of the timestamp to the value set in DBDictionary.datePrecision.  So the exception can still occur if a user has not set datePrecision to match the precision of the Timestamp defined in the database.

Thanks,

Heath Thomann",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-05-01 02:34:17.096,,,no_permission,,,,,,,,,,,,372460,,,Thu Mar 07 06:39:40 UTC 2019,,,,,,,0|i1s6t3:,372764,,,,,,,,"01/May/14 02:34;jira-bot;Commit 1591536 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1591536 ]

OPENJPA-2476: Fixed OptimisticLockEx due to rounding of a Timestamp","01/May/14 02:55;jira-bot;Commit 1591538 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1591538 ]

OPENJPA-2476: Fixed OptimisticLockEx due to rounding of a Timestamp","01/May/14 03:06;jira-bot;Commit 1591539 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1591539 ]

OPENJPA-2476: Fixed OptimisticLockEx due to rounding of a Timestamp","01/May/14 03:10;jira-bot;Commit 1591540 from [~jpaheath] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1591540 ]

OPENJPA-2476: Fixed OptimisticLockEx due to rounding of a Timestamp","01/May/14 03:24;jira-bot;Commit 1591541 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1591541 ]

OPENJPA-2476: Fixed OptimisticLockEx due to rounding of a Timestamp","16/May/14 19:12;jira-bot;Commit 1595313 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1595313 ]

OPENJPA-2476: Fixed OptimisticLockEx due to rounding of a Timestamp",07/Mar/19 06:39;dcam;Is this problem also able to occur if you have a Timestamp in the DB and a java.util.Date to represent it instead of java.sql.Timestamp?  java.sql.Timestamp is a thin layer over java.util.Date.,,,,,,,,,,,,,,,,,,,,
A query with LEFT FETCH JOIN returns incorrect results.,OPENJPA-2475,12692355,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jpaheath,jpaheath,jpaheath,30/Jan/14 18:30,21/Sep/16 20:17,14/Mar/19 03:03,05/May/14 17:53,2.1.1,2.2.1.1,2.2.2,2.3.0,2.4.0,,,,2.1.2,2.2.1.1,2.2.3,2.4.0,,query,,,,0,,,,,,,,"Take the following two entities:

@Entity
public class DepartmentTest{	
    @Id
    private String primaryKey;

    @OrderBy(""name"")
    @OneToMany(mappedBy = ""departmentTest"")
     private Set<PersonTest> persons = new HashSet<PersonTest>();
...........

@Entity
public class PersonTest  {
	@Id
	private String primaryKey;

	@ManyToOne
        @ForeignKey
	private DepartmentTest departmentTest;

        private String name;
.....

With these entities, take this JPQL:

""SELECT DISTINCT dept FROM DepartmentTest dept LEFT JOIN FETCH dept.persons"";

Depending on the data in the database (the order is important, see the provided test), this query can return a results set where some of the 'persons' are missing.

Thanks,

Heath Thomann",,,,,,,,,,,,,,,,,,,30/Jan/14 18:35;jpaheath;OPENJPA-2475-2.1.x.test;https://issues.apache.org/jira/secure/attachment/12626141/OPENJPA-2475-2.1.x.test,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-02-18 21:11:42.833,,,no_permission,,,,,,,,,,,,370950,,,Fri May 16 19:07:54 UTC 2014,,,,,,,0|i1rxjz:,371255,,,,,,,,"18/Feb/14 21:11;jira-bot;Commit 1569528 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1569528 ]

OPENJPA-2475: A query with LEFT FETCH JOIN returns incorrect results - applied fix to 2.1.x.","07/Mar/14 23:00;jira-bot;Commit 1575444 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1575444 ]

OPENJPA-2475: A query with LEFT FETCH JOIN returns incorrect results - made test update.","07/Mar/14 23:04;jira-bot;Commit 1575445 from [~jpaheath] in branch 'openjpa/branches/1.2.x'
[ https://svn.apache.org/r1575445 ]

OPENJPA-2475: A query with LEFT FETCH JOIN returns incorrect results - applied changes to 1.2.x.","11/Mar/14 21:59;jira-bot;Commit 1576519 from [~jpaheath] in branch 'openjpa/branches/2.0.x'
[ https://svn.apache.org/r1576519 ]

OPENJPA-2475: A query with LEFT FETCH JOIN returns incorrect results - merged changes to 2.0.x.","23/Mar/14 02:34;jira-bot;Commit 1580429 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1580429 ]

OPENJPA-2475: A query with LEFT FETCH JOIN returns incorrect results - applied fix to 2.2.1.x","23/Mar/14 02:35;jira-bot;Commit 1580430 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1580430 ]

OPENJPA-2475: A query with LEFT FETCH JOIN returns incorrect results - applied fix to 2.2.x","23/Mar/14 02:36;jira-bot;Commit 1580431 from [~jpaheath] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1580431 ]

OPENJPA-2475: A query with LEFT FETCH JOIN returns incorrect results - applied fix to 2.3.x","23/Mar/14 02:38;jira-bot;Commit 1580432 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1580432 ]

OPENJPA-2475: A query with LEFT FETCH JOIN returns incorrect results - applied fix to trunk.","16/May/14 19:07;jira-bot;Commit 1595308 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1595308 ]

OPENJPA-2475: A query with LEFT FETCH JOIN returns incorrect results",,,,,,,,,,,,,,,,,,
Concurrency issue in ClassMetaData.getPkAndNonPersistentManagedFmdIndexes(),OPENJPA-2472,12689595,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,bentmann,bentmann,17/Jan/14 23:22,23/Nov/18 16:41,14/Mar/19 03:03,22/Jan/16 20:11,2.2.2,2.3.0,,,,,,,2.2.1.1,2.2.3,2.4.0,,,kernel,,,,0,,,,,,,,"In a scenario where brand new entity instances of the same class get inserted concurrently, we noticed sporadic failures like this:

Caused by: <openjpa-2.3.0-r422266:1540826 fatal store error> org.apache.openjpa.persistence.EntityNotFoundException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
	at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2370)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2207)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2105)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:2023)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1528)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:933)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:570)
	... 2 more
Caused by: <openjpa-2.3.0-r422266:1540826 nonfatal store error> org.apache.openjpa.persistence.EntityNotFoundException: The instance of type ""class ..."" with oid ""ec2cfaa9e2f04b628d7e1991e65751dc"" no longer exists in the data store.  This may mean that you deleted the instance in a separate transaction, but this context still has a cached version.
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:3109)
	at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:3188)
	at org.apache.openjpa.kernel.StateManagerImpl.fetchStringField(StateManagerImpl.java:2474)
	at org.apache.openjpa.kernel.StateManagerImpl.fetchString(StateManagerImpl.java:2464)
	at org.apache.openjpa.jdbc.meta.strats.StringFieldStrategy.insert(StringFieldStrategy.java:105)
	at org.apache.openjpa.jdbc.meta.FieldMapping.insert(FieldMapping.java:623)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.insert(AbstractUpdateManager.java:238)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.populateRowManager(AbstractUpdateManager.java:165)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:96)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:77)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:732)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:131)
	... 9 more

The primary ID of each entity is set manually by the app prior to insertion.

Debugging led me to ClassMetaData.getPkAndNonPersistentManagedFmdIndexes() which is called from StateManagerImpl.initialize() to set up the _loaded bit set. When the above exception occurs, all bits in that set are zero. This ultimately caused the erroneous loadField() call that fails the insertion.

The following line in getPkAndNonPersistentManagedFmdIndexes() disturbs the thread-safety:

_pkAndNonPersistentManagedFmdIndexes = new int[idsSize];

Once this has executed, another thread which executes the if (_pkAndNonPersistentManagedFmdIndexes == null) in line 2778 can read the array before the first thread has finished the loop that initializes its values.

The line following ""// Default to FALSE, until proven true."" in hasPKFieldsFromAbstractClass() looks equally troublesome, setting an instance variable to a temp value. Somebody whose more familar with the codebase might want to check for more occurrences of this pattern.",,,,,,,,,,,,,,,,,,,05/Feb/14 21:39;dalia;OPENJPA-2472.txt;https://issues.apache.org/jira/secure/attachment/12627222/OPENJPA-2472.txt,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-02-05 21:39:56.663,,,no_permission,,,,,,,,,,,,368562,,,Tue Nov 10 22:39:05 UTC 2015,,,,,,,0|i1rixb:,368866,,,,,,,,"05/Feb/14 21:39;dalia;I have attached a patch where I solve this issue by using a temporary variable to store the field's data we're interested in and populate it. Then after the temporary variable is finished being populated, the field is assigned to the temporary variable. 
I also attached the tests I used to make sure the problem is solved using this solution. ","05/Feb/14 23:12;jira-bot;Commit 1564989 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1564989 ]

OPENJPA-2472: Fix concurrency bug in ClassMetaData. Patch contributed by Dalia Abo Sheasha.","05/Feb/14 23:14;curtisr7;Committed revision 1564989 to trunk. Thanks for the patch Dalia!

I'll note that I excluded your contributed test as recreating this timing window is very machine dependent. ","10/Nov/15 22:36;jira-bot;Commit 1713741 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1713741 ]

OPENJPA-2472: Fix concurrency bug in ClassMetaData. Patch contributed by Dalia Abo Sheasha - back ported to 2.2.1.x Dalia's trunk changes.","10/Nov/15 22:39;jira-bot;Commit 1713742 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1713742 ]

OPENJPA-2472: Fix concurrency bug in ClassMetaData. Patch contributed by Dalia Abo Sheasha - back ported to 2.2.x Dalia's trunk changes.",,,,,,,,,,,,,,,,,,,,,,
DataCacheManagerImpl infinite loop for checking if classes are cachable,OPENJPA-2470,12688907,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,curtisr7,sebyonthenet,sebyonthenet,15/Jan/14 01:10,12/Oct/15 22:10,14/Mar/19 03:03,12/Oct/15 22:10,2.0.1,2.1.1,2.2.2,,,,,,2.2.3,2.4.0,,,,datacache,,,,0,,,,,,,,"We're integrated openjpa into our latest software delivery and in the last three months we're ran two times into this issue. First time it was not investigated at all, but the last time we've had the chance to grab extra information out of the system.

At that point in time, we've had one of our processes not getting response back from the application that was using openjpa.

All the connection threads were running the same calls:

2014-01-07 07:21:37,716 - INFO  ""ClientConnection - 9"" prio=10 tid=0x00007f33d400e000 nid=0x8d9 runnable [0x00007f32db1ef000]
2014-01-07 07:21:37,716 - INFO     java.lang.Thread.State: RUNNABLE
2014-01-07 07:21:37,716 - INFO  	at java.util.HashMap.getEntry(Unknown Source)
2014-01-07 07:21:37,716 - INFO  	at java.util.HashMap.get(Unknown Source)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.datacache.DataCacheManagerImpl.isCachable(DataCacheManagerImpl.java:145)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.datacache.DataCacheManagerImpl.selectCache(DataCacheManagerImpl.java:128)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.datacache.DataCacheStoreManager.initialize(DataCacheStoreManager.java:358)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:112)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1027)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:985)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:907)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1041)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:280)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2381)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.jdbc.meta.strats.RelationToManyInverseKeyFieldStrategy.loadElement(RelationToManyInverseKeyFieldStrategy.java:90)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.jdbc.meta.strats.RelationCollectionInverseKeyFieldStrategy.loadElement(RelationCollectionInverseKeyFieldStrategy.java:76)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.load(StoreCollectionFieldStrategy.java:558)
2014-01-07 07:21:37,716 - INFO  	at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:934)
2014-01-07 07:21:37,717 - INFO  	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:702)
2014-01-07 07:21:37,717 - INFO  	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:117)
2014-01-07 07:21:37,717 - INFO  	at org.apache.openjpa.datacache.DataCacheStoreManager.load(DataCacheStoreManager.java:461)
2014-01-07 07:21:37,717 - INFO  	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:117)
2014-01-07 07:21:37,717 - INFO  	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
2014-01-07 07:21:37,717 - INFO  	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:3061)
2014-01-07 07:21:37,717 - INFO  	at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:3136)
2014-01-07 07:21:37,717 - INFO  	at org.apache.openjpa.kernel.StateManagerImpl.beforeAccessField(StateManagerImpl.java:1606)
2014-01-07 07:21:37,717 - INFO  	at org.apache.openjpa.kernel.StateManagerImpl.accessingField(StateManagerImpl.java:1591)
....


We've narrowed this down to the fact that a HashMap is used in the org.apache.openjpa.datacache.DataCacheManagerImpl to globally serv our all the threads. So multiple threads can add and get information from the _cacheable at the same time.

HashMaps are not thread safe and can get corrupted with eating the entire CPU. The problem is better described here (but you can find it in a lot of places):
http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html

I could not find this bug logged yet and I'm surprised that nobody has ran into this yet. 

Our plan for now is to just switch to ConcurrentHashMap instantiation for the _cacheable Map.
",linux 64,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-01-15 21:44:20.586,,,no_permission,,,,,,,,,,,,367874,,,Mon Aug 17 23:58:03 UTC 2015,,,,,,,0|i1reqf:,368181,,,,,,,,15/Jan/14 21:44;curtisr7;I'm also surprised that no one else has encountered this same problem. I'll try to get a fix committed today for this one.,"15/Jan/14 22:34;jira-bot;Commit 1558594 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1558594 ]

OPENJPA-2470 : Update DataCacheManagerImpl to use a ConcurrentHashMap rather than a HashMap.","15/Jan/14 22:37;curtisr7;I committed a code change to trunk for this issue. I also created a unit test to expose the reported problem, but I don't think I'm going to commit it as it is quite machine / hardware dependent and I can't see someone actually regressing this behavior. 

This JIRA does expose a larger issue that might exist in other parts of the code base. I'm going to take a couple hours tomorrow to dig around to see if any other areas jump out at me. ",15/Jan/14 22:46;sebyonthenet;Thank you Ric for the quick reaction on this ticket. Would it be possible you can let me know if it's planned to include this change in 2.2.x in the near future or we'll have to wait for 2.4?,16/Jan/14 02:49;curtisr7;I'll check with the owner of the 2.2.x branch to see his thoughts on getting it committed to there.,"01/May/14 16:25;sebyonthenet;Could you please let me know if you found other places that required a similar fix? I see no other changes besides the DCMI class tight to this ticket. Thanks
",01/May/14 16:56;curtisr7;I didn't find any other areas of the code that require a similar fix.,"17/Aug/15 23:58;jira-bot;Commit 1696353 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1696353 ]

OPENJPA-2470: Update DataCacheManagerImpl to use a ConcurrentHashMap rather than a HashMap - backported to 2.2.x Rick Curtis' changes from trunk.",,,,,,,,,,,,,,,,,,,
No setter was found for method like tStart,OPENJPA-2467,12685900,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,daniele.pirola@icteam.it,daniele.pirola@icteam.it,20/Dec/13 21:52,06/Jun/15 14:25,14/Mar/19 03:03,05/Feb/14 21:19,2.2.2,,,,,,,,2.4.0,,,,,jpa,,,,0,,,,,,,,"Suppose having an entity class with fields like tStart, tEnd, tModify (with second letter in upper case). The corresponding getter and setter are gettStart and settStart, gettEnd, ... and not getTStart or setTStart.

Inside class PersistenceMetaDataDefaults use of StringUtils.capitalize in method isDefaultPersistent generate the mistake.

Look at this pdf, section 8.8
http://download.oracle.com/otn-pub/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/beans.101.pdf",,,,,,,,,,,,,,,,,,,31/Jan/14 21:58;dalia;OPENJPA-2467.txt;https://issues.apache.org/jira/secure/attachment/12626387/OPENJPA-2467.txt,30/Jan/14 15:53;dalia;OPENJPA-2467.txt;https://issues.apache.org/jira/secure/attachment/12626115/OPENJPA-2467.txt,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2014-01-06 19:06:03.272,,,no_permission,,,,,,,,,,,,364842,,,Wed Feb 05 21:19:00 UTC 2014,,,,,,,0|i1qvwf:,365142,,,,,,,,"06/Jan/14 19:06;curtisr7;Since the first two characters of tStart, tEnd, etc are not capitalized, the convention(per section 8.8) is to capitalize the first character of the property name. 

getTStart, getTEnd, etc is correct. Please reopen this JIRA with additional data if you disagree.","06/Jan/14 21:13;daniele.pirola@icteam.it;Specs at section 8.8 start explanation from getter and setter so the first two characters are the characters of the method, not of the property. In fact in the example there is ""FooBah becomes fooBah"" and not ""fooBah becomes FooBah"". Please see the code of method Introspector.decapitalize for a correct implementation of the rule.
Please see also https://hibernate.atlassian.net/browse/HHH-8716 
this is another issue for the same problem ","07/Jan/14 00:09;ayl2;Daniele,

I believe you are misinterpreting the bean spec. As it says prior to the section that you referenced, ""...Thus when we extract a property or event name from the middle of an existing Java name, we normally convert the first character to lower case."" The situation that they are referring to is the one where they are trying to generate a field name FROM a getter name. This is the opposite of the situation that you are describing. 

If this is not clear please see also section 8.3.1 of the bean spec. where you will see a case of property name inference. 

-Aron","07/Jan/14 08:18;daniele.pirola@icteam.it;This is a very common mistake I found many times in many java library and also in earliest version of IDE like Eclipse or IntelliJ.
Please read this 
http://stackoverflow.com/questions/2948083/naming-convention-for-getters-setters-in-java
or this
http://dertompson.com/2013/04/29/java-bean-getterssetters/

The spec are not so clear but please fix this bug. Also try to use BeanInfo introspector classes to find the correct property from a getter and viceversa, you will find that the correct setter for property like tStart is gettStart, also try in a JSF page
 ",07/Jan/14 14:53;curtisr7;After looking at it again this is an edge case that we (and many others) missed.,"07/Jan/14 15:01;daniele.pirola@icteam.it;yes I undestand, for me it's usual because we have database field like T_START or K_PRODUCT that we convert into tStart and kProduct java property","30/Jan/14 15:53;dalia;I have attached a patch that includes my fix to this issue. FieldMetaData now handles generating the correct setter name for any case where the second letter of the variable is capitalized. Otherwise, the old behavior is observed. I also added code to look for getters that use the correct naming convention.
To test the changes, I created two entities. One uses the correct naming convention where a variable named tStart would have the corresponding gettStart(). The other entity uses the old wrong way of naming where tStart would have the corresponding getTStart() method. The second entity is there to make sure the old behavior is still supported. ","30/Jan/14 17:12;kwsutter;Thanks, Dalia.  A couple of suggestions...  In the code where you explain that we're now looking for both getaStart and getAStart, could you include the JavaBeans section as a reference?  Down the road, if somebody looks at this code, they are going to wonder why this ""exception"" was put in place.  Also, the text above made me think about another scenario...  What happens if the attribute is named a_Start? That is, the second character is not an alphabetic character?  Does the JavaBean spec outline this behavior?  And, how would we respond?  Other than that, this looks like a good patch.  We're fixing this edge case, but leaving the current behavior.

On a related note...  What happens when we generate Entity classes?  If we read an attribute from the database named aStart, which getter/setter methods get generated?  Is this a completely separate code path and, thus, your code changes don't affect that processing?  Or, are they related and now we're (accidentally) changing how the Entity classes are getting generated?","31/Jan/14 21:58;dalia;Thank you for the suggestions, Kevin. I have attached a new patch that includes the line referring to the section of the JavaBeans section that should be explaining the naming convention. 

According to my understanding, the scenario where the field name is a_Start should yield the getter name getA_Start(). To double check, I generated the getter/setter in Eclipse and that's what gets generated by default (granted Eclipse isn't always correct). In the JUnit test, I indirectly test this by having a letter then a number. 

I am glad you pointed out the ReverseMappingTool. I went in and made a minor change in the CodeGenerator class so that the getters and setters follow the correct naming convention. I ran the tool and it generated the classes correctly. ","03/Feb/14 20:52;kwsutter;I'm good with your latest patch, Dalia.  Since I know you are working with Rick, I'll let him take care of committing on your behalf.  Thanks.","05/Feb/14 21:18;jira-bot;Commit 1564931 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1564931 ]

OPENJPA-2467: Fix detection of property access method names. Patch contributed by Dalia Abo Sheasha.",05/Feb/14 21:19;curtisr7;Committed revision 1564931 to trunk. Thanks for the patch Dalia!,,,,,,,,,,,,,,,
Wrong logging level on message issued by the fix to OPENJPA-2233,OPENJPA-2463,12682710,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,curtisr7,monoman,monoman,04/Dec/13 15:53,21/Sep/16 14:38,14/Mar/19 03:03,17/Dec/13 02:44,2.0.1,2.1.2,2.2.1.1,2.2.2,,,,,2.4.0,,,,,Enhance,,,,0,error-feedback,,,,,,,"Patch for issue OPENJPA-2233 introduced a message when a Embeddable entity defines an ID property, which the Enhancer can't properly add a helper method (getIDOwningClass).

--- openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java	(revision 1325823)
+++ openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java	(working copy)
@@ -1150,6 +1150,11 @@
             if (_meta.hasAbstractPKField() == true) { 
                 addGetIDOwningClass();
             }
+            
+        	if (_meta.isEmbeddedOnly() 
+            		&& _meta.getIdentityType() == ClassMetaData.ID_APPLICATION) {
+            	_log.error(_loc.get(""ID-field-in-embeddable-unsupported"", _meta.toString()));
+            }
             addNewObjectIdInstanceMethod(true);
             addNewObjectIdInstanceMethod(false);

The problem is that this message is also emitted when inheriting from a MappedSuperClass, containing an Id field/property, which is a very common pattern. 

As the persistence engine of OpenJPA works perfectly with such a class hierarchy (and even the Enhancer with the complement of that patch just skips adding a call to the non-added helper method), it is pointless to alarm operations personnel with a message labeled and tagged as an error.

Therefore I suggest to log it as a warning, also editing the corresponding message text to better indicate that the Enhancer will simply not add/call the helper method, skipping a potential optimization.",OpenJPA as bundled on WebSphere 8.5.5,,,,,,,,,,,,,OPENJPA-2478,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-12-17 02:43:24.132,,,no_permission,,,,,,,,,,,,361967,,,Tue Dec 17 02:45:19 UTC 2013,,,,,,,0|i1qe7z:,362262,,,,,,,,04/Dec/13 16:01;monoman;Patch for 2233 introduced this problem.,"17/Dec/13 02:43;jira-bot;Commit 1551449 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1551449 ]

OPENJPA-2463 : Change message from error to warning.",17/Dec/13 02:45;curtisr7;Committed a change to trunk that changes the message from error to warning.,,,,,,,,,,,,,,,,,,,,,,,,
Fresh checkout from svn won't compile tests due to OutOfMemoryError: Java heap space,OPENJPA-2456,12679798,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,jzwolak,jzwolak,18/Nov/13 19:32,06/Jun/15 14:25,14/Mar/19 03:03,18/Nov/13 21:02,,,,,,,,,2.4.0,,,,,build / infrastructure,,,,0,,,,,,,,"On a Mac with the above environment, run

> svn checkout http://svn.apache.org/repos/asf/openjpa/trunk openjpa
> cd openjpa
> mvn clean install

And the result is:

[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:2.3.2:testCompile (test-source-compile) on project openjpa-persistence-jdbc: Compilation failure
[ERROR] Failure executing javac, but could not parse the error:
[ERROR] 
[ERROR] 
[ERROR] The system is out of resources.
[ERROR] Consult the following stack trace for details.
[ERROR] java.lang.OutOfMemoryError: Java heap space
[ERROR] at java.util.HashMap.addEntry(HashMap.java:753)
[ERROR] at java.util.HashMap.put(HashMap.java:385)
[ERROR] at java.util.HashSet.add(HashSet.java:200)
[ERROR] at com.sun.tools.javac.comp.Resolve.findMethod(Resolve.java:748)
[ERROR] at com.sun.tools.javac.comp.Resolve.findMethod(Resolve.java:772)
[ERROR] at com.sun.tools.javac.comp.Resolve.findMethod(Resolve.java:720)
[ERROR] at com.sun.tools.javac.comp.Resolve.resolveQualifiedMethod(Resolve.java:1229)
[ERROR] at com.sun.tools.javac.comp.Annotate.enterAnnotation(Annotate.java:156)
[ERROR] at com.sun.tools.javac.comp.Annotate.enterAttributeValue(Annotate.java:205)
[ERROR] at com.sun.tools.javac.comp.Annotate.enterAttributeValue(Annotate.java:219)
[ERROR] at com.sun.tools.javac.comp.Annotate.enterAnnotation(Annotate.java:167)
[ERROR] at com.sun.tools.javac.comp.Annotate.enterAttributeValue(Annotate.java:205)
[ERROR] at com.sun.tools.javac.comp.Annotate.enterAttributeValue(Annotate.java:219)
[ERROR] at com.sun.tools.javac.comp.Annotate.enterAnnotation(Annotate.java:167)
[ERROR] at com.sun.tools.javac.comp.MemberEnter.enterAnnotations(MemberEnter.java:743)
[ERROR] at com.sun.tools.javac.comp.MemberEnter.access$300(MemberEnter.java:42)
[ERROR] at com.sun.tools.javac.comp.MemberEnter$5.enterAnnotation(MemberEnter.java:711)
[ERROR] at com.sun.tools.javac.comp.Annotate.flush(Annotate.java:95)
[ERROR] at com.sun.tools.javac.comp.Annotate.enterDone(Annotate.java:87)
[ERROR] at com.sun.tools.javac.comp.Enter.complete(Enter.java:485)
[ERROR] at com.sun.tools.javac.comp.Enter.main(Enter.java:442)
[ERROR] at com.sun.tools.javac.main.JavaCompiler.enterTrees(JavaCompiler.java:822)
[ERROR] at com.sun.tools.javac.main.JavaCompiler.compile(JavaCompiler.java:727)
[ERROR] at com.sun.tools.javac.main.Main.compile(Main.java:353)
[ERROR] at com.sun.tools.javac.main.Main.compile(Main.java:279)
[ERROR] at com.sun.tools.javac.main.Main.compile(Main.java:270)
[ERROR] at com.sun.tools.javac.Main.compile(Main.java:87)
[ERROR] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[ERROR] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
[ERROR] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
[ERROR] at java.lang.reflect.Method.invoke(Method.java:597)
[ERROR] at org.codehaus.plexus.compiler.javac.JavacCompiler.compileInProcess(JavacCompiler.java:554)
","Mac OS/X 10.9
HomeBrew was used to install Maven.
Java 1.7 and 1.6 (I'm not sure which one Maven is using, but on the command line ""java -version"" gives 1.7 64-bit)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-11-18 20:02:13.091,,,no_permission,,,,,,,,,,,,359156,,,Mon Nov 18 21:02:40 UTC 2013,,,,,,,0|i1pwyv:,359455,,,,,,,,"18/Nov/13 19:35;jzwolak;A work around to this is to set the maven options with:

export MAVEN_OPTS=""-Xmx512m""","18/Nov/13 20:02;kwsutter;It looks like my default setting is this:  MAVEN_OPTS=-Xmx1024m

We should update http://openjpa.apache.org/building.html with this requirement.","18/Nov/13 21:02;allee8285;building.html updated to:

Author: buildbot
Date: Mon Nov 18 20:58:40 2013
New Revision: 887135

Log:
Staging update by buildbot for openjpa

Modified:
    websites/staging/openjpa/trunk/content/   (props changed)
    websites/staging/openjpa/trunk/content/building.html

Propchange: websites/staging/openjpa/trunk/content/
------------------------------------------------------------------------------
--- cms:source-revision (original)
+++ cms:source-revision Mon Nov 18 20:58:40 2013
@@ -1 +1 @@
-1536901
+1543150

Modified: websites/staging/openjpa/trunk/content/building.html
==============================================================================
--- websites/staging/openjpa/trunk/content/building.html (original)
+++ websites/staging/openjpa/trunk/content/building.html Mon Nov 18 20:58:40 2013
@@ -200,10 +200,16 @@ console, and are known to work on Linux,
 <ol>
 <li>Ensure that you have Java installed and in your path by running: <code>java
 -fullversion</code></li>
-<li>Install the build tool, Apache Maven 2.2.1 or later, from
+<li>
+<p>Set following maven options to avoid out of memory error:</p>
+<p>set MAVEN_OPTS=""-XX:MaxPermSize=128m -Xms512m -Xmx1024m""</p>
+</li>
+<li>
+<p>Install the build tool, Apache Maven 2.2.1 or later, from
 <a href=""http://maven.apache.org/"">http://maven.apache.org/</a>. If it is installed correctly, typing <em>mvn -v</em>
 from the console will result in text like <code>Apache Maven 2.2.1 (r801777;
-2009-08-06 21:16:01+0200)</code></li>
+2009-08-06 21:16:01+0200)</code></p>
+</li>
 <li>Install Subversion v1.4.x or newer from <a href=""http://subversion.apache.org/"">http://subversion.apache.org/</a>.
 If it is installed correctly, typing the following command should output
 help information: <strong>svn help</strong> or <strong>svn --version</strong></li>",,,,,,,,,,,,,,,,,,,,,,,,
ReverseMappingTool creates orm.xml files in the current working directory,OPENJPA-2444,12675569,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,struberg,struberg,24/Oct/13 21:30,06/Jun/15 14:25,14/Mar/19 03:03,25/Oct/13 13:57,2.3.0,,,,,,,,2.3.0,2.4.0,,,,kernel,,,,0,,,,,,,,"when running TestUseSchemaElement a file 'orm.xml' remains as left over and breaks the follow up tests. This happens because the MetaDataFactory creates a new File(""orm.xml"") without any base path if there is no orm.xml already on the classpath.

It should actually use the base directory handed over to the mapping tool.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-10-24 21:31:59.44,,,no_permission,,,,,,,,,,,,355146,,,Mon Oct 28 18:10:54 UTC 2013,,,,,,,0|i1p85z:,355434,,,,,,,,"24/Oct/13 21:31;jira-bot;Commit 1535560 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1535560 ]

OPENJPA-2444 fix default orm.xml location for ReverseMappingTool

I also fixed the badly formatted and partly broken TestUseSchemaElement.","25/Oct/13 07:13;jira-bot;Commit 1535648 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1535648 ]

OPENJPA-2444 fix default orm.xml location for ReverseMappingTool

I also fixed the badly formatted and partly broken TestUseSchemaElement.","25/Oct/13 09:35;jira-bot;Commit 1535665 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1535665 ]

OPENJPA-2444 also use target folder in the test itself","25/Oct/13 11:20;jira-bot;Commit 1535692 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1535692 ]

OPENJPA-2444 also use target folder in the test itself","28/Oct/13 18:01;jira-bot;Commit 1536455 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1536455 ]

OPENJPA-2444 move the cleanup after freeing the InputStream

Win* blocks the whole file as long as the InputStream is not closed.
Thus we can only delete the file afterwards.","28/Oct/13 18:10;jira-bot;Commit 1536462 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1536462 ]

OPENJPA-2444 move the cleanup after freeing the InputStream

Win* blocks the whole file as long as the InputStream is not closed.
Thus we can only delete the file afterwards.",,,,,,,,,,,,,,,,,,,,,
InvalidStateException while merging a new Entity with a GeneratedValue id,OPENJPA-2443,12675132,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,22/Oct/13 21:28,06/Jun/15 14:25,14/Mar/19 03:03,24/Oct/13 13:43,2.3.0,2.4.0,,,,,,,2.3.0,2.4.0,,,,kernel,,,,1,,,,,,,,"This problem only happens if you have an Entity with a Generated id that also has the annotation @Basic(optional = false). If you create a new Entity and then try to persist it via EntityManager.merge(...) call, you'll get the following stack :

<openjpa-0.0.0-rnull fatal user error> org.apache.openjpa.persistence.InvalidStateException: The field ""id"" of instance ""org.apache.openjpa.persistence.jdbc.auto.AutoIncrementEntity@99883308"" contained a null value; the metadata for this field specifies that nulls are illegal.
	at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:567)
	at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:511)
	at org.apache.openjpa.kernel.StateManagerImpl.preFlush(StateManagerImpl.java:3019)
	at org.apache.openjpa.kernel.PNewState.beforeFlush(PNewState.java:44)
	at org.apache.openjpa.kernel.StateManagerImpl.beforeFlush(StateManagerImpl.java:1035)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2141)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2101)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1872)
	at org.apache.openjpa.kernel.DelegatingBroker.flush(DelegatingBroker.java:1045)
	at org.apache.openjpa.persistence.EntityManagerImpl.flush(EntityManagerImpl.java:663)",,,,,,,,,,,,,,,,,,,22/Oct/13 22:19;curtisr7;OPENJPA-2443.patch;https://issues.apache.org/jira/secure/attachment/12609738/OPENJPA-2443.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-10-23 15:58:47.998,,,no_permission,,,,,,,,,,,,354752,,,Thu Oct 24 13:43:16 UTC 2013,,,,,,,0|i1p5qn:,355041,,,,,,,,"22/Oct/13 22:19;curtisr7;Attaching a unit test and a test-fix.

The net of this change is that in pre-flush, don't check to see if a field is null if  is a GenerationType.IDENTITY field as the value will get populated later in the flush processing.","23/Oct/13 15:58;jira-bot;Commit 1535067 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1535067 ]

OPENJPA-2443 : Fix SingleFieldManager to not check for null values for IDENTITY generated fields when flushing.","23/Oct/13 17:58;jira-bot;Commit 1535082 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1535082 ]

OPENJPA-2443 : Remove unnecessary import.","23/Oct/13 23:05;struberg;Rick, if you like then you might also apply this to the 2.3.x branch. Seems save for me to do so.","24/Oct/13 13:42;jira-bot;Commit 1535379 from [~curtisr7] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1535379 ]

OPENJPA-2443 : Fix SingleFieldManager to not check for null values for IDENTITY generated fields when flushing.",24/Oct/13 13:43;curtisr7;I merged the changes back to 2.3.x.,,,,,,,,,,,,,,,,,,,,,
java.lang.VerifyError in TestProxyManager when loading a dynamically created custom proxy class on Oracle Java 8,OPENJPA-2442,12674871,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,curtisr7,curtisr7,21/Oct/13 18:59,06/Jun/15 14:24,14/Mar/19 03:03,11/Apr/14 13:33,2.4.0,,,,,,,,2.4.0,,,,,kernel,,,,0,,,,,,,,"While testing with Java 8 I encountered the following error noted below[1]. I'm opening this JIRA as I want to get all known issues documented.

[1]
<openjpa-2.3.0-SNAPSHOT-r422266:1532833M nonfatal general error> org.apache.openjpa.util.GeneralException: org.apache.openjpa.util.java$util$TreeMap$6$proxy
	at org.apache.openjpa.util.GeneratedClasses.loadBCClass(GeneratedClasses.java:71)
	at org.apache.openjpa.util.ProxyManagerImpl.getFactoryProxyMap(ProxyManagerImpl.java:407)
	at org.apache.openjpa.util.ProxyManagerImpl.copyMap(ProxyManagerImpl.java:222)
	at org.apache.openjpa.util.TestProxyManager.testCopySortedMaps(TestProxyManager.java:421)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:491)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
Caused by: java.lang.VerifyError: (class: org/apache/openjpa/util/java$util$TreeMap$6$proxy, method: remove signature: (Ljava/lang/Object;Ljava/lang/Object;)Z) Expecting to find integer on stack
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:339)
	at org.apache.openjpa.util.GeneratedClasses.loadBCClass(GeneratedClasses.java:67)
	... 21 more",">java -version
java version ""1.8.0-ea""
Java(TM) SE Runtime Environment (build 1.8.0-ea-b109)
Java HotSpot(TM) 64-Bit Server VM (build 25.0-b51, mixed mode)",,,,,,,,,OPENJPA-2386,,,,OPENJPA-2487,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-04-10 19:35:58.638,,,no_permission,,,,,,,,,,,,354493,,,Mon Nov 24 21:43:19 UTC 2014,,,,,,,0|i1p45b:,354783,,,,,,,,"21/Oct/13 19:29;curtisr7;This same-ish error is encountered many, many(100+) times when running through the tests in openjpa-persistence-jdbc. ","10/Apr/14 19:35;kwsutter;Looked at the failing tests in openjpa-kernel. Built OpenJPA with Java 7, then attempted to run the openjpa-kernel tests with Java 8 runtime.  I get 3 errors.  They are related to the dynamic custom proxies generated for Map attributes in an Entity.  The errors are due to the fact that OpenJPA does not properly recognize the new remove(key. value) method on the Map interface.  Actually, it does sort of recognize it due to the ConcurrentHashMap interface, but the existence of this remove(key, value) method just confuses our proxy generation.  I don't have a complete answer yet, but I thought I would post what I have found out so that we don't have to start over the next time...

From the call stack of one of the failures:

testCopyMaps(org.apache.openjpa.util.TestProxyManager)  Time elapsed: 0.012 sec <<< ERROR!
<openjpa-2.4.0-SNAPSHOT-r422266:1580972M nonfatal general error> org.apache.openjpa.util.GeneralException: org.apache.openjpa.util.org$apache$openjpa$util$TestProxyManager$CustomMap$9$proxy
        at org.apache.openjpa.util.GeneratedClasses.loadBCClass(GeneratedClasses.java:72)

You can follow the code path and see that we are attempting to generate the bytecodes right when we're trying to load the class.  Eventually, we get to this portion of the code in ProxyManagerImpl.generateProxyMapBytecode():

        Class<? extends ProxyMaps> mapProxyClassType =
            ConcurrentMap.class.isAssignableFrom(type) ? ProxyConcurrentMaps.class : ProxyMaps.class;
        proxyRecognizedMethods(bc, type, mapProxyClassType, ProxyMap.class);

This is where things go awry...  Since a standard Map now supports a remove(key, value) method, we end up matching up with ProxyMaps instead of ProxyConcurrentMaps, which then generates some strange code (from the javap output):

  public boolean remove(java.lang.Object, java.lang.Object);
    descriptor: (Ljava/lang/Object;Ljava/lang/Object;)Z
    flags: ACC_PUBLIC
    Code:
      stack=4, locals=4, args_size=3
         0: aload_0       
         1: aload_1       
         2: aload_2       
         3: invokespecial #132                // Method org/apache/openjpa/util/TestProxyManager$CustomMap.remove:(Ljava/lang/Object;Ljava/lang/Object;)Z
         6: istore_3      
         7: aload_0       
         8: aload_1       
         9: aload_2       
        10: iload_3       
        11: invokestatic  #101                // Method org/apache/openjpa/util/ProxyMaps.afterRemove:(Lorg/apache/openjpa/util/ProxyMap;Ljava/lang/Object;Ljava/lang/Object;Z)Ljava/lang/Object;
        14: ireturn       

There is no matching beforeRemove() method invoked -- which should be a standard practice of having matching before/after calls.  And, the afterRemove() method that is invoked on ProxyMaps really doesn't match the expected processing of the remove(key, value) method.  Looking at our code a bit, it looks like the use of the ProxyConcurrentMaps interface would have been a better match.  At least the remove(key, value) method is already recognized...

Anyway, that's what I have so far.  I don't know if this is simply a matter of including processing for remove(key, value) in ProxyMaps, or if there's something more involved than that.  Need more time to experiment and I have run out of that for the time being...  :-)  Good luck to the next player.
","10/Apr/14 20:45;kwsutter;Okay, I couldn't resist...  I tried a quick hack and am making tremendous progress.  Since it looked like our ProxyConcurrentMaps interface was a close match, I decided to just force the use of that.  Since it extends ProxyMaps and it provides the remove(key, value) method, I figured it was a close match.

//        Class<? extends ProxyMaps> mapProxyClassType =
//            ConcurrentMap.class.isAssignableFrom(type) ? ProxyConcurrentMaps.class : ProxyMaps.class;
        Class<? extends ProxyMaps> mapProxyClassType = ProxyConcurrentMaps.class;  // KWS
        proxyRecognizedMethods(bc, type, mapProxyClassType, ProxyMap.class);

With that change, all of the tests in openjpa-kernel now succeed with Java 8.  Here's the updated bytecodes for the remove(key, value) method.  They look much, much better with a matching before/after methods and proper processing of the return boolean value:

  public boolean remove(java.lang.Object, java.lang.Object);
    descriptor: (Ljava/lang/Object;Ljava/lang/Object;)Z
    flags: ACC_PUBLIC
    Code:
      stack=5, locals=5, args_size=3
         0: aload_0       
         1: aload_1       
         2: aload_2       
         3: invokestatic  #134                // Method org/apache/openjpa/util/ProxyConcurrentMaps.beforeRemove:(Lorg/apache/openjpa/util/ProxyMap;Ljava/lang/Object;Ljava/lang/Object;)Z
         6: istore_3      
         7: aload_0       
         8: aload_1       
         9: aload_2       
        10: invokespecial #136                // Method org/apache/openjpa/util/TestProxyManager$CustomMap.remove:(Ljava/lang/Object;Ljava/lang/Object;)Z
        13: istore        4
        15: aload_0       
        16: aload_1       
        17: aload_2       
        18: iload         4
        20: iload_3       
        21: invokestatic  #139                // Method org/apache/openjpa/util/ProxyConcurrentMaps.afterRemove:(Lorg/apache/openjpa/util/ProxyMap;Ljava/lang/Object;Ljava/lang/Object;ZZ)Z
        24: ireturn       

I'll do some more testing with this change, but so far it's looking pretty good...
","11/Apr/14 13:33;jira-bot;Commit 1586651 from kwsutter@apache.org in branch 'openjpa/trunk'
[ https://svn.apache.org/r1586651 ]

OPENJPA-2442.  Just using ProxyConcurrentMaps for proxying the Map methods.  Since this extends ProxyMaps anyway, this is pretty safe change.  This change resolves the TestProxyManager errors in openjpa-kernel when testing with Java 8 runtime.  And, it doesn't affect Java 7 runtime at all.  Refer to the Comments section for more details.","24/Nov/14 21:43;jira-bot;Commit 1641483 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1641483 ]

OPENJPA-2442: java.lang.VerifyError in TestProxyManager when loading a dynamically created custom proxy class on Oracle Java 8 [JDK8]",,,,,,,,,,,,,,,,,,,,,,
TestNullSafeConcurrentHashMap fails when running on Oracle Java 8 ,OPENJPA-2441,12674821,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,21/Oct/13 16:08,06/Jun/15 14:25,14/Mar/19 03:03,20/Feb/14 16:34,2.4.0,,,,,,,,2.4.0,,,,,lib,,,,0,,,,,,,,"While testing with Java 8 I found that org.apache.openjpa.lib.util.concurrent.NullSafeConcurrentHashMap doesn't work on Oracle Java 8 as java.util.ConcurrentHashMap was completely rewritten and it doesn't like playing with our extension. 

I'm not sure what the correct solution for this JIRA will be, but I wanted to get it documented. I did a small amount of searching and it appears that NullSafeConcurrentHashMap isn't used very much in our code base so it might be easiest to remove those references and deprecate the data structure. That being said, we'll still need to fix this data structure as it is possible that a user of OpenJPA pulled this structure into app code.",">java -version
java version ""1.8.0-ea""
Java(TM) SE Runtime Environment (build 1.8.0-ea-b109)
Java HotSpot(TM) 64-Bit Server VM (build 25.0-b51, mixed mode)",,,,,,,,,OPENJPA-2386,,,,,,,,,18/Feb/14 15:02;dalia;2441.patch;https://issues.apache.org/jira/secure/attachment/12629539/2441.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-02-18 15:02:50.435,,,no_permission,,,,,,,,,,,,354443,,,Mon Nov 24 20:51:34 UTC 2014,,,,,,,0|i1p3u7:,354733,,,,,,,,"18/Feb/14 15:02;dalia;I have attached a patch where NullSafeConcurrentHashMap is deprecated as well as SizedConcurrentHashMap since it extends NullSafeConcurrentHashMap. Naturally, the tests corresponding to both classes were removed. Any usage of the SizedConcurrentHashMap data structure was replaced by a ConcurrentReferenceHashMap which supports setting a maximum size for the map. Usage of NullSafeConcurrentHashMap was replaced by ConcurrentHashMap. Since this change required replacing some operations, I added some tests to make sure the logic for the method using NullSafeConcurrentHashMap is still working as intended. ","20/Feb/14 16:33;jira-bot;Commit 1570261 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1570261 ]

OPENJPA-2441: Remove usage of NullSafeConcurrentHashMap. Patch contributed by Dalia Abo Sheasha.","20/Feb/14 16:34;curtisr7;Committed revision 1570261 to trunk.

Thanks for the patch Dalia!","09/Oct/14 10:52;puntogil;hi,
used:
OpenJDK version ""1.8.0_11""
OpenJDK Runtime Environment (build 1.8.0_11-b12)
OpenJDK Zero VM (build 25.11-b02, interpreted mode)

applied the patch for java 8 problems, but now i have still this problem:

[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project openjpa-persistence: Compilation failure: Compilation failure:
[ERROR] /builddir/build/BUILD/apache-openjpa-2.2.2-source/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceXMLMetaDataParser.java:[164,64] cannot find symbol
[ERROR] symbol:   method booleanValue()
[ERROR] location: class java.lang.Object
[ERROR] /builddir/build/BUILD/apache-openjpa-2.2.2-source/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceXMLMetaDataParser.java:[167,43] cannot find symbol
[ERROR] symbol:   method booleanValue()
[ERROR] location: class java.lang.Object
[ERROR] /builddir/build/BUILD/apache-openjpa-2.2.2-source/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceXMLMetaDataParser.java:[217,13] cannot find symbol
[ERROR] symbol:   method booleanValue()
[ERROR] location: class java.lang.Object
[ERROR] /builddir/build/BUILD/apache-openjpa-2.2.2-source/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceXMLMetaDataParser.java:[239,44] cannot find symbol
[ERROR] symbol:   method booleanValue()
[ERROR] location: class java.lang.Object
[ERROR] -> [Help 1] 

thanks in advance","24/Nov/14 20:51;jira-bot;Commit 1641472 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1641472 ]

OPENJPA-2441: Remove usage of NullSafeConcurrentHashMap. [JDK8]",,,,,,,,,,,,,,,,,,,,,,
foreign key drop leaks jdbc connections,OPENJPA-2440,12674126,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,romain.manni-bucau,romain.manni-bucau,16/Oct/13 13:53,06/Jun/15 21:19,14/Mar/19 03:03,18/Oct/13 21:28,2.3.0,,,,,,,,2.3.0,,,,,,,,,0,,,,,,,,"Hi some connections are not closed when dropping fk, here is a proposed patch:

Index: openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java
===================================================================
--- openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java	(revision 1531344)
+++ openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java	(working copy)
@@ -18,6 +18,23 @@
  */
 package org.apache.openjpa.jdbc.schema;
 
+import org.apache.commons.lang.StringUtils;
+import org.apache.openjpa.conf.OpenJPAConfiguration;
+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;
+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;
+import org.apache.openjpa.jdbc.identifier.DBIdentifier;
+import org.apache.openjpa.jdbc.sql.DBDictionary;
+import org.apache.openjpa.jdbc.sql.SQLExceptions;
+import org.apache.openjpa.lib.conf.Configurations;
+import org.apache.openjpa.lib.jdbc.DelegatingDataSource;
+import org.apache.openjpa.lib.log.Log;
+import org.apache.openjpa.lib.meta.MetaDataSerializer;
+import org.apache.openjpa.lib.util.Files;
+import org.apache.openjpa.lib.util.Localizer;
+import org.apache.openjpa.lib.util.Options;
+import org.apache.openjpa.util.InvalidStateException;
+
+import javax.sql.DataSource;
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -33,24 +50,7 @@
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.Set;
-import javax.sql.DataSource;
 
-import org.apache.commons.lang.StringUtils;
-import org.apache.openjpa.conf.OpenJPAConfiguration;
-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;
-import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;
-import org.apache.openjpa.jdbc.identifier.DBIdentifier;
-import org.apache.openjpa.jdbc.sql.DBDictionary;
-import org.apache.openjpa.jdbc.sql.SQLExceptions;
-import org.apache.openjpa.lib.conf.Configurations;
-import org.apache.openjpa.lib.jdbc.DelegatingDataSource;
-import org.apache.openjpa.lib.log.Log;
-import org.apache.openjpa.lib.meta.MetaDataSerializer;
-import org.apache.openjpa.lib.util.Files;
-import org.apache.openjpa.lib.util.Localizer;
-import org.apache.openjpa.lib.util.Options;
-import org.apache.openjpa.util.InvalidStateException;
-
 /**
  * The SchemaTool is used to manage the database schema. Note that the
  * tool never adds or drops unique constraints from existing tables, because
@@ -1099,7 +1099,12 @@
      */
     public boolean dropForeignKey(ForeignKey fk)
         throws SQLException {
-        return executeSQL(_dict.getDropForeignKeySQL(fk,_ds.getConnection()));
+        final Connection connection = _ds.getConnection();
+        try {
+            return executeSQL(_dict.getDropForeignKeySQL(fk, connection));
+        } finally {
+            connection.close();
+        }
     }
 
     /**
",,,,,,,,,,,,,,,,,,,18/Oct/13 17:50;struberg;OPENJPA-2440.patch;https://issues.apache.org/jira/secure/attachment/12609176/OPENJPA-2440.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-10-18 17:04:00.111,,,no_permission,,,,,,,,,,,,353749,,,Fri Oct 18 21:28:58 UTC 2013,,,,,,,0|i1ozmn:,354041,,,,,,,,18/Oct/13 17:04;struberg;Actually I've found that our SchemaTool source is full with NOT freeing up our connections properly it seems.,18/Oct/13 17:50;struberg;patch against 2.3.x. Please review! Like to commit this tonight...,"18/Oct/13 21:25;jira-bot;Commit 1533640 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1533640 ]

OPENJPA-2440 close connection after not using it anymore

this prevents leaks like the one reported by rmannibucau.","18/Oct/13 21:28;struberg;Thanks for the report, Romain!

I also fixed the other similar situations. Applied to 2.3.x and trunk","18/Oct/13 21:28;jira-bot;Commit 1533641 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1533641 ]

OPENJPA-2440 close connection after not using it anymore

this prevents leaks like the one reported by rmannibucau.",,,,,,,,,,,,,,,,,,,,,,
transactional listeners added too late to observe begin event,OPENJPA-2437,12673459,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,romain.manni-bucau,romain.manni-bucau,11/Oct/13 16:09,06/Jun/15 21:19,14/Mar/19 03:03,29/Oct/13 07:58,,,,,,,,,2.2.1.1,2.2.3,2.3.0,,,kernel,,,,1,,,,,,,,,,,,,,,,,,TOMEE-1056,,,,,,,,,11/Oct/13 16:10;romain.manni-bucau;openjpa-listeners.patch;https://issues.apache.org/jira/secure/attachment/12608021/openjpa-listeners.patch,12/Oct/13 17:04;romain.manni-bucau;tx-listener.patch;https://issues.apache.org/jira/secure/attachment/12608160/tx-listener.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2013-10-12 12:10:12.852,,,no_permission,,,,,,,,,,,,353082,,,Wed Apr 02 20:25:24 UTC 2014,,,,,,,0|i1ovhb:,353369,,,,,,,,"12/Oct/13 12:10;curtisr7;[~romain.manni-bucau] -- The proposed change looks good by me, but is it possible to come up with a small OpenJPA unit test that would expose this bug to ensure that we don't regress this behavior in the future?",12/Oct/13 15:13;romain.manni-bucau;I'll do ASAP (surely next week),12/Oct/13 17:04;romain.manni-bucau;adding a test to the patch,28/Oct/13 21:04;struberg;fix applied + cleaned up + test case rewritten to openjpa style. Now running all tests before committing.,"29/Oct/13 06:36;jira-bot;Commit 1536595 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1536595 ]

OPENJPA-2437 transactional listeners added too late to observe begin event

txs 2 rmannibucau for the fix.
Patch applied with cleanup and tests pimped.","29/Oct/13 06:37;jira-bot;Commit 1536596 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1536596 ]

OPENJPA-2437 transactional listeners added too late to observe begin event

txs 2 rmannibucau for the fix.
Patch applied with cleanup and tests pimped.","02/Apr/14 20:15;jira-bot;Commit 1584153 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1584153 ]

OPENJPA-2437: transactional listeners added too late to observe begin event - back ported Mark Struber's changes to 2.2.1.x.","02/Apr/14 20:25;jira-bot;Commit 1584156 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1584156 ]

OPENJPA-2437: transactional listeners added too late to observe begin event - back ported Mark Struber's changes to 2.2.x.",,,,,,,,,,,,,,,,,,,
Version field in a projection always returned as an Integer.,OPENJPA-2435,12672937,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,jpaheath,jpaheath,09/Oct/13 01:02,06/Jun/15 21:19,14/Mar/19 03:03,18/Oct/13 15:07,2.1.0,2.2.1.1,2.2.2,2.3.0,,,,,2.1.2,2.2.1.1,2.2.3,2.3.0,,jdbc,,,,0,,,,,,,,"I've recreated an issue where a @Version field is returned as an Integer when the field is defined as a Long or Short.  To explain, lets take this entity:

@Entity
public class LongVersionEntity implements Serializable {
.......
    @Version
    protected Long version;
.......

With this entity take the following query:

String str = ""SELECT o.id, o.version FROM LongVersionEntity o"";
Query query = em.createQuery(str);
List<Object[]> objectList = query.getResultList();
for (Object[] objects : objectList) {
    objects[1].getClass() //Will return Integer.

Notice in this query we are selecting the version field.  When iterating over the results, we will find that objects[1].getClass() will return Integer, rather than Long.  The same seems to be true for the other supported types, except for Timestamp.
I will provide a full test in the next day or so.

Thanks,

Heath",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-10-17 23:00:39.962,,,no_permission,,,,,,,,,,,,352560,,,Thu Oct 17 23:28:32 UTC 2013,,,,,,,0|i1os9z:,352847,,,,,,,,"17/Oct/13 23:00;jira-bot;Commit 1533280 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1533280 ]

OPENJPA-2435: Version field in a projection always returned as an Integer.","17/Oct/13 23:02;jira-bot;Commit 1533281 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1533281 ]

OPENJPA-2435: Version field in a projection always returned as an Integer.  Merged 2.1.x changes to 2.2.1.x.","17/Oct/13 23:17;jira-bot;Commit 1533287 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1533287 ]

OPENJPA-2435: Version field in a projection always returned as an Integer.  Merged 2.1.x changes to 2.2.x.","17/Oct/13 23:22;jira-bot;Commit 1533288 from [~jpaheath] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1533288 ]

OPENJPA-2435: Version field in a projection always returned as an Integer.  Merged 2.1.x changes to 2.3.x.","17/Oct/13 23:28;jira-bot;Commit 1533289 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1533289 ]

OPENJPA-2435: Version field in a projection always returned as an Integer.  Merged 2.1.x changes to trunk.",,,,,,,,,,,,,,,,,,,,,,
MySQL dictionary can't be found from a valid connection,OPENJPA-2432,12670908,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,romain.manni-bucau,romain.manni-bucau,27/Sep/13 12:05,27/Sep/13 16:12,14/Mar/19 03:03,27/Sep/13 16:07,,,,,,,,,2.3.0,,,,,,,,,0,,,,,,,,The code to check the DB Product Version (the only way to differentiate MariaDB and MySQL through DBMeta) did not properly handle the fact that MySQL's product version string did not contain target identifier tokens.  This causes MySQL auto detection to fail.,,,,,,,,,,,,,,,,,,,27/Sep/13 12:06;romain.manni-bucau;openjpa-mysql-dict-guess.patch;https://issues.apache.org/jira/secure/attachment/12605432/openjpa-mysql-dict-guess.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-09-27 14:24:36.109,,,no_permission,,,,,,,,,,,,350737,,,Fri Sep 27 16:05:02 UTC 2013,,,,,,,0|i1oh2v:,351028,,,,,,,,"27/Sep/13 14:24;fyrewyld;Good catch, thanks!","27/Sep/13 16:05;jira-bot;Commit 1526968 from [~fyrewyld] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1526968 ]

OPENJPA-2432: MySQL dictionary can't be found from a valid connection",,,,,,,,,,,,,,,,,,,,,,,,,
SELECT fields with @ExternalValues defined returns datastore values instead of unmapped fields,OPENJPA-2425,12666733,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,03/Sep/13 19:19,06/Jun/15 21:19,14/Mar/19 03:03,17/Oct/13 22:29,2.1.2,2.2.1.1,2.2.3,2.3.0,,,,,2.1.2,2.2.1.1,2.2.3,2.3.0,,jdbc,,,,0,,,,,,,,"If entity fields is annotated with,

	@ExternalValues( { ""SMALL=SML"", ""MEDIUM=MID"", ""LARGE=LRG"" })
	private String s1;

Object query returns umapped value in the object,
        Query q = em.createQuery(""SELECT a from EntityA a"");
        EntityA aPrime = (EntityA) q.getSingleResult();
        Assert.assertEquals(""SMALL"", aPrime.getS1());

However, field query returns mapped value from the datastore:
        q = em.createQuery(""SELECT t0.s1 FROM EntityA t0"");
        List<Object[]> res = q.getResultList();
        Iterator<Object[]> itr = res.iterator();
        Object[] values = itr.next();
        Assert.assertEquals(""SMALL"", values[1]);     <<< FAILED here, values[1]==""SML""

This problem also causes a similarly structured CritieriaAPI query to return incorrect values.

If the field type is boolean, even if the database has ""true"" value, both of the above scenario will return false, due to new Boolean(""non-true"") always return false.
",,,,,,,,,,,,,,,,,,,03/Sep/13 19:21;allee8285;OPENJPA-2425.patch;https://issues.apache.org/jira/secure/attachment/12601212/OPENJPA-2425.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-10-08 03:56:18.02,,,no_permission,,,,,,,,,,,,346671,,,Thu Oct 17 20:17:42 UTC 2013,,,Patch Available,,,,0|i1ns33:,346972,,,,,,,,"08/Oct/13 03:56;jira-bot;Commit 1530146 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1530146 ]

OPENJPA-2425: SELECT fields with @ExternalValues defined returns datastore values instead of unmapped fields - applied Albert Lee's patch to 2.1.x.","08/Oct/13 16:50;jira-bot;Commit 1530347 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1530347 ]

OPENJPA-2425: SELECT fields with @ExternalValues defined returns datastore values instead of unmapped fields - applied Albert Lee's patch to 2.2.1.x.","08/Oct/13 17:32;jira-bot;Commit 1530364 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1530364 ]

OPENJPA-2425: SELECT fields with @ExternalValues defined returns datastore values instead of unmapped fields - applied Albert Lee's patch to 2.2.x.","08/Oct/13 17:35;jira-bot;Commit 1530368 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1530368 ]

OPENJPA-2425: SELECT fields with @ExternalValues defined returns datastore values instead of unmapped fields - applied Albert Lee's patch to trunk.","17/Oct/13 20:17;jira-bot;Commit 1533243 from [~jpaheath] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1533243 ]

OPENJPA-2425: SELECT fields with @ExternalValues defined returns datastore values instead of unmapped fields - applied Albert Lee's patch to 2.3.x.",,,,,,,,,,,,,,,,,,,,,,
Isolation level is not working properly on DB2 for JPQL queries with nested sub-queries.,OPENJPA-2423,12665556,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,jpaheath,jpaheath,jpaheath,26/Aug/13 17:56,04/Feb/14 22:24,14/Mar/19 03:03,05/Nov/13 18:35,2.1.1,2.2.1.1,2.2.2,2.3.0,,,,,2.1.2,2.2.1.1,2.2.3,2.3.0,,query,,,,0,,,,,,,,"Isolation level hint is not properly working on DB2 for JPQL queries with nested sub-queries. It is generating incorrect query.  Please see example below. You will notice that it is adding “WITH UR” suffix to both nested sub-query as well as outer main query. As per SQL syntax, it should be adding “WITH UR” only at outer main query level. 
 
-- Query Hints used:
query.setHint(""openjpa.FetchPlan.Isolation"", ""read-uncommitted"");
query.setHint(""openjpa.FetchPlan.ReadLockMode"", ""READ"");
 

-- JPQL Query:
SELECT m FROM AnEntity m WHERE m.id.memberIdTd = :memberIdTd AND m.id.entryTimestamp IN
      (SELECT max(b.id.entryTimestamp) FROM AnEntity b WHERE b.id.memberIdTd = :memberIdTd)
 

-- Generated Query:
SELECT t0.ENTRY_TIMESTAMP, t0.MEMBER_ID_TD, t0.CREATED_BY, t0.DEPT_CD,  t0.EVENT_CLASS,t0.EVENT_DT,t0.EVENT_PRIORITY_IND,t0.EVENT_REMARKS,
t0.EVENT_STATUS,t0.EVENT_TYPE,t0.LAST_MOD_DATE,t0.LAST_MOD_USER,t0.LEGAL_COUNSEL_IND,t0.SYSTEM_CD
FROM DBA.ANENTITY t0
WHERE
( t0.MEMBER_ID_TD = ? AND t0.ENTRY_TIMESTAMP IN
   ( SELECT MAX(t1.ENTRY_TIMESTAMP) FROM DBA.ANENTITY t1
      WHERE ( t1.MEMBER_ID_TD = ?
            ) FOR READ ONLY WITH UR
   )
) optimize for 1 row FOR READ ONLY WITH UR
 

I'm attaching a patch, named subqueryURclause.patch.txt, created by Pinaki Poddar.

Thanks,

Heath Thomann",,,,,,,,,,,,,,,,,,,26/Aug/13 17:57;jpaheath;subqueryURclause.patch.txt;https://issues.apache.org/jira/secure/attachment/12599989/subqueryURclause.patch.txt,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-08-27 14:49:07.787,,,no_permission,,,,,,,,,,,,345496,,,Tue Feb 04 22:23:10 UTC 2014,,,Patch Available,,,,0|i1nkuv:,345797,,,,,,,,"26/Aug/13 17:57;jpaheath;Attaching a patch created by Pinaki Poddar.

Thanks,

Heath Thomann","27/Aug/13 14:49;jira-bot;Commit 1517838 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1517838 ]

OPENJPA-2423: Isolation level is not working properly on DB2 for JPQL queries with nested sub-queries - committed to 2.1.x the patch/fix provided by Pinaki Poddar.","27/Aug/13 14:57;jira-bot;Commit 1517839 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1517839 ]

OPENJPA-2423: Isolation level is not working properly on DB2 for JPQL queries with nested sub-queries - committed to 2.2.1.x the patch/fix provided by Pinaki Poddar.","27/Aug/13 15:02;jira-bot;Commit 1517841 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1517841 ]

OPENJPA-2423: Isolation level is not working properly on DB2 for JPQL queries with nested sub-queries - committed to 2.2.x the patch/fix provided by Pinaki Poddar.","27/Aug/13 15:06;jira-bot;Commit 1517843 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1517843 ]

OPENJPA-2423: Isolation level is not working properly on DB2 for JPQL queries with nested sub-queries - committed to trunk the patch/fix provided by Pinaki Poddar.","04/Feb/14 20:33;jira-bot;Commit 1564471 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1564471 ]

OPENJPA-2423: Added null-check to DB2Dictionary update","04/Feb/14 21:11;jira-bot;Commit 1564495 from [~fyrewyld] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1564495 ]

OPENJPA-2423: Added null-check to DB2Dictionary update","04/Feb/14 22:23;jira-bot;Commit 1564537 from [~fyrewyld] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1564537 ]

OPENJPA-2423: Added null-check to DB2Dictionary update",,,,,,,,,,,,,,,,,,,
Slices: Can't setting up FinderTargetPolicy,OPENJPA-2421,12663617,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,lookis,lookis,14/Aug/13 10:46,06/Jun/15 21:19,14/Mar/19 03:03,16/Aug/13 18:17,2.2.2,2.3.0,,,,,,,2.3.0,,,,,slice,,,,0,,,,,,,,"@openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java

    public FinderTargetPolicy getFinderTargetPolicyInstance() {
        if (finderTargetPolicyPlugin.get() == null) {
            finderTargetPolicyPlugin.instantiate(ReplicationPolicy.class,
                    this, true);
        }
        return (FinderTargetPolicy) finderTargetPolicyPlugin.get();
    }


try to init the FinderTargetPolicy with ReplicationPolicy.class",Jdk 7 on mac,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-08-16 18:12:30.521,,,no_permission,,,,,,,,,,,,343618,,,Fri Aug 16 18:12:30 UTC 2013,,,,,,,0|i1n9bb:,343922,,,,,,,,"16/Aug/13 18:12;jira-bot;Commit 1514829 from [~ppoddar@apache.org] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1514829 ]

OPENJPA-2421: Correct a bug on FinderTargetPolicy",,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot build 2.2.x due to NullPointerException in maven-checkstyle-plugin,OPENJPA-2418,12662235,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,curtisr7,snortasprocket,snortasprocket,06/Aug/13 22:33,07/Aug/13 19:06,14/Mar/19 03:03,07/Aug/13 18:02,2.0.2,2.1.2,2.2.3,2.3.0,,,,,2.2.3,2.3.0,,,,build / infrastructure,,,,0,,,,,,,,"Here's the issue when building the 2.2.x branch.

Updating to newer maven-checkstyle-plugin (2.6) seems to workaround it.

{noformat}
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-checkstyle-plugin:2.4:checkstyle (default) on project openjpa-lib: Execution default of goal org.apache.maven.plugins:maven-checkstyle-plugin:2.4:checkstyle failed. NullPointerException -> [Help 1]
org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-checkstyle-plugin:2.4:checkstyle (default) on project openjpa-lib: Execution default of goal org.apache.maven.plugins:maven-checkstyle-plugin:2.4:checkstyle failed.
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:225)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:319)
	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)
	at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)
	at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)
	at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)
	at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)
	at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)
Caused by: org.apache.maven.plugin.PluginExecutionException: Execution default of goal org.apache.maven.plugins:maven-checkstyle-plugin:2.4:checkstyle failed.
	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:110)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.apache.maven.plugin.checkstyle.rss.DefaultCheckstyleRssGenerator.generateRSS(DefaultCheckstyleRssGenerator.java:72)
	at org.apache.maven.plugin.checkstyle.CheckstyleReport.executeReport(CheckstyleReport.java:639)
	at org.apache.maven.reporting.AbstractMavenReport.generate(AbstractMavenReport.java:131)
	at org.apache.maven.reporting.AbstractMavenReport.execute(AbstractMavenReport.java:76)
	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101)
	... 20 more
{noformat}","Apache Maven 3.0.3 (r1075438; 2011-02-28 12:31:09-0500)
Maven home: /usr/share/maven
Java version: 1.6.0_51, vendor: Apple Inc.
Java home: /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
Default locale: en_US, platform encoding: MacRoman
OS name: ""mac os x"", version: ""10.8.4"", arch: ""x86_64"", family: ""mac""",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-08-07 14:02:09.982,,,no_permission,,,,,,,,,,,,342239,,,Wed Aug 07 19:06:29 UTC 2013,,,,,,,0|i1n0tr:,342544,,,,,,,,"07/Aug/13 14:02;curtisr7;I'm running maven 2.2.1 and when I change to checkstyle 2.6 I get the following exception :

[ERROR] FATAL ERROR
[INFO] ------------------------------------------------------------------------
[INFO] null
[INFO] ------------------------------------------------------------------------
[INFO] Trace
java.lang.StringIndexOutOfBoundsException
        at java.lang.String.substring(String.java:1093)
        at org.codehaus.classworlds.UrlUtils.normalizeUrlPath(UrlUtils.java:28)
        at org.codehaus.classworlds.DefaultClassRealm.getResource(DefaultClassRealm.java:284)
        at org.codehaus.classworlds.RealmClassLoader.getResource(RealmClassLoader.java:237)
        at org.codehaus.plexus.resource.loader.ThreadContextClasspathResourceLoader.getResource(ThreadContextClasspathResourceLoader.java:63)
        at org.codehaus.plexus.resource.DefaultResourceManager.getResource(DefaultResourceManager.java:159)
        at org.codehaus.plexus.resource.DefaultResourceManager.getResourceAsFile(DefaultResourceManager.java:91)
        at org.apache.maven.plugin.checkstyle.DefaultCheckstyleExecutor.getConfigFile(DefaultCheckstyleExecutor.java:471)
        at org.apache.maven.plugin.checkstyle.DefaultCheckstyleExecutor.getConfiguration(DefaultCheckstyleExecutor.java:236)
        at org.apache.maven.plugin.checkstyle.DefaultCheckstyleExecutor.executeCheckstyle(DefaultCheckstyleExecutor.java:173)
        at org.apache.maven.plugin.checkstyle.CheckstyleReport.executeReport(CheckstyleReport.java:578)
        at org.apache.maven.reporting.AbstractMavenReport.generate(AbstractMavenReport.java:190)
        at org.apache.maven.reporting.AbstractMavenReport.execute(AbstractMavenReport.java:99)
        at org.apache.maven.plugin.DefaultPluginManager.executeMojo(DefaultPluginManager.java:490)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoals(DefaultLifecycleExecutor.java:694)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalWithLifecycle(DefaultLifecycleExecutor.java:556)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoal(DefaultLifecycleExecutor.java:535)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalAndHandleFailures(DefaultLifecycleExecutor.java:387)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeTaskSegments(DefaultLifecycleExecutor.java:348)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.execute(DefaultLifecycleExecutor.java:180)
        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:328)
        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:138)
        at org.apache.maven.cli.MavenCli.main(MavenCli.java:362)
        at org.apache.maven.cli.compat.CompatibleMain.main(CompatibleMain.java:60)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)
        at java.lang.reflect.Method.invoke(Method.java:611)
        at org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315)
        at org.codehaus.classworlds.Launcher.launch(Launcher.java:255)
        at org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:430)
        at org.codehaus.classworlds.Launcher.main(Launcher.java:375)","07/Aug/13 14:06;curtisr7;If I change <checkstyle.config.location> and <checkstyle.suppressions.location> to use ${file.separator} rather than '/', everything seems to work on both versions. Can I have you check that also?","07/Aug/13 14:35;kwsutter;I see that you are using Maven 3.0.3.  OpenJPA currently states a build dependency on Maven 2.2.1.  If you build with Maven 2.2.1, there is no problem.  Do you have a requirement to use Maven 3.x?  We could consider moving up to Maven 3 on trunk, but doing so on a service branch may introduce some unexpected build dependencies.  We'd have to see if this move to Maven 3 is a big deal or not...  Input would be appreciated.  Thanks.","07/Aug/13 15:46;jira-bot;Commit 1511367 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1511367 ]

OPENJPA-2418 : Fix checkstyle to run with maven 3.x.","07/Aug/13 17:51;jira-bot;Commit 1511418 from [~curtisr7] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1511418 ]

OPENJPA-2418: Fix checkstyle to run with maven 3.x.",07/Aug/13 18:02;curtisr7;I committed changes to trunk and 2.2.x.,"07/Aug/13 19:05;snortasprocket;[~kwsutter]: I guess I didn't read too carefully w/r/t to Maven 2.2.1 being a build requirement; I made bad assumption that since Maven 3.x has been out for some time now that there wouldn't be a problem. :)

[~curtisr7]: I've pulled the changes and confirmed them in 2.2.x, which is good enough for me. :)",07/Aug/13 19:06;snortasprocket;Looks good from my end.,,,,,,,,,,,,,,,,,,,
FinderCache does not consider active Fetch Groups/FetchPlan added Fields,OPENJPA-2414,12659627,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,fyrewyld,fyrewyld,24/Jul/13 18:10,29/Oct/13 16:24,14/Mar/19 03:03,29/Oct/13 16:23,2.2.3,2.3.0,,,,,,,2.1.2,2.2.1.1,2.2.3,2.3.0,,kernel,,,,0,,,,,,,,"The FinderCache retains a Map, associating a ClassMapping with a FinderQuery.  However, this cache does not factor in the characteristics of the FetchPlan that was active when a mapping is created, nor does it factor them to determine if a cache hit is appropriate.  This causes the find() operation to perform the same SQL as the first time it was executed, regardless of changes to the active FetchPlan afterwards.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-08-21 16:15:01.692,,,no_permission,,,,,,,,,,,,339820,,,Tue Oct 29 16:23:38 UTC 2013,,,,,,,0|i1mlzz:,340139,,,,,,,,"21/Aug/13 16:15;jira-bot;Commit 1516197 from [~fyrewyld] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1516197 ]

OPENJPA-2414: FinderCache does not consider active Fetch Groups/FetchPlan added Fields","22/Aug/13 14:39;jira-bot;Commit 1516464 from [~fyrewyld] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1516464 ]

OPENJPA-2414: FinderCache does not consider active Fetch Groups/FetchPlan added Fields","22/Aug/13 19:27;jira-bot;Commit 1516543 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1516543 ]

OPENJPA-2414: FinderCache does not consider active Fetch Groups/FetchPlan added Fields","23/Aug/13 14:11;jira-bot;Commit 1516853 from [~fyrewyld] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1516853 ]

OPENJPA-2414: FinderCache does not consider active Fetch Groups/FetchPlan added Fields","23/Aug/13 14:58;jira-bot;Commit 1516873 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1516873 ]

OPENJPA-2414: FinderCache does not consider active Fetch Groups/FetchPlan added Fields","23/Aug/13 15:59;jira-bot;Commit 1516910 from [~fyrewyld] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1516910 ]

OPENJPA-2414: FinderCache does not consider active Fetch Groups/FetchPlan added Fields","23/Aug/13 16:50;jira-bot;Commit 1516931 from [~fyrewyld] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1516931 ]

OPENJPA-2414: FinderCache does not consider active Fetch Groups/FetchPlan added Fields","27/Aug/13 22:16;ppoddar@apache.org;This change is not align with the original intent. The idea of caching a finder query is *not* related to whether *only* default Fetch Plan is being used. The idea is (or at least was) that if *anything* (fetch plan, lock mode) that impact a target SQL, the application *must* bypass the cache. This design decision is deliberate from a performance perspective. Because under such immutablity assumption, the runtime does not have to spend any extra computation cycle to use the cache. While if the application always knows when it changes something that impacts the target SQL, so it can always bypass the finder cache. This choice favors the common 80% use case over the less common use case where the application mutates *something* that impacts a target SQL.

This issue is reopened. Please either start a discussion if you are suggesting an alternative design/usage or revert to ""user-is-reponsible"" model of usage which was the original intent.","28/Aug/13 01:33;fyrewyld;Please show me the location in the OpenJPA documentation that supports your position as ""original intent"" is meaningless if it's not well documented.  It's sure not intuitive and it's going to fool a lot of applications consuming OpenJPA (which has already happened, hence this going into a service branch.)  If you're asserting that OpenJPA's behavior before the fix is correct and in ""alignment with original intent"", then you're going to have a race condition where the first em.find() sets the sql for every em.find() that comes after (look at the new tests added that look for this.)  In a J2EE application with many entry points, whoever first gets to set the Fetch Plan forever associates with the characteristics of that fetch plan with every future em.find(MyEntity.class) -- you will have a race condition.  A call to em.find() with a default fetch plan with a FinderCache initialized with an entry with a non default fetch plan will execute the non-default fetch plan sql because that is what is cached.  I think everyone can agree that is a BAD thing.

The change this JIRA makes is quite simple: only SQL generated by the default fetch plan for the persistence context (be it just ""default"" or a new default as set by pu properties) is what's cached.  If an em.find() is performed with a fetch plan that is not equal to the default, then it will not go to the cache and instead build the SQL as dictated by the current fetch plan.  This way an altered fetch plan is honored (instead of ignored) each time it is changed, and is safe for consumption in a service stream.  80% of most OpenJPA users probably do not touch FetchPlans, so this will not impact them.

I have considered making the FinderCache FetchPlan smart for trunk, that will be done in a future JIRA.

I will discuss this with Kevin tomorrow morning, and if he still agrees with my change I will re-close this JIRA.","28/Aug/13 15:16;kwsutter;Oh sure, Thanks Jody for hauling me into this discussion...  :-)

I will agree that the current usage scenario was not intuitive or documented.  And, since we have customers hitting this condition of accidentally caching the ""wrong"" SQL, I agree that we need to do something in the service streams to resolve the issue.  And, considering the 80/20 rule, it seems that erring on the default/conservative side definitely hits the 80% side of the market.

That all being said, Pinaki does have a valid point that we are now alienating users that use fetch plans from using the FinderCache.  But, that is also consistent with Pinaki's direction to have the application control whether these generated SQL's should be cached or not.  We're just making that decision for them.

Also, does this change in behavior have any impact on the normal callpath from a performance perspective?  Pinaki is hinting that it will affect performance.  If we are doing additional processing on every generated SQL and access to the FinderCache, then are we negating the benefits of the cache?

One alternative is to modify the FinderCache so that it could take the FetchPlan settings into account.  Whether this extra processing would offset the benefit of the cache would have to be determined.  Regardless, this is too big of an effort for the service streams.  I would suggest creating a sub-JIRA feature for this effort so that we have it on the books.  But, stick with this conservative approach until this sub-feature is resolved.

That's my two cents worth.  But, don't just re-close this JIRA without coming to some type of agreement.  I've posted a few questions that should be discussed and resolved.  Thanks. ","04/Oct/13 19:22;fyrewyld;An update will be coming soon, adding a Compatibilty option that can turn off the changes introduced by this JIRA.","04/Oct/13 20:46;jira-bot;Commit 1529292 from [~fyrewyld] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1529292 ]

OPENJPA-2414: FinderCache does not consider active Fetch Groups/FetchPlan added Fields","09/Oct/13 20:42;jira-bot;Commit 1530789 from [~fyrewyld] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1530789 ]

OPENJPA-2414: FinderCache does not consider active Fetch Groups/FetchPlan added Fields","16/Oct/13 15:28;jira-bot;Commit 1532797 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1532797 ]

OPENJPA-2414: FinderCache does not consider active Fetch Groups/FetchPlan added Fields","16/Oct/13 20:12;jira-bot;Commit 1532882 from [~fyrewyld] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1532882 ]

OPENJPA-2414: FinderCache does not consider active Fetch Groups/FetchPlan added Fields","29/Oct/13 16:23;jira-bot;Commit 1536793 from [~fyrewyld] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1536793 ]

OPENJPA-2414: FinderCache does not consider active Fetch Groups/FetchPlan added Fields",,,,,,,,,,,
allow the openjpa-maven-plugin to use a persistence.xml from resources and not only from files,OPENJPA-2409,12657213,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,romain.manni-bucau,romain.manni-bucau,11/Jul/13 08:11,06/Jun/15 21:19,14/Mar/19 03:03,18/Oct/13 14:37,2.2.2,,,,,,,,2.3.0,,,,,tooling,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,11/Jul/13 09:00;romain.manni-bucau;OPENJPA-2409.patch;https://issues.apache.org/jira/secure/attachment/12591810/OPENJPA-2409.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-07-11 10:09:14.457,,,no_permission,,,,,,,,,,,,337435,,,Fri Oct 18 14:37:40 UTC 2013,,,,,,,0|i1m7bb:,337758,,,,,,,,"11/Jul/13 09:00;romain.manni-bucau;A patch handling it with the following strategy:
1) if the persistence.xml exists -> nothing
2) else try in TCCL, if found -> use it
3) else try in compiler artifacts
3) else try in runtime artifacts

When found the persistence.xml is copied in target/openjpa-work  to ensure it is a File.","11/Jul/13 10:09;struberg;sounds great, will look at the patch in the afternoon and apply it if it works.","11/Jul/13 12:59;romain.manni-bucau;just saw the workDir field i added uses @parameter expression=""${openjpa.classes}"" instead of @parameter expression=""${openjpa.workDir}"". I can't fix the patch right but i'll do later if it is needed","18/Oct/13 14:11;jira-bot;Commit 1533462 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1533462 ]

OPENJPA-2409 enable persistenceXmlFile parameter to handle classpath resources as well.

contributed by rmannibucau, txs!
applied with small changes and doc improvements","18/Oct/13 14:25;jira-bot;Commit 1533466 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1533466 ]

OPENJPA-2409 enable persistenceXmlFile parameter to handle classpath resources as well.

contributed by rmannibucau, txs!
applied with small changes and doc improvements",18/Oct/13 14:37;struberg;also applied to trunk.,,,,,,,,,,,,,,,,,,,,,
EntityManager.merge does not work for entity that is managed by another EntityManager,OPENJPA-2405,12654693,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,arne,arne,25/Jun/13 09:38,12/Jun/18 02:29,14/Mar/19 03:03,01/Jul/13 17:04,2.2.3,,,,,,,,2.3.0,,,,,kernel,,,,0,,,,,,,,EntityManager.merge does not work for entity that is managed by another EntityManager. Instead of updating that entity OpenJPA tries to persist the entity a second time,,7200,7200,,0%,7200,7200,,,,,,,,,,,,25/Jun/13 09:40;arne;OPENJPA-2405.patch;https://issues.apache.org/jira/secure/attachment/12589574/OPENJPA-2405.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-06-25 13:25:22.675,,,no_permission,,,,,,,,,,,,334970,,,Tue Jun 12 02:03:35 UTC 2018,,,,,,,0|i1ls4v:,335294,,,,,,,,25/Jun/13 09:40;arne;Added test that reproduces the problem,"25/Jun/13 13:25;allee8285;Per Spec:
====================
3.2.7.1 Merging Detached Entity State
The merge operation allows for the propagation of state from detached entities onto persistent entities
managed by the entity manager.
The semantics of the merge operation applied to an entity X are as follows:
........
• If X is a managed entity, it is ignored by the merge operation, however, the merge operation is
cascaded to entities referenced by relationships from X if these relationships have been annotated
with the cascade element value cascade=MERGE or cascade=ALL annotation.
====================

merge() is for ""detached"" entity only. If it is ""managed"", it is IGNORED.....
","26/Jun/13 06:01;arne;1. So you agree with me that it is a BUG that OpenJPA tries to INSERT the entity and throws an exception due to the duplicate key?

2. Yes, I have read that chapter of the spec, too. And I come to the conclusion, that the only way to interpret it, is that managed entities of the SAME persistence context are meant.
Your way of reading the spec simply does not work. Think of the following situation:
 a. Entity A is loaded by EntityManager X. Entity A has a Cascade.ALL relation to Entity B.
 b. Entity B is newly created and assigned to A
 c. Entity A is merged to EntityManager Y.
Now Entity B would be managed by EntityManager Y due to the cascading behavior you cited. In addition Entity B would be managed by EntityManager X due to 3.2.4

Spec 3.24
=====================
The semantics of the flush operation, applied to an entity X are as follows:
- If X is a managed entity, it is synchronized to the database.
   - For all entities Y referenced by a relationship from X, if the relationship to Y has been annotated with the cascade element value cascade=PERSIST or cascade=ALL, the persist operation is applied to Y.
=====================
How do you think OpenJPA should behave in such situation? Should Entity B be managed by two persistence contexts?

Btw. Any other persistence provider returns a managed copy of Entity A in such situation, no matter if A is managed by another persistence context or detached. And this is the expected behavior, I guess.","27/Jun/13 15:37;allee8285;I am just pointing out that merge() is meant for merging DETACHED entity into a persistence context. If an entity is managed by the SAME persistence context, there is nothing to merge since the state of X is already maintained, hence the merge operation is ignored. However, the child relationship is still processed if proper cascade is specified.

The spec also spelled out the following;
=================================
3.2.8 Managed Instances
It is the responsibility of the application to insure that an instance is managed in only a single persistence
context. The behavior is undefined if the same Java instance is made managed in more than one
persistence context.
=================================

In the original test case,  A (managed by em, not detached) is merged to em2 and there is no managed A in em2. Since A is marked managed and not managed in em2, OpenJPA creates a new managed instance in em2 and eventually ""INSERT"" to the database. I am not saying this is the right or wrong behavior but this use case is undefined.

If you wants to merge changed content in A to a different persistence context, you may have to do:
- em.find(A);
- detach A from em2
- make changes to A
- em2.find(A);
- em2.merge(A);
- commit/flush em2
","27/Jun/13 17:16;arne;Yes, I know how I could make it work in the test case.
Unfortunately this is not true for real life applications.
The problem occured in a web-app with concurrent requests.
I load the entity within one request and the EntityManager is closed after that request.
In the second request I merge that entity to have an attached instance again.
Unfortunately from time to time the second request comes in when the first is not completely finished and the first EntityManager is still open. Then the problem occures.

So, until this behavior of OpenJPA is not fixed, I cannot have concurrent requests with JPA?

Btw. I am willing to help fixing this issue.

Is it common sense that the best behavior in the described case would be that OpenJPA simply copies the state of the entity?","28/Jun/13 09:24;struberg;Well, imo it's an OpenJPA bug in any case. If we simply ignore managed entities in em.merge() than we must not insert the children into the database twice neither.

Regarding 3.2.8: In this paragraph 'instance' clearly does not mean 'entity identity' but 'java identity' as indicated by the sentence: ""The behavior is undefined if the same Java instance is made managed in more than one persistence context.""

In any case I'm not sure if 'fixing' this would help you, Arne.

I guess it's all about the entitymanager-per-request pattern and a premature redirect().
In this case it might happen that finishing the first request (the one with the redirect) takes longer to end than the new request to hit the server (in a parallel thread now).
In this case the flush() on the first request might change your records in the db and also update the @Version in those Entities. So even if you would get the entity merged into another EM in the 2nd request it would contain the old @Version and you will blow up at the end of the 2nd request with an OptimisticLockException. Doesn't sound good neither, right? :)

There are now 2 ways to solve this issue in your application (even without changing OpenJPA)

1.) Use a Servlet Filter to synchronize on your Session for those requests. Be careful as this might cause unnecessary locks ...

2.) explicitly invoke em.flush() and em.close() before you do the redirect. And hope that your @Transactional Interceptor can deal with it :) For JSF apps we might be able to register a hook for the redirect in the FacesContext. Need to check...

This might btw also work a bit different depending if you use synchronized or unsynchronized EM (see JTA-2.1 and em.joinTransaction()).

Summary: multi-page 'wizard' style pages without DTOs suck at this time. We need this new pattern we've talked about last week where we use em.joinTransaction() to explicitly store the entity in the 'save' action on the last page - without having the em.merge() operations automagically prematurely store all changes into the database on the intermediate pages. Still thinking about how this can be done best with OpenJPA
","28/Jun/13 18:29;fyrewyld;Just reviewing this JIRA and wanted to post my own thoughts.  First, some clips from the JPA Specification that I think are relevant:

3.2 Entity Instance’s Life Cycle
This section describes the EntityManager operations for managing an entity instance’s lifecycle. An entity instance can be characterized as being new, managed, detached, or removed.
￼￼￼￼• • • •
A new entity instance has no persistent identity, and is not yet associated with a persistence context.
A managed entity instance is an instance with a persistent identity that is currently associated with a persistence context.
A detached entity instance is an instance with a persistent identity that is not (or no longer) associated with a persistence context.
A removed entity instance is an instance with a persistent identity, associated with a persistence context, that will be removed from the database upon transaction commit.

-- What I take from this is that an Entity Class that has been freshly created by its constructor (ie, not created by em.find() or a JPA query) and has never, ever been touched by an em.persist() or em.merge() operation is a ""new entity"".  Such an object will not have any StateManager (DetachedStateManager or otherwise, it is simply null) associated with its internal state (internal state being the hidden variables added by enhancement.)

-- A ""managed entity"" is an Entity Class instance that has a link to a live StateManager in its internal state -- and there's caveats to that.  A StateManager is associated to one and only one Persistence Context (ie, EntityManager instance) - to those and only those Persistence Contexts is the entity a ""managed entity"".  A new entity becomes a managed entity when em.persist() or em.merge() is called on it.  (Managed entities are also provided by find/query operations (though it would return a detached entity if it's a CMTS entitymanager invocation outside of a transaction.))

-- To any other Persistence Context, because it is not ""new"" (because it has a StateManager object associated with it) and has a non DetachedStateManager that is associated with another Persistence Context, it should be interpreted as a ""detached entity"" (even if the StateManager associated with the Entity Object instance's internal state is not a DetachedStateManager.)  So calling em.merge(entityWithSomeOtherPCsStateManager) should be treated as a detached entity, and return a new Entity Object instance.  Which could create ""interesting problems"" if the original entity doesn't have a committed row on the database yet (because the two different PCs will have two different db connections, and a merge operation will trigger a fetch operation from the database/cache.)  Remember the JPA spec requires Read-Committed to be the minimum isolation level.","28/Jun/13 18:39;fyrewyld;Further Thoughts, as I realize the statement ""A managed entity instance is an instance with a persistent identity that is currently associated with a persistence context."" could be read differently than how I read it (using the 2.1 spec, which should not be different from previous spec iterations.)

3.2.8 Managed Instances
It is the responsibility of the application to insure that an instance is managed in only a single persistence context. The behavior is undefined if the same Java instance is made managed in more than one persistence context.

The contains() method can be used to determine whether an entity instance is managed in the current persistence context.

-- What I take from here is that from the perspective of a Persistence Context, an entity is managed if and only if it is actively associated with it.  So an Entity Object instance with a StateManager associated with PCtx#1 is a ""managed entity"" only from the perspective of PCtx#1 (emPCTX1.contains(entity) returns true).  Any other PCtxs, such as PCtx#2 would see that it has a StateManager that is not associated with it so it is neither ""new"" nor ""managed"" (by PCtx#2) and should consider it to be unmanaged (detached, since it cannot be a ""new"" entity for reasons previously stated) - in this case emPCTX2(entity) returns false.","28/Jun/13 18:44;struberg;> Managed entities are also provided by find/query operations (though it would return a detached entity if it's a CMTS entitymanager invocation outside of a transaction.)

Well, this is not quite what I do read from the JPA and JTA specs. The spec says that in such cases all query operations must succeed (thus also lacy loading shall work) but all write operations must get queued until the EntityManager joins a transaction.
And this mechanism is lacking in OpenJPA I fear. At least I'm not aware that we can do this somehow.","28/Jun/13 18:54;fyrewyld;Outside of a tran, a CMTS EM find/query will work, the spec/javadoc just requires that the entities returned are detached.  Anyways, that really isn't relevant to this JIRA.

And I focused a bit too much on the first part and gave just a partial answer.

As I interpret it, write operations are queued, and it's up to the persistence provider to decide when to flush them to the database (with em.flush() and tran commit being the ""push everything to the database and do it Now"" tools.)  However, because of the Read Committed isolation policy, a new Entity that has been persisted and made managed by EM#1, even if flushed () (but not tran committed yet) will not be detectable to any other EM because EM#(not 1) doesn't share the same JDBC connection.  So EM#1 could conceivably automatically sync every mutation as it comes in from the application to the database, but it's invisible until that critical tran.commit() takes place.","28/Jun/13 19:15;struberg;Jody, I'm not sure if the Entity of such a unsynchronized CMTS EM would be 'detached'. At least according to what I talked with Mike Keith (assuming that I didn't misunderstand him) lazy loading and graph traversal would work for such entitites.

I agree with your 2nd part. Having the same db row managed in 2 different EMs will either not see each other properly or if they do (update case) most likely cause an OptimisticLockingException in one of them - at least if both write!","28/Jun/13 19:28;fyrewyld;Looking at the attached test, my opinion is that the following should happen:

1) The call to populate(), before the test begins, creates a new em, adds a row to the database, commits, and destroys the em.
2) Enter testMergeManagedParent()
3) Parent parent = em.find(Parent.class, pk); - returns an instance of Parent (id=K1) with an address of, say, @0000001.
4) Parent mergedParent = em2.merge(parent); - sees parent is not ""new"" (because it has a StateManager), and that its associated StateManager belongs to em and not em2, should view parent as a detached entity - so it should perform a fetch from the database, create a new object, say, @0000002, and bring in any fields which have been mutated in @0000001 (which in this case, are none), and return @0000002 to the caller which is saved in the mergedParent field.

It's a little different scenario than what I was initially led to believe (I thought the scenario would have been the em from step #3 was creating a new entity object instance, here, the row already exists on the db before the test logic runs.)

Does anyone disagree with this?","28/Jun/13 20:31;fyrewyld;I propose the attached fix for this issue, which allows the reporter's sample test to pass.

Basically the idea is simple: check if the object to be merged (toAttach) has a StateManager associated with it.  If it does and that StateManager is a StateManagerImpl (which DetachedStateManager is not a descendent of) then grab its broker reference.

If this broker reference is different than the broker being used to perform the merge() operation, then set isManagedByAnotherPCtx=true.

Then modify isNew to the following logic:

boolean isNew = !broker.isDetached(pc) && !isManagedByAnotherPCtx;

Basically, if toAttach is not detached and it is not managed by another persistence context, then it is to be considered a new object.  If toAttach is not detached (because pc.isDetached() is not broker context aware) but if it is managed by some other broker,t hen it should NOT be considered a new object.

(Disclaimer: have not run the full junit suite yet, will do so after posting this.)","28/Jun/13 20:39;fyrewyld;I would also like to take the time to make the reminder that the 2.2.x is managed by IBM, any changes to this branch will need to go through the PMR process.  Otherwise, if the general consensus decides that this is an appropriate fix it will have to go into trunk.","01/Jul/13 16:58;jira-bot;Commit 1498565 from [~fyrewyld]
[ https://svn.apache.org/r1498565 ]

OPENJPA-2405: EntityManager.merge does not work for entity that is managed by another EntityManager",01/Jul/13 16:58;fyrewyld;Fix has been checked into trunk.,"01/Jul/13 18:59;arne;Thanks for fixing this, Jody. Your suggested (and implemented) behavior matches my expectation :-)
","12/Jun/18 01:33;rengels@ix.netcom.com;I don't think this is working correctly in 2.4.2. I have TomEE 7.0.4 installed, which uses version 2.4.2.

I have any entity, that has a many to one reference - Customer, contains and Address, which has a many to one reference to Country.

In the process of editing, and persisting the Customer (an update) - I load an Country using another EntityManager (via a drop down list search), because I want to change the Country on the customer.

When I use the following code:

 

 
{code:java}
public String update()
{
   this.conversation.end();

   try
   {
      if (this.id == null)
      {
         this.entityManager.persist(this.customer);
         return ""search?faces-redirect=true"";
      }
      else
      {
         this.entityManager.merge(customer);
         return ""view?faces-redirect=true&id="" + this.customer.getId();
      }
   }
   catch (Exception e)
   {
      FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(e.getMessage()));
      return null;
   }
}

{code}
 

 

I get the following exception:

 

If I change the JPA to be eclipselink, it works fine without error, saving properly.

Btw, this is the standard petstore sample for JaveEE 7 available at [https://github.com/agoncal/agoncal-application-petstore-ee7]

Also, it would seem that I should be able to mark the 'many to one' as cascade NEVER and have this work. I would never want to delete the Country when a Customer is deleted ??? Also, the 'Country' entries are maintained in a standalone fashion. It seems like something is broken here in OpenJPA.

{{11-Jun-2018 20:31:17.191 WARNING [http-nio-8080-exec-3] org.apache.geronimo.transaction.manager.TransactionImpl.beforeCompletion Unexpected exception from beforeCompletion; transaction will roll back}}
{{ <openjpa-2.4.2-r422266:1777108 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: The given instance ""org.agoncal.application.petstore.model.Country-1225"" is not managed by this context.}}
{{FailedObject: org.agoncal.application.petstore.model.Country-1225}}
{{ at org.apache.openjpa.kernel.BrokerImpl.getStateManagerImpl(BrokerImpl.java:4650)}}
{{ at org.apache.openjpa.kernel.BrokerImpl.persistInternal(BrokerImpl.java:2614)}}
{{ at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2602)}}
{{ at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2585)}}
{{ at org.apache.openjpa.kernel.SingleFieldManager.preFlushPC(SingleFieldManager.java:800)}}
{{ at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:621)}}
{{ at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:589)}}
{{ at org.apache.openjpa.kernel.SingleFieldManager.preFlush(SingleFieldManager.java:510)}}
{{ at org.apache.openjpa.kernel.StateManagerImpl.preFlush(StateManagerImpl.java:3055)}}
{{ at org.apache.openjpa.kernel.ECopyState.beforeFlush(ECopyState.java:42)}}
{{ at org.apache.openjpa.kernel.StateManagerImpl.beforeFlush(StateManagerImpl.java:1072)}}
{{ at org.apache.openjpa.kernel.BrokerImpl.flushTransAdditions(BrokerImpl.java:2283)}}
{{ at org.apache.openjpa.kernel.BrokerImpl.flushAdditions(BrokerImpl.java:2262)}}
{{ at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2144)}}
{{ at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2103)}}
{{ at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:2021)}}
{{ at org.apache.geronimo.transaction.manager.TransactionImpl.beforeCompletion(TransactionImpl.java:527)}}
{{ at org.apache.geronimo.transaction.manager.TransactionImpl.beforeCompletion(TransactionImpl.java:512)}}
{{ at org.apache.geronimo.transaction.manager.TransactionImpl.beforePrepare(TransactionImpl.java:413)}}
{{ at org.apache.geronimo.transaction.manager.TransactionImpl.commit(TransactionImpl.java:262)}}
{{ at org.apache.geronimo.transaction.manager.TransactionManagerImpl.commit(TransactionManagerImpl.java:252)}}
{{ at org.apache.openejb.core.transaction.JtaTransactionPolicy.completeTransaction(JtaTransactionPolicy.java:331)}}
{{ at org.apache.openejb.core.transaction.TxRequired.commit(TxRequired.java:76)}}
{{ at org.apache.openejb.core.transaction.EjbTransactionUtil.afterInvoke(EjbTransactionUtil.java:77)}}
{{ at org.apache.openejb.core.stateful.StatefulContainer.afterInvoke(StatefulContainer.java:930)}}
{{ at org.apache.openejb.core.stateful.StatefulContainer.businessMethod(StatefulContainer.java:737)}}
{{ at org.apache.openejb.core.stateful.StatefulContainer.invoke(StatefulContainer.java:379)}}
{{ at org.apache.openejb.core.ivm.EjbObjectProxyHandler.synchronizedBusinessMethod(EjbObjectProxyHandler.java:265)}}
{{ at org.apache.openejb.core.ivm.EjbObjectProxyHandler.businessMethod(EjbObjectProxyHandler.java:260)}}
{{ at org.apache.openejb.core.ivm.EjbObjectProxyHandler._invoke(EjbObjectProxyHandler.java:89)}}
{{ at org.apache.openejb.core.ivm.BaseEjbProxyHandler.invoke(BaseEjbProxyHandler.java:347)}}
{{ at org.agoncal.application.petstore.view.admin.CustomerBean$$LocalBeanProxy.update(org/agoncal/application/petstore/view/admin/CustomerBean.java)}}
{{ at org.agoncal.application.petstore.view.admin.CustomerBean$$OwbNormalScopeProxy0.update(org/agoncal/application/petstore/view/admin/CustomerBean.java)}}
{{ at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)}}
{{ at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)}}
{{ at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)}}
{{ at java.lang.reflect.Method.invoke(Method.java:498)}}
{{ at org.apache.el.parser.AstValue.invoke(AstValue.java:247)}}
{{ at org.apache.el.MethodExpressionImpl.invoke(MethodExpressionImpl.java:267)}}
{{ at org.apache.webbeans.el22.WrappedMethodExpression.invoke(WrappedMethodExpression.java:52)}}
{{ at com.sun.faces.facelets.el.TagMethodExpression.invoke(TagMethodExpression.java:105)}}
{{ at javax.faces.component.MethodBindingMethodExpressionAdapter.invoke(MethodBindingMethodExpressionAdapter.java:87)}}
{{ at com.sun.faces.application.ActionListenerImpl.processAction(ActionListenerImpl.java:102)}}
{{ at javax.faces.component.UICommand.broadcast(UICommand.java:315)}}
{{ at javax.faces.component.UIViewRoot.broadcastEvents(UIViewRoot.java:790)}}
{{ at javax.faces.component.UIViewRoot.processApplication(UIViewRoot.java:1282)}}
{{ at com.sun.faces.lifecycle.InvokeApplicationPhase.execute(InvokeApplicationPhase.java:81)}}
{{ at com.sun.faces.lifecycle.Phase.doPhase(Phase.java:101)}}
{{ at com.sun.faces.lifecycle.LifecycleImpl.execute(LifecycleImpl.java:198)}}
{{ at javax.faces.webapp.FacesServlet.service(FacesServlet.java:658)}}
{{ at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)}}
{{ at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)}}
{{ at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)}}
{{ at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)}}
{{ at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)}}
{{ at org.apache.openejb.server.httpd.EEFilter.doFilter(EEFilter.java:65)}}
{{ at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)}}
{{ at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)}}
{{ at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198)}}
{{ at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)}}
{{ at org.apache.tomee.catalina.OpenEJBValve.invoke(OpenEJBValve.java:44)}}
{{ at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478)}}
{{ at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)}}
{{ at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80)}}
{{ at org.apache.tomee.catalina.OpenEJBSecurityListener$RequestCapturer.invoke(OpenEJBSecurityListener.java:97)}}
{{ at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650)}}
{{ at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)}}
{{ at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)}}
{{ at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799)}}
{{ at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)}}
{{ at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)}}
{{ at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1457)}}
{{ at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)}}
{{ at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)}}
{{ at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)}}
{{ at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)}}
{{ at java.lang.Thread.run(Thread.java:748)}}

 

 ","12/Jun/18 02:03;rengels@ix.netcom.com;If I change the update code to the following, it works as expected - but again, no need to do this with EclipseLink, and it certainly seems like a bug. If cascading is not enabled for the ManyToOne relationship, it shouldn't even care about the persisted state of the Country object, it should just be using it's ID to form the relation. Only if the Country object had no ID should there be a failure.

 
{code:java}
customer.getHomeAddress().setCountry(entityManager.merge(customer.getHomeAddress().getCountry()));
this.entityManager.merge(customer);
return ""view?faces-redirect=true&id="" + this.customer.getId();

{code}",,,,,,,,
Support MariaDB,OPENJPA-2400,12652902,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,fyrewyld,fyrewyld,14/Jun/13 15:29,06/Jun/15 21:19,14/Mar/19 03:03,07/Oct/13 17:51,2.2.3,,,,,,,,2.3.0,,,,,docs,jdbc,,,1,,,,,,,,"Add support for MariaDB to OpenJPA, including a new DBDictionary and documentation update.",,,,,,,,,,,,,,,,,,,19/Jul/13 18:52;dlau;OPENJPA-2400-fix.patch;https://issues.apache.org/jira/secure/attachment/12593227/OPENJPA-2400-fix.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-07-10 15:43:19.517,,,no_permission,,,,,,,,,,,,333225,,,Fri Jul 19 19:58:36 UTC 2013,,,,,,,0|i1lhfb:,333553,,,,,,,,"10/Jul/13 15:43;jira-bot;Commit 1501805 from [~fyrewyld]
[ https://svn.apache.org/r1501805 ]

OPENJPA-2400: MariaDB support",19/Jul/13 18:52;dlau;Fixed the solidDB failure on MariaDB and MySQL test cases in TestDynamicSchemas with the help from Joe and Albert. Attached is the patch for this change. Changes made to DBDictionaryFactory.java and TestDynamicSchemas.java.,"19/Jul/13 19:58;jira-bot;Commit 1504985 from [~fyrewyld] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1504985 ]

OPENJPA-2400: MariaDB DBDictionaryFactory update",,,,,,,,,,,,,,,,,,,,,,,,
HSQLDB v2.2.9,OPENJPA-2391,12650354,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,puntogil,puntogil,31/May/13 15:16,06/Jun/15 21:19,14/Mar/19 03:03,24/Jun/13 17:33,,,,,,,,,2.3.0,,,,,jdbc,,,,0,,,,,,,,"hi 
any plan for port jdbc module to hsqldb to latest 2.x series?
i have this problem:
org.apache.openjpa.jdbc.sql.HSQLDictionary.java, the referenced class
is org.hsqldb.Trace. Trace used to contain various error codes, amidst
others VIOLATION_OF_UNIQUE_INDEX . Some of the old error codes in
Trace were ported to the class org.hsqldb.error.ErrorCode in newer
versions of HSQLDB, but VIOLATION_OF_UNIQUE_INDEX is not among them.
any ideas?
thanks in advance for every suggestion","OpenJDK Runtime Environment (fedora-2.3.9.5.fc18-i386)
OpenJDK Server VM (build 23.7-b01, mixed mode)
Apache Maven 3.0.4 (rNON-CANONICAL_2013-04-08_07-49_mockbuild; 2013-04-08 09:49:23+0200)
Maven home: /usr/share/maven
Java version: 1.7.0_19, vendor: Oracle Corporation
Java home: /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.19/jre
Default locale: it_IT, platform encoding: UTF-8
OS name: ""linux"", version: ""3.9.2-200.fc18.i686"", arch: ""i386"", family: ""unix""",,,,,,,,,,,,,,,,,,24/Jun/13 18:12;dlau;OPENJPA-2391.patch;https://issues.apache.org/jira/secure/attachment/12589453/OPENJPA-2391.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-06-19 20:20:20.104,,,no_permission,,,,,,,,,,,,330681,,,Mon Jun 24 19:03:19 UTC 2013,,,,,,,0|i1l1sn:,331015,,,,,,,,19/Jun/13 20:20;dlau;Does anyone have objections to upgrade from hsql 1.x to 2.x?,"24/Jun/13 17:23;jira-bot;Commit 1496128 from allee8285@apache.org
[ https://svn.apache.org/r1496128 ]

OPENJPA-2391 - commit patch contributed by Di Lau.","24/Jun/13 17:58;dlau;VIOLATION_OF_UNIQUE_INDEX is combined with VIOLATION_OF_UNIQUTE_CONTRAINT in org.hsqldb.error.ErrorCode. The integer value for both of them is 104 now. Attached is the patch for this fix. 
Thank you.","24/Jun/13 19:03;puntogil;thanks!
regards",,,,,,,,,,,,,,,,,,,,,,,
HSQLDB SELECT NEXT VALUE FOR Sequence will skip 1 sequence value if allocation size is 1,OPENJPA-2390,12649901,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,rene.link,rene.link,29/May/13 12:40,06/Jun/15 21:19,14/Mar/19 03:03,24/Jun/13 17:11,2.2.1,,,,,,,,2.3.0,,,,,jdbc,,,,0,,,,,,,,"The HSQLDictionary sets the DBDictionary.nextSequenceQuery to ""SELECT NEXT VALUE FOR {0} FROM INFORMATION_SCHEMA.SYSTEM_SEQUENCES"" when the HSQLDictionary is initialized.

The NativeJDBCSeq uses
 _select = MessageFormat.format(format, new Object[]{name, String.valueOf(_allocate * _increment)});
to build the select next value sql. The format is pased 2 arguments ""name"" and ""_allocate * _increment""
but the second is not honored by the nextSequenceQuery.

So when the allocation size is set to 1 the hsqldb nextSequenceQuery statement will return 2 next values
anyway. That is why always one next value will be skipped... 1, 3, 5, 7, and so on.

The nextSequenceQuery should be set with an limit. E.g.
""SELECT NEXT VALUE FOR {0} FROM INFORMATION_SCHEMA.SYSTEM_SEQUENCES LIMIT {1}""

I will attatch an unit test that uses in memory hsqldb to show the problem soon.",,,,,,,,,,,,,,,,,,,29/May/13 12:41;rene.link;HSQLSequenceTest.java;https://issues.apache.org/jira/secure/attachment/12585191/HSQLSequenceTest.java,19/Jun/13 19:52;dlau;OPENJPA-2390.patch;https://issues.apache.org/jira/secure/attachment/12588671/OPENJPA-2390.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2013-06-19 19:52:03.384,,,no_permission,,,,,,,,,,,,330228,,,Mon Jun 24 17:05:05 UTC 2013,,,Patch Available,,,,0|i1kz07:,330562,,,,,,,,29/May/13 12:41;rene.link;The attatched tests shows the problem I described in the Issue.,"19/Jun/13 19:52;dlau;Problem is fixed by adding LIMIT 1 to the nextSequenceQuery String in HSQLDictionary. This force the sequence to hand back only 1 value at a time. 

Any version that is lower than 2.1.0 does not need to add LIMIT 1. The older versions do not have the skipping problem.

To make the code more compatible, I added some conditions in HSQLDictionary to check the HSQL versions so that only version 2.1.0 and beyond will add LIMIT 1 to the nextSequenceQuery.

Uploadded is my patch file. In this file, I added two test cases that use allocationSize=1 and allocationSize=2 to demonstrate the problem.

Thanks.
","24/Jun/13 17:05;jira-bot;Commit 1496124 from allee8285@apache.org
[ https://svn.apache.org/r1496124 ]

OPENJPA-2390 - commit patch contributed by Di Lau.",,,,,,,,,,,,,,,,,,,,,,,,
Rendering criteria query to JPQL-like string ignores multiple GROUP BY clauses,OPENJPA-2384,12648936,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,22/May/13 17:39,06/Jun/15 21:19,14/Mar/19 03:03,22/May/13 17:42,,,,,,,,,2.3.0,,,,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,329265,,,Wed May 22 17:42:01 UTC 2013,,,,,,,0|i1kt3j:,329603,,,,,,,,"22/May/13 17:40;ppoddar@apache.org;this issue was fixed with following revision without a JIRA.

r1456576 | ppoddar | 2013-03-14 10:59:17 -0700 (Thu, 14 Mar 2013) | 1 line

Simple change to stringify a collection of values with proper spaces",22/May/13 17:42;ppoddar@apache.org;see revision r1456576 (that was not referred to an issue).,,,,,,,,,,,,,,,,,,,,,,,,,
Update serp to 1.15.1,OPENJPA-2381,12647764,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,fyrewyld,ddamours,ddamours,15/May/13 15:13,21/Sep/16 20:17,14/Mar/19 03:03,24/Nov/14 19:43,2.2.2,,,,,,,,2.2.3,2.4.0,,,,Enhance,,,,0,,,,,,,,"There is a new version 1.14.2 of Serp that appears to fix OPENJPA-888 (https://issues.apache.org/jira/browse/OPENJPA-888).

Would it be possible to update to 1.14.2 in OpenJPA?

Serp 1.14.2 : http://serp.cvs.sourceforge.net/viewvc/serp/serp/
Also: http://openjpa.apache.org/publishing-serp-to-maven-central-repository.html
",,,,,,,,,,,,,,OPENJPA-2386,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-05-15 16:30:48.732,,,no_permission,,,,,,,,,,,,328120,,,Mon Nov 24 19:42:43 UTC 2014,,,,,,,0|i1km2n:,328464,,,,,,,,"15/May/13 16:30;kwsutter;Version 1.14.2 of Serp is actually ""trunk"".  Trunk is the current snapshot for 1.14.2.  So, pulling in a new version of ""Serp 1.14.2"" is not as easy as it sounds, unfortunately.  This would require someone creating a new Serp release (not sure of the process) and then pulling it into the OpenJPA trunk.  Pulling in a new/updated dependency into an OpenJPA service stream can be dangerous.  In this case, maybe it could be considered a simple bug fix (moving from 1.14.1 to 1.14.2).  I just looked at the source and here's the simple change that is in 1.14.2 that corrects the issue:

    public Instruction getEnd() {
        if (_end != null)
            return _end;
        int idx = _target.getByteIndex() + _length;
        Instruction end = getCode().getInstruction(idx);
        if (end != null && (end.prev instanceof Instruction)) {  // updated
             return (Instruction) end.prev;                               // new
        }
        return getCode().getLastInstruction();
    }
","08/Oct/14 15:21;fyrewyld;My upcoming changes to Serp to support Java 8 Lambdas will be going into the next Serp release, so we'll need to get the release process figured out in short order.  Will use this JIRA to deliver my SERP changes.","15/Oct/14 18:04;jira-bot;Commit 1632148 from [~fyrewyld] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1632148 ]

OPENJPA-2381: Upgrade Serp to 1.15.0","15/Oct/14 18:05;fyrewyld;Published Serp 1.15.0, updated trunk to consume it.","24/Nov/14 17:14;jira-bot;Commit 1641426 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1641426 ]

OPENJPA-2381: Update SERP to 1.15.1 [JDK 8]","24/Nov/14 18:49;jira-bot;Commit 1641442 from [~fyrewyld] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1641442 ]

OPENJPA-2381: Update serp to 1.15.1","24/Nov/14 19:42;jira-bot;Commit 1641452 from [~fyrewyld] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1641452 ]

OPENJPA-2381: Update serp to 1.15.1",,,,,,,,,,,,,,,,,,,,
TestHandlerStrategy.testIssue_OPENJPA2328 failed with Oracle,OPENJPA-2378,12646130,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,05/May/13 16:45,05/Aug/13 19:23,14/Mar/19 03:03,05/Aug/13 19:22,2.3.0,,,,,,,,2.3.0,,,,,jpa,,,,0,,,,,,,,"TestHandlerStrategy was introduced in OPENJPA-2328. This passed in Derby but failed when run against Oracle and yielded the following error.

     73   <testcase time=""0.443"" classname=""org.apache.openjpa.persistence.jdbc.strategy.TestHandlerStrategy"" name=""testIssue_OPENJPA2328"">
     74     <error message=""The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred."" type=""&lt;openjpa-2.3.0-SNAPSHOT-r422266"">&lt;openjpa-2.3.0-SN        APSHOT-r422266:1447955 fatal store error&gt; org.apache.openjpa.persistence.RollbackException: The transaction has been rolled back.  See the nested exceptions for details on the errors tha        t occurred.
     75 FailedObject: org.apache.openjpa.persistence.jdbc.strategy.MappedEntity@3b5ad1da
     76   at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:594)
     77   at org.apache.openjpa.persistence.jdbc.strategy.TestHandlerStrategy.testIssue_OPENJPA2328(TestHandlerStrategy.java:46)
     78   at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
 ....
    108 Caused by: &lt;openjpa-2.3.0-SNAPSHOT-r422266:1447955 fatal general error&gt; org.apache.openjpa.persistence.PersistenceException: The transaction has been rolled back.  See the nested exce        ptions for details on the errors that occurred.
    109 FailedObject: org.apache.openjpa.persistence.jdbc.strategy.MappedEntity@3b5ad1da
    110   at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2341)
    111   at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2178)
    112   at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2076)
    113   at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1994)
    114   at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
    115   at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1518)
    116   at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:933)
    117   at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:570)
    118   ... 31 more
    119 Caused by: &lt;openjpa-2.3.0-SNAPSHOT-r422266:1447955 fatal store error&gt; org.apache.openjpa.persistence.EntityExistsException: ORA-01400: cannot insert NULL into (&quot;SCOTT&quot;.&quot        ;MAPPEDENTITY&quot;.&quot;ID&quot;)
    120  {prepstmnt 1311769641 INSERT INTO MappedEntity (value) VALUES (?)} [code=1400, state=23000]
    121 FailedObject: org.apache.openjpa.persistence.jdbc.strategy.MappedEntity@3b5ad1da
    122   at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4935)
    123   at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4910)
    124   at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:136)
    125   at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:78)
    126   at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:144)
    127   at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushAndUpdate(BatchingPreparedStatementManagerImpl.java:79)
    128   at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:100)
    129   at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:88)
    130   at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:550)
    131   at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:106)
    132   at org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager.flush(BatchingConstraintUpdateManager.java:59)
    133   at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:105)
    134   at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:78)
    135   at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:732)
    136   at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:131)
    137   ... 38 more
    138 Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: ORA-01400: cannot insert NULL into (&quot;SCOTT&quot;.&quot;MAPPEDENTITY&quot;.&quot;ID&quot;)
    139  {prepstmnt 1311769641 INSERT INTO MappedEntity (value) VALUES (?)} [code=1400, state=23000]
    140   at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:219)
    141   at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:195)
    142   at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$1000(LoggingConnectionDecorator.java:59)
    143   at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:1134)
    144   at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:275)
    145   at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:275)
    146   at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.executeUpdate(PreparedStatementManagerImpl.java:268)
    147   at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:119)
    148   ... 48 more
",,,,,,,,,,,,,,,,,,,05/Aug/13 16:39;dlau;OPENJPA-2378.patch;https://issues.apache.org/jira/secure/attachment/12596146/OPENJPA-2378.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-08-05 16:39:37.105,,,no_permission,,,,,,,,,,,,326488,,,Mon Aug 05 19:15:53 UTC 2013,,,,,,,0|i1kbqf:,326833,,,,,,,,"05/Aug/13 16:39;dlau;Attached is the patch for this problem. Oracle does not support auto assign and therefore, I added if statement to check for this support in testHandlerStratety to exclude oracle. ","05/Aug/13 19:15;jira-bot;Commit 1510667 from [~allee8285] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1510667 ]

OPENJPA-2378 - Fix test case to run test only if supportsAutoAssign is enabled. Contributed by Di Lau",,,,,,,,,,,,,,,,,,,,,,,,,
Metamodel.managedType returns wrong result for Embeddable,OPENJPA-2377,12644570,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,azuo_lee,azuo_lee,25/Apr/13 10:15,06/Jun/15 21:19,14/Mar/19 03:03,14/May/13 16:28,,,,,,,,,2.3.0,,,,,,,,,0,,,,,,,,"I use the following code to dynamically determine if a class is an embeddable:

Class c = Class.forName(s);
ManagedType type = metamodel.managedType(c);
if (type.getPersistenceType() == Type.PersistenceType.EMBEDDABLE) {
     logger.debug("""" + c + "" is an Embeddable."");
     // do somthing with the embeddable
}
else if (type.getPersistenceType() == Type.PersistenceType.ENTITY) {
     logger.debug("""" + c + "" is an Entity."");
     // do somthing with the entity
}

but when I use this code for an Embeddable, I always get ""xxx is an Entity"" logged.

After examining the source code, I found ""MetamodelImpl.instantiate"" method will always put embeddable to both ""embeddables"" and ""entities"" containers, but ""MetamodelImpl.managedType"" method will first search ""entities"" and then ""embeddables"" for a persistence class, thus, ""Entity"" type will be returned for a ACTUAL Embeddable class.

Hope this can be fixed.",,,,,,,,,,,,,,,,,,,03/May/13 21:41;allee8285;OPENJPA-2377.trunk.patch;https://issues.apache.org/jira/secure/attachment/12581753/OPENJPA-2377.trunk.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-05-03 21:41:44.916,,,no_permission,,,,,,,,,,,,324935,,,Tue May 14 16:28:19 UTC 2013,,,,,,,0|i1k25r:,325280,,,,,,,,"03/May/13 21:41;allee8285;This patch fixed the reported problem. 

While investigating the problem, due to meta model implementation, we have identified the getEntities and getManagedTypes return more entries than expected if embeddable is used.  This patch also fix these problems as well.","03/May/13 21:43;allee8285;Azuo,

Can you apply the patch and verify if this resolve your problem.

Thanks,
Albert Lee.","14/May/13 12:28;azuo_lee;The patch works fine for my code. Thanks.

P.S. Should I resolve and close the issure right now, or it will be closed automatically (or by you?) after the patch is committed?","14/May/13 16:28;allee8285;Azuo,  I have resolved the issue and you can close the JIRA when you feel it has resolved your problem.",,,,,,,,,,,,,,,,,,,,,,,
Avoid OID creation in BrokerImpl.isDetached when lookup is not required.,OPENJPA-2374,12644134,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,helenxu,helenxu,helenxu,23/Apr/13 15:00,06/Jun/15 21:19,14/Mar/19 03:03,05/Feb/14 22:19,2.2.1,2.3.0,,,,,,,2.3.0,,,,,kernel,,,,0,,,,,,,,The OID creation in BrokerImpl.isDetached could be avoided when the lookup is not required. This could improve the performance.,,,,,,,,,,,,,,,,,,,23/Apr/13 15:01;helenxu;OPENJPA2374.patch;https://issues.apache.org/jira/secure/attachment/12580056/OPENJPA2374.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-04-23 19:44:10.439,,,no_permission,,,,,,,,,,,,324501,,,Tue Apr 23 19:44:10 UTC 2013,,,Patch Available,,,,0|i1jzhb:,324846,,,,,,,,"23/Apr/13 19:44;jira-bot;Commit 1471113 from helenxu
[ https://svn.apache.org/r1471113 ]

OPENJPA-2374: avoid OID creation when the lookup is not required.",,,,,,,,,,,,,,,,,,,,,,,,,,
duplicate call to getUnloadedInternal function,OPENJPA-2369,12642602,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,helenxu,helenxu,helenxu,15/Apr/13 20:02,06/Jun/15 21:19,14/Mar/19 03:03,05/Feb/14 22:20,2.2.1,2.2.3,,,,,,,2.3.0,,,,,kernel,,,,0,,,,,,,,"in StateManagerImpl.loadField, it called the getUnloadedInternal twice which could be eliminated to improve performance.",,,,,,,,,,,,,,,,,,,15/Apr/13 20:06;helenxu;OPENJPA2369.patch;https://issues.apache.org/jira/secure/attachment/12578800/OPENJPA2369.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-04-16 18:05:03.563,,,no_permission,,,,,,,,,,,,323016,,,Tue Apr 16 18:05:03 UTC 2013,,,Patch Available,,,,0|i1jqbr:,323361,,,,,,,,15/Apr/13 20:39;helenxu;This duplicate calls happen when changing a field of an entity which triggers the invocation of StateManagerImpl.dirty.,"16/Apr/13 18:05;jira-bot;Commit 1468536 from helenxu
[ https://svn.apache.org/r1468536 ]

OPENJPA-2369, eliminate the duplicate call to getUnloadedInternal function.",,,,,,,,,,,,,,,,,,,,,,,,,
@..ToMany(optional=false) throws InvalidStateException: [...] the metadata for this field specifies that nulls are illegal.,OPENJPA-2357,12638547,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,curtisr7,gchauvet,gchauvet,22/Mar/13 17:31,06/Jun/15 21:19,14/Mar/19 03:03,26/Mar/13 12:44,2.2.0,2.2.1,,,,,,,2.3.0,,,,,kernel,,,,0,,,,,,,,"Hi,

We have discovered a bug in OpenJPA when InverseManager is used with collection annoted @toMany([...], optional = false). OpenJPA doesn't solve inverse relations before calling the internal preflush method.

This bug does not exist on versions 2.1.0 and 2.1.1.

A unitary test and a small patch is worth a thousand words ;) [1]

[1] Patch successfully tested on OpenJPA 2.2.1 and in our software.

Regards,
",,,,,,,,,,,,,,,,,,,22/Mar/13 17:37;gchauvet;OPENJPA-22357.zip;https://issues.apache.org/jira/secure/attachment/12575051/OPENJPA-22357.zip,22/Mar/13 17:37;gchauvet;OPENJPA-2357.patch;https://issues.apache.org/jira/secure/attachment/12575050/OPENJPA-2357.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2013-03-26 12:43:34.173,,,no_permission,,,,,,,,,,,,319023,,,Tue Mar 26 12:44:24 UTC 2013,,,Patch Available,,,,0|i1j1o7:,319364,,,,,,,,"26/Mar/13 12:43;jira-bot;Commit 1461090 from curtisr7
[ https://svn.apache.org/r1461090 ]

OPENJPA-2357: Fix InvalidStateException when using the InverseManager. Fix contributed by Guillaume Chauvet.",26/Mar/13 12:44;curtisr7;Committed revision 1461090 to trunk. Thanks for the patch Guillaume!,,,,,,,,,,,,,,,,,,,,,,,,,
CONCAT() function must support more than two arguments,OPENJPA-2355,12638102,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,20/Mar/13 22:50,06/Jun/15 21:19,14/Mar/19 03:03,28/Mar/13 15:21,,,,,,,,,2.3.0,,,,,,,,,0,,,,,,,,"CONCAT() query expression currently only takes exactly two input arguments. Must allow for more than 2 arguments because JPA spec says so.
functions_returning_strings ::= CONCAT(string_primary, string_primary {, string_primary}*)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-03-20 22:52:29.027,,,no_permission,,,,,,,,,,,,318580,,,Mon Jul 22 22:38:25 UTC 2013,,,,,,,0|i1iyxr:,318921,,,,,,,,"20/Mar/13 22:52;jira-bot;Commit 1459091 from [~ppoddar@apache.org]
[ https://svn.apache.org/r1459091 ]

OPENJPA-2355: Allow more than two input argument to CONCAT()","17/Jul/13 21:18;jira-bot;Commit 1504282 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1504282 ]

OPENJPA-2355: Made changes to localizer.properties files to update the message previously added by this JIRA.","22/Jul/13 22:27;jira-bot;Commit 1505837 from [~jpaheath] in branch 'openjpa/branches/2'
[ https://svn.apache.org/r1505837 ]

OPENJPA-2355: Allow more than two input argument to CONCAT() - back ported to 2.1.x Pinaki Poddar's trunk changes.","22/Jul/13 22:35;jira-bot;Commit 1505839 from [~jpaheath] in branch 'openjpa/branches/2'
[ https://svn.apache.org/r1505839 ]

OPENJPA-2355: Allow more than two input argument to CONCAT() - back ported to 2.2.1.x Pinaki Poddar's trunk changes.","22/Jul/13 22:38;jira-bot;Commit 1505840 from [~jpaheath] in branch 'openjpa/branches/2'
[ https://svn.apache.org/r1505840 ]

OPENJPA-2355: Allow more than two input argument to CONCAT() - back ported to 2.2.x Pinaki Poddar's trunk changes.",,,,,,,,,,,,,,,,,,,,,,
Version field returns null when explicity projected from a JOIN in SELECT clause,OPENJPA-2343,12634822,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,hkelsey,hkelsey,01/Mar/13 14:56,06/Jun/15 21:19,14/Mar/19 03:03,17/Oct/13 22:30,2.2.1,2.3.0,,,,,,,2.1.2,2.2.1.1,2.2.3,2.3.0,,query,,,,0,,,,,,,,"With these entities: 

@Entity
public class Foo {
    private int id;
    private int version;
    @Id
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}

	public void setVersion(int version) {
		this.version = version;
	}	
	@Version
	public int getVersion() {
		return this.version;
	}
}

@Entity
public class Bar{
	private int id;
	private Foo foo;
    @Id
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
    public void setFoo(Foo foo) {
        this.foo = foo;
    }
    @ManyToOne
    public Foo getFoo() {
        return foo;
    }
}
Insert a record for each associating foo with bar.

Foo foo = new Foo();
em.getTransaction().begin(); 
em.persist(foo); 
Bar bar = new Bar();
bar.setFoo(foo);
em.persist(bar);
em.getTransaction().commit(); 
em.close(); 

queries 

select bar.id as id, foo as foo from Bar bar join bar.foo foo
The version field is available via foo.getVersion()

select bar.id as id, foo.version as version from Bar bar join bar.foo foo
version is always null.

By enabling the jdbc debug I can see that the actual SQL being run is correct but the value is just not hydrated.",,,,,,,,,,,,,,OPENJPA-662,,,,,05/Mar/13 11:28;hkelsey;OPENJPA-2343-2.2.1.x.patch;https://issues.apache.org/jira/secure/attachment/12572075/OPENJPA-2343-2.2.1.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-10-17 19:14:41.364,,,no_permission,,,,,,,,,,,,315315,,,Thu Oct 17 19:59:00 UTC 2013,,,Patch Available,,,,0|i1ietb:,315659,,,,,,,,"17/Oct/13 19:14;jira-bot;Commit 1533218 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1533218 ]

OPENJPA-2343: Version field returns null when explicity projected from a JOIN in SELECT clause - based fix off of patch provided by Howard Kelsey.","17/Oct/13 19:23;jira-bot;Commit 1533222 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1533222 ]

OPENJPA-2343: Version field returns null when explicity projected from a JOIN in SELECT clause - based fix off of patch provided by Howard Kelsey.  Merged 2.1.x commit to 2.2.1.x.","17/Oct/13 19:31;jira-bot;Commit 1533223 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1533223 ]

OPENJPA-2343: Version field returns null when explicity projected from a JOIN in SELECT clause - based fix off of patch provided by Howard Kelsey.  Merged 2.2.1.x commit to 2.2.x.","17/Oct/13 19:46;jira-bot;Commit 1533227 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1533227 ]

OPENJPA-2343: Version field returns null when explicity projected from a JOIN in SELECT clause - based fix off of patch provided by Howard Kelsey.  Merged 2.2.x commit to trunk.","17/Oct/13 19:59;jira-bot;Commit 1533235 from [~jpaheath] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1533235 ]

OPENJPA-2343: Version field returns null when explicity projected from a JOIN in SELECT clause - based fix off of patch provided by Howard Kelsey.  Merged 2.2.x commit to 2.3.x.",,,,,,,,,,,,,,,,,,,,,,
Relax Join column name comparison based on database dictionary schema case setting ,OPENJPA-2336,12633087,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,ppoddar@apache.org,ppoddar@apache.org,19/Feb/13 22:29,06/Jun/15 21:19,14/Mar/19 03:03,28/Mar/13 15:22,,,,,,,,,2.3.0,,,,,,,,,0,,,,,,,,Name of join column name comparison should allow schema case set in database dictionary,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-02-19 22:30:36.6,,,no_permission,,,,,,,,,,,,313583,,,Wed Feb 20 18:11:54 UTC 2013,,,,,,,0|i1i44n:,313928,,,,,,,,"19/Feb/13 22:30;jira-bot;Commit 1447945 from [~ppoddar@apache.org]
[ https://svn.apache.org/r1447945 ]

OPENJPA-2336: Consider database dictionary schema case while matching join column name","20/Feb/13 18:11;jpaheath;For the sake of history, and to make it absolutely clear, in addition to this fix one may need to set DBDictionary.schemaCase as appropriate for the use case.  E.g.:

<property name=""openjpa.jdbc.DBDictionary"" value=""schemaCase=upper""/>

As another example, take this Column definition:

@Column(name=""MYCOL#"")
@Id

and assume we use a different case when referred as a join column:

@JoinColumn(name=""hpnum"", referencedColumnName=""mycol#"")

Given the referencedColumnName is a different case than the actual column, OpenJPA will not find the column.  To resolve this, one must have the fix of this JIRA, as well as setting the DBDictionary.schemaCase.",,,,,,,,,,,,,,,,,,,,,,,,,
Constrained foreign key column value setting needs to be flexible ,OPENJPA-2335,12633067,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,19/Feb/13 20:27,06/Jun/15 21:19,14/Mar/19 03:03,18/Nov/13 05:42,,,,,,,,,2.3.0,,,,,,,,,0,,,,,,,,Should allow setting a column from default value to a non-default value. The logic had a bug.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-02-19 20:33:15.418,,,no_permission,,,,,,,,,,,,313563,,,Mon Mar 16 21:45:45 UTC 2015,,,,,,,0|i1i407:,313908,,,,,,,,"19/Feb/13 20:33;jira-bot;Commit 1447906 from [~ppoddar@apache.org]
[ https://svn.apache.org/r1447906 ]

OPENJPA-2335: Set non-default value to a foreign key contrained column","03/Nov/13 21:19;struberg;The change seems broken, it makes a few of my apps blow up.

I do not really get the whole change. The bug description doesn't tell me why this change got done and there is also no unit test for this change to tell me what you did like to fix. 

I can give you my use case which is now broken

Car -> n Inspections
with @OrderColumn(name = ""POSITION"")

Car c = new Car();
Inspection i1 = new Inspection(1, c); //Inspection adds itself to car.inspections
Inspection i2 = new Inspection(2, c);
em.persist(c).

This currently blurps out with 

Caused by: <openjpa-2.3.0-r422266:1538090M fatal user error> org.apache.openjpa.persistence.InvalidStateException: Attempt to set column ""Inspection.POSITION"" to two different values: (class java.lang.Integer)""1"", (class java.lang.Integer)""0"" This can occur when you fail to set both sides of a two-sided relation between objects, or when you map different fields to the same column, but you do not keep the values of these fields in synch.
        at org.apache.openjpa.jdbc.sql.PrimaryRow.setObject(PrimaryRow.java:344)
        at org.apache.openjpa.jdbc.sql.RowImpl.setInt(RowImpl.java:442)
        at org.apache.openjpa.jdbc.meta.strats.PrimitiveFieldStrategy.update(PrimitiveFieldStrategy.java:164)
        at org.apache.openjpa.jdbc.meta.strats.PrimitiveFieldStrategy.insert(PrimitiveFieldStrategy.java:124)
        at org.apache.openjpa.jdbc.meta.FieldMapping.insert(FieldMapping.java:623)
        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.insert(AbstractUpdateManager.java:238)
        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.populateRowManager(AbstractUpdateManager.java:165)
        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:96)
        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:77)


It seems that the @OrderColumn is the issue in this case. Your change looks fine for primary keys, but OrderColumns and all other stuff which gets auto-managed by OpenJPA also use the same code. 

Maybe we should only do these checks in case of real primary or foreign keys?

","03/Nov/13 21:28;jira-bot;Commit 1538463 from [~struberg]
[ https://svn.apache.org/r1538463 ]

rollback of openjpa 2.3.0 release

We first need to fix OPENJPA-2335 before we can continue","04/Nov/13 00:01;jira-bot;Commit 1538480 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1538480 ]

OPENJPA-2335 add a unit test for demonstrating the bug","04/Nov/13 00:12;struberg;The issue happens if an @OrderColumn on the @OneToMany side references a (read-only) attribute in the entity. I'm not really sure if this is allowed by the spec though: 
"" The order column is not visible as part of the state of the entity or embeddable class.""

It used to work without problems in openjpa-2.2.2 though. 

This also seems to work fine in hibernate
http://stackoverflow.com/questions/2956171/jpa-2-0-ordercolumn-annotation-in-hibernate-3-5

","09/Nov/13 08:21;jira-bot;Commit 1540277 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1540277 ]

OPENJPA-2335 only handle key columns very restrictive

There is no reason to forbid updates to other Columns like OrderColumn, etc","09/Nov/13 19:26;jira-bot;Commit 1540371 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1540371 ]

OPENJPA-2335 review test case and update checks","16/Mar/15 21:45;jira-bot;Commit 1667136 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1667136 ]

OPENJPA-2335 only handle key columns very restrictive

There is no reason to forbid updates to other Columns like OrderColumn, etc
Ported over from 2.3.x",,,,,,,,,,,,,,,,,,,
OpenJPA must support processing puRoot & jar-file URLs as jar-formatted InputStreams,OPENJPA-2334,12632301,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,fyrewyld,fyrewyld,13/Feb/13 23:02,24/Feb/13 19:59,14/Mar/19 03:03,24/Feb/13 19:59,2.2.2,2.3.0,,,,,,,2.2.2,2.3.0,,,,jpa,,,,0,,,,,,,,"TheJPA Specification states in the javadoc for javax.persistence.spi.PersistenceUnitInfo methods getJarFileUrls() and getPersistenceUnitRootUrl():

""A URL will either be a file: URL referring to a jar file or referring to a directory that contains an exploded jar file, or some other URL from which an InputStream in jar format can be obtained.""

Currently the method OpenJPA uses to identify PCTypes does not completely meet the specification requirements, and needs to be adapted to support non-file/jar URLs that provide jar-formatted InputStreams.",,,,,,,,,,,,,,,,,,,13/Feb/13 23:04;fyrewyld;openjpa-2.2.x-urljarinput-02132013.patch;https://issues.apache.org/jira/secure/attachment/12569283/openjpa-2.2.x-urljarinput-02132013.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-02-19 20:31:49.164,,,no_permission,,,,,,,,,,,,312797,,,Tue Feb 19 20:31:49 UTC 2013,,,Patch Available,,,,0|i1hza7:,313143,,,,,,,,15/Feb/13 02:39;fyrewyld;Commits r1446295 for 2.2.x and 1446294 for trunk.,19/Feb/13 20:31;ppoddar@apache.org;The patch has some hardcoded error messages. They should be localized.,,,,,,,,,,,,,,,,,,,,,,,,,
Stackoverflow due to endless recursive calls,OPENJPA-2330,12631234,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,curtisr7,gchauvet,gchauvet,07/Feb/13 11:03,06/Jun/15 21:19,14/Mar/19 03:03,05/Nov/13 18:03,2.2.0,2.2.1,,,,,,,2.1.2,2.2.1.1,2.2.3,2.3.0,,validation,,,,0,,,,,,,,"We wish to report another bug that generates a memory overflow resulting in an infinite recursive loop. Here are two stacktraces apparently from the same bug:

First stacktrace sample :
================================================
Exception in thread ""AWT-EventQueue-0"" java.lang.StackOverflowError
	at java.util.LinkedHashMap$KeyIterator.<init>(LinkedHashMap.java:383)
	at java.util.LinkedHashMap$KeyIterator.<init>(LinkedHashMap.java:383)
	at java.util.LinkedHashMap.newKeyIterator(LinkedHashMap.java:396)
	at java.util.HashMap$KeySet.iterator(HashMap.java:874)
	at java.util.HashSet.iterator(HashSet.java:153)
	at org.apache.openjpa.util.java$util$LinkedHashSet$proxy.iterator(Unknown Source)
	at java.util.AbstractCollection.toArray(AbstractCollection.java:120)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedCollection(OpenJPAPersistenceUtil.java:240)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedField(OpenJPAPersistenceUtil.java:212)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoaded(OpenJPAPersistenceUtil.java:161)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedArray(OpenJPAPersistenceUtil.java:265)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedCollection(OpenJPAPersistenceUtil.java:242)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedField(OpenJPAPersistenceUtil.java:212)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoaded(OpenJPAPersistenceUtil.java:161)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedField(OpenJPAPersistenceUtil.java:223)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoaded(OpenJPAPersistenceUtil.java:161)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedField(OpenJPAPersistenceUtil.java:223)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoaded(OpenJPAPersistenceUtil.java:161)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedArray(OpenJPAPersistenceUtil.java:265)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedCollection(OpenJPAPersistenceUtil.java:242)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedField(OpenJPAPersistenceUtil.java:212)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoaded(OpenJPAPersistenceUtil.java:161)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedField(OpenJPAPersistenceUtil.java:223)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoaded(OpenJPAPersistenceUtil.java:161)
[...]

Second stacktrace sample :
================================================
Exception in thread ""AWT-EventQueue-0"" java.lang.StackOverflowError
	at java.util.HashMap$EntrySet.size(HashMap.java:963)
	at org.apache.openjpa.util.ProxyMaps$ProxyEntrySetImpl.size(ProxyMaps.java:255)
	at java.util.AbstractCollection.toArray(AbstractCollection.java:119)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedMap(OpenJPAPersistenceUtil.java:288)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedField(OpenJPAPersistenceUtil.java:215)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoaded(OpenJPAPersistenceUtil.java:161)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedArray(OpenJPAPersistenceUtil.java:265)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedCollection(OpenJPAPersistenceUtil.java:242)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedField(OpenJPAPersistenceUtil.java:212)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoaded(OpenJPAPersistenceUtil.java:161)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedArray(OpenJPAPersistenceUtil.java:265)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedCollection(OpenJPAPersistenceUtil.java:242)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedField(OpenJPAPersistenceUtil.java:212)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoaded(OpenJPAPersistenceUtil.java:161)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedField(OpenJPAPersistenceUtil.java:223)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoaded(OpenJPAPersistenceUtil.java:161)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoadedField(OpenJPAPersistenceUtil.java:223)
	at org.apache.openjpa.persistence.OpenJPAPersistenceUtil.isLoaded(OpenJPAPersistenceUtil.java:161)
[...]
",,,,,,,,,,,,,,,,,,,11/Feb/13 15:29;gchauvet;OPENJPA-2330.zip;https://issues.apache.org/jira/secure/attachment/12568833/OPENJPA-2330.zip,20/Feb/13 23:08;curtisr7;openjpa-2330.jar;https://issues.apache.org/jira/secure/attachment/12570205/openjpa-2330.jar,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2013-02-07 14:53:12.392,,,no_permission,,,,,,,,,,,,311730,,,Tue Nov 05 18:01:17 UTC 2013,,,,,,,0|i1hsp3:,312076,,,,,,,,"07/Feb/13 14:53;kwsutter;Hi,
Can you give some more details on your environment and the scenario that is causing this failure?  I can see where it looks like a potential issue with the PersistenceUtils, but what was the user scenario that got you into this mess?  We have some tests (junit, functional, cts) that utilize the PersistenceUtils.  We would need some more information, preferably a junit, in order to recreate the error.  Thanks!","08/Feb/13 11:07;gchauvet;Hello,

So sorry I was not able to provide you with more detailed information from the start, but unfortunately I didn't have the time yesterday as we are approaching deadline for release of new software.
I am working on creating a unit test, however I will not be able to provide it straight away as I haven't been able to reproduce the bug, even though our software crashes systematically.
So I think I will first create a patch for our version of OpenJPA to rectify the problem, then generate the unit test(s), as with the last bug report I made.

The environment we use is OpenJPA 2.2.1 in a thick client Swing (JRE 1.6_39 64 bits). We operate an Apache Derby 10.8.2.2 database in client/server mode.
Belowlisted the scenario in which the problematic memory overflow occurs in our application:
 
Prerequisites:
==========
- 3 classes of entities ""EntityA"", ""EntityB"", ""EntityC""
- bidirectional navigation between classes:
                - Cardinality OneToMany between EntityA and EntityB with the following parameters: fetch = FetchType.EAGER, mappedBy = ""entitya"", orphanRemoval = true, cascade = CascadeType.ALL
                - Cardinality OneToMany between EntityB and EntityC with the following parameters: fetch = FetchType.EAGER, mappedBy = ""entityb"", orphanRemoval = true, cascade = CascadeType.ALL
                - EntityC is associated with alot of other tables, which I won't list for now.
 
 
Parameterization of OpenJPA:
==========
<properties>
        <property name=""openjpa.InverseManager"" value=""true""/>
        <property name=""openjpa.RuntimeUnenhancedClasses"" value=""supported""/>
        <property name=""openjpa.jdbc.SchemaFactory"" value=""native(ForeignKeys=true)""/>
        <property name=""openjpa.jdbc.MappingDefaults"" value=""ForeignKeyDeleteAction=restrict, JoinForeignKeyDeleteAction=restrict""/>
        <property name=""openjpa.Multithreaded"" value=""true""/>
        <property name=""openjpa.MaxFetchDepth"" value=""1""/>
        <property name=""openjpa.NontransactionalWrite"" value=""true""/>
        <property name=""openjpa.FetchBatchSize"" value=""0""/>
</properties
 
Initial state:
==========
The data base already contains an entities tree depth level 3 organized as follows:
* 2 instances of type ""EntityA"" type : A1, A2
* 2 instances of ""EntityB"" type : B1, B2
* 3 instances of ""EntityC"" type : C1, C2, C3
 
-> Representation of the entity linking 
A1 -> [B1 -> [C1, C2]]
A2 -> [B2 -> [C3]]
 
 
Scenario:
=================
1) 2 new instances of EntityC ""C4"" & ""C5"" type occurrences are inserted into entity B2:
                * State of the graph following insertion:
                               A1 -> [B1 -> [C1, C2]]
                               A2 -> [B2 -> [C3, C4, C5]]
 
2) Only entities A1 & A2 are persisted in two consecutive transactions. 
=> First persist on entity A1
                * State of the graph following commit:
                               A1 -> [B1 -> [C1, C2]]
                               A2 -> [B2 -> []]  => C3 was deleted during the first persist (new problem which we hadn't remarked yesterday).
 
=> Second persist on entity A2
                * State of the graph following insertion:
                               A1 -> [B1 -> [C1, C2]]
                               A2 -> [B2 -> [C4, C5]]     => Memory overflow, causing loss of entities C4, C5.
Urgent solution
=================
We are going to create a homemade corrective patch in order to mark the relations crossed between entities in the  «OpenJPAPersistenceUtil » class in order to avoid all looping.","08/Feb/13 14:19;curtisr7;I see that you are using two properties that are known to cause headaches...

* openjpa.RuntimeUnenhancedClasses -- has many known bugs and I highly recommend using another enhancement strategy. I'd wager a guess that using buildtime enhacement has a good chance of fixing this StackOverflowError.

* openjpa.Multithreaded, also has a number of known issues and if you're seeing intermittent deadlocks, it is due to the usage of this property. 

Thanks,
Rick","08/Feb/13 17:17;gchauvet;I use the buildtime enhancement strategy now. I noticed that I no longer random clob/blob error anymore in another part of the software, after removing the two OpenJPA properties (thanks !!).
In contrast, I've always the Stackoverflow error... I continue my investigation.","11/Feb/13 15:29;gchauvet;Hello,

I am writing to you again as after having removed the two problematic options, I tried several times but the problem was not at all resolved.
I am however obliged to retain the openjpa.Multithreaded property, given that we use swingworkers in another part of the software; otherwise a competitive access provider exception occurs.

Attached (finally!) please find a draft including a unit test capable of systematically reproducing the error.","11/Feb/13 15:39;gchauvet;oops, please downgrade openjpa-all version from 2.2.2-QFD to 2.2.1","15/Feb/13 21:37;curtisr7;I wasn't able to figure out the root problem yet, but it appears that it has something to do with the interaction between OpenJPA and Apache BeanValidation. If you're not using bv, a workaround for the meantime would be to set <validation-mode> to NONE. Hopefully I'll get some more time next week to continue digging into this issue.

Thanks,
Rick

  <persistence-unit name=""OPENJPA2330"" transaction-type=""RESOURCE_LOCAL"">
    <class>com.qualiformed.openjpa.jira2330.entity.AbstractEntityC</class>
    <class>com.qualiformed.openjpa.jira2330.entity.EntityA</class>
    <class>com.qualiformed.openjpa.jira2330.entity.EntityB</class>
    <class>com.qualiformed.openjpa.jira2330.entity.EntityC</class>
    <validation-mode>NONE</validation-mode>
    <properties>","20/Feb/13 23:08;curtisr7;Please try to test fix that I've attached here. This fix is based off trunk, and it should work on 2.2.x, but let me know if it doesn't work. You can either lay this class on top of your existing openjpa jar, or you can preprend it to your classpath. Let me know how it goes.

Your other option is to pull the patch out of the jar, and build your own fix based off your version of OpenJPA.","21/Feb/13 11:12;gchauvet;Hi Rick,

Your patch works perfectly, however I still have the loss of a node in the tree.
I will now open a new ticket with the unit test (which is an extension of the one provided in this ticket).","21/Feb/13 14:39;jira-bot;Commit 1448662 from curtisr7
[ https://svn.apache.org/r1448662 ]

OPENJPA-2330: Fix StackoverflowError when checking if a field is loaded. Test contributed by Guillaume Chauvet.",21/Feb/13 14:39;curtisr7;Committed revision 1448662 to trunk. Thanks for the UT Guillaume!,"21/Feb/13 20:46;jira-bot;Commit 1448796 from curtisr7
[ https://svn.apache.org/r1448796 ]

OPENJPA-2330: Change test Entity names.","11/Oct/13 02:44;jira-bot;Commit 1531176 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1531176 ]

OPENJPA-2330: Stackoverflow due to endless recursive calls - back ported to 2.2.1.x Rick Cutis's changes to trunk.","11/Oct/13 02:49;jira-bot;Commit 1531177 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1531177 ]

OPENJPA-2330: Stackoverflow due to endless recursive calls - back ported to 2.2.x Rick Cutis's changes to trunk.","05/Nov/13 18:01;jira-bot;Commit 1539086 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1539086 ]

OPENJPA-2330: Stackoverflow due to endless recursive calls - back ported to 2.1.x Rick Cutis's changes to trunk.",,,,,,,,,,,,
NPE caused by one too many calls on the iterator inside the library.,OPENJPA-2328,12630095,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,curtisr7,gchauvet,gchauvet,31/Jan/13 08:44,06/Jun/15 21:19,14/Mar/19 03:03,19/Feb/13 22:55,2.1.1,2.2.0,2.2.1,,,,,,2.3.0,,,,,jdbc,,,,0,,,,,,,,"We have just discovered a critical bug in the library preventing our program from operating. The problem comes from an NPE generated when there is one too many calls on the iterator of a collection, causing this type of stack trace:

<openjpa-2.2.1-r422266:1396819 fatal store error> org.apache.openjpa.persistence.RollbackException: null
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:594)
	at com.qualiformed.qualinax.platform.dao.GenericDAO.update(GenericDAO.java:136)
	at com.qualiformed.qualinax.platform.dao.SettingDAO.persist(SettingDAO.java:54)
	at com.qualiformed.qualinax.application.QualinaxConfig.save(QualinaxConfig.java:509)
	at com.qualiformed.qualinax.application.model.LancerQualimagiQModel.supprimerSettingsQualimagiQ(LancerQualimagiQModel.java:103)
	at com.qualiformed.qualinax.application.controller.QualimagiqController.setupAnalysis(QualimagiqController.java:371)
	at com.qualiformed.qualinax.application.controller.QualimagiqProcessor$8$1.doInBackground(QualimagiqProcessor.java:449)
	at com.qualiformed.qualinax.application.controller.QualimagiqProcessor$8$1.doInBackground(QualimagiqProcessor.java:446)
	at javax.swing.SwingWorker$1.call(SwingWorker.java:277)
	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)
	at java.util.concurrent.FutureTask.run(FutureTask.java:138)
	at javax.swing.SwingWorker.run(SwingWorker.java:316)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:662)
Caused by: <openjpa-2.2.1-r422266:1396819 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: null
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:2000)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1516)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:933)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:570)
	... 14 more
Caused by: java.util.NoSuchElementException
	at java.util.HashMap$HashIterator.nextEntry(HashMap.java:796)
	at java.util.HashMap$KeyIterator.next(HashMap.java:828)
	at org.apache.openjpa.jdbc.meta.strats.HandlerRelationMapTableFieldStrategy.update(HandlerRelationMapTableFieldStrategy.java:320)
	at org.apache.openjpa.jdbc.meta.FieldMapping.update(FieldMapping.java:699)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.update(AbstractUpdateManager.java:343)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.update(AbstractUpdateManager.java:370)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.populateRowManager(AbstractUpdateManager.java:174)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:97)
	at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:78)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:735)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:131)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2176)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2074)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1992)
	... 18 more

We have created a patch to correct the problem, but I haven't had the time to create the unitary test to reproduce it.",,,,,,,,,,,,,,,,,,,04/Feb/13 22:47;gchauvet;OPENJPA-2328-JUNIT.patch;https://issues.apache.org/jira/secure/attachment/12567900/OPENJPA-2328-JUNIT.patch,31/Jan/13 08:46;gchauvet;OPENJPA-2328.patch;https://issues.apache.org/jira/secure/attachment/12567318/OPENJPA-2328.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2013-01-31 14:56:11.539,,,no_permission,,,,,,,,,,,,310591,,,Mon Aug 05 18:51:33 UTC 2013,,,Patch Available,,,,0|i1hlo7:,310936,,,,,,,,"31/Jan/13 14:56;kwsutter;Nice catch, nice debugging, and nice patch.  It looks like this patch not only prevents the NPE, but it's also correcting the expected processing for this value handler strategy.  It looks like OpenJPA was accidentally skipping items via this iterator processing.  I am surprised that this wasn't discovered previously just due to incorrect results...  Thanks again.

If you can provide a junit test case for this condition, it would be icing on the cake...","31/Jan/13 15:27;gchauvet;Yes, I intend to send you a unit test soon (within 3 days, over the weekend)",04/Feb/13 22:47;gchauvet;The expected unitary test.,"18/Feb/13 21:48;gchauvet;Please, can someone may check the correctness of our patch ? (fix + junit)",18/Feb/13 23:09;curtisr7;I'll try to take a look tomorrow.,"19/Feb/13 22:54;jira-bot;Commit 1447955 from curtisr7
[ https://svn.apache.org/r1447955 ]

OPENJPA-2328: Fix NoSuchElementException when using HandlerRelationMapTableFieldStrategy. Patch contributed by Guillaume Chauvet.",19/Feb/13 22:55;curtisr7;Committed revision 1447955 to trunk. Thanks for the patch Guillaume!,19/Feb/13 22:55;curtisr7;Committed a UT and bug fix to trunk.,05/May/13 17:24;allee8285;OPENJPA-2378 opened to address test case failure introduced by this commit for Oracle.,"05/Aug/13 18:51;dlau;The reason is: Oracle does not support auto assign, so we need to exclude Oracle from the test. I post a patch for this change on OPENJPA-2378. ",,,,,,,,,,,,,,,,,
Updates in TCK execution configuration,OPENJPA-2326,12628822,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,22/Jan/13 23:31,21/Sep/16 14:38,14/Mar/19 03:03,10/Apr/13 14:40,2.3.0,,,,,,,,2.0.2,2.1.2,2.2.1.1,2.2.2,2.3.0,integration,,,,0,,,,,,,,I'm attempting to run the TCK using the pom.xml configuration in the integration/tck module and I'm running into a couple of issues.  I will use this JIRA for fixing the pom.xml and associated build-related configuration files to make execution easier.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-02-11 15:14:58.314,,,no_permission,,,,,,,,,,,,308300,,,Wed Feb 13 15:14:15 UTC 2013,,,,,,,0|i1b1lj:,272557,,,,,,,,"11/Feb/13 15:14;jira-bot;Commit 1444821 from kwsutter
[ https://svn.apache.org/r1444821 ]

OPENJPA-2326.  Just some cosmetic updates to pom.xml to help differentiate between the TCK 2.0 setup and the TCK 1.0 setup configurations.","12/Feb/13 15:40;jira-bot;Commit 1445201 from allee8285
[ https://svn.apache.org/r1445201 ]

OPENJPA-2326 - Enable 21x and 221x running TCK 2 against databases other then Derby. Fixed a few configuration problems.","12/Feb/13 15:40;jira-bot;Commit 1445202 from allee8285
[ https://svn.apache.org/r1445202 ]

OPENJPA-2326 - Enable 21x and 221x running TCK 2 against databases other then Derby. Fixed a few configuration problems.","12/Feb/13 15:40;jira-bot;Commit 1445203 from allee8285
[ https://svn.apache.org/r1445203 ]

OPENJPA-2326 - Enable 21x and 221x running TCK 2 against databases other then Derby. Fixed a few configuration problems.","12/Feb/13 16:41;jira-bot;Commit 1445254 from kwsutter
[ https://svn.apache.org/r1445254 ]

OPENJPA-2326.  Found an errant trace statement that is not needed.  Left over from a previous commit cleanup.  Too much trace is generated...","12/Feb/13 22:09;jira-bot;Commit 1445412 from allee8285
[ https://svn.apache.org/r1445412 ]

OPENJPA-2326 - Enable 20x running TCK 2 against databases other then Derby. Fixed a few configuration problems.","13/Feb/13 14:59;jira-bot;Commit 1445644 from allee8285
[ https://svn.apache.org/r1445644 ]

OPENJPA-2326 - Enable 22x running TCK 2 against databases other then Derby. Fixed a few configuration problems.","13/Feb/13 15:14;jira-bot;Commit 1445652 from allee8285
[ https://svn.apache.org/r1445652 ]

OPENJPA-2326 - Fixed StoreCharAsInteger property for DB2.","13/Feb/13 15:14;jira-bot;Commit 1445653 from allee8285
[ https://svn.apache.org/r1445653 ]

OPENJPA-2326 - Fixed StoreCharAsInteger property for DB2.","13/Feb/13 15:14;jira-bot;Commit 1445654 from allee8285
[ https://svn.apache.org/r1445654 ]

OPENJPA-2326 - Fixed StoreCharAsInteger property for DB2.","13/Feb/13 15:14;jira-bot;Commit 1445655 from allee8285
[ https://svn.apache.org/r1445655 ]

OPENJPA-2326 - Fixed StoreCharAsInteger property for DB2.",,,,,,,,,,,,,,,,
MappedSuperClass without an @Id causes wrong identity type for the inherited types,OPENJPA-2325,12628714,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,22/Jan/13 13:59,06/Jun/15 21:19,14/Mar/19 03:03,22/Jan/13 14:37,2.3.0,,,,,,,,2.3.0,,,,,kernel,,,,0,,,,,,,,"A MappedSuperClass without a declared identity field can cause the derived classes that have decalred an @Id field to be wrongly using DATASTORE identity type because the identity type of its superclass being UNKNOWN leads the derived type to use the default identity type, which for JPA faced is set to DATASTORE. 
The suggested change modifies the logic of ClassMetaData while detecting the identity type whether it is an abstract (i.e. MappedSuperClass). Also introduced a change that distinguishes whether the identity type was ever evaluated versus whether identity type  is indeterminable (i.e. UNKNOWN) which will  will save few  cycles for this commonly invoked operation. Previously for UNKNOWN type was indistinguishable from the case where identity type was never evaluated.   ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-04-18 21:27:30.581,,,no_permission,,,,,,,,,,,,307241,,,Thu Apr 25 01:44:02 UTC 2013,,,,,,,0|i1akov:,269818,,,,,,,,22/Jan/13 14:30;ppoddar@apache.org;The problem surfaces when an instance of the derived class (using application identity) created via new operator is merged while an instance with the same identity value exists. ,"18/Apr/13 21:27;jira-bot;Commit 1469582 from hthomann
[ https://svn.apache.org/r1469582 ]

OPENJPA-2325: MappedSuperClass without an @Id causes wrong identity type for the inherited types - back-ported to 2.0.x Pinaki Poddar's commit to trunk, as well as an additional change he made specific to 2.0.x.","19/Apr/13 16:40;jira-bot;Commit 1469949 from hthomann
[ https://svn.apache.org/r1469949 ]

OPENJPA-2325: MappedSuperClass without an @Id causes wrong identity type for the inherited types - back-ported to 2.1.x Pinaki Poddar's commit to trunk.","20/Apr/13 02:18;jira-bot;Commit 1470097 from hthomann
[ https://svn.apache.org/r1470097 ]

OPENJPA-2325: MappedSuperClass without an @Id causes wrong identity type for the inherited types - back-ported to 2.2.1.x Pinaki Poddar's commit to trunk.","25/Apr/13 01:44;jira-bot;Commit 1471807 from hthomann
[ https://svn.apache.org/r1471807 ]

OPENJPA-2325: MappedSuperClass without an @Id causes wrong identity type for the inherited types - back-ported to 2.2.x Pinaki Poddar's commit to trunk.",,,,,,,,,,,,,,,,,,,,,,
Synchronizing logging output stream causes deadlock when used some JDK LogManger derivative ,OPENJPA-2321,12627027,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,10/Jan/13 21:14,10/Apr/13 14:47,14/Mar/19 03:03,10/Jan/13 21:16,,,,,,,,,2.1.2,2.2.1.1,2.2.2,2.3.0,,,,,,0,,,,,,,,"OpenJPA acquires lock on the supplied log stream. Under some container environment and using JDK logging, a deadlock was detected that is related to the fact that OpenJPA grabbed a lock on the supplied output stream. 
This issue suggests that OpenJPA will not hold the lock on the stream. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,303720,,,2013-01-10 21:14:08.0,,,,,,,0|i17e1b:,251243,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CriteriaBuilder predicate construction deadlocks in multi-core VM due to static initializer,OPENJPA-2320,12626461,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,08/Jan/13 02:38,10/Apr/13 14:48,14/Mar/19 03:03,10/Jan/13 21:16,,,,,,,,,2.1.2,2.2.1.1,2.2.2,2.3.0,,,,,,0,,,,,,,,,,,,,,,,,,,,OPENJPA-2304,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,303068,,,2013-01-08 02:38:28.0,,,,,,,0|i177qf:,250221,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Left outer join is not generated when specifien using Criteria API,OPENJPA-2318,12626144,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,levtse,levtse,05/Jan/13 00:50,06/Jun/15 21:19,14/Mar/19 03:03,16/Aug/13 18:26,2.1.1,,,,,,,,2.2.1.1,2.2.3,2.3.0,,,criteria,,,,2,,,,,,,,"Entities
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public class DiscoveryObjectImpl {
	@Id
	private String id;
	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	@ManyToOne(cascade = CascadeType.ALL)
	private DiscoveryObjectImpl parent;
	

	public DiscoveryObjectImpl getParent() {		
		return parent;
	}

	public void setParent(DiscoveryObjectImpl parent) {
		this.parent = parent;  

	}
}

@Entity
public class ColumnFormatImpl extends DiscoveryObjectImpl {
	@Basic
	String formatName; 
}

@Entity
public class ColumnImpl extends DiscoveryObjectImpl {
@OneToMany(mappedBy=""parent"")
private List<ColumnFormatImpl> formats = new ArrayList<ColumnFormatImpl>();

}

@Entity
public class VirtualTableImpl extends DiscoveryObjectImpl {
@OneToMany(mappedBy=""parent"")
	private List<ColumnImpl> columns = new ArrayList<ColumnImpl>();
}

persistence.xml
<persistence xmlns=""http://java.sun.com/xml/ns/persistence""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
    xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd""
    version=""1.0"">
 <persistence-unit name=""Test"" transaction-type=""RESOURCE_LOCAL"">
 	<provider>org.apache.openjpa.persistence.PersistenceProviderImpl</provider>
 	<class>com.ibm.infosphere.test.model.interfaces.impl.DiscoveryObjectImpl</class>
 	<class>com.ibm.infosphere.test.model.interfaces.impl.VirtualTableImpl</class>
 	<class>com.ibm.infosphere.test.model.interfaces.impl.ColumnImpl</class>
 	<class>com.ibm.infosphere.test.model.interfaces.impl.ColumnFormatImpl</class> 	
 	<exclude-unlisted-classes>true</exclude-unlisted-classes> 			
	<properties>
			<property name=""openjpa.Log"" value=""DefaultLevel=ERROR, Runtime=ERROR, Tool=ERROR, SQL=TRACE, MetaData=ERROR""/>
			<property name=""openjpa.DynamicEnhancementAgent""  value=""false""/>
            <property name=""openjpa.RuntimeUnenhancedClasses"" value=""supported""/>
            <property name=""openjpa.jdbc.SynchronizeMappings"" value=""buildSchema(ForeignKeys=true)""/>
            <property name=""openjpa.InitializeEagerly"" value=""true""/>
            <property name=""openjpa.jdbc.DBDictionary"" value=""oracle""/>
            <property name=""openjpa.jdbc.DBDictionary"" value=""MaxTableNameLength=61""/>
            <property name=""openjpa.jdbc.DBDictionary"" value=""useWildCardForCount=true""/>
            <property name=""openjpa.jdbc.DBDictionary"" value=""JoinSyntax=sql92""/>
 			<property name=""openjpa.ConnectionURL"" value=""jdbc:oracle:thin:@localhost:1521:orcl""/>
			 
    		<property name=""openjpa.ConnectionDriverName"" value=""oracle.jdbc.driver.OracleDriver""/> 
      		<property name=""openjpa.ConnectionUserName"" value=""lev""/>
      		<property name=""openjpa.ConnectionPassword"" value=""lev""/>

            <property name=""openjpa.ConnectionFactoryProperties""    value=""PrettyPrint=true, PrettyPrintLineLength=80, PrintParameters=true""/>
            <property name=""openjpa.DataCache""                value=""true""/>        
            <property name=""openjpa.RemoteCommitProvider""     value=""sjvm""/>            
            <property name=""openjpa.jdbc.QuerySQLCache""       value=""true(EnableStatistics=true)""/>            
		</properties>
</persistence-unit>
</persistence>

Test code:
public void test() {
        CriteriaQuery<ColumnImpl> cri = cb.createQuery(ColumnImpl.class);
        Root<VirtualTableImpl> tbl = cri.from(VirtualTableImpl.class);
        Join<VirtualTableImpl, ColumnImpl> col = tbl.join(""columns"");
        Join<ColumnImpl, ColumnFormatImpl> format = col.join(""formats"", JoinType.LEFT);
        cri.where(cb.equal(format.get(""formatName""), ""ABC""));
        cri.select(col);
        em.createQuery(cri).getResultList();
}

Generated SQL:
SELECT t1.id, t1.PARENT_ID 
    FROM VirtualTableImpl t0 INNER JOIN ColumnImpl t1 ON t0.id = t1.PARENT_ID INNER 
        JOIN ColumnFormatImpl t2 ON t1.id = t2.PARENT_ID 
    WHERE (t2.formatName = ? AND 1 = 1) 

As you can see the secong JOIN is INNER instead of LEFT OUTER

        ",Windows/Oracle,,,,,,,,,,,,,,,,,,16/Aug/13 14:36;wizman;OPENJPA-2318-TEST.patch;https://issues.apache.org/jira/secure/attachment/12598475/OPENJPA-2318-TEST.patch,16/Aug/13 14:36;wizman;OPENJPA-2318.patch;https://issues.apache.org/jira/secure/attachment/12598474/OPENJPA-2318.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2013-05-15 10:56:29.322,,,no_permission,,,,,,,,,,,,302727,,,Thu Dec 05 18:49:16 UTC 2013,,,,,,,0|i174zr:,249777,,,,,,,,"15/May/13 10:56;slowstrider;I'm having exacly the same issue. When printing the internally generated ""JPQL"" using (OpenJPACriteriaQuery) q).toCQL() it does show a LEFT JOIN, but the actual generated SQL has an inner join.
The manually written equivalent JPQL does generate SQL with ""LEFT OUTER JOIN"".

The problem does not happen when the query has only one join.","15/May/13 11:09;slowstrider;Not 100% sure but this may have to do with inheritance.

My structure is like Order 1..* OrderLine 1..1 Product *..1 Category. Category is optional so when I select from Order I (should) get inner joins followed by a left join.
My Order class extends from another abstract entity class using TABLE_PER_CLASS.
When I leave out Order and select from OrderLine I do get an inner join followed by a left outer join.","15/May/13 11:30;slowstrider;Same issue when leaving out Category and making OrderLine 1 .. 1 Product optional (= 3 tables, 2 joins just like the example of this issue).",15/May/13 11:48;slowstrider;I reproduced the problem for another query with 3 entities that have no superclasses (except for @MappedSuperclass). I select from an inner join followed by a left join and get the exact same issue. (A 1..* B *..1 C),"15/May/13 12:18;slowstrider;I created an (almost) official OpenJPA test case that reproduces the issue.
I took the CriteriaTest TestJPQLSubquery.testSubqueries6 as a starting point to create the test. It reuses the existing structure

Customer 1..* accounts 1..1 owner

    public void testLeftJoinAfterInnerJoin() {
        String jpql = ""SELECT c FROM Customer c INNER JOIN c.accounts a LEFT JOIN a.owner o"";
        String expectedSQL = ""SELECT t0.id, t0.accountNum, t4.id, t4.city, t4.country, t4.county, t4.state, "" +
        		""t4.street, t5.userid, t5.DTYPE, t5.age, t5.compName, t5.creditRating, t5.name, t4.zipCode, "" +
        		""t0.balanceOwed, t0.creditRating, t0.filledOrderCount, t0.firstName, t0.lastName, t0.name, t0.status "" +
        		""FROM CR_CUST t0 "" +
        		""INNER JOIN CR_CUST_CR_ACCT t1 ON t0.id = t1.CUSTOMER_ID "" +
        		""LEFT OUTER JOIN CR_ADDR t4 ON t0.ADDRESS_ID = t4.id "" +
        		""INNER JOIN CR_ACCT t2 ON t1.ACCOUNTS_ID = t2.id "" +
        		""LEFT OUTER JOIN CompUser t5 ON t4.id = t5.ADD_ID "" +
        		""LEFT OUTER JOIN CR_PSN t3 ON t2.OWNER_ID = t3.id"";

        executeAndCompareSQL(jpql, expectedSQL);
        
        CriteriaQuery<Customer> q = cb.createQuery(Customer.class);
        Root<Customer> c = q.from(Customer.class);
        Join<Customer,Account> a = c.join(Customer_.accounts);
        Join<Account, Person> o = a.join(Account_.owner, JoinType.LEFT);
        q.select(c);
        
        assertEquivalence(q, jpql);
    }

Simply copy/paste into TestJPQLSubquery and run.
You will get a nice assertion error that compares the SQL for the JPQL query with the SQL for the Criteria query and you can see that only the last part of the query differs. JPQL has ""LEFT OUTER JOIN"" while Criteria has ""INNER JOIN"".

Can an OpenJPA committer look into this? I think I have now done the necessary work I can do to pinpoint the issue.","15/May/13 12:43;slowstrider;I found the cause of the problem!

By simply following the call chain of join I found that this test can be made to pass by changing line 210 of org.apache.openjpa.persistence.criteria.Joins from

path.get(_member.fmd, false);

to

path.get(_member.fmd, allowNull);

This is the code that translates the join into an openJPA kernal expression and somehow fills in false for allowNull while it should be true according to
allowNull = joinType != JoinType.INNER

There is also another call to path.get using the literal value of false.

I believe an OpenJPA committer should be able to quickly fix this issue now. (Note that I have no clue of the consequences of this change, perhaps the literal value of false was deliberate and perhaps it breaks other tests.)
",16/Aug/13 14:36;wizman;Fix for OPENJPA-2318,"16/Aug/13 18:25;jira-bot;Commit 1514833 from [~ppoddar@apache.org] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1514833 ]

OPENJPA-2318: Left outer join is not generated because allowNull was not passed correctly","05/Dec/13 17:52;jira-bot;Commit 1548222 from [~fyrewyld] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1548222 ]

OPENJPA-2318: Left outer join is not generated when specified using Criteria API","05/Dec/13 18:49;jira-bot;Commit 1548238 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1548238 ]

OPENJPA-2318: Left outer join is not generated when specified using Criteria API",,,,,,,,,,,,,,,,,
Remove superseded releases from main Apache mirrors,OPENJPA-2308,12623454,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,sebb@apache.org,sebb@apache.org,11/Dec/12 20:45,11/Dec/12 21:46,14/Mar/19 03:03,11/Dec/12 21:36,2.1.0,2.1.1,2.2.0,,,,,,,,,,,build / infrastructure,,,,0,,,,,,,,"Only the current release should appear on the ASF mirrors.
This is to reduce the disk space requirements for the mirror system.

It takes a few days for all mirrors to catch up with a new release, but after a suitable period (e.g. a week) any superseded releasese should be deleted from:

http://www.apache.org/dist/openjpa/

In some cases, projects maintain several release series (e.g. Tomcat6 and Tomcat7) in which case only the latest of each series should remain on the mirror system.

AFAICT, the following releases are no longer current and should be removed:

2.1.0
2.1.1
2.2.0

Older releases are always available from archive.apache.org.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-12-11 21:36:20.75,,,no_permission,,,,,,,,,,,,297153,,,Tue Dec 11 21:46:29 UTC 2012,,,,,,,0|i14lpz:,234983,,,,,,,,11/Dec/12 21:36;kwsutter;Thanks for the catch.  I've updated the links on the download page to point at the archive site and I have deleted the old directories from the http://www.apache.org/dist/openjpa/.,11/Dec/12 21:46;sebb@apache.org;Thanks.,,,,,,,,,,,,,,,,,,,,,,,,,
Download page must not advertise snapshot builds,OPENJPA-2307,12623452,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,kwsutter,sebb@apache.org,sebb@apache.org,11/Dec/12 20:35,06/Jun/18 17:10,14/Mar/19 03:03,17/Dec/12 17:32,,,,,,,,,,,,,,,,,,0,,,,,,,,"The download page http://openjpa.apache.org/downloads.html contains links to several snapshot builds.

These presumably have not been voted on; as such they are not proper ASF releases and must not be advertised to the general public.

They are only intended for use by developers and should only appear (if at all) in pages which are clearly for developers only.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-12-11 20:46:26.029,,,no_permission,,,,,,,,,,,,297151,,,Wed Jun 06 17:10:12 UTC 2018,,,,,,,0|i14lpj:,234981,,,,,,,,"11/Dec/12 20:46;kwsutter;The download links on this page are clearly separated based on Releases vs Nightly Snapshots.  The official releases are at the top of this page, and the nightly snapshots at the bottom of this page.  The nightly snapshot section clearly has this text:

     Nightly Snapshots

     These distributions are built and deployed nightly, and contain up-to-date fixes and improvements. However, their stability cannot be guaranteed. Use at your own risk.

The OpenJPA site has been formatted this way forever.  Although this JIRA is a nice suggestion, I don't see it as a bug that needs to be resolved.  Unless you are indicating that we're breaking some type of Apache rule, I don't see any reason to separate these downloads into separate pages.","11/Dec/12 20:59;sebb@apache.org;I'm sorry, but snapshot builds must not be advertised to the general public.

http://www.apache.org/dev/release.html#what",11/Dec/12 21:02;kwsutter;Bummer...  :-)  Looks to be a valid defect...,"11/Dec/12 21:51;kwsutter;As I was fixing OPENJPA-2308, I also discovered that the RELEASE-NOTES.html links are not valid on the Download page due to the lack of the ""builds"" directory on the openjpa.apache.org site...  We'll have to get that fixed once we figure out the proper location for the Documentation...","11/Dec/12 21:56;kwsutter;Can the main download page have a reference to the ""developer only"" page for the nightly snapshots?  Or, does it have to be a standalone page with no link or mention of the development downloads?  I'm assuming at a minimum, I could reference our general Development page and let developers go down that path...","11/Dec/12 22:22;sebb@apache.org;I don't think the main download page should mention snapshot builds even indirectly.

It would be better to add the nightly build reference somewhere under the pages in the ""Development"" section of the navigation.

For example it could be added to

http://openjpa.apache.org/building.html",17/Dec/12 17:32;kwsutter;The Downloads page is now only for official OpenJPA releases.  We've broken off the Nightly Downloads page under the Development tab.  Thanks for the catch.,"06/Jun/18 17:10;struberg;tickets are all resolved since at least 2012, so closing them finally",,,,,,,,,,,,,,,,,,,
Broken link,OPENJPA-2306,12623450,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,kwsutter,sebb@apache.org,sebb@apache.org,11/Dec/12 20:29,11/Dec/12 20:50,14/Mar/19 03:03,11/Dec/12 20:50,,,,,,,,,,,,,,docs,,,,0,,,,,,,,"http://openjpa.apache.org/downloads.html#verifying-releases.html
should be
http://openjpa.apache.org/downloads.html#verifying-releases",http://openjpa.apache.org/downloads.html,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-12-11 20:50:24.572,,,no_permission,,,,,,,,,,,,297149,,,Tue Dec 11 20:50:24 UTC 2012,,,,,,,0|i14lp3:,234979,,,,,,,,11/Dec/12 20:50;kwsutter;Done.  Thanks for the catch.,,,,,,,,,,,,,,,,,,,,,,,,,,
Thread deadlock in CriteriaBuilder,OPENJPA-2304,12623423,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,11/Dec/12 18:14,10/Apr/13 14:48,14/Mar/19 03:03,10/Jan/13 21:16,2.2.1.1,,,,,,,,2.1.2,2.2.1.1,2.2.2,2.3.0,,criteria,,,12/Dec/12 00:00,0,,,,,,,,The CriteriaBuilder blocks when multiple threads work on constructing predicate expressions.,Multi-core virtualized CPUs,,,,,,,,,,,OPENJPA-2320,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,297122,,,Thu Jan 10 20:35:43 UTC 2013,,,,,,,0|i14lin:,234950,,,,,,,,"10/Jan/13 20:35;ppoddar@apache.org;The duplicate (2320) got created by oversight (so many bugs, so little time:). The actual commits are associated with 2320.",,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError/Stack underflow due to extra 'return' statements generated by PCEnhancer.,OPENJPA-2298,12616445,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,jpaheath,jpaheath,jpaheath,16/Nov/12 17:18,10/Apr/13 14:49,14/Mar/19 03:03,10/Apr/13 14:49,2.2.0,2.3.0,,,,,,,2.2.1.1,2.2.2,2.3.0,,,Enhance,instrumentation,,,0,,,,,,,,"I've been assisting Kevin Sutter with a 'VerifyError' and am opening this JIRA on his behalf.  He has discovered a situation where the following VerifyError occurs:

Exception data: java.lang.VerifyError: JVMVRFY036 stack underflow; class=irwwbase/PersistentTimerStatsJPA, method=pcNewObjectIdInstance(Ljava/lang/Object;)Ljava/lang/Object;, pc=26
    at java.lang.J9VMInternals.verifyImpl(Native Method)
    at java.lang.J9VMInternals.verify(J9VMInternals.java:85)
    at java.lang.J9VMInternals.initialize(J9VMInternals.java:162)
    at java.lang.Class.forNameImpl(Native Method)
    at java.lang.Class.forName(Class.java:176)
    at org.apache.openjpa.meta.MetaDataRepository.classForName(MetaDataRepository.java:1552)
    at org.apache.openjpa.meta.MetaDataRepository.loadPersistentTypesInternal(MetaDataRepository.java:1528)
    at org.apache.openjpa.meta.MetaDataRepository.loadPersistentTypes(MetaDataRepository.java:1506)
    at org.apache.openjpa.kernel.AbstractBrokerFactory.loadPersistentTypes(AbstractBrokerFactory.java:282)
    at org.apache.openjpa.kernel.AbstractBrokerFactory.initializeBroker(AbstractBrokerFactory.java:238)
    at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:212)
    at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:156)
    at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:227)
    ...........


This issue occurs on, and is unique to, Java 7 and our enhancement code (as well as the entity definition).  That is, in PCEnhancer we are generating extra 'returns' in methods which throw an exception.  This has an effect on ASM post-processing needed on Java 7 which ultimately causes the VerifyError.  This description probably makes no sense without more details and code to go along with it.  So let me now show how this looks in code.  First, I'm attaching an entity, named PersistentTimerStatsJPA.java, and a PK class named 'PersistentTimerStatsPK.java'.  While I won't go into exact details on how to use these classes to recreate the issue, I am providing them for the reader's reference.
Next, lets look at enhanced code before ASM post-processing occurs.  Take this code:

  public java.lang.Object pcNewObjectIdInstance(java.lang.Object);
    flags: ACC_PUBLIC

    Code:
      stack=3, locals=2, args_size=2
         0: new           #207                // class java/lang/IllegalArgumentException
         3: dup           
         4: ldc_w         #367                // String The id type \""class irwwbase.PersistentTimerStatsPK\"" specified by persistent type \""class irwwbase.PersistentTimerStatsJPA\"" does not have a public class irwwbase.PersistentTimerStatsPK(String) or class irwwbase.PersistentTimerStatsPK(Class, String) constructor.
         7: invokespecial #368                // Method java/lang/IllegalArgumentException.""<init>"":(Ljava/lang/String;)V
        10: athrow        
        11: return        

As you can see, we have a ""10: athrow"" and ""11: return"".  This extraneous ""11: return"" hasn't caused problems in the past, but as will be explained in more details below, with ASM post-processing necessary in Java 7, this ""11: return"" causes problems.  To see this, lets look at the code above after going through ASM post-processing:

  public java.lang.Object pcNewObjectIdInstance(java.lang.Object);
    flags: ACC_PUBLIC

    Code:
      stack=3, locals=2, args_size=2
         0: new           #205                // class java/lang/IllegalArgumentException
         3: dup           
         4: ldc_w         #363                // String The id type \""class irwwbase.PersistentTimerStatsPK\"" specified by persistent type \""class irwwbase.PersistentTimerStatsJPA\"" does not have a public class irwwbase.PersistentTimerStatsPK(String) or class irwwbase.PersistentTimerStatsPK(Class, String) constructor.
         7: invokespecial #364                // Method java/lang/IllegalArgumentException.""<init>"":(Ljava/lang/String;)V
        10: athrow        
        11: athrow        
      StackMapTable: number_of_entries = 1
           frame_type = 255 /* full_frame */
          offset_delta = 11
          locals = []
          stack = [ class java/lang/Throwable ]

Notice that the ""11: return"" was changed to a second ""11: athrow"".  To tie this all together, let me blatantly copy/paste a detailed description sent to me by Kevin: 

""When JPA was attempting to generate the bytecodes for throwing an exception, we were accidentally including a return bytecode as well.  Of course, in a normal Java environment, this would have been flagged since the return would have been unreachable code.  But, since we were generating the bytecodes during enhancement, nothing is going to flag this situation.  But, due to the Java 7 class validation that is now being performed, we had to introduce the ASM post-processing.  Normally, these simple enhanced methods would not have been touched by ASM.  But, since these methods now had multiple exit points (due to the throw and return bytecodes), these methods were being flagged as ""complicated"" and needed Stack Map table adjustments performed by ASM.  Unfortunately, this additional ASM code now introduced the situation where too many items would have been popped off the stack (if the code could have actually executed as coded).  This is the Stack Underflow exception that was happening during Class load time.""

Basically, Kevin's fix was to find all of the areas where we generate a ""throw"" followed by a ""return"", and remove the ""return"".  Since this method is only attempting to throw an exception, we really don't need the second ""return"" instruction.  I'm providing Kevin's patch, which is named 'VerifyError.patch'.

Thanks,

Heath",,,,,,,,,,,,,,OPENJPA-2339,,,,,16/Nov/12 17:20;jpaheath;PersistentTimerStatsJPA.java;https://issues.apache.org/jira/secure/attachment/12553799/PersistentTimerStatsJPA.java,16/Nov/12 17:20;jpaheath;PersistentTimerStatsPK.java;https://issues.apache.org/jira/secure/attachment/12553800/PersistentTimerStatsPK.java,16/Nov/12 17:20;jpaheath;VerifyError.patch;https://issues.apache.org/jira/secure/attachment/12553798/VerifyError.patch,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2012-11-16 19:12:14.356,,,no_permission,,,,,,,,,,,,258287,,,Fri Nov 16 19:12:14 UTC 2012,,,Patch Available,,,,0|i0kr5b:,119215,,,,,,,,"16/Nov/12 17:20;jpaheath;I'm providing a patch which was created by Kevin Sutter, and am attaching two classes he used when recreating the issue.

Thanks,

Heath","16/Nov/12 19:12;kwsutter;Good write-up, Heath.  My patch had commented out the extra ""return"" bytecode generations.  When you apply the patch, please remove the ""return"" statements.  Don't comment them out.  Thanks.",,,,,,,,,,,,,,,,,,,,,,,,,
Additional SQL alias generated for query with subquery causes incorrect # of rows returned - Oracle only,OPENJPA-2289,12614256,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,31/Oct/12 18:40,21/Sep/16 14:38,14/Mar/19 03:03,10/Apr/13 14:51,2.0.1,2.1.1,2.2.0,2.3.0,,,,,2.0.2,2.1.2,2.2.1.1,2.2.2,2.3.0,sql,,,,0,,,,,,,,"                .createQuery(""SELECT e FROM MaxQueryEntity e, MaxQueryMapEntity map ""
                    + ""WHERE map.selectCriteria = 'B3' AND map.refEntity = e ""
                    + ""  AND e.revision = ( SELECT MAX(e_.revision)""
                    + ""                     FROM MaxQueryEntity e_""
                    + ""                     WHERE e_.domainId = e.domainId )""
                    + ""  AND map.revision = ( SELECT MAX(map_.revision)""
                    + ""                       FROM MaxQueryMapEntity map_""
                    + ""                       WHERE map_.refEntity = map.refEntity )"");        


On Oracle we generate SQL like this on 2.0.x+:

SELECT t1.id, t1.domainId, t1.revision FROM OPENJPA_MAXQUERY_MAPENTITY t0, OPENJPA_MAXQUERY_ENTITY t1, OPENJPA_MAXQUERY_MAPENTITY t4 WHERE (t0.selectCriteria = ? AND t0.refEntity = t1.id AND t1.revision = (SELECT MAX(t2.revision) FROM OPENJPA_MAXQUERY_ENTITY t2 WHERE (t2.domainId = t1.domainId)) AND t0.revision = (SELECT MAX(t3.revision) FROM OPENJPA_MAXQUERY_MAPENTITY t3 WHERE (t3.refEntity = t4.refEntity))) [params=(String) B3]

The additional alias ""OPENJPA_MAXQUERY_MAPENTITY t4"" caused more unexpected rows to return.",,,,,,,,,,,,,,,,,,,31/Oct/12 19:47;allee8285;OPENJPA-2289.20x.patch;https://issues.apache.org/jira/secure/attachment/12551610/OPENJPA-2289.20x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,253489,,,2012-10-31 18:40:55.0,,,Patch Available,,,,0|i0dnu7:,77791,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MetaDataRepository should be able to filter classes from other app ClassLoaders in JEE Env,OPENJPA-2288,12613904,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,fyrewyld,fyrewyld,29/Oct/12 14:54,30/Nov/12 22:21,14/Mar/19 03:03,30/Nov/12 22:21,2.1.1,2.2.0,,,,,,,2.1.2,2.2.1.1,2.2.2,2.3.0,,kernel,,,,0,,,,,,,,"When an enhanced Class is loaded by a ClassLoader, its static initializer registers it with metadata in a map in the PCRegistry.  Every MetaDataRepository that registers as a listener with the PCRegistry will receive each class, regardless of whichever ClassLoader it is associated with.  In a JEE environment, this means all Classes from all Applications (including stopped Applications whose ClassLoaders have not yet been Garbage Collected) are received by each MDR instance in the MDR.processRegisteredClasses() method.

It has been found that there is a problem in the MDR.processRegisteredClasses() method.  While processing each registrant, one of the first things it attempts to do is instantiate the class to determine whether the version level of the enhancer that enhanced the class is compatible with the runtime.  If the class constructor contains application logic that addresses static (session-context sensitive) data and does not gracefully capture the resulting RuntimeException, it can cause the JPA operation responsible for triggering the MDR.pRC() operation to fail.

As a Compatibility option, I propose enabling a filter that eliminates classes that are not loadable through the envLoader (or Thread Context ClassLoader when envLoader is null).  This will eliminate instantiating Classes from other applications (thus eliminating the execution of potential application custom logic embedded in the constructors) inappropriately.",,,,,,,,,,,,,,,,,,,29/Oct/12 17:54;fyrewyld;OPENJPA-2288-2.1.x.patch;https://issues.apache.org/jira/secure/attachment/12551215/OPENJPA-2288-2.1.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,252791,,,2012-10-29 14:54:53.0,,,,,,,0|i0d89b:,75114,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA makes fields null,OPENJPA-2287,12613873,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,struberg,mlaskows,mlaskows,29/Oct/12 11:03,06/Jun/15 14:25,14/Mar/19 03:03,16/Apr/15 20:35,2.2.0,,,,,,,,2.4.0,,,,,kernel,,,,1,,,,,,,,When there are two objects in OneToMany relation and when One sets Many and vice versa the filed Many.one became null. It seems to be related with code added in this issue https://issues.apache.org/jira/browse/OPENJPA-2006. To reproduce: https://github.com/dogenkigen/OpenJPA-bug,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-10-29 16:58:51.93,,,no_permission,,,,,,,,,,,,252732,,,Thu Apr 16 20:35:12 UTC 2015,,,,,,,0|i0d567:,74614,,,,,,,,"29/Oct/12 16:58;curtisr7;I haven't been able to quite figure this one out, but it looks like there is a bug between the runtime flush logic and the InverseManager trying to 'fix-up' relationships. As a work around, you could manage your own relationships rather than relying on the runtime to do it for you?

ie: Remove <property name=""openjpa.InverseManager"" value=""true"" /> from your p.xml file.","30/Oct/12 08:17;mlaskows;It could be work around if the application have only few relations, but in my system I have hundreds of them.","16/Apr/15 20:12;struberg;I've pretty much hit the same issue. 
From debugging into it seems that the StateManager#fetchObjectField resets the internally stored value to null after the method gets used. 
As the InversManager relies on this field it 'trashes' the later 'normal' usage.

The comment which were on the code seems to indicate that this used to create mem leaks a _very_ long time ago:
{quote}
// don't hold onto strong ref to object
{quote}
This is really ancient code but from what I've seen we can really remove this reset. ","16/Apr/15 20:35;jira-bot;Commit 1674148 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1674148 ]

OPENJPA-2287 do not clear object fields for fetchObjectField

* Other objects do not get cleared neither.
* The code dates from JDO times and I've asked a few people and no one had an explanation for it
* It introduces nullpointer exceptions in cases where we have to navigate over the field a few times. E.g. in complex scenarios.",,,,,,,,,,,,,,,,,,,,,,,
"SELECT COUNT with date litteral,used more than once, provokes ArgumentException: Attempt to compare incompatible types class java.util.Date and class org.apache.openjpa.jdbc.sql.Raw",OPENJPA-2286,12613632,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,hvieren,hvieren,26/Oct/12 10:50,21/Sep/16 20:17,14/Mar/19 03:03,08/Sep/16 22:23,2.2.0,,,,,,,,2.1.2,2.2.1.1,2.2.3,2.4.0,,query,,,,0,,,,,,,,"a select count with date literal throws exception if used more than once in EntityManagerFactory

SELECT COUNT(x) FROM TestCountWithDate x WHERE LOWER(x.name) LIKE '%vier%' AND x.adate =  {d '2007-12-12'}

INFO: qry_0=SELECT COUNT(x) FROM TestCountWithDate x WHERE LOWER(x.name) LIKE '%vier%' AND x.adate =  {d '2007-12-12'}
Exception in thread ""main"" <openjpa-2.2.0-r422266:1244990 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Attempt to compare incompatible types ""class java.util.Date"" and ""class org.apache.openjpa.jdbc.sql.Raw"".
	at org.apache.openjpa.jdbc.kernel.exps.CompareEqualExpression.appendTo(CompareEqualExpression.java:101)
	at org.apache.openjpa.jdbc.kernel.exps.AndExpression.appendTo(AndExpression.java:65)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.buildWhere(SelectConstructor.java:312)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.evaluate(SelectConstructor.java:94)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.createWhereSelects(JDBCStoreQuery.java:360)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeQuery(JDBCStoreQuery.java:193)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:783)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1005)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:863)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:794)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:286)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302)
	at org.apache.openjpa.persistence.QueryImpl.getSingleResult(QueryImpl.java:330)
	at client.Client.doQueries(Client.java:51)
	at client.Client.main(Client.java:101)



testprogram

//export CLASSPATH=$JAVA_HOME/db/lib/derbyclient.jar:/opt/apache-openjpa-2.2.0/openjpa-all-2.2.0.jar:../:~/tmp/build/website1/build/WEB-INF/classes/
//javac Client.java
//java  client.Client hoefsmidb
/*
create table testCountWithDate(id INT NOT NULL GENERATED BY DEFAULT AS IDENTITY primary key,Name char(32) not null,aDATE DATE NOT NULL);
INSERT INTO testCountWithDate(name,aDate) values ('hvieren','2007-12-12');
INSERT INTO testCountWithDate(name,aDate) values ('vierendeels','2012-10-26');
INSERT INTO testCountWithDate(name,aDate) values ('tshvr','2012-10-27');
*/
package client;

import javax.persistence.EntityManager;
import javax.persistence.Persistence;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Query;

import java.util.Collection;
import java.util.List;

import java.util.logging.*;

import entities.APP.TestCountWithDate;


public class Client
{
 private static final Logger logger=Logger.getLogger(Client.class.getName());

 private static EntityManagerFactory emf;
 private static EntityManager em;

 private static String qry_0=""SELECT COUNT(x) FROM TestCountWithDate x WHERE LOWER(x.name) LIKE '%vier%' AND x.adate =  {d '2007-12-12'}"";
 private static String qry_1=""SELECT x FROM TestCountWithDate AS x WHERE LOWER(x.name) LIKE '%vier%' AND x.adate =  {d '2007-12-12'}  order by x.id"";

 private static void createTransactionalEntityManager()
 {
  em=emf.createEntityManager();
  em.getTransaction().begin();
  logger.info(""createTransactionalEntityManager done"");
 }
 private static void closeTransactionalEntityManager()
 {
  em.getTransaction().commit();
  em.close();
  logger.info(""closeTransactionalEntityManager done"");
 }

 public static String doQueries()
 {
  long qry_count=-1;
  logger.info(""qry_0=""+qry_0);
  qry_count=em.createQuery(qry_0,Long.class).getSingleResult();
  logger.info(""qry_count=""+qry_count);

  /***
   Exception in thread ""main"" <openjpa-2.2.0-r422266:1244990 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Attempt to compare incompatible types ""class java.sql.Date"" and ""class org.apache.openjpa.jdbc.sql.Raw"".
	at org.apache.openjpa.jdbc.kernel.exps.CompareEqualExpression.appendTo(CompareEqualExpression.java:101)
	at org.apache.openjpa.jdbc.kernel.exps.AndExpression.appendTo(AndExpression.java:65)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.buildWhere(SelectConstructor.java:312)
	at org.apache.openjpa.jdbc.kernel.exps.SelectConstructor.evaluate(SelectConstructor.java:94)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.createWhereSelects(JDBCStoreQuery.java:360)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeQuery(JDBCStoreQuery.java:193)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeQuery(ExpressionStoreQuery.java:783)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1005)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:863)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:794)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:286)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302)
	at org.apache.openjpa.persistence.QueryImpl.getSingleResult(QueryImpl.java:330)
  ***/
  /********
  logger.info(""qry=""+qry_1);
  Query qry=em.createQuery(qry_1);

  List qry_rslts=qry.getResultList();
  //if(qry_rslts==null || qry_rslts() !=0)
  int qry_rslts_size=qry_rslts.size();
  logger.info(""qry_rslts_size=""+qry_rslts_size);
  for(Object o:qry_rslts)
  {
   logger.info(""o=""+o);
  }//for
  *******/
  return(""OK"");
 }//doQueries

 public static void main(String[] args)
 {
  String pu_name=args[0];
  emf=Persistence.createEntityManagerFactory(pu_name);
  createTransactionalEntityManager();

  doQueries();
  closeTransactionalEntityManager();
  emf.close();
  emf=Persistence.createEntityManagerFactory(pu_name);
  createTransactionalEntityManager();
  doQueries();
  closeTransactionalEntityManager();
  createTransactionalEntityManager();
  doQueries();

  closeTransactionalEntityManager();

  System.exit(0);
 }//main
}
---------------------
package entities.APP;

import java.util.*;
import javax.persistence.*;

/**
 * Auto-generated by:
 * org.apache.openjpa.jdbc.meta.ReverseMappingTool$AnnotatedCodeGenerator
 */
@Entity
@Table(schema=""APP"", name=""testCountWithDate"")
public class TestCountWithDate {
	@Basic
	@Column(nullable=false)
	@Temporal(TemporalType.DATE)
	private Date adate;

	@Id
	private int id;

	@Basic
	@Column(nullable=false, length=32)
	private String name;


	public TestCountWithDate() {
	}

	public TestCountWithDate(int id) {
		this.id = id;
	}

	public Date getAdate() {
		return adate;
	}

	public void setAdate(Date adate) {
		this.adate = adate;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}



","tested with 
openjpa-all-2.2.0.jar
openjpa-all-2.3.0-20121019.065014-74.jar

org.apache.derby.jdbc.ClientDriver
com.ibm.as400.access.AS400JDBCDriver




",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-03-24 17:55:35.382,,,no_permission,,,,,,,,,,,,251226,,,Thu Sep 08 19:06:04 UTC 2016,,,,,,,0|i0b63b:,63099,,,,,,,,"24/Mar/14 17:55;jira-bot;Commit 1580939 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1580939 ]

OPENJPA-2286: ArgumentException: Attempt to compare incompatible types class java.util.Date and class org.apache.openjpa.jdbc.sql.Raw","24/Mar/14 18:19;jira-bot;Commit 1580966 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1580966 ]

OPENJPA-2286: ArgumentException: Attempt to compare incompatible types class java.util.Date and class org.apache.openjpa.jdbc.sql.Raw","24/Mar/14 18:26;jira-bot;Commit 1580972 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1580972 ]

OPENJPA-2286: ArgumentException: Attempt to compare incompatible types class java.util.Date and class org.apache.openjpa.jdbc.sql.Raw","24/Mar/14 18:29;jira-bot;Commit 1580973 from [~jpaheath] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1580973 ]

OPENJPA-2286: ArgumentException: Attempt to compare incompatible types class java.util.Date and class org.apache.openjpa.jdbc.sql.Raw","08/Sep/16 19:04;jpaheath;Re-opening to commit to 2.1.x.

Thanks,

Heath","08/Sep/16 19:06;jira-bot;Commit 1759888 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1759888 ]

OPENJPA-2286: ArgumentException: Attempt to compare incompatible types class java.util.Date and class org.apache.openjpa.jdbc.sql.Raw.  Backported changes from 2.2.x.",,,,,,,,,,,,,,,,,,,,,
NPE occurs when <cascade-persist/> is added to a <persistence-unit-defaults> in an orm.,OPENJPA-2284,12613539,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jpaheath,jpaheath,jpaheath,25/Oct/12 19:07,21/Sep/16 14:38,14/Mar/19 03:03,10/Apr/13 15:03,2.0.1,2.2.1,2.3.0,,,,,,2.0.2,2.1.2,2.2.1.1,2.2.2,2.3.0,jpa,,,,0,,,,,,,,"Take this entity:

public class Simple {

  private int id;
  private String name;


Take this orm.xml entry:

  <persistence-unit-metadata>
    <persistence-unit-defaults>
       <schema>MySchema</schema>
       <delimited-identifiers/>
          <!-- The cascade-persist entry causes an issue:      -->
        <cascade-persist/>
    </persistence-unit-defaults>
  </persistence-unit-metadata>

  <entity class=""hat.entities.Simple"" access=""FIELD"">
    <attributes>
      <id name=""id"" />
      <basic name=""name"" />
    </attributes>
  </entity>


With this, the following exception will occur:

Caused by: org.xml.sax.SAXException: file:/E:/jpa/openJPAcode/PMR93141/target/test-classes/META-INF/orm.xml [Location: Line: 16, C: 23]: An error was encountered while parsing element ""id"".  Make sure the metadata file is correctly formatted. [java.lang.NullPointerException]
	at org.apache.openjpa.lib.meta.XMLMetaDataParser.getException(XMLMetaDataParser.java:739)
	at org.apache.openjpa.lib.meta.CFMetaDataParser.endElement(CFMetaDataParser.java:147)
	at org.apache.openjpa.lib.meta.XMLMetaDataParser.endElement(XMLMetaDataParser.java:499)
	at org.apache.xerces.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:579)
	at org.apache.xerces.parsers.AbstractXMLDocumentParser.emptyElement(AbstractXMLDocumentParser.java:218)
	at org.apache.xerces.impl.XMLNamespaceBinder.handleStartElement(XMLNamespaceBinder.java:873)
	at org.apache.xerces.impl.XMLNamespaceBinder.emptyElement(XMLNamespaceBinder.java:590)
	at org.apache.xerces.impl.dtd.XMLDTDValidator.emptyElement(XMLDTDValidator.java:777)
	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:748)
	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(XMLDocumentFragmentScannerImpl.java:1453)
	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:333)
	at org.apache.xerces.parsers.DTDConfiguration.parse(DTDConfiguration.java:524)
	at org.apache.xerces.parsers.DTDConfiguration.parse(DTDConfiguration.java:580)
	at org.apache.xerces.parsers.XMLParser.parse(XMLParser.java:152)
	at org.apache.xerces.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1169)
	at javax.xml.parsers.SAXParser.parse(SAXParser.java:395)
	at org.apache.openjpa.lib.meta.XMLMetaDataParser.parseNewResource(XMLMetaDataParser.java:421)
	... 60 more


If I comment out the '<cascade-persist/>' entry, all works fine.  Note that in the above XML I've added the </schema> and <delimited-identifiers/> entries as well.  Neither of these have an effect on the outcome (they could simply be removed).  I was thinking that if the issue occurred for the cascade stanza that it might also occur for the <delimited-identifiers/> entry since the two are similar in their XML definition (XSD).  However, this issue seems isolated to just the cascade stanza.",,,,,,,,,,,,,,,,,,,03/Dec/12 19:05;jpaheath;OPENJPA-2284-mvn-test.zip;https://issues.apache.org/jira/secure/attachment/12555809/OPENJPA-2284-mvn-test.zip,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,251086,,,Mon Dec 03 19:05:08 UTC 2012,,,,,,,0|i0b42f:,62771,,,,,,,,"03/Dec/12 19:05;jpaheath;I'm attaching my test to recreate this issue.  This is a stand alone maven test/project which can be imported into eclipse as an existing mvn project.....sorry, have not have time to convert it to a test which can be applied to OpenJPA.....the 'Simple.java' entity and orm.xml are the two pertinent pieces.....

Thanks,

Heath",,,,,,,,,,,,,,,,,,,,,,,,,,
ESCAPE '\' is appended to the like clause unexpectedly,OPENJPA-2282,12613027,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,helenxu,helenxu,helenxu,22/Oct/12 19:07,06/Jun/15 21:19,14/Mar/19 03:03,28/Nov/12 16:00,2.3.0,,,,,,,,2.3.0,,,,,sql,,,,0,,,,,,,,"When I run the unit test on TestEJBQLCondExpression.testLikeExpr, I noticed that ESCAPE '\' is appended to the like clause unexpectedly. This could cause the wrong query result.  
",,,,,,,,,,,,,,,,,,,23/Oct/12 14:38;helenxu;OPENJPA-2282.patch;https://issues.apache.org/jira/secure/attachment/12550469/OPENJPA-2282.patch,13/Nov/12 21:40;helenxu;OPENJPA-2282Doc.patch;https://issues.apache.org/jira/secure/attachment/12553374/OPENJPA-2282Doc.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2014-06-05 18:31:01.813,,,no_permission,,,,,,,,,,,,250401,,,Thu Jun 05 19:56:05 UTC 2014,,,Patch Available,,,,0|i0ay5b:,61805,,,,,,,,23/Oct/12 14:38;helenxu;fix and unit test attached,13/Nov/12 21:40;helenxu;attached the doc change,28/Nov/12 16:00;helenxu;The fix and migration doc are added to trunk,"05/Jun/14 18:31;gshank;I was running with openjpa-all-2.2.2 and I was getting ESCAPE's when LIKE was used but now, with v2.3.0, I don't see any ESCAPE's at all for any LIKE's.
","05/Jun/14 19:56;curtisr7;Gary -

Please take a look at the migration guide[1] for 2.3.0 as it looks like that behavior changed.

[1] http://ci.apache.org/projects/openjpa/trunk/docbook/manual.html#jpa_2.3_RequiresSearchStringEscapeForLike",,,,,,,,,,,,,,,,,,,,,,
Old <ciManagement/> info on root POM,OPENJPA-2271,12609885,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,curtisr7,ilgrosso,ilgrosso,02/Oct/12 08:48,06/Jun/15 21:19,14/Mar/19 03:03,02/Oct/12 13:09,,,,,,,,,2.3.0,,,,,build / infrastructure,,,,0,,,,,,,,CI management info say 'Hudson' and an (old) Hudson URL - updating.,,,,,,,,,,,,,,,,,,,02/Oct/12 08:49;ilgrosso;OPENJPA-2271.patch;https://issues.apache.org/jira/secure/attachment/12547358/OPENJPA-2271.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-10-02 13:09:01.081,,,no_permission,,,,,,,,,,,,239717,,,Tue Oct 02 13:09:01 UTC 2012,,,Patch Available,,,,0|i00sx3:,2617,,,,,,,,02/Oct/12 13:09;curtisr7;Committed revision 1392901 to trunk. Thanks for the patch Francesco!,,,,,,,,,,,,,,,,,,,,,,,,,,
Duplicate key exception in sequence table on multithreaded initialization,OPENJPA-2269,12609437,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,garpinc,garpinc,27/Sep/12 18:49,07/Dec/17 07:25,14/Mar/19 03:03,09/Oct/12 12:10,2.2.0,2.3.0,,,,,,,2.3.0,,,,,jdbc,,,,0,,,,,,,,"When using a sequence table that isn't initialized yet, the following exception[2] can occur if running with multiple EMFs across multiple threads. This problem was reported on the users mailing list[1].

[1]
[2]
<openjpa-2.3.0-SNAPSHOT-r422266:1388137M fatal store error> org.apache.openjpa.persistence.RollbackException: Duplicate entry 'ID2' for key 'PRIMARY' {prepstmnt 1162102084 INSERT INTO ID_Gen (GEN_NAME, GEN_VAL) VALUES (?, ?) [params=(String) ID2, (int) 20]} [code=1062, state=23000]
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:594)
	at org.apache.openjpa.persistence.generationtype.TestTableGeneratorMultithreadedInitialization$Worker.run(TestTableGeneratorMultithreadedInitialization.java:107)
Caused by: <openjpa-2.3.0-SNAPSHOT-r422266:1388137M fatal store error> org.apache.openjpa.persistence.EntityExistsException: Duplicate entry 'ID2' for key 'PRIMARY' {prepstmnt 1162102084 INSERT INTO ID_Gen (GEN_NAME, GEN_VAL) VALUES (?, ?) [params=(String) ID2, (int) 20]} [code=1062, state=23000]
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4931)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4906)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:137)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:110)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:62)
	at org.apache.openjpa.jdbc.kernel.AbstractJDBCSeq.next(AbstractJDBCSeq.java:66)
	at org.apache.openjpa.util.ImplHelper.generateValue(ImplHelper.java:161)
	at org.apache.openjpa.util.ImplHelper.generateFieldValue(ImplHelper.java:144)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.assignField(JDBCStoreManager.java:778)
	at org.apache.openjpa.util.ApplicationIds.assign(ApplicationIds.java:493)
	at org.apache.openjpa.util.ApplicationIds.assign(ApplicationIds.java:469)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.assignObjectId(JDBCStoreManager.java:762)
	at org.apache.openjpa.kernel.DelegatingStoreManager.assignObjectId(DelegatingStoreManager.java:135)
	at org.apache.openjpa.kernel.StateManagerImpl.assignObjectId(StateManagerImpl.java:601)
	at org.apache.openjpa.kernel.StateManagerImpl.preFlush(StateManagerImpl.java:3024)
	at org.apache.openjpa.kernel.PNewState.beforeFlush(PNewState.java:44)
	at org.apache.openjpa.kernel.StateManagerImpl.beforeFlush(StateManagerImpl.java:1043)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2114)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2074)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1992)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1516)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:933)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:570)
	... 1 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: Duplicate entry 'ID2' for key 'PRIMARY' {prepstmnt 1162102084 INSERT INTO ID_Gen (GEN_NAME, GEN_VAL) VALUES (?, ?) [params=(String) ID2, (int) 20]} [code=1062, state=23000]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:219)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:195)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$4(LoggingConnectionDecorator.java:194)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:1134)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:272)
	at org.apache.openjpa.jdbc.kernel.TableJDBCSeq.executeUpdate(TableJDBCSeq.java:818)
	at org.apache.openjpa.jdbc.kernel.TableJDBCSeq.insertSequence(TableJDBCSeq.java:503)
	at org.apache.openjpa.jdbc.kernel.TableJDBCSeq.access$1(TableJDBCSeq.java:475)
	at org.apache.openjpa.jdbc.kernel.TableJDBCSeq$AllocateSequenceRunnable.run(TableJDBCSeq.java:903)
	at org.apache.openjpa.jdbc.kernel.TableJDBCSeq.allocateSequence(TableJDBCSeq.java:455)
	at org.apache.openjpa.jdbc.kernel.TableJDBCSeq.nextInternal(TableJDBCSeq.java:300)
	at org.apache.openjpa.jdbc.kernel.AbstractJDBCSeq.next(AbstractJDBCSeq.java:60)
	... 19 more",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-09-27 19:39:44.066,,,no_permission,,,,,,,,,,,,239715,,,Thu Dec 07 07:25:01 UTC 2017,,,,,,,0|i00swn:,2615,,,,,,,,"27/Sep/12 19:39;curtisr7;The root problem is that when trying to get sequence values, we don't anticipate that multiple threads could try to insert a row at the same time. My fix is to catch SQLException upon insertion and try to select a sequence again.

Committed revision 1391185 to trunk.","07/Dec/17 07:22;cryptoe;https://github.com/apache/openjpa/commit/e424097b564273b807f0637056ea244c40a125c3  it the git commit id.
This is fixed in 2.4.0",07/Dec/17 07:25;cryptoe;[~curtisr7] Can you please update the patch version in the jira?,,,,,,,,,,,,,,,,,,,,,,,,
native query select with null result causes NullPointerException,OPENJPA-2267,12609165,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,curtisr7,tedmanleung@gmail.com,tedmanleung@gmail.com,26/Sep/12 02:29,06/Jun/15 21:19,14/Mar/19 03:03,27/Sep/12 21:06,2.2.0,2.3.0,,,,,,,2.3.0,,,,,query,,,,0,,,,,,,,"if you do a native query with a null resultset where the resulting object is not the model object, it causes a null pointer exception.

---------------------------------------------------

mysql> desc Data;
+--------------------------+--------------+------+-----+---------+----------------+
| Field                    | Type         | Null | Key | Default | Extra          |
+--------------------------+--------------+------+-----+---------+----------------+
| id                       | bigint(20)   | NO   | PRI | NULL    | auto_increment |
| data                     | mediumblob   | YES  |     | NULL    |                |
+--------------------------+--------------+------+-----+---------+----------------+
12 rows in set (0.01 sec)

mysql> select count(*) from Data;
+----------+
| count(*) |
+----------+
|        0 |
+----------+
1 row in set (0.00 sec)

mysql> select max(id) from Data;
+---------+
| max(id) |
+---------+
|    NULL |
+---------+
1 row in set (0.00 sec)

now in java do :

Query query = entityManager.createNativeQuery(""select max(id) from Data"", Long.class);
List results = query.getResultList();

The following exception ensues.

---------------------------------------------------

<openjpa-2.2.0-r422266:1244990 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Failed to execute query ""select max(id) from Data"". Check the query syntax for correctness. See nested exception for details.
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:872)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:794)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:286)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302)
...
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.kernel.ResultPacker.pack(ResultPacker.java:202)
	at org.apache.openjpa.jdbc.kernel.SQLProjectionResultObjectProvider.getResultObject(SQLProjectionResultObjectProvider.java:88)
	at org.apache.openjpa.lib.rop.RangeResultObjectProvider.getResultObject(RangeResultObjectProvider.java:80)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:36)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1251)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1007)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:863)","my system is fedora 16, MySql 5.5.18 (running innodb), jdk1.6.0_26, openjdk 2.2.0 (also happened in 2.1.0), mysql-connector-java 5.1.18, commons-dbcp 1.4, spring 3.1.1",,,,,,,,,,,OPENJPA-2195,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-09-27 21:06:21.871,,,no_permission,,,,,,,,,,,,240099,,,Thu Aug 01 15:32:26 UTC 2013,,,,,,,0|i00xbz:,3332,,,,,,,,"26/Sep/12 02:46;tedmanleung@gmail.com;for a work around (at least for mysql users) change the select to 

select ifnull(max(id),0) from Data

Might not work for all use cases but in the case of trying to retrieve the max(id) it will work.",27/Sep/12 21:06;curtisr7;Committed revision 1391218 to trunk.,"31/Jul/13 18:30;jira-bot;Commit 1508983 from [~fyrewyld] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1508983 ]

OPENJPA-2267: native query select with null result causes NullPointerException","01/Aug/13 15:32;jira-bot;Commit 1509299 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1509299 ]

OPENJPA-2267: native query select with null result causes NullPointerException",,,,,,,,,,,,,,,,,,,,,,,
Query SQL Cache issue with NULL parameters,OPENJPA-2261,12606907,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,fyrewyld,fyrewyld,10/Sep/12 16:50,13/Sep/12 15:13,14/Mar/19 03:03,13/Sep/12 15:13,2.1.0,2.1.1,2.2.0,,,,,,2.1.2,2.2.1,2.3.0,,,query,,,,0,,,,,,,,"The Query SQL Cache matches previously executed SQL for a given JPQL by using the JPQL string itself for the key.  As long as none of the predicate parameters are NULL, this is fine, as the prepared statement's SQL remains unchanged.  Since SQL requires ""column IS NULL"" statements and not ""column = NULL"", the approach used by OpenJPA's Query SQL Cache breaks and results with bad getResultList() returns.

In the future (say, trunk), the Query SQL Cache needs more intelligence to handle this situation, but for service releases the best way to handle this issue is to disqualify queries with NULL parameters from the query cache.     ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,240105,,,2012-09-10 16:50:51.0,,,,,,,0|i00xdb:,3338,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Parenthesis-augmented parameters are improperly processed at EM level,OPENJPA-2260,12606896,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,fyrewyld,fyrewyld,10/Sep/12 15:50,13/Sep/12 15:13,14/Mar/19 03:03,13/Sep/12 15:13,2.1.0,2.1.1,2.2.0,,,,,,2.1.2,2.2.1,2.3.0,,,jpa,,,,0,,,,,,,,"The processing of properties for the creation of an EntityManager do not properly handle simple value types that can be augmented by parenthesized configuration options.

For example,

   Map propMap = new HashMap();
   propMap.put(""openjpa.jdbc.QuerySQLCache"", ""true(EnableStatistics=true)"");
   EntityManager em = emf.createEntityManager(propMap);

actually results in the creation of an EntityManager instance where the Query SQL Cache is disabled.  This is because the entire value, ""true(EnableStatistics=true)"" is passed into Strings.parse() which returns the result of a Boolean.valueOf() operation.  Since ""true"" doesn't match ""true(EnableStatistics=true)"", the call to parse() returns false - so in this case, the QuerySQLCache property is set to false causing it to be disabled for that instance of EntityManager.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,240106,,,2012-09-10 15:50:58.0,,,,,,,0|i00xdj:,3339,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Concurreny in org.apache.openjpa.persistence.EntityManagerImpl.getProperties leads to NullPointer and ConcurrentModificationException,OPENJPA-2257,12605972,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,stephan82,stephan82,03/Sep/12 10:28,10/Apr/13 15:04,14/Mar/19 03:03,05/Sep/12 20:11,2.1.2,,,,,,,,2.1.2,2.2.1.1,2.2.2,2.3.0,,jpa,,,,0,concurrency,concurrentmodificationexception,nullpointerexception,,,,,"A call of EntityManager.getProperties() can lead to NullPointer and ConcurrentModificationException. Issue occurs right after start up of the overlying JEE application if multiple EntityManager instance are created at same time.

Please find the issued stack trace below:

Caused by: java.lang.NullPointerException
        at java.lang.String.compareTo(String.java:482)
        at java.lang.String.compareTo(String.java:31)
        at java.util.TreeMap.cmp(TreeMap.java:4514)
        at java.util.TreeMap.putImpl(TreeMap.java:4556)
        at java.util.TreeMap.put(TreeMap.java:4536)
        at java.util.TreeSet.add(TreeSet.java:122)
        at
org.apache.openjpa.lib.conf.ConfigurationImpl.getPropertyKeys(ConfigurationImpl.java:708)
        at
org.apache.openjpa.kernel.BrokerImpl.getSupportedProperties(BrokerImpl.java:729)
        at
org.apache.openjpa.kernel.DelegatingBroker.getSupportedProperties(DelegatingBroker.java:223)
        at
org.apache.openjpa.persistence.EntityManagerImpl.getProperties(EntityManagerImpl.java:1624)
        ... 33 more","AIX 6.1 (64-bit)
WebSphere Application Server V8.0 (32-bit) ",,,,,,,,,,,,,,,,,,06/Sep/12 14:52;allee8285;OPENJPA-2257.patch;https://issues.apache.org/jira/secure/attachment/12544051/OPENJPA-2257.patch,03/Sep/12 10:32;stephan82;OpenJPABugTest.zip;https://issues.apache.org/jira/secure/attachment/12543526/OpenJPABugTest.zip,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-09-05 18:33:02.475,,,no_permission,,,,,,,,,,,,240109,,,Fri Dec 28 16:56:27 UTC 2012,,,,,,,0|i00xe7:,3342,,,,,,,,"05/Sep/12 18:33;allee8285;The problem is caused by the assumption that the configurationImpl obtained from emf is threadsafe since all the configuration values are frozen once the emf is created. However the broker getProperty() implementation defers the building up of the property key collection (_supportedKeys) in the configurationImpl when it is needed, but the _supportedKeys is not synchronized( thread safe), hence the observed exceptions.","05/Sep/12 20:11;allee8285;Fixed only in trunk. To get fixes for 2.1.x, you'll need to request it from WebSphere service channel.","28/Dec/12 16:56;jpaheath;In addition to Albert's changes, I've found that more changes were necessary.  That is, synchronizing on '_supportedKeys' in ConfigurationImpl.getPropertyKeys is necessary and fixes one ConcurrentModificationException/NPE, however, I found another spot which causes a ConcurrentModificationException when the returned '_supportedKeys' is added to by other areas of code.  The exception and stack I saw was the following:

java.util.ConcurrentModification
	at java.util.TreeMap$AbstractMapIterator.makeNext(TreeMap.java:5794)
            at java.util.TreeMap$UnboundedKeyIterator.next(TreeMap.java:5896)
	at org.apache.openjpa.persistence.EntityManagerImpl.getProperties(EntityManagerImpl.java:1624)
	at Test.run(Test.java:26)


From the stack, EntityManagerImpl.getProperties is operating on the the set (i.e. '_supportedKeys') returned by ConfigurationImpl.getPropertyKeys.  In a single threaded environment, operating on the set is just fine.  However, in my test, I had found that if one thread is operating on the set (as shown in the stack above), yet another thread is adding to the set, the ConcurrentModification exception can occur.  While the details of my tests are rather long and nearly impossible to hit in a real world situation, let me basically state that I found that if a thread was in the 'EntityManagerImpl.getProperties' listed above, and another thread was in this portion of code in BrokerImpl:


     public Set<String> getSupportedProperties() {
         Set<String> keys = _conf.getPropertyKeys();
        for (String s : _supportedPropertyNames)
            keys.add(""openjpa."" + s);

A ConcurrentModification exception could occur given that the one thread operating in 'getSupportedProperties' could add to 'keys' (which is really the '_supportedKeys'), and another thread could be iterating over this same set.  This issue seemed to be further complicated, and dependent on, the JDK in use.  I created the above exception by using an IBM JDK which appears to add some inner classes (e.g. .TreeMap$UnboundedKeyIterator) to a TreeMap which performs some additional checks for concurrent access.  Bottom line is that the fix appears to be to return a copy of '_supportedKeys' which is returned by ConfigurationImpl.getPropertyKeys.",,,,,,,,,,,,,,,,,,,,,,,,
Couldn't load the referencedColumn definition when create the JoinTable,OPENJPA-2255,12605631,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,gary,gary,31/Aug/12 01:15,06/Jun/15 21:19,14/Mar/19 03:03,11/Sep/12 15:16,2.1.1,,,,,,,,2.3.0,,,,,jpa,,,,0,documentation,patch,,,,,,"The JoinColumn couldn't have the referencedColumn's definition which includes the length definition. and it's length  should be assigned to the default value 255. 


@Entity 
public class Student { 
  @Id @Column(name=""id"", length=128, nullable=false) private String id; 
  @Column(name=""sName"", length=255) private String sName; 
  @ManyToMany 
  @JoinTable( 
    name=""student_course_map"", 
    joinColumns={@JoinColumn(name=""student_id"", referencedColumnName=""id"", nullable=false)}, 
    inverseJoinColumns={@JoinColumn(name=""course_id"", referencedColumnName=""id"", nullable=false)} 
  ) 
  public Collection getCourses() 

  ... 
} 

@Entity 
public class Courses{ 
  @Id @Column(name=""id"", length=128, nullable=false) private String id; 
  @Column(name=""cName"", length=255) private String cName; 

  ... 
} 

We can see the student id length has been defined to 128. And there is no definition length in the JoinColumn student_id. The JoinColumn should be set to the default value 255. 

The warning message will occur like this 

WARN  [Schema] Existing column ""student_id"" on table ""test.student_course_map"" is incompatible with the same column in the given schema definition. Existing column: 
Full Name: student_course_map.student_id 
Type: varchar 
Size: 128 
Default: null 
Not Null: true 
Given column: 
Full Name: student_course_map.student_id 
Type: varchar 
Size: 255 
Default: null 
Not Null: true ",,,,,,,,,,,,,,,,,,,31/Aug/12 21:54;allee8285;OPENJPA-2255.patch;https://issues.apache.org/jira/secure/attachment/12543347/OPENJPA-2255.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-08-31 22:06:34.127,,,no_permission,,,,,,,,,,,,240111,,,Thu Sep 06 16:25:16 UTC 2012,,,,,,,0|i00xen:,3344,,,,,,,,"31/Aug/12 22:06;allee8285;This problem only happens when 
* @JoinTable is specified in the entity.
* String type entity identity field
* database table is created with join column id with length other than the database specific column length.

This problem also affects the Mapping tool creating database table operation, always assume database defect VARCHAR/CHAR length define in the database dictionary.

Attached a patch for trunk. Please try if this has resolved your issue. 

For fix/commit for 2.2.x, 2.1.x and 2.0.x releases, you will need to work with IBM service channel to get this fix in these releases.

Albert Lee.
","05/Sep/12 02:39;gary;Thanks,Albert. I got your patch, and apply it into my server (geronimo-tomcat7-javaee6-3.0.0), The warning message mentioned in the jira did disappear, but another message occurred. Same message, same problem. But the difference is the column is defined in ManyToOne annotation.

The source is below.

 @ManyToOne(optional=true, cascade={CascadeType.PERSIST, CascadeType.MERGE}) @JoinColumn(name=""classField"") private Location schoolField;

The message is below.

2012-09-05 09:19:58,293 WARN  [Schema] Existing column ""classField"" on table ""test.classField"" is incompatible with the same column in the
 given schema definition. Existing column:
Full Name: classes.classField
Type: varchar
Size: 255
Default: null
Not Null: false
Given column:
Full Name: classes.classField
Type: varchar
Size: 128
Default: null
Not Null: false","05/Sep/12 21:04;allee8285;XieZhi,

Can you provide a more concrete test case and the conditions reproducing the failure?

","06/Sep/12 16:25;allee8285;I don't think the new message is in error.

What the message saying is the classField in the database has column length 255 and whereas the id field of the @OneToMany side has column length 128. This means OpenJPA recognized the length=128 set on the id field. Before the patch, join column did not pick up the id column length and defaulted to 255, therefore this message did not happened. Either the id column has to match the join column length or the join column length need to match the id length.  

This is just the reverse of the original scenario.

Albert Lee.",,,,,,,,,,,,,,,,,,,,,,,
Memory leak in Audit feature,OPENJPA-2253,12604028,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,ppoddar@apache.org,yaytay,yaytay,20/Aug/12 10:08,06/Jun/15 21:19,14/Mar/19 03:03,29/Oct/13 08:03,2.2.0,2.3.0,,,,,,,2.3.0,,,,,,,,,0,,,,,,,,"Note: Is a blocker for the audit facility, removing audit lets us continue (obviously without any audit :)

We are getting major memory leaks from an OSGi application using OpenJPA with auditing (and with a custom auditor).

Mail thread with problem identified by Rick Curtis:
http://mail-archives.apache.org/mod_mbox/openjpa-users/201208.mbox/browser

Quote: I think the problem is that in
AuditManager<eclipse-javadoc:%E2%98%82=openjpa-kernel/src%5C/main%5C/java%3Corg.apache.openjpa.kernel%7BAuditManager.java%E2%98%83AuditManager>.afterBegin(...)
we register a listener (Broker.addLifecycleListener), but we fail to
deregister this listener.

I've stopped auditing my large objects but the problem persists: any @Auditable object accessed remains in memory forever.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-09-12 15:49:29.716,,,no_permission,,,,,,,,,,,,240113,,,Tue Oct 29 08:03:22 UTC 2013,,,,,,,0|i00xf3:,3346,,,,,,,,"12/Sep/12 15:49;curtisr7;Pinaki -- I see you committed some changes for this JIRA. 

Yaytay -- Can you confirm that his changes fix your problem?","29/Oct/13 08:03;struberg;Closing as fixed as I know a few people who use this feature with 2.3.0-SNAPSHOT and not had this problem it seems.
Please reopen if the problem persists.",,,,,,,,,,,,,,,,,,,,,,,,,
JoinColumn annotation is ignored when mapping a unidirectional owned OneToOne that is in a SecondaryTable,OPENJPA-2247,12601384,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,curtisr7,curtisr7,03/Aug/12 15:29,21/Sep/16 14:38,14/Mar/19 03:03,09/Oct/12 18:18,2.0.1,2.1.2,2.2.1,2.3.0,,,,,2.0.2,2.1.2,2.2.1,2.3.0,,kernel,,,,0,,,,,,,,"The runtime incorrectly ignores @JoinColumn.name when mapping a unidirectional owned OneToOne that is in a SecondaryTable.

This problem only exists when running with a persistence.xml that is set to 2.0 (version=""2.0"">).

For example:

@Entity
@SecondaryTable(name = ""ParentSecondaryTable"", pkJoinColumns = 
    { @PrimaryKeyJoinColumn(name = ""idParent"", referencedColumnName = ""idParent"") })
public class Parent {

    @Id
    @GeneratedValue
    int idParent;

    String child_ref;

    @OneToOne
    @JoinColumn(name = ""CHILD_REF"", table = ""ParentSecondaryTable"", referencedColumnName = ""idChild"")
    PChild child;

}

The column ""CHILD_REF"" will be ignored and the runtime will look for the fk in non-existent column ParentSecondaryTable.CHILD_IDCHILD.",,,,,,,,,,,,,,,,,,,01/Oct/12 22:13;allee8285;OPENJPA-2247.20x.patch;https://issues.apache.org/jira/secure/attachment/12547286/OPENJPA-2247.20x.patch,01/Oct/12 22:13;allee8285;OPENJPA-2247.21x.patch;https://issues.apache.org/jira/secure/attachment/12547287/OPENJPA-2247.21x.patch,01/Oct/12 22:13;allee8285;OPENJPA-2247.22x.patch;https://issues.apache.org/jira/secure/attachment/12547288/OPENJPA-2247.22x.patch,01/Oct/12 22:13;allee8285;OPENJPA-2247.trunk.patch;https://issues.apache.org/jira/secure/attachment/12547289/OPENJPA-2247.trunk.patch,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2012-09-25 17:34:37.753,,,no_permission,,,,,,,,,,,,240119,,,Mon Oct 01 19:09:04 UTC 2012,,,,,,,0|i00xgf:,3352,,,,,,,,03/Aug/12 15:40;curtisr7;Committed revision 1369043 to trunk.,25/Sep/12 17:34;allee8285;Fix committed under revision 1369042 to trunk.,"01/Oct/12 17:04;jpaheath;HI!  Please note that part of this fix (Revision 1369042) was incorrectly listed under JIRA OPENJPA-2229.

Thanks,

Heath",01/Oct/12 19:09;allee8285;Reopen the issue to address similar problem affecting the 1x1 bi and mx1 uni use case.,,,,,,,,,,,,,,,,,,,,,,,
NotSerializableException when using a remote QueryCache and the Criteria API,OPENJPA-2245,12601211,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,02/Aug/12 12:41,19/Aug/16 18:57,14/Mar/19 03:03,19/Aug/16 18:57,2.2.0,2.3.0,,,,,,,2.2.3,2.3.0,2.4.2,,,criteria,datacache,query,,0,,,,,,,,"When running with a remote QueryCache and using the Criteria API the following exception will occur:


<openjpa-2.3.0-SNAPSHOT-r422266:1367126M nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Failed to execute query ""null"". Check the query syntax for correctness. See nested exception for details.
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:872)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:794)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:286)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302)
	at org.apache.openjpa.persistence.criteria.TestRemoteQueryCacheCriteriaQuery.test(TestRemoteQueryCacheCriteriaQuery.java:42)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:600)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runTest(AbstractPersistenceTestCase.java:579)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:566)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:542)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:206)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
Caused by: java.lang.RuntimeException: java.io.NotSerializableException: org.apache.openjpa.persistence.criteria.CriteriaQueryImpl
	at org.apache.openjpa.persistence.criteria.SerializingConcurrentQueryCache.roundtrip(SerializingConcurrentQueryCache.java:57)
	at org.apache.openjpa.persistence.criteria.SerializingConcurrentQueryCache.get(SerializingConcurrentQueryCache.java:36)
	at org.apache.openjpa.datacache.QueryCacheStoreQuery.checkCache(QueryCacheStoreQuery.java:125)
	at org.apache.openjpa.datacache.QueryCacheStoreQuery.access$000(QueryCacheStoreQuery.java:63)
	at org.apache.openjpa.datacache.QueryCacheStoreQuery$QueryCacheExecutor.executeQuery(QueryCacheStoreQuery.java:342)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1005)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:863)
	... 27 more
Caused by: java.io.NotSerializableException: org.apache.openjpa.persistence.criteria.CriteriaQueryImpl
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1173)
	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:336)
	at org.apache.openjpa.datacache.QueryKey.writeExternal(QueryKey.java:451)
	at java.io.ObjectOutputStream.writeExternalData(ObjectOutputStream.java:1438)
	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1407)
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1167)
	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:336)
	at org.apache.openjpa.persistence.criteria.SerializingConcurrentQueryCache.roundtrip(SerializingConcurrentQueryCache.java:52)
	... 33 more
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2016-08-19 18:53:32.858,,,no_permission,,,,,,,,,,,,240121,,,Fri Aug 19 18:57:03 UTC 2016,,,,,,,0|i00xgv:,3354,,,,,,,,"02/Aug/12 12:53;curtisr7;Rather than making CriteriaQueryImpl and all objects it references serializable, it is much simpler to hold onto the stringified version(SQL) of the CriteriaQuery in the QueryKey.",02/Aug/12 12:57;curtisr7;Committed revision 1368438 to trunk.,"19/Aug/16 18:53;jira-bot;Commit 1756957 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1756957 ]

OPENJPA-2245: NotSerializableException when using a remote QueryCache and the Criteria API.  Back ported to 2.2.x Rick Curtis' changes in trunk.","19/Aug/16 18:57;jpaheath;Going to commit change to 2.2.x.

Thanks,

Heath",,,,,,,,,,,,,,,,,,,,,,,
Nested classpath ignored in mapping tool ant task,OPENJPA-2244,12601129,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,helenxu,helenxu,helenxu,01/Aug/12 21:43,21/Sep/16 14:38,14/Mar/19 03:03,10/Apr/13 15:05,2.0.1,2.1.1,2.2.0,,,,,,2.0.2,2.1.2,2.2.1.1,2.2.2,2.3.0,,,,,0,,,,,,,,"The nested classpath element inside the mappingtool ant task are ignored when loading the persistent configuration file. User got the following error:

<openjpa-2.0.2-SNAPSHOT-r422266:1361284M fatal user error> org.apache.openjpa.util.MetaDataException: MetaDataFactory could not be configured (conf.newMetaDataFactoryInstance() returned null). This might mean that no configuration properties were found. Ensure that you have a META-INF/persistence.xml file, that it is available in your classpath, or that the properties file you are using for configuration is available. If you are using Ant, please see the <properties> or <propertiesFile> attributes of the task's nested <config> element. This can also occur if your OpenJPA distribution jars are corrupt, or if your security policy is overly strict.",,,,,,,,,,,,,,,,,,,19/Sep/12 20:47;helenxu;OPENJPA-2244.patch;https://issues.apache.org/jira/secure/attachment/12545800/OPENJPA-2244.patch,03/Aug/12 18:36;helenxu;OPENJPA-2244.patch;https://issues.apache.org/jira/secure/attachment/12539075/OPENJPA-2244.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,240122,,,Wed Sep 19 20:47:01 UTC 2012,,,Patch Available,,,,0|i00xh3:,3355,,,,,,,,"02/Aug/12 15:02;helenxu;The fix is to add the ant classloader before loading the configuration file.

patch attached.",03/Aug/12 18:36;helenxu;new patch attached to load context classloader only when it is needed.,"19/Sep/12 20:47;helenxu;When user specifies the properties attribute inside the config element to point to a specific persistence config file and persistent unit, the persistence config file or unit cannot be loaded from the nested classpath as well. here is an example:
<mappingtool schemaAction=""build"" sqlFile=""create.sql"">  
      	<classpath>
      		<pathelement location=""mapping-tool-pi.jar"" /> 
      		<pathelement location=""mapping-tool-persistenceunit-pi.jar"" /> 
      		<pathelement location=""./"" />
      	</classpath>
        <config propertiesFile=""""persistence.xml#mappingtool-pu"" connectionDriverName=""com.ibm.db2.jcc.DB2Driver""/>
</mappingtool> 

user will get the following exception
Caused by: java.util.MissingResourceException: persistence.xml#mappingtool-pu
	at org.apache.openjpa.lib.conf.ProductDerivations.load(ProductDerivations.java:286)
	at org.apache.openjpa.lib.conf.ConfigurationImpl.setProperties(ConfigurationImpl.java:858)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)
	at java.lang.reflect.Method.invoke(Method.java:611)
	at org.apache.tools.ant.IntrospectionHelper$AttributeSetter.setObject(IntrospectionHelper.java:1498)
	at org.apache.tools.ant.IntrospectionHelper.setAttribute(IntrospectionHelper.java:405)

The reason it failed to load the config is:
1. It doesn't have the properties value parsing to separate the file name and persistent unit name
2. ConfigurationImpl.setProperties() didn't take the ant class loader when it try to load the config file, or it loaded the config file too early. Ideally it should wait until all the classpath setting loaded. 
This problem will happen for all types of OPENJPA ant task.

I have created a fix for this problem. please refer to the patch file for details.
",,,,,,,,,,,,,,,,,,,,,,,,
JVMVRFY012 when using openjpa together with hyperjaxb3,OPENJPA-2240,12600145,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,kwsutter,nannou9,nannou9,25/Jul/12 10:32,10/Apr/13 16:03,14/Mar/19 03:03,10/Apr/13 16:03,2.2.0,2.2.1,2.3.0,,,,,,2.2.2,2.3.0,,,,Enhance,,,,0,enhancement,hyperjaxb3,jpa,stubs,xsd,,,"We are facing a problem with class enhancing generated by hyperjaxb3.

""Caused by: java.lang.VerifyError: JVMVRFY012 stack shape inconsistent; class=foo/Bar, metoda=pcgetDataTimeItem()Ljava/util/Date;, pc=7""

The problem occurs on every usage of non JPA compatible type like XMLGregorianCalendar.
For those types, the hyperjaxb3 plugin creates a kind of ""proxy"" setter/getter that uses JPA capable type.

Example of such proxy getter/setter:
<code>
        @Basic
        @Column(name = ""DATATIMEITEM"")
        @Temporal(TemporalType.TIMESTAMP)
        public Date getDataTimeItem() {
            return XmlAdapterUtils.unmarshall(XMLGregorianCalendarAsDateTime.class, this.getDataTime());
        }
</code>

then the XmlAdapterUtils.unmarshall looks like:

<code>
	public static <ValueType, BoundType> BoundType unmarshall(
			Class<? extends XmlAdapter<ValueType, BoundType>> xmlAdapterClass,
			ValueType v) {
		try {
			final XmlAdapter<ValueType, BoundType> xmlAdapter = getXmlAdapter(xmlAdapterClass);
			return xmlAdapter.unmarshal(v);
		} catch (Exception ex) {
			throw new RuntimeException(ex);
		}
	}
</code>

I have found that the problem occurs only because of the type of XmlAdapterUtils.unmarshall method. The problem is that it's 1st type is a ""Class"". Changing the 1st type from Class type to any other like Object solves the problem but it is not a solution.

I think the problem is somewhere in serp project as after the enhancment process of classes containing non JPA capable XSD types, each call of that class generates the JVMVRFY012 exception- even during junit tests.

Please note, that this bug is a blocker for my project.","IBM-JDK, SUN-JDK",,,,,,,,,,,,,,,,,,30/Aug/12 08:01;nannou9;OpenJpa2240BugTestProject_v1.1.tar.gz;https://issues.apache.org/jira/secure/attachment/12543056/OpenJpa2240BugTestProject_v1.1.tar.gz,29/Aug/12 15:32;kwsutter;mvn.out;https://issues.apache.org/jira/secure/attachment/12542932/mvn.out,01/Sep/12 15:12;kwsutter;serp-1.14.1.jar;https://issues.apache.org/jira/secure/attachment/12543430/serp-1.14.1.jar,01/Sep/12 15:12;kwsutter;serp-1.14.1.pom;https://issues.apache.org/jira/secure/attachment/12543431/serp-1.14.1.pom,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2012-07-25 18:11:57.997,,,no_permission,,,,,,,,,,,,240126,,,Thu Sep 06 13:25:11 UTC 2012,,,,,,,0|i00xhz:,3359,,,,,,,,"25/Jul/12 18:11;kwsutter;Hmmm...  The error you reported sounds identical to the Java 7 class format errors that were corrected via https://issues.apache.org/jira/browse/OPENJPA-2122 and https://issues.apache.org/jira/browse/OPENJPA-2085.  But, both of these were resolved before the 2.2.0 release was cut...

In your Environment, you mention both the IBM and Sun JDKs.  What version of Java are you using?  I will assume Java 7 since we never experienced the VerifyError before that.  Is it possible for you to try Java 6?  I'm just looking for a quick workaround for you since figuring out the necessary changes to ASM and/or Serp will take some time (if this is a new problem).

You also mention that this affects OpenJPA 2.2.0.  Can you verify that this version is actually in use in your scenario.  And, have you tried to turn on Trace during the enhancement process to verify that ASM is getting invoked to ""clean up"" these StackMapTable issues?

Thanks for your help in attempting to debug this problem.

Kevin","26/Jul/12 07:21;nannou9;Hi Kevin,

Thanks for quick reply.

I am using IBM-JDK as follows:
java version ""1.6.0""
Java(TM) SE Runtime Environment (build pxa6460sr10-20111208_01(SR10))
IBM J9 VM (build 2.4, JRE 1.6.0 IBM J9 2.4 Linux amd64-64 jvmxa6460sr10-20111207_96808 (JIT enabled, AOT enabled)
J9VM - 20111207_096808
JIT  - r9_20111107_21307ifx1
GC   - 20110519_AA)
JCL  - 20111104_02

I've been testing the problem with following OpenJPA versions: 2.2.0, 2.3.0-SNAPSHOT.
I have also tried with serp 1.14.2 w/o success.

As i said the problem disappears after removing all Class type parameters from methods invoked from enriched entities.

I will try to provide some debug info in about 2 days as i have much different ""todos"" right now.

Greetings
Piotr Klimczak","26/Jul/12 08:23;nannou9;As i ""cannot sleep"" because of that bug, i have tried to trace is as you wish.
Unfortunately i have found nothing interesting:

122  INFO   [main] openjpa.Tool - Enhancer running on type ""class pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"".
133  TRACE  [main] openjpa.MetaData - Loading metadata for ""class pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"" under mode ""[META]"".
133  TRACE  [main] openjpa.MetaData - Parsing class ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"".
150  TRACE  [main] openjpa.MetaData - Generating default metadata for type ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"".
151  TRACE  [main] openjpa.MetaData - Using reflection for metadata generation.
159  TRACE  [main] openjpa.MetaData - Set persistence-capable superclass of ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"" to ""null"".
159  TRACE  [main] openjpa.MetaData - Resolving metadata for ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne@1436046744"".
160  TRACE  [main] openjpa.MetaData -   Resolving field ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne@1436046744.dataTimeItem"".
163  TRACE  [main] openjpa.MetaData -   Resolving field ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne@1436046744.hjid"".
163  TRACE  [main] openjpa.MetaData -   Resolving field ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne@1436046744.offlineId"".
163  TRACE  [main] openjpa.MetaData -   Resolving field ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne@1436046744.retry"".
164  TRACE  [main] openjpa.MetaData - Preparing mapping for ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"".
164  TRACE  [main] openjpa.MetaData - Resolving mapping for ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne@1436046744"".
164  TRACE  [main] openjpa.Enhance - Enhancing type ""class pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"" loaded by java.net.URLClassLoader@71a371a3.
173  WARN   [main] openjpa.Enhance - Detected the following possible violations of the restrictions placed on property access persistent types:
""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"" uses property access, but its field ""offlineId"" is accessed directly in method ""copyTo"" defined in ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"".
""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"" uses property access, but its field ""offlineId"" is accessed directly in method ""copyTo"" defined in ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"".
""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"" uses property access, but its field ""retry"" is accessed directly in method ""copyTo"" defined in ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"".
""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"" uses property access, but its field ""retry"" is accessed directly in method ""copyTo"" defined in ""pl.com.bgk.smx.kgapi.contract.basics.types.BasicResponseData$Offilne"".


The class enhance is successful. The problem occurs on every each usage of this class by an app. Even during junit test case.

If you need more debug info i will do my best to provide it.

Greetings,
Piotr","26/Jul/12 14:42;kwsutter;Thanks for the info, Piotr.  I was surprised to see that you are running Java 6.  I hadn't seen the VerifyError with Java 6, only Java 7.  In Java 7, the class verification was turned on by default.  In Java 6, this class verification was supposed to be optional.  Is there any chance that you running with class verification?  If so, can you turn it off?  Since we introduced a dependency on ASM to correct these StackMapTable errors with Java 7, is there any chance you could build/enhance with Java 7.  If that helps, then maybe we can just enable ASM for Java 6 class files as well as Java 7.  In the mean time, if I have time, I will try to reproduce the issue locally with your submitted entity definitions.  Thanks.

Kevin","26/Jul/12 15:10;nannou9;No problem. Will try to reproduce the problem with IBM JDK 7 tomorrow morning.

Piotr","26/Jul/12 20:37;kwsutter;I have been trying to reproduce the situation with no luck.  Granted, I don't have the hyperjaxb and the associated XML libraries.  But, from your description, it sounded like I should be able to reproduce the VerifyError with an extra helper getter method that called a utility method passing in a .class as the first parameter.  Just something to complicate the getter method just enough to screw up the StackMapTables.  But, I have had no luck.  As an example, here's what I added to a simple Entity class:

    @Basic
    @Column(name = ""DATATIMEITEM"")
    @Temporal(TemporalType.TIMESTAMP)
    public Date getDataTimeItem() {
        //  return XmlAdapterUtils.unmarshall(XMLGregorianCalendarAsDateTime.class, this.getDataTime()); 
        return unmarshall(XMLGregorianCalendar.class, this.getDateField());
    }

    private Date unmarshall(Class<XMLGregorianCalendar> class1, Date dateField2) {
        // TODO Auto-generated method stub
        return dateField2;
    }

I tried this with Java6sr9 (my current default), Java6sr10 (your current Java), and Java7.  No luck with reproducing.  If you can help with narrowing down the scenario with a simpler testcase, or maybe provide the Entity classes and needed libraries to reproduce it, I'm very interested in tracking down this problem.  Thanks.","27/Jul/12 08:50;nannou9;Hi Kevin!

Thanks again for your help.

According to your test It is possible you have no luck because the method with Class type parameter was a static method placed in different class/file.
In my situation an entity getter calls:

<code>
            return XmlAdapterUtils.unmarshall(XMLGregorianCalendarAsDateTime.class, this.getDataTime());
</code>

Please also note, the the unmarshall method was generic.","27/Jul/12 09:02;nannou9;There is very same problem on Java7.

Caused by: java.lang.VerifyError: JVMVRFY012 niespójny kształt stosu; klasa=foo/BasicResponseData$Offilne, metoda=pcgetDataTimeItem()Ljava/util/Date;, pc=7
        at java.lang.J9VMInternals.verifyImpl(Native Method)
        at java.lang.J9VMInternals.verify(J9VMInternals.java:85)
        at java.lang.J9VMInternals.initialize(J9VMInternals.java:162)
        at java.lang.Class.forNameImpl(Native Method)
        at java.lang.Class.forName(Class.java:139)
.......

Tested with:
java version ""1.7.0""
Java(TM) SE Runtime Environment (build pxa6470sr1-20120330_01(SR1))
IBM J9 VM (build 2.6, JRE 1.7.0 Linux amd64-64 20120322_106209 (JIT enabled, AOT enabled)
J9VM - R26_Java726_SR1_20120322_1720_B106209
JIT  - r11_20120322_22976
GC   - R26_Java726_SR1_20120322_1720_B106209
J9CL - 20120322_106209)
JCL - 20120322_01 based on Oracle 7u3-b05

","27/Jul/12 14:58;kwsutter;Hi Piotr,
Still no luck with reproducing the problem.  I created a separate Utility class and created this static unmarshall() method.  Still works just fine.

And, it wasn't good to hear that your problem still exists with the Java 7 build environment.  That means that the ASM solution we put in place for Java 7 doesn't help in your situation either.  You did re-build and re-enhance with Java 7, correct?  That's where the ASM ""magic"" occurs is with the enhancement processing.

Can you provide the actual Entity classes (before and after enhancement)?  If you can also provide the utility classes that would allow us to load the classes to reproduce the problem, that would be great.  Thanks!

Kevin",15/Aug/12 12:08;nannou9;A quick simple project reproducing reported bug.,"15/Aug/12 12:11;nannou9;Hi Kevin,

Sorry for late answer- I have just returned from holidays.
As you can see, I have uploaded simple maven project reproducing reported bug.

The bug occurs on very simple test case that creates an instance of ""Page"" class which contains xsd:dateTime type as an XMLGregorianCalendar.

I've tested it on:

java version ""1.6.0_31""
Java(TM) SE Runtime Environment (build 1.6.0_31-b04)
Java HotSpot(TM) 64-Bit Server VM (build 20.6-b01, mixed mode)

The result is a little different than above. Probably because of different JDK.
-------------------------------------------------------------------------------
Test set: pl.klimczakowie.site.dev.site.domain.OpenJPA2240bugTest
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.079 sec <<< FAILURE!
test(pl.klimczakowie.site.dev.site.domain.OpenJPA2240bugTest)  Time elapsed: 0.039 sec  <<< ERROR!
java.lang.VerifyError: (class: pl/klimczakowie/site/dev/site/domain/Page, method: pcgetLastModItem signature: ()Ljava/util/Date;) Incompatible argument to function
        at pl.klimczakowie.site.dev.site.domain.OpenJPA2240bugTest.test(OpenJPA2240bugTest.java:34)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
        at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
        at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
        at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
        at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
        at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
        at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
        at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:62)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:138)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:125)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:132)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:308)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:879)
","15/Aug/12 14:07;nannou9;The result of uploaded project on IBM JDK 6:

java version ""1.6.0""
Java(TM) SE Runtime Environment (build pxa6460sr9fp2-20110625_01(SR9 FP2))
IBM J9 VM (build 2.4, JRE 1.6.0 IBM J9 2.4 Linux amd64-64 jvmxa6460sr9-20110624_85526 (JIT enabled, AOT enabled)
J9VM - 20110624_085526
JIT  - r9_20101028_17488ifx17
GC   - 20101027_AA)
JCL  - 20110530_01

Result:
-------------------------------------------------------------------------------
Test set: pl.klimczakowie.site.dev.site.domain.OpenJPA2240bugTest
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.103 sec <<< FAILURE!
test(pl.klimczakowie.site.dev.site.domain.OpenJPA2240bugTest)  Time elapsed: 0.06 sec  <<< ERROR!
java.lang.VerifyError: JVMVRFY012 stack shape inconsistent; class=pl/klimczakowie/site/dev/site/domain/Page, method=pcgetLastModItem()Ljava/util/Date;, pc=7
        at java.lang.J9VMInternals.verifyImpl(Native Method)
        at java.lang.J9VMInternals.verify(J9VMInternals.java:72)
        at java.lang.J9VMInternals.initialize(J9VMInternals.java:134)
        at pl.klimczakowie.site.dev.site.domain.OpenJPA2240bugTest.test(OpenJPA2240bugTest.java:34)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)
        at java.lang.reflect.Method.invoke(Method.java:611)
        at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
        at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
        at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
        at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
        at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
        at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
        at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
        at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:62)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:138)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:125)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:132)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)
        at java.lang.reflect.Method.invoke(Method.java:611)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:308)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:879)



The result of uploaded project on IBM JDK 7:

java version ""1.7.0""
Java(TM) SE Runtime Environment (build pxa6470sr1-20120330_01(SR1))
IBM J9 VM (build 2.6, JRE 1.7.0 Linux amd64-64 20120322_106209 (JIT enabled, AOT enabled)
J9VM - R26_Java726_SR1_20120322_1720_B106209
JIT  - r11_20120322_22976
GC   - R26_Java726_SR1_20120322_1720_B106209
J9CL - 20120322_106209)
JCL - 20120322_01 based on Oracle 7u3-b05


Result:
-------------------------------------------------------------------------------
Test set: pl.klimczakowie.site.dev.site.domain.OpenJPA2240bugTest
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.089 sec <<< FAILURE!
test(pl.klimczakowie.site.dev.site.domain.OpenJPA2240bugTest)  Time elapsed: 0.048 sec  <<< ERROR!
java.lang.VerifyError: JVMVRFY012 stack shape inconsistent; class=pl/klimczakowie/site/dev/site/domain/Page, method=pcgetLastModItem()Ljava/util/Date;, pc=7
        at java.lang.J9VMInternals.verifyImpl(Native Method)
        at java.lang.J9VMInternals.verify(J9VMInternals.java:85)
        at java.lang.J9VMInternals.initialize(J9VMInternals.java:162)
        at pl.klimczakowie.site.dev.site.domain.OpenJPA2240bugTest.test(OpenJPA2240bugTest.java:34)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:88)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:55)
        at java.lang.reflect.Method.invoke(Method.java:613)
        at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
        at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
        at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
        at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
        at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)
        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
        at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
        at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
        at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:62)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:138)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:125)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:132)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:88)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:55)
        at java.lang.reflect.Method.invoke(Method.java:613)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:308)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:879)


Each time running #mvn clean install.","28/Aug/12 06:13;nannou9;Hi Kevin!

Thank you for your help!

Did you succeed with bug reproduction using my example project?
Do you want me to provide more examples? Or maybe to simplify the example?

Greetings,
Piotr Klimczak
","29/Aug/12 13:44;kwsutter;Thank you, Piotr, for the sample.  I was out on vacation recently and just missed these updates.  I will try to reproduce with your sample and, hopefully, figure out a solution quickly...  Thanks.","29/Aug/12 15:32;kwsutter;My ""mvn clean install"" output...  Can't do some of the mvn processing...  Maybe due to an older version of maven?","29/Aug/12 16:58;kwsutter;Piotr, As you can see by the attachment, I tried your ""simple"" project and I seem to be having an issue with attempting to override the output directory...  I did some searching and it doesn't look like this was supposed to be overridable...  But, maybe that changed in some later version of maven?  Anyway, I don't have the project running yet...  I can see where this is a bit more involved than what I had hoped...  Running with jaxb generated entities and the XML types complicates the example just a bit...  Hopefully, you have some ideas on how to quickly get the project building.  Thanks.",30/Aug/12 08:01;nannou9;Fixed Spring dep. missing form jaxb2 plugin,"30/Aug/12 08:16;nannou9;I am using maven 3.0.4.
I have reuploaded the project with one small fix- added spring-context dep. to jaxb plugin which fixes possible ClassNotFoundException during stubs generation.

According to outputDirectory- yes, it is not docummented, but it works in older versions of maven and is extremely helpful (2.0.2 for example). In newer version 2.2+ there is a generatedSourcesDirectory which is doing same thing as outputDirectory in older versions.
So you can comment this line if you want or change it to ""generatedSourcesDirectory"" (if you are using newer compiler plugin), as it is responsible only for overriding the output directory of entities metamodel sources, to let them be easily accessible by eclipse (in target/jaxws as all other stubs).

Greetings,
Piotr Klimczak","30/Aug/12 14:08;kwsutter;Piotr, I have now reproduced the problem.  Good news!  I did end up changing the errant outputDirectory to the generatedSourcesDirectory in the pom.xml.  I'll now take a closer look at the VerifyError.  Thanks for the sample project.","31/Aug/12 20:58;kwsutter;Piotr, I have found the problem.  It's in the Serp enhancement code.  It looks like Serp never expected a Class constant to be loaded via an ldc operation.  In the second edition of the JVM, the ldc was limited to loading int, long, float, double, and String.  Sometime later, this was expanded to allow loading of Class objects from the constant pool.  Serp was never updated to allow for this.

Your Page.class required the loading of a Class constant for that first parameter to the unmarshall() method.  When we used Serp to create the pcgetLastMod() method, the code that was transferred over from the original getLastMod() method didn't transfer correctly because this loading of Class constants was not recognized properly.

I have done a quick patch in my own environment and I can now load your enhanced Page.class.  I'm going to try our Junit bucket to see what I am going to break with this type of change.  And, then I need to figure out how to get a fix into the Serp code.  :-)  It's been so solid for so many years that nobody has had to update it.  As soon as I get something I am comfortable with, I'll post a patch so that you might try it out in your environment as well.","01/Sep/12 15:10;kwsutter;Piotr, I found an even easier solution (I hope)...  As I was checking into the updating of the Serp code, I noticed there was a later version of Serp (1.14.1) that stated, ""Fix class constant copying bug.""  Sounds familiar, huh? So, I re-built a local copy of OpenJPA 2.2.0  and a local copy of Serp 1.14.1.  Tried your test project and all is working.  I also verified that all of the JUnits are also working.  The problem is that this version of Serp is not in the Maven Central repo...  And, I'm not exactly sure how to get it there...  It's a SourceForge project.  If anybody has any insights on how to get it published to the maven repo, let me know.  Otherwise, I'll dig into it further this weekend.

In the mean time, I'll upload a copy of the Serp 1.14.1 jar and pom in case you want to install it into your local repo and try some testing.  Thanks.",01/Sep/12 15:12;kwsutter;Serp 1.14.1 jar and pom until we figure out how to publish these to the maven repo...,"03/Sep/12 07:21;nannou9;Hi Kevin!

I am very happy to hear the problem is solved! :) THANKS!

Now i have to wait for serp to be available in public repo. Unfortunately due to security reasons I cannot use other repos than public ones so i have to wait.
Do you know which version of openjpa will fix the problem (public available version) and when it will be available?

Once again thanks...
Piotr","05/Sep/12 21:02;kwsutter;Piotr,
I have figured out a way to update Maven Central with the updated Serp.  I will be fixing this dependency in OpenJPA Trunk (2.3.0-SNAPSHOT).  I have pinged the owners of the service branches (2.0.x, 2.1.x, and 2.2.x) that this issue also applies to those releases.  The tricky part is the updating of a dependency in a service stream and how that dependency update may affect other unrelated processing.  Basically, it will require additional testing -- more than the basic JUnit bucket that I will be using before integrating the change into Trunk.

If Trunk (2.3.0-SNAPSHOT) will work for you, then great, we're done.  If you require this change in a service stream (ie. 2.2.x), please indicate which one so that the appropriate changes, decisions, and testing can be done.  Thank you.","06/Sep/12 13:25;kwsutter;For future reference, I have documented how to update Serp in Maven Central as part of this JIRA:  http://openjpa.apache.org/publishing-serp-to-maven-central-repository.html",,
IllegalAccessError when trying to proxy a default scoped Class,OPENJPA-2238,12599852,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,curtisr7,curtisr7,curtisr7,23/Jul/12 14:41,06/Jun/15 21:19,14/Mar/19 03:03,23/Jul/12 15:35,2.2.0,2.3.0,,,,,,,2.3.0,,,,,kernel,,,,0,,,,,,,,"When trying to create a proxy for a type that is package protected, you'll get a IllegalAccessError when trying load the created proxy. 

The root issue is that we create all of our proxies in the org.apache.openjpa.util package, and if the default scoped type isn't in that package, we can't dynamically generate a subclass.


<openjpa-2.3.0-SNAPSHOT-r422266:1361564M nonfatal general error> org.apache.openjpa.util.GeneralException: org.apache.openjpa.util.org$apache$openjpa$util$custom$CustomProxyDefaultScopeType$8$proxy
	at org.apache.openjpa.util.GeneratedClasses.loadBCClass(GeneratedClasses.java:71)
	at org.apache.openjpa.util.ProxyManagerImpl.getFactoryProxyBean(ProxyManagerImpl.java:475)
	at org.apache.openjpa.util.ProxyManagerImpl.newCustomProxy(ProxyManagerImpl.java:326)
	at org.apache.openjpa.util.TestProxyManager.testProxyCustomDefaultScopedType(TestProxyManager.java:356)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
Caused by: java.lang.IllegalAccessError: class org.apache.openjpa.util.org$apache$openjpa$util$custom$CustomProxyDefaultScopeType$8$proxy cannot access its superclass org.apache.openjpa.util.custom.CustomProxyDefaultScopeType
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClassCond(ClassLoader.java:631)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:615)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:465)
	at serp.bytecode.BCClassLoader.findClass(BCClassLoader.java:50)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:247)
	at org.apache.openjpa.util.GeneratedClasses.loadBCClass(GeneratedClasses.java:67)
	... 21 more
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,240128,,,Mon Jul 23 15:35:31 UTC 2012,,,,,,,0|i00xif:,3361,,,,,,,,"23/Jul/12 15:35;curtisr7;Committed code change and UT to trunk.

----

Transmitting file data ....
Committed revision 1364683.",,,,,,,,,,,,,,,,,,,,,,,,,,
Trace of connection info can cause class transform/enhancement to fail,OPENJPA-2236,12599542,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,19/Jul/12 22:03,06/Jun/15 21:19,14/Mar/19 03:03,10/Apr/13 21:13,2.2.1,2.3.0,,,,,,,1.2.3,2.2.1,2.3.0,,,jdbc,,,,0,,,,,,,,"While transforming persistent classes, if a specific DBDictionary is not provided, OpenJPA attempts to detect and set up a dictionary.   Within this process, DBDictionary.connectedConfiguration() is called (to determine the DB type) when a connection is obtained.  If trace is enabled, information about the connection is traced.  I hit a case where one of the methods that is called on the connection to gather trace data threw an exception, resulting in classes not being enhanced.  The simple (but not always possible) workaround is to specify the db dictionary type.  Regardless, a trace point should not cause a catastrophic failure.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,240130,,,2012-07-19 22:03:20.0,,,,,,,0|i00xiv:,3363,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""READ_UNCOMMITTED"" setting for the fetch plan isolation level is ignored in DB2Dictionary",OPENJPA-2235,12599487,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,helenxu,helenxu,helenxu,19/Jul/12 15:55,10/Apr/13 16:04,14/Mar/19 03:03,10/Apr/13 16:04,2.1.1,2.2.0,2.3.0,,,,,,2.1.2,2.2.1.1,2.2.2,2.3.0,,performance,query,,,0,,,,,,,,"When user set query hint as shown below for db2, no ""with UR"" clause append to the query. The setting is ignored.
query.setHint(""openjpa.FetchPlan.Isolation"", ""READ_UNCOMMITTED"");

Uncommitted read is very risky and should be avoid if it is possible. JPA specification requires a minimum of read-committed isolation to ensure no ""dirty read"" and ""non-repeatible read"" can occur. Use of read-uncommitted isolation may cause data integrity problem.
",,,,,,,,,,,,,,,,,,,20/Aug/12 16:18;helenxu;OPENJPA-2235.patch;https://issues.apache.org/jira/secure/attachment/12541605/OPENJPA-2235.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-07-24 20:09:33.447,,,no_permission,,,,,,,,,,,,240131,,,Mon Aug 20 16:17:12 UTC 2012,,,Patch Available,,,,0|i00xj3:,3364,,,,,,,,19/Jul/12 23:54;helenxu;Fix and unit test attached.,"24/Jul/12 20:09;kwsutter;Helen,
Thanks for taking a look at this jira and providing a patch.  Based on the initial problem description, we're only concerned with the openjpa.FetchPlan.Isolation hint getting set to UR, right?  But, your code patch would also work if the openjpa.jdbc.TransactionIsolation property is set.  At least that's what I get from this conditional:

         if ( isolationLevel == Connection.TRANSACTION_READ_UNCOMMITTED ) {

and isolation level is set via these statements earlier in this method:

        if (fetch != null && fetch.getIsolation() != -1)
            isolationLevel = fetch.getIsolation();
        else
            isolationLevel = conf.getTransactionIsolationConstant();

So, if we're looking to support UR for both the FetchPlan hint and the TransactionIsolation property, then your patch looks good.  But, if we're trying to fix just the FetchPlan hint, then the patch might be too broad.","26/Jul/12 17:04;helenxu;good catch. Thanks

we should only check the isolation hint. Modified the code for that. Attached a new patch.","27/Jul/12 15:18;kwsutter;The code patch looks clean.  I would suggest a few more comments in the header block for this method...  Since we're kind of extending the use of the getForUpdateClause() method to only do the ""WITH UR"" clause if isForUpdate parameter is false, it would be good to explain that.  Either that, or we should consider breaking off these two aspects into separate methods.  Not sure of the ripple effect though with this type of change.  Thanks.","20/Aug/12 16:17;helenxu;We'll have to change the interface from the abstract class and all the subclasses if we want to break the function. It is kind of risky.

I just added a bit more comment to the method to indicate it also handle the UR hint.",,,,,,,,,,,,,,,,,,,,,,
EntityManager instance creation needs TX activity,OPENJPA-2234,12599438,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,erikkis,erikkis,19/Jul/12 10:06,06/Jun/15 21:19,14/Mar/19 03:03,16/Oct/12 21:32,2.0.1,,,,,,,,2.3.0,,,,,,,,,0,,,,,,,,"While working with Spring Data, we came across a potential bug in OpenJPA.

The bug was provoked by a query lookup module in Spring Data JPA, but it has its roots in AbstractBrokerFactory class, which seems to require transaction existence in order to create EntityManager (which is contrary to JPA spec).

I have already been in touch with Spring Data JPA author (where I filed a bug against Spring Data JPA) who actually pointed me to file a bug here.

I have extensively documented my findings on this thread (http://stackoverflow.com/questions/10688040/spring-data-jpa-fails-to-invoke-jtatransactionmanager), so I'll rather post the link, instead of repeating the whole thing here.

All that being said, I am not entirely sure what actually happened and am no authority whatsoever on JPA spec.","- JDK 1.5
- Spring 3.1.1.RELEASE
- Spring Data JPA 1.1 GA (issue confirmed on version 1.0.3)
- Atomikos 3.7.0
- OpenJPA 2.0.1
- DB2 9.7
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-07-19 13:47:12.129,,,no_permission,,,,,,,,,,,,240132,,,Tue Oct 16 21:32:49 UTC 2012,,,,,,,0|i00xjb:,3365,,,,,,,,"19/Jul/12 13:47;curtisr7;Erik -

Thanks for the thorough SO writeup. Unfortunately I think you're assessment of where the problems lies isn't quite correct. If you were to look at the OpenJPA code: 

    boolean syncWithManagedTransaction(BrokerImpl broker, boolean begin) {
        Transaction trans;
        try {
            ManagedRuntime mr = broker.getManagedRuntime();
            TransactionManager tm = mr.getTransactionManager();
            trans = tm.getTransaction(); <<< line 720

you will notice that the NPE is coming from not having a TransactionManager, not that you don't have a transaction.


I see the following line in your persistence configuration :

<entry key=""openjpa.ManagedRuntime"" value=""invocation(TransactionManagerMethod=com.atomikos.icatch.jta.TransactionManagerImp.getTransactionManager)"" />

We can start out with an easy one, is the getTransactionManager method static? If not, try changing that.

Thanks,
Rick","20/Jul/12 12:59;erikkis;Hello, Rick, thanks for your quick response.

Regarding persistence configuration, I've checked - getTransactionManager() method _is_ static.

Regarding problem assessment - I agree with you; I've actually noticed that Spring doesn't set the TransactionManager (PlatformTransactionManager's setter is not invoked), hence we get NPE@line 720. The problem happens while bootstrapping Spring application context - more specifically, while Spring Data JPA performs query lookup. Now, if you were to check comments in SO writeup, you'll notice that in correspondence with Oliver Gierke (Spring Data JPA project lead), he had stated that OpenJPA is actually not conforming here to JPA specification, since by JPA spec, no tx activity is needed during query creation (i.e. while executing entityManager.createQuery(...)).

As I said, I am far from understanding every nook and cranny in any of the participating modules (be it OpenJPA, Spring Data JPA or the JPA2 specification itself), however, his arguments do seem convincing, at least to me.

Is there anything else we could try?","20/Jul/12 15:32;curtisr7;The root issue is that you configured OpenJPA to call com.atomikos.icatch.jta.TransactionManagerImp.getTransactionManager() to get a TransactionManager instance and that method returned null. 

The OpenJPA runtime requires that we have a TransactionManager (Not a transaction, just a manager) to function properly. I believe Oliver is incorrect in stating that we're in violation of the spec in this regards.

> Is there anything else we could try? 
Perhaps Oliver could help you/us understand why you have the configuration you do, and why it is returning a null TransactionManager?

Thanks,
Rick",13/Sep/12 17:47;oliver.gierke;I didn't suspect OpenJPA to violate the spec. All I was stumbling above was that apparently the EntityManagerFactory bootstrap code tries to access a TransactionManager which effectively can't be in place at that time as usually the Txmanager works with the EntityManagerFactory in turn. At least OpenJPA behaves very different compared to other JPA providers and I wondered why this early TxManager lookup is required.,"17/Sep/12 16:50;curtisr7;> that apparently the EntityManagerFactory bootstrap code tries to access a TransactionManager which effectively can't be in place at that time as usually the Txmanager works with the EntityManagerFactory in turn.
I don't follow your comment? The exception occurs at EntityManager creation, not EntityManagerFactory.",09/Oct/12 12:13;curtisr7;Closing as invalid. Please reopen with additional data if you disagree.,09/Oct/12 13:07;oliver.gierke;How is the TransactionManager expected to be set on the EntityManagerFactory then? I cannot see any API on EntityManagerFactoryImpl which could have been invoked. I'd also argue that the implementation should shield against the transaction manager being null more explicitly if it is mandatory rather than throwing a generic NPE. There seems to be a configuration/setup error by the user and that should be communicated.,"09/Oct/12 13:18;romain.manni-bucau;Hi Olivier, it is done thanks to the managed runtime

just configure <entry key=""openjpa.ManagedRuntime"" value=""invocation(TransactionManagerMethod=foo.TxMgrHolder.getTransactionManager)"" /> 

for spring you can return a proxy which will get the tx mgr from the app ctx - btw then you'll need to deal with spring/openjpa lifecycle","09/Oct/12 13:44;curtisr7;> I'd also argue that the implementation should shield against the transaction manager being null more explicitly if it is mandatory rather than throwing a generic NPE.
Agreed. I'll add that sometime this morning.","09/Oct/12 13:52;erikkis;> Hi Olivier, it is done thanks to the managed runtime....

Hello, Romain, if you check the StackOverflow link in the problem description, you'll notice that ManagedRuntime property has indeed been set, but had not prevented NPE from being thrown.","09/Oct/12 13:55;romain.manni-bucau;this means spring is not started, just need to be started before","09/Oct/12 14:25;curtisr7;Committed revision 1396043 to trunk.

Now we'll throw the following exception when we encounter a nullTransactionManager.

<openjpa-2.3.0-SNAPSHOT-r422266:1393779M fatal internal error> org.apache.openjpa.util.InternalException: Received a null javax.transaction.TransactionManager from the openjpa.ManagedRuntime ""org.apache.openjpa.ee.TestNullTransactionManagerFromRuntime$ManagedRuntimeNullTransactionManager@64686468"".
	at org.apache.openjpa.kernel.AbstractBrokerFactory.syncWithManagedTransaction(AbstractBrokerFactory.java:727)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:391)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:325)","09/Oct/12 16:35;erikkis;Thx, Rick for this - I just wonder is there any way to recover from this exception? Also, is there any chance of backporting this to 2.0.x branch?","09/Oct/12 18:48;curtisr7;Erik - Honestly, I'm not aware of any way to recover. I suspect I could log a warning, but other parts of the runtime would blow chunks with a similar NPE due to the missing TM. It seemed safer to detect this condition and fail fast.

It is unlikely that this change will make it into 2.0.x as that is a WebSphere managed branch... but I'll shoot a note to the branch owner to see what he thinks.
",16/Oct/12 21:32;curtisr7;I talked with the branch owner and he said that to get this change into 2.0.x you'd need to go through WebSphere support and get PMR opened to get the thumbs up to merge this change.,,,,,,,,,,,,
Failed to invoke pcGetIDOwningClass method on embeddable entity with ID annotation,OPENJPA-2233,12599130,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,helenxu,helenxu,17/Jul/12 15:39,21/Sep/16 20:17,14/Mar/19 03:03,17/Dec/13 02:33,2.0.1,2.1.0,2.2.0,2.3.0,,,,,2.0.2,2.1.2,2.2.1.1,2.2.2,2.4.0,Enhance,,,,0,,,,,,,,"It failed to invoke pcGetIDOwningClass method on an embeddable entity which has the ID annotation. here is the exception:

java.lang.NoSuchMethodError: com/xxx/xxx/entity/MyClass.pcGetIDOwningClass()Ljava/lang/Class;
at com.xxx.xxx.entity.MyClass.pcNewObjectIdInstance(MyClass.java)
at org.apache.openjpa.enhance.PCRegistry.newObjectId(PCRegistry.java:137)
at org.apache.openjpa.meta.MetaDataRepository.processRegisteredClass(MetaDataRepository.java:1661)
at org.apache.openjpa.meta.MetaDataRepository.processRegisteredClasses(MetaDataRepository.java:1615)
at org.apache.openjpa.meta.ClassMetaData.getPCSubclasses(ClassMetaData.java:365)
at org.apache.openjpa.jdbc.meta.MappingRepository.findBaseClassMapping(MappingRepository.java:1510)
at org.apache.openjpa.jdbc.meta.MappingRepository.prepareMapping(MappingRepository.java:403)
at org.apache.openjpa.meta.MetaDataRepository.preMapping(MetaDataRepository.java:736)
at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:625)
at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:385)
at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:358)
at org.apache.openjpa.meta.MetaDataRepository.resolveAll(MetaDataRepository.java:1923)
at org.apache.openjpa.meta.MetaDataRepository.getQueryMetaDataInternal(MetaDataRepository.java:1901)
at org.apache.openjpa.meta.MetaDataRepository.getQueryMetaData(MetaDataRepository.java:1888)
at org.apache.openjpa.persistence.EntityManagerImpl.createNamedQuery(EntityManagerImpl.java:1013)

This is because it uses different condition to add and invoke pcNewObjectIdInstance method in PCEnhancer.

here is the section it adds pcNewObjectIdInstance in PCEnhancer.addPCMethods

            if (_meta.hasAbstractPKField() == true) { 
                addGetIDOwningClass();
            }

here is the section it invokes pcNewObjectIdInstance in PCEnhancer.addNewObjectIdInstanceMethod

          if(_meta.isEmbeddedOnly() || _meta.hasAbstractPKField() == true) {
                code.aload().setThis();
                code.invokevirtual().setMethod(PRE + ""GetIDOwningClass"",
                    Class.class, null);
            } else {
                code.classconstant().setClass(getType(_meta));
            }

",,,,,,,,,,,,,,OPENJPA-2463,,OPENJPA-2478,,,17/Jul/12 20:53;helenxu;OPENJPA-2233.patch;https://issues.apache.org/jira/secure/attachment/12536890/OPENJPA-2233.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-09-19 21:39:52.985,,,no_permission,,,,,,,,,,,,240133,,,Tue Dec 17 02:33:45 UTC 2013,,,Patch Available,,,,0|i00xjj:,3366,,,,,,,,17/Jul/12 15:52;helenxu;attached fix and uni ttest,"17/Jul/12 20:53;helenxu;double checked the persistence spec, the Identity field is not supported in embeddable entity. 

Changed the code to check that condition before invoke pcGetIDOwningClass. Log the user error as well.","19/Sep/12 21:39;fyrewyld;Checking fix into SVN on Helen's behalf.  Thanks, Helen!",17/Dec/13 02:26;curtisr7;Reopening to merge changes to trunk and to 2.3.x.,"17/Dec/13 02:28;jira-bot;Commit 1551446 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1551446 ]

OPENJPA-2233: Merge changes to trunk.","17/Dec/13 02:33;jira-bot;Commit 1551447 from [~curtisr7] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1551447 ]

OPENJPA-2233: Merge changes from trunk.",17/Dec/13 02:33;curtisr7;Merged changes to 2.3.x and trunk.,,,,,,,,,,,,,,,,,,,,
Event Listener detection didn't work with MappedSuperClasses or Entity heirarchies,OPENJPA-2230,12598746,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,13/Jul/12 19:21,09/Oct/12 18:39,14/Mar/19 03:03,23/Aug/12 13:40,2.2.1,2.3.0,,,,,,,2.2.1,2.3.0,,,,kernel,,,,0,,,,,,,,"When an entity/mapped super class heirarchy was in place and the EventListeners were declared on one of the super classes, the optimized detection introduced by openjpa-2168 was not working.  And, thus, these EventListeners were not getting invoked.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,240136,,,2012-07-13 19:21:56.0,,,,,,,0|i00xk7:,3369,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Persistence entities not recognized when deploying on JBoss AS 7.1,OPENJPA-2229,12598564,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,ilgrosso,ilgrosso,12/Jul/12 14:19,15/Dec/16 14:25,14/Mar/19 03:03,03/Aug/12 15:20,2.2.0,2.2.1,2.3.0,,,,,,2.3.0,,,,,kernel,,,,0,,,,,,,,"I've found this guide [1] about using OenJPA 2.2.0 and JBoss 7.1: I had some minor issues (already reported on that page) easily solved, but then I came to this exception, thrown at every JPA query:

<openjpa-2.2.0-r422266:1244990 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: An error occurred while parsing the query filter ""SELECT e FROM  ExternalResource e"". Error message: The name ""ExternalResource"" is not a recognized entity or identifier. Perhaps you meant ExternalResource, which is a close match. Known entity names: [ExternalResource, AbstractSchema, RAttrUniqueValue, AbstractVirAttr, Membership, TaskExec, SyncopeConf, Report, RAttr, AbstractExec, SyncopeLogger, USchema, MAttr, PasswordPolicy, RSchema, MSchema, MAttrValue, MAttrUniqueValue, AbstractAttr, AbstractDerSchema, AbstractVirSchema, UAttr, AccountPolicy, RAttrValue, UAttrValue, ReportExec, SyncopeUser, Notification, ConnInstance, AbstractDerAttr, AbstractAttrValue, SyncopeRole, SyncPolicy, Policy, ReportletConfInstance, Task, UAttrUniqueValue, Entitlement, SchemaMapping, UserRequest]
        at org.apache.openjpa.kernel.exps.AbstractExpressionBuilder.parseException(AbstractExpressionBuilder.java:119) [openjpa-kernel-2.2.0.jar:2.2.0]
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getClassMetaData(JPQLExpressionBuilder.java:194) [openjpa-kernel-2.2.0.jar:2.2.0]
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.resolveClassMetaData(JPQLExpressionBuilder.java:167) [openjpa-kernel-2.2.0.jar:2.2.0]
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:242) [openjpa-kernel-2.2.0.jar:2.2.0]
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateMetaData(JPQLExpressionBuilder.java:212) [openjpa-kernel-2.2.0.jar:2.2.0]
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getCandidateType(JPQLExpressionBuilder.java:205) [openjpa-kernel-2.2.0.jar:2.2.0]
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.access$200(JPQLExpressionBuilder.java:80) [openjpa-kernel-2.2.0.jar:2.2.0]
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder$ParsedJPQL.populate(JPQLExpressionBuilder.java:2417) [openjpa-kernel-2.2.0.jar:2.2.0]
        at org.apache.openjpa.kernel.jpql.JPQLParser.populate(JPQLParser.java:61) [openjpa-kernel-2.2.0.jar:2.2.0]


After some deeper investigation, I've found that the problem resides in the vfs: JBoss URLs, currently not managed.

[1] https://community.jboss.org/thread/201329 ",JBoss AS 7.1.1-Final,,,,,,,,,,,,,SYNCOPE-109,,,,,12/Jul/12 14:22;ilgrosso;jboss-vfs.patch;https://issues.apache.org/jira/secure/attachment/12536225/jboss-vfs.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-07-12 15:05:30.503,,,no_permission,,,,,,,,,,,,240137,,,Mon Oct 01 17:07:23 UTC 2012,,,Patch Available,,,,0|i00xkf:,3370,,,,,,,,"12/Jul/12 14:22;ilgrosso;This patch makes AbstractCFMetaDataFactory handle vfs: URLs.

Since the JBoss library for managing such URLs is LGPL, I've preferred to implement these calls using Java reflections in order to avoid pushing any additional dependency.

I've tested this patch by deploying Apache Syncope on JBoss AS 7.1.1.Final and found no issues.","12/Jul/12 15:05;curtisr7;Francesco -

Your patch looks pretty good... I think a few small modifications will be required, but I should be able to handle those. I'll try to get around to committing this patch to trunk late today or early tomorrow.

Thanks,
Rick","12/Jul/12 15:13;ilgrosso;Hi Rick,
this sounds very nice!

Once you'll apply the patch and commit, will the updated Maven artifacts be published immediately? I'd love to be able to have it with 2.2.1-SNAPSHOT ;-)

Thanks.","12/Jul/12 16:42;struberg;Hi!

This is only ONE of n known problems with URL.

The problem is most times that URL.toExternalForm() and new URL() are not commutative. There is a long thread over at commons for classpath scanning. The problem with the JBoss VFS is a well known issue not only for JPA but other frameworks. There is not only vfs:// but e.g. wsjar:// and tons of other possible URLs. You can read more about this in this thread: 
http://apache-commons.680414.n4.nabble.com/classscan-new-URL-xxx-and-it-s-problems-td4634723.html#a4634734

The only way to solve this right is a plugable archive mechanism like proposed and implemented by David Blevins in xbean-finder.","12/Jul/12 18:48;ilgrosso;Mark,
for the (little) extent of my knowledge of OpenJPA internals, I agree with you: the attached patch is definitely not the ending solution for URL handling issues; anyway, it could be a temporary fix that allows to cover some more use cases.
This, of course, to be refactored as soon as the new URL scanning mechanism will be in place.
WDYT?","13/Jul/12 09:25;struberg;perfectly fine. I just wanted to raise the awareness that this might hit us in other situations as well. Not only with other url prefixes, but also in other locations in the OpenJPA codebase. It would be perfect if we can move this to a common helper class somehow.","14/Jul/12 17:19;curtisr7;Francesco -

Since I have zero JBoss experience I committed your patch some some minor modifications to trunk without new tests. Please verify the patch works as expected when you get a chance.

> It would be perfect if we can move this to a common helper class somehow. 
Agreed, but I don't see that happening until someone really screams and ponies up some cycles.
","15/Jul/12 07:06;ilgrosso;Hi Rick,
I've taken a look at the code modification on trunk: did not think to that AccessController.doPrivileged()!

I made my patch against 2.2.x branch because my application (Apache Syncope) is based on 2.2.0: I've tried to quickly test Syncope on JBoss with 2.3.0-SNAPSHOT artifacts (after a fresh 'mvn clean install' from updated OpenJPA trunk source tree), unfortunately with no luck.

Then I backported the AbstractCFMetaDataFactory class from trunk to branch 2.2.x, did another 'mvn clean install', then switch Syncope POMs to 2.2.1-SNAPSHOT: it worked.

Baseline: the applied patch is working, but I am not (currently) able to test it with trunk (2.3.0-SNAPSHOT).",03/Aug/12 15:20;curtisr7;Committed revision 1361564 to trunk.,"01/Oct/12 17:07;jpaheath;HI!  Please note that part of this fix (Revision 1369042) was incorrectly listed under JIRA OPENJPA-2229.....the commit was meant for JIRA OPENJPA-2247.

Thanks,

Heath",,,,,,,,,,,,,,,,,
QuerySQLCache broken for Entities with @EmbeddedId,OPENJPA-2228,12598245,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,helenxu,mglauche,mglauche,10/Jul/12 18:48,06/Jun/15 21:19,14/Mar/19 03:03,17/Jul/12 22:00,2.2.0,2.3.0,,,,,,,2.3.0,,,,,query,,,,0,,,,,,,,"Multiple calls of a query which has some Relationships with @EmbeddedId fields fails if QuerySQLCache is enabled.

q = em.createQuery(""select l from ListTest l where l.te=:test"");
does create:
SELECT t0.id, t0.keyA, t0.keyB, t0.keyC, t1.keyA, t1.keyB, t1.keyC, t1.data1, 
        t1.data2 
    FROM ListTest t0 LEFT OUTER JOIN TestEntity t1 ON t0.keyA = t1.keyA AND t0.keyB 
        = t1.keyB AND t0.keyC = t1.keyC 
    WHERE (t0.keyA = ? AND t0.keyB = ? AND t0.keyC = ?) 
[params=(int) 1, (int) 2, (int) 3]

however a second query will create:
q = em.createQuery(""select l from ListTest l where l.te=:test"");
SELECT t0.id, t0.keyA, t0.keyB, t0.keyC, t1.keyA, t1.keyB, t1.keyC, t1.data1, 
        t1.data2 
    FROM ListTest t0 LEFT OUTER JOIN TestEntity t1 ON t0.keyA = t1.keyA AND t0.keyB 
        = t1.keyB AND t0.keyC = t1.keyC 
    WHERE (t0.keyA = ? AND t0.keyB = ? AND t0.keyC = ?) 
[params=(int) 3, (int) 2, (int) 3]

Note the wrong first param !
(There is some Index filed calculated somewhere in the query and the index Array has [0,0,0] as values, so the 0th position does get updated three times .. the bug should be something with the index i think)

See attached test-project
",,,,,,,,,,,,,,,,,,,16/Jul/12 17:13;helenxu;OPENJPA-2228.patch;https://issues.apache.org/jira/secure/attachment/12536659/OPENJPA-2228.patch,10/Jul/12 18:53;mglauche;openjpaBugreport.zip;https://issues.apache.org/jira/secure/attachment/12535895/openjpaBugreport.zip,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-07-13 14:05:45.605,,,no_permission,,,,,,,,,,,,240138,,,Tue Jul 17 21:59:51 UTC 2012,,,Patch Available,,,,0|i00xkn:,3371,,,,,,,,"10/Jul/12 18:53;mglauche;Small demo for bug, see failing maven test, it works if QuerySqlCache is disabled","13/Jul/12 14:05;helenxu;I was able to reproduce the problem. 

user parameter index got messed up when there are duplicate param key.

the fix and unit test attached.",14/Jul/12 16:55;curtisr7;Helen - It looks like you missed something when you created the patch.... it only has a testcase. ,"16/Jul/12 17:13;helenxu;Sorry, I didn't include the actual fix which is in openjpa-jdbc.

new patch attached.",17/Jul/12 21:59;curtisr7;Committed revision 1362679 to trunk. Thanks for the patch Helen!,,,,,,,,,,,,,,,,,,,,,,
OpenJPA doesn't find custom SequenceGenerators,OPENJPA-2227,12598075,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,fyrewyld,jensleisenberg,jensleisenberg,09/Jul/12 19:24,24/Aug/12 00:21,14/Mar/19 03:03,24/Aug/12 00:20,2.0.0,2.1.0,2.2.0,,,,,,2.1.2,2.2.1,2.3.0,,,kernel,,,,0,,,,,,,,"I'm trying to use a custom SequenceGenerator within an enterprise application using openJPA (providing by WebSphere).

When defining a custom Sequence a ClassNotFoundException (for the Sequence class) will be thrown when trying to insert data into the database.

ExampleConfiguration:
{code}
@Entity
@SequenceGenerator(name=""MySequence"", sequenceName=""org.apache.openjpa.generator.UIDGenerator()"")
public class Customer implements Serializable {
    @Id
    @GeneratedValue(strategy=GenerationType.SEQUENCE, generator=""MySequence"")
    private long id;
{code}

The example will produce the stacktrace attached.

It seems that the wrong class loader is used to instantiate the custom sequence class. A very similar issue seems to be: OPENJPA-758. With JavaSE (JUnit) all is working fine, but after deploying into WAS the Exception will occur.

I think within the method SequenceMetaData.instantiate(Classloader envLoader) the JavaTypes.classForName() -method with parameter mustExist=false should be used instead of the pure Class.forName() call. But I'm not sure about the Metadata-parameter needed for this method call.",WebSphere Application Server V8.0 and V8.5,,,,,,,,,,,,,,,,,,09/Jul/12 19:24;jensleisenberg;ClassNotFoundException.txt;https://issues.apache.org/jira/secure/attachment/12535725/ClassNotFoundException.txt,31/Jul/12 14:34;fyrewyld;OPENJPA-2227-2.2.x.patch;https://issues.apache.org/jira/secure/attachment/12538556/OPENJPA-2227-2.2.x.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-07-20 21:27:08.107,,,no_permission,,,,,,,,,,,,240139,,,Tue Jul 31 14:34:11 UTC 2012,,,,,,,0|i00xkv:,3372,,,,,,,,"20/Jul/12 21:27;fyrewyld;This problem doesn't show up in the JSE (which likely applies to JUnits) environment because the application ClassLoader would be the ClassLoader responsible for loading both the OpenJPA and JUnit/JSE application classes.  In a JEE environment, you have a hierarchy of ClassLoaders - in the WebSphere case, OpenJPA would be loaded by one of the OSGi ClassLoaders, application code lives in Application ClassLoaders which are children of the OSGi ClassLoaders.

When SequenceMetaData initializes, it attempts to perform a Class.forName() lookup for the class denoted in the sequenceName entry.  However, it scopes the lookup to the ClassLoader responsible for loading the OpenJPA classes, so it would never be able to check child ClassLoaders for application-custom SequenceGenerators.

Curiously, the SequenceMetaData.instantiate() method takes a ClassLoader envLoader argument (which, tracking back a couple frames in the stack trace, originates with a call to StoreContext.getClassloader() -- which returns the Thread Context ClassLoader that was current when the StoreContext was created.)  A modification to instantiate() to first perform the original Class.forName() lookup, falling back to a Class.forName() lookup using envLoader if the first call results in a ClassNotFoundException seems to resolve the issue in my test environment.","31/Jul/12 14:34;fyrewyld;Uploaded copy of the patch for 2.2.x, as integration for this branch needs to be delayed.",,,,,,,,,,,,,,,,,,,,,,,,,
Use of AbstractValueHandler map() causes exception on find(),OPENJPA-2221,12596262,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,dianner,dianner,28/Jun/12 14:47,06/Jun/15 21:19,14/Mar/19 03:03,18/Oct/13 13:49,2.1.0,,,,,,,,2.1.1,2.3.0,,,,,,,,0,,,,,,,,"When a value strategy implemented by a subclass of AbstractValuehandler overrides the map() method, an exception occurs on a find() if the strategy is implemented on an id field. The method returns a Column[].

<openjpa-2.1.2-SNAPSHOT-r422266:1297100 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: The specified parameter of type ""class [Ljava.lang.Object;"" is not a valid query parameter.
FailedObject: id1 [org.apache.openjpa.util.StringId] [java.lang.String]
	at org.apache.openjpa.jdbc.sql.DBDictionary.setUnknown(DBDictionary.java:1465)
	at org.apache.openjpa.jdbc.sql.DBDictionary.setUnknown(DBDictionary.java:1391)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.setParameters(SQLBuffer.java:656)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:565)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:541)
	at org.apache.openjpa.jdbc.sql.SelectImpl.prepareStatement(SelectImpl.java:479)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:420)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:382)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.getInitializeStateResult(JDBCStoreManager.java:576)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:378)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:333)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:112)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1027)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:985)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:902)
	at org.apache.openjpa.kernel.DelegatingBroker.find(DelegatingBroker.java:231)
	at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:486)
	at org.apache.openjpa.persistence.strategy.value.TestValueStrategy.testIt(TestValueStrategy.java:37)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:88)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:55)
	at java.lang.reflect.Method.invoke(Method.java:613)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runTest(AbstractPersistenceTestCase.java:579)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:566)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:542)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:206)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)

Presumably the exception would occur on other fields if they were part of the query.

The DBDictionary setUnknown() method needs to handle input of an Object[].",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-10-17 07:37:43.754,,,no_permission,,,,,,,,,,,,240145,,,Thu Oct 17 11:04:36 UTC 2013,,,,,,,0|i00xm7:,3378,,,,,,,,17/Oct/13 07:37;struberg;Any special reason this fix didn't get applied to trunk as well?,"17/Oct/13 09:53;struberg;I also gonna apply this patch to trunk and 2.3.x, ok?","17/Oct/13 09:57;jira-bot;Commit 1533026 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1533026 ]

OPENJPA-2221 also applied to 2.3.x branch","17/Oct/13 11:04;jira-bot;Commit 1533047 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1533047 ]

OPENJPA-2221 AbstractValueHandler map() fix applied to trunk",,,,,,,,,,,,,,,,,,,,,,,
OpenJPA site reports unreleased version to be available,OPENJPA-2215,12595074,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,kwsutter,sslavic,sslavic,19/Jun/12 09:23,06/Jun/18 17:10,14/Mar/19 03:03,19/Jun/12 14:45,2.2.0,,,,,,,,,,,,,site,,,,0,,,,,,,,"On http://openjpa.apache.org/ page there is a sentence:

{quote}
The 2.x releases *(2.2.1 is the latest)* are a production ready...
{quote}

even though 2.2.0 is the latest.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-06-19 14:45:09.413,,,no_permission,,,,,,,,,,,,240151,,,Wed Jun 06 17:10:11 UTC 2018,,,,,,,0|i00xnj:,3384,,,,,,,,"19/Jun/12 14:45;kwsutter;This was actually updated back in Feb by yours truly...  But, due to the lovely way that the wiki doesn't get automatically updated, the change was never brought forward...  I have now just ""touched"" the main page which should force a reload of the information into the customer-viewing wiki.  Hopefully, that will do the trick.","06/Jun/18 17:10;struberg;tickets are all resolved since at least 2012, so closing them finally",,,,,,,,,,,,,,,,,,,,,,,,,
Exception caught from before_completion synchronization operation,OPENJPA-2212,12560527,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,,rnj786,rnj786,13/Jun/12 16:24,14/Jun/12 15:54,14/Mar/19 03:03,14/Jun/12 15:54,1.0.3,,,,,,,,,,,,,jpa,,,,0,,,,,,,,"Looks like this issue is an OpenJPA issue. Very strange thing is the code exception catch block doesn't catch this exception at all and this happens only in stage environment and not in any lower environment. Though QA and Stage have exact same code base and they both get data from same source.

FROM the exception it looks like a duplicate primary key and its trying to insert the same record twice, is it something with flush operation in openjpa ? multithreading ? or something else ? 

its definately not data issue, coz it doesn't happen in QA with same data 



00000287 RegisteredSyn E   WTRN0074E: Exception caught from before_completion synchronization operation: <openjpa-1.0.3-SNAPSHOT-r420667:646455 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: ORA-00001: unique constraint (FIS.SYS_C008294) violated

FailedObject: prepstmnt 454695706 INSERT INTO TABLENAME COLUMNS (X,Y,Z ? , ? , ?) [org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement]

[org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement]
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:3949)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:97)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:67)
	at com.ibm.ws.persistence.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:170)
	at org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:105)
	at com.ibm.ws.persistence.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:93)
	at com.ibm.ws.persistence.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:75)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:514)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1955)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1853)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1771)
	at com.ibm.ws.uow.ComponentContextSynchronizationWrapper.beforeCompletion(ComponentContextSynchronizationWrapper.java:66)
	at com.ibm.ws.Transaction.JTA.RegisteredSyncs.distributeBefore(RegisteredSyncs.java:242)
	at com.ibm.ws.Transaction.JTA.TransactionImpl.prePrepare(TransactionImpl.java:2404)
	at com.ibm.ws.Transaction.JTA.TransactionImpl.stage1CommitProcessing(TransactionImpl.java:1637)
	at com.ibm.ws.Transaction.JTA.TransactionImpl.processCommit(TransactionImpl.java:1608)
	at com.ibm.ws.Transaction.JTA.TransactionImpl.commit(TransactionImpl.java:1543)
	at com.ibm.ws.Transaction.JTA.TranManagerImpl.commit(TranManagerImpl.java:240)
	at com.ibm.ws.Transaction.JTA.TranManagerSet.commit(TranManagerSet.java:164)
	at com.ibm.ejs.csi.TranStrategy.commit(TranStrategy.java:782)
	at com.ibm.ejs.csi.TranStrategy.postInvoke(TranStrategy.java:206)
	at com.ibm.ejs.csi.TransactionControlImpl.postInvoke(TransactionControlImpl.java:581)
	at com.ibm.ejs.container.EJSContainer.postInvoke(EJSContainer.java:4311)
	at com.ibm.ejs.container.MessageEndpointHandler.afterDelivery(MessageEndpointHandler.java:1440)
	at com.ibm.ejs.container.MessageEndpointHandler.invokeMessageEndpointMethod(MessageEndpointHandler.java:801)
	at com.ibm.ejs.container.MessageEndpointHandler.invoke(MessageEndpointHandler.java:762)
	at $Proxy54.afterDelivery(Unknown Source)
	at com.ibm.ws.sib.ra.inbound.impl.SibRaTransactionalDispatcher.afterDelivery(SibRaTransactionalDispatcher.java:469)
	at com.ibm.ws.sib.ra.inbound.impl.SibRaDispatcher.dispatch(SibRaDispatcher.java:780)
	at com.ibm.ws.sib.ra.inbound.impl.SibRaSingleProcessListener$SibRaWork.run(SibRaSingleProcessListener.java:584)
	at com.ibm.ejs.j2c.work.WorkProxy.run(WorkProxy.java:419)
	at com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1473)
Caused by: com.ibm.websphere.ce.cm.DuplicateKeyException: ORA-00001: unique constraint (FIS.SYS_C008294) violated

	at sun.reflect.GeneratedConstructorAccessor39.newInstance(Unknown Source)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:522)
	at com.ibm.websphere.rsadapter.GenericDataStoreHelper.mapExceptionHelper(GenericDataStoreHelper.java:523)
	at com.ibm.websphere.rsadapter.GenericDataStoreHelper.mapException(GenericDataStoreHelper.java:578)
	at com.ibm.ws.rsadapter.jdbc.WSJdbcUtil.mapException(WSJdbcUtil.java:909)
	at com.ibm.ws.rsadapter.jdbc.WSJdbcPreparedStatement.executeUpdate(WSJdbcPreparedStatement.java:626)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:856)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1363)
	at com.ibm.ws.persistence.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:112)
	... 29 more
NestedThrowables:
java.sql.SQLException: ORA-00001: unique constraint (FIS.SYS_C008294) violated

	at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:112)
	at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:331)
	at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:288)
	at oracle.jdbc.driver.T4C8Oall.receive(T4C8Oall.java:743)
	at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:216)
	at oracle.jdbc.driver.T4CPreparedStatement.executeForRows(T4CPreparedStatement.java:955)
	at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1168)
	at oracle.jdbc.driver.OraclePreparedStatement.executeInternal(OraclePreparedStatement.java:3316)
	at oracle.jdbc.driver.OraclePreparedStatement.executeUpdate(OraclePreparedStatement.java:3400)
	at com.ibm.ws.rsadapter.jdbc.WSJdbcPreparedStatement.pmiExecuteUpdate(WSJdbcPreparedStatement.java:948)
	at com.ibm.ws.rsadapter.jdbc.WSJdbcPreparedStatement.executeUpdate(WSJdbcPreparedStatement.java:615)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:856)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1363)
	at com.ibm.ws.persistence.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:112)
	at org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:105)
	at com.ibm.ws.persistence.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:93)
	at com.ibm.ws.persistence.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:75)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:514)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1955)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1853)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1771)
	at com.ibm.ws.uow.ComponentContextSynchronizationWrapper.beforeCompletion(ComponentContextSynchronizationWrapper.java:66)
	at com.ibm.ws.Transaction.JTA.RegisteredSyncs.distributeBefore(RegisteredSyncs.java:242)
	at com.ibm.ws.Transaction.JTA.TransactionImpl.prePrepare(TransactionImpl.java:2404)
	at com.ibm.ws.Transaction.JTA.TransactionImpl.stage1CommitProcessing(TransactionImpl.java:1637)
	at com.ibm.ws.Transaction.JTA.TransactionImpl.processCommit(TransactionImpl.java:1608)
	at com.ibm.ws.Transaction.JTA.TransactionImpl.commit(TransactionImpl.java:1543)
	at com.ibm.ws.Transaction.JTA.TranManagerImpl.commit(TranManagerImpl.java:240)
	at com.ibm.ws.Transaction.JTA.TranManagerSet.commit(TranManagerSet.java:164)
	at com.ibm.ejs.csi.TranStrategy.commit(TranStrategy.java:782)
	at com.ibm.ejs.csi.TranStrategy.postInvoke(TranStrategy.java:206)
	at com.ibm.ejs.csi.TransactionControlImpl.postInvoke(TransactionControlImpl.java:581)
	at com.ibm.ejs.container.EJSContainer.postInvoke(EJSContainer.java:4311)
	at com.ibm.ejs.container.MessageEndpointHandler.afterDelivery(MessageEndpointHandler.java:1440)
	at com.ibm.ejs.container.MessageEndpointHandler.invokeMessageEndpointMethod(MessageEndpointHandler.java:801)
	at com.ibm.ejs.container.MessageEndpointHandler.invoke(MessageEndpointHandler.java:762)
	at $Proxy54.afterDelivery(Unknown Source)
	at com.ibm.ws.sib.ra.inbound.impl.SibRaTransactionalDispatcher.afterDelivery(SibRaTransactionalDispatcher.java:469)
	at com.ibm.ws.sib.ra.inbound.impl.SibRaDispatcher.dispatch(SibRaDispatcher.java:780)
	at com.ibm.ws.sib.ra.inbound.impl.SibRaSingleProcessListener$SibRaWork.run(SibRaSingleProcessListener.java:584)
	at com.ibm.ejs.j2c.work.WorkProxy.run(WorkProxy.java:419)
	at com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1473)
---- Begin backtrace for Nested Throwables
java.sql.SQLException: ORA-00001: unique constraint (FIS.SYS_C008294) violated

	at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:112)
	at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:331)
	at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:288)
	at oracle.jdbc.driver.T4C8Oall.receive(T4C8Oall.java:743)
	at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:216)
	at oracle.jdbc.driver.T4CPreparedStatement.executeForRows(T4CPreparedStatement.java:955)
	at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1168)
	at oracle.jdbc.driver.OraclePreparedStatement.executeInternal(OraclePreparedStatement.java:3316)
	at oracle.jdbc.driver.OraclePreparedStatement.executeUpdate(OraclePreparedStatement.java:3400)
	at com.ibm.ws.rsadapter.jdbc.WSJdbcPreparedStatement.pmiExecuteUpdate(WSJdbcPreparedStatement.java:948)
	at com.ibm.ws.rsadapter.jdbc.WSJdbcPreparedStatement.executeUpdate(WSJdbcPreparedStatement.java:615)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:856)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:269)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1363)
	at com.ibm.ws.persistence.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:112)
	at org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:105)
	at com.ibm.ws.persistence.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:93)
	at com.ibm.ws.persistence.jdbc.kernel.OperationOrderUpdateManager.flush(OperationOrderUpdateManager.java:75)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:514)
	at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:1955)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:1853)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1771)
	at com.ibm.ws.uow.ComponentContextSynchronizationWrapper.beforeCompletion(ComponentContextSynchronizationWrapper.java:66)
	at com.ibm.ws.Transaction.JTA.RegisteredSyncs.distributeBefore(RegisteredSyncs.java:242)
	at com.ibm.ws.Transaction.JTA.TransactionImpl.prePrepare(TransactionImpl.java:2404)
	at com.ibm.ws.Transaction.JTA.TransactionImpl.stage1CommitProcessing(TransactionImpl.java:1637)
	at com.ibm.ws.Transaction.JTA.TransactionImpl.processCommit(TransactionImpl.java:1608)
	at com.ibm.ws.Transaction.JTA.TransactionImpl.commit(TransactionImpl.java:1543)
	at com.ibm.ws.Transaction.JTA.TranManagerImpl.commit(TranManagerImpl.java:240)
	at com.ibm.ws.Transaction.JTA.TranManagerSet.commit(TranManagerSet.java:164)
	at com.ibm.ejs.csi.TranStrategy.commit(TranStrategy.java:782)
	at com.ibm.ejs.csi.TranStrategy.postInvoke(TranStrategy.java:206)
	at com.ibm.ejs.csi.TransactionControlImpl.postInvoke(TransactionControlImpl.java:581)
	at com.ibm.ejs.container.EJSContainer.postInvoke(EJSContainer.java:4311)
	at com.ibm.ejs.container.MessageEndpointHandler.afterDelivery(MessageEndpointHandler.java:1440)
	at com.ibm.ejs.container.MessageEndpointHandler.invokeMessageEndpointMethod(MessageEndpointHandler.java:801)
	at com.ibm.ejs.container.MessageEndpointHandler.invoke(MessageEndpointHandler.java:762)
	at $Proxy54.afterDelivery(Unknown Source)
	at com.ibm.ws.sib.ra.inbound.impl.SibRaTransactionalDispatcher.afterDelivery(SibRaTransactionalDispatcher.java:469)
	at com.ibm.ws.sib.ra.inbound.impl.SibRaDispatcher.dispatch(SibRaDispatcher.java:780)
	at com.ibm.ws.sib.ra.inbound.impl.SibRaSingleProcessListener$SibRaWork.run(SibRaSingleProcessListener.java:584)
	at com.ibm.ejs.j2c.work.WorkProxy.run(WorkProxy.java:419)
	at com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1473)



",Stage and Prod,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-06-13 17:13:08.424,,,no_permission,,,,,,,,,,,,240154,,,Thu Jun 14 15:54:02 UTC 2012,,,,,,,0|i00xo7:,3387,,,,,,,,"13/Jun/12 17:13;allee8285;>>> Very strange thing is the code exception catch block doesn't catch this exception at all and this happens only in stage environment and not in any lower environment. 

I assume the exception you mentioned is ""java.sql.SQLException: ORA-00001: unique constraint (FIS.SYS_C008294) violated""

What catch block are you referring?  Some openjpa code try/catch ? Or application try/catch?

What do you mean by ""lower environment""? Unit test environment?

From the stack, it indicates you are running WebSphere, using EJB calling out to JPA function.  The JPA appl uses ""operation order"" update manager access data in Oracle DB. Based on this info, the operation order update manager will honor the exact order of JPA requests from the business logics. If there is any constraint violation imposed by the database, the applications needs to be aware of the configuration. 

To diagnose the problem, you may want to enable SQL=TRACE to see the SQL statements being submitted to the database and examinate what is the cause of the constraint violation.
","14/Jun/12 15:53;rnj786;Thanks Albert !!

                    In the lower Environments (QA and Dev) SQL = TRACE wasn't set and so the logs were not showing the exceptions... turned it on and was able to reproduce the issue and fixed ! Thanks for the suggestion. It was a Duplicate Key Exception caused by duplicate data insertion instead of update.",14/Jun/12 15:54;rnj786;Reproduced and Fixed ... Was a duplicate data insertion issue. ,,,,,,,,,,,,,,,,,,,,,,,,
NPE in JDBCStoreManager with Trace turned on,OPENJPA-2204,12558784,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,31/May/12 13:47,06/Jun/15 21:19,14/Mar/19 03:03,05/Jun/12 02:23,2.2.1,2.3.0,,,,,,,2.3.0,,,,,jdbc,logging,,,0,,,,,,,,"Reporting JIRA on behalf of a user without access to JIRAs...

OK - nearly there! Presumably because we're no longer hooked in to the container, OpenJPA was pumping out its log messages to system out. I set openjpa.Log to ""commons"" and, as desired, it now sends trace to java.util.logging. The only problem is that, when I set trace to ""openjpa.*=all"" I get a NullPointerException (that isn't there when trace is turned off):

[31/05/12 11:31:05:576 BST] 00000020 id=         com.ibm.amc.AmcRuntimeException                              3 printStackTrace java.lang.NullPointerException
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.find(JDBCStoreManager.java:979)
	at org.apache.openjpa.jdbc.meta.strats.UntypedPCValueHandler.toObjectValue(UntypedPCValueHandler.java:127)
	at org.apache.openjpa.jdbc.meta.strats.HandlerStrategies.loadObject(HandlerStrategies.java:207)
	at org.apache.openjpa.jdbc.meta.strats.HandlerCollectionTableFieldStrategy.loadElement(HandlerCollectionTableFieldStrategy.java:78)
	at org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy.load(StoreCollectionFieldStrategy.java:558)
	at org.apache.openjpa.jdbc.meta.FieldMapping.load(FieldMapping.java:934)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:673)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.load(WsJpaJDBCStoreManager.java:130)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:117)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:3071)
	at org.apache.openjpa.kernel.StateManagerImpl.loadField(StateManagerImpl.java:3148)
	at org.apache.openjpa.kernel.StateManagerImpl.beforeAccessField(StateManagerImpl.java:1612)
	at org.apache.openjpa.kernel.StateManagerImpl.accessingField(StateManagerImpl.java:1597)
	at com.ibm.amc.server.action.impl.ActionStatusImpl.pcGetupdates(ActionStatusImpl.java)
	at com.ibm.amc.server.action.impl.ActionStatusImpl.getUpdates(ActionStatusImpl.java:206)

This NPE looks to be due to dumping the parameters for the JDBCStoreManager.find():

        if (_log.isTraceEnabled()) {
            _log.trace(""find: oid=""+oid+"" ""+vm.getDeclaredTypeMapping().getDescribedType());
        }

And, either vm or vm.getDeclaredTypeMapping() is null...",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,240162,,,Tue Jun 05 02:21:18 UTC 2012,,,,,,,0|i00xpz:,3395,,,,,,,,"31/May/12 14:28;kwsutter;A quick review of the code shows that the vm parameter must not be null.  This JDBCStoreManager.find() is called from three locations and all three locations have accessed the ""vm"" parameter prior to this find() operation.  So, it's looking like it's the getDeclaredTypeMapping() that is returning null.  I'll look at that next...","31/May/12 21:09;kwsutter;Now that I look closer at the original exception and call stack, it looks like the NPE might actually be coming from attempting to dump the oid...  We check if the oid is null at the beginning of the method, but maybe the toString() method on one of our oid types is causing the NPE...","05/Jun/12 02:21;kwsutter;Reproduced the problem  by turning on Trace for the org.apache.openjpa.persistence.graph.TestPersistentGraph junit testcase.  My first guess was correct -- the getDeclaredTypeMapping() was returning null and causing the NPE for the trace string.  I modified the prep for this trace string and all works now.  I'll correct in Trunk and let other service stream owners pull it back, if desired.",,,,,,,,,,,,,,,,,,,,,,,,
Constraint violation exception when removing relationship using (orphanRemoval = true),OPENJPA-2199,12556252,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,17/May/12 16:23,21/Sep/16 14:38,14/Mar/19 03:03,26/Jul/12 18:43,2.0.0,2.1.0,2.2.0,2.3.0,,,,,2.0.2,2.1.2,2.2.1,2.3.0,,jdbc,,,,0,,,,,,,,"The problem occurs with the following relationships between classes:

Parent ->* Child ->* GrandChild. Class Parent has a collection of Childs.
Class Child has a collection of GrandChilds.
Each one-to-many relationship is annotated like this: @OneToMany(cascade = CascadeType.
ALL, orphanRemoval = true, ...). I.e. we use orphan removal and remove operations cascade from parents to children and grandchildren.

When we do the following a DB constraint violation occurs:
1) Start a transaction
2) Load a Parent instance from the database
3) Navigate to a Child and modify it
4) Cut the relationship between Child and GrandChild
5) Cut the relationship between Parent and Child
6) Commit the transaction

Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: DELETE on table 'JPAORPHAN_CHILD' caused a violation of foreign key constraint 'SQL120320110237861' for key (11).  The statement has been rolled back. {prepstmnt 1074806800 DELETE FROM APP.JPAORPHAN_CHILD WHERE ID = ? [params=(int) 11]} [code=20000, state=23503]",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,240167,,,2012-05-17 16:23:16.0,,,,,,,0|i00xr3:,3400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MethodComparator in AnnotationPersistenceMetaDataParser should also compare parameters,OPENJPA-2197,12556135,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,struberg,struberg,16/May/12 22:10,06/Jun/15 21:19,14/Mar/19 03:03,17/May/12 07:58,2.2.0,,,,,,,,2.3.0,,,,,kernel,,,,0,,,,,,,,"AnnotationPersistenceMetaDataParser contains a MethodComparator which only compares the class + the method name. Too bad I have (had...) 2 methods with the same name in my EntityListener:

    @PreUpdate
    public void updateChangeLog(Object entity) { ..

and also

    private void updateChangeLog(BaseEntity he, ChangeLogEntry cle)

which is a private helper method.

Due to the bug in MethodComparator, my @PreUpdate sometimes didn't get detected.",,,,,,,,,,,,,,,,,,,17/May/12 06:44;struberg;OPENJPA-2197_test.patch;https://issues.apache.org/jira/secure/attachment/12527800/OPENJPA-2197_test.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-05-17 14:30:59.977,,,no_permission,,,,,,,,,,,,240169,,,Fri May 18 17:17:44 UTC 2012,,,,,,,0|i00xrj:,3402,,,,,,,,17/May/12 06:44;struberg;this test shows the problem. I'm working on a fix right now.,"17/May/12 06:48;struberg;We currently use the Method#hashCode in the MethodComparator. But this is really ugly, as it's defined as :
    /**
     * Returns a hashcode for this <code>Method</code>.  The hashcode is computed
     * as the exclusive-or of the hashcodes for the underlying
     * method's declaring class name and the method's name.
     */
 
Please note that Method#hashCode does *NOT* cover any method parameters!

As we do already equals on class and the method name, this doesn't bring any benefit. ",17/May/12 07:58;struberg;fixed in r1339509.,"17/May/12 14:30;allee8285;Per spec section ""3.5.1 Lifecycle Callback Methods""
  Callback methods defined on an entity class or mapped superclass have the following signature:
    void <METHOD>()
  Callback methods defined on an entity listener class have the following signature:
    void <METHOD>(Object)

I am wondering if a simpler solution is to detect this requirement rather than check for method signature.

I.e.
    public static Collection<LifecycleCallbacks>[] parseCallbackMethods
        (Class<?> cls, Collection<LifecycleCallbacks>[] callbacks, boolean sups,
        boolean listener, MetaDataRepository repos) {
            .........
                if (Modifier.isStatic(mods) || Modifier.isFinal(mods) ||
                    Object.class.equals(m.getDeclaringClass()))
                    continue;

                // ******* addition logic to filter out invalid listeners
                if( m.getParameterTypes().length != (listener?0:1) || m.getReturnType() != Void.class )
                    continue;                     
                // ******* 

                key = new MethodKey(m);
                if (!seen.contains(key)) {
                    methods.add(m);
                    seen.add(key);
                }
            }
","17/May/12 19:55;struberg;We should check this in any case. I assumed that this will be checked already. Can you quickly change the test and verify if it fails with a message if you try to apply a lifecycle callback on another method?

I went for fixing the Comparator as I didn't like to change the whole logic of this part. Of course, if there are other open tasks in this area, then we might think about doing a clean rework...","18/May/12 16:43;allee8285;Ignore my suggestion! The logic also handles more than the JPA spec required callbacks, which caused some test failures.","18/May/12 17:17;struberg;Yes I feared that. I just saw some old stuff I know form kodo, so most probably either JDO or homegrown stuff ;)",,,,,,,,,,,,,,,,,,,,
Create Sequence Postgres 9.1,OPENJPA-2196,12555953,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,hendimarcos,hendimarcos,16/May/12 04:41,08/Nov/13 20:47,14/Mar/19 03:03,25/Jul/12 18:40,2.2.0,,,,,,,,2.2.1.1,2.2.2,2.3.0,,,jdbc,jpa,,,0,,,,,,,,"Sorry my bad english ..

when annotated a entity with @SequenceGenerator and with allocationSize = 1 and initialValue = 1, the method DBDictionary.commonCreateAlterSequenceSQL is creating a alter sequence sql invalid for Postgres 9.1.
Despite the documentation of postgres inform you that the other parameters are optional (http://www.postgresql.org/docs/9.1/static/sql-altersequence.html), an error occurs in executing the sql below.

Eg: ALTER SEQUENCE schema_experimento.usuario_sq (no other attributes)

Even the method NativeJDBCSeq.udpateSql being fault tolerant, the connection is marked for rollback and not allowing run the next val of sequence.

Hêndi Marcos","OpenJPA-2.2.0
Transaction-type JTA
Postgres 9.1
JBoss 6.1",14400,14400,,0%,14400,14400,,,,,,,,,,,,09/Jul/12 13:58;snortasprocket;OPENJPA-2196-2.2.0.patch;https://issues.apache.org/jira/secure/attachment/12535673/OPENJPA-2196-2.2.0.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-06-20 13:45:49.017,,,no_permission,,,,,,,,,,,,240170,,,Wed Jul 25 18:40:33 UTC 2012,,,Patch Available,,,,0|i00xrr:,3403,,,,,,,,"20/Jun/12 13:45;kwsutter;Through another discussion on the OpenJPA mailing list (http://openjpa.208410.n2.nabble.com/Postgres-sequence-current-transaction-is-aborted-td7580299.html), we've come to the bottom of this issue.  The creation of this ""alter sequence.."" statement stops prematurely when it's discovered that the sequence allocation size is not greater than 1.  I think this conditional should be greater than 0 (instead of 1).  Regardless, we have to be smarter with creating these ""create/alter sequence.."" statements so that they are complete before attempting to execute.","20/Jun/12 13:47;kwsutter;Albert, I'm going to assign to you since this issue is in the area of the sequence updates you did via openjpa-1376 and openjpa-2069.  Good luck!","20/Jun/12 16:35;kwsutter;Since the title of this JIRA is generic enough, I'm also going to post the other issue that came about due to the discussion on the mailing list (http://openjpa.208410.n2.nabble.com/Postgres-sequence-current-transaction-is-aborted-td7580299.html).

We have an issue with the permissions required to alter a database sequence with Postgres.  Or, at least, that's the only database that seems to be reporting this error.  With the changes introduced by OpenJPA-1376 and OpenJPA-2069, we are now blindly attempting to issue an ""alter sequence.."".  This is not good for Postgres users since only the owner of the Sequence can alter it.  So far, we must be lucking out with the other databases.

A couple of things that need to be re-looked at for this Sequence update.  Thanks.","29/Jun/12 18:03;snortasprocket;Consider, also, this scenario, where OpenJPA is using PostgreSQL and the owner of sequence is not the same user of the client (but client does have the {{USAGE}} grant on the sequence to call nextval, etc.). Let i be the initial starting value of the database sequence.

1. An OpenJPA application connects to the database, and inserts n records into the database where n > 1 and n < allocationSize. On the first insert, the {{ALTER SEQUENCE}} call is made fails silently (although PostgreSQL will log an error serverside, but since the exception is swallowed by the client, no one is the wiser -- including the code that ""thinks"" it has the next allocationSize ids cached. The database, however, still thinks that next sequence number is i+1.

2. If the application is stopped and restarted, the next insert will fail due to a duplicate key violation (because, since the first ALTER SEQUENCE failed, the database still thinks its current sequence is i+1, but OpenJPA allowed that record to be inserted in the first run.

I'm not seeing the behavior where the ALTER SEQUENCE call marks the transaction for rollback, though. I *think* I'm in a JTA-managed transaction, too... so not sure about that. Looking at the code in NativeJDBCSeq.allocateInternal, it appears that a new connection is grabbed from the store; not sure that connection is under JTA.

At minimum, I think that OpenJPA should detect the failure to ALTER SEQUENCE and not cache allocationSize values (perhaps logging to WARN level the first time this happens per session per sequence). Additionally, the original DBDictionary.commonCreateAlterSequenceSQL should always specify INCREMENT BY even if it is set to 1, as that breaks the ""workaround"" for users who wish emulate previous OpenJPA behavior using useNativeSequenceCache=False.
",09/Jul/12 13:58;snortasprocket;This patch works around the case where the ALTER SEQUENCE statement fails to execute (which will happen on PostgreSQL if the sequence is not owned by the current connection's user). A warning message is logged for each sequence indicating that the sequence was not modified and that sequence values are not cached.,"25/Jul/12 18:40;allee8285;I only commit the fix in trunk (2.3.0). If you need fixes in 2.2.x, you need to work with the release manager for inclusion.  2.2.x is a maintenance release for WebSphere, one can request a service call to the WebSphere product, if needed.
",,,,,,,,,,,,,,,,,,,,,
Native Query with specified result class can throw NPE when return data contains a null-valued column,OPENJPA-2195,12555891,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,fyrewyld,fyrewyld,15/May/12 20:52,05/Aug/13 18:50,14/Mar/19 03:03,05/Aug/13 18:50,2.0.0,2.0.1,2.1.0,2.1.1,2.2.0,,,,,,,,,kernel,,,,0,,,,,,,,"When fetching a column from the current row in the ResultSet, there is the potential for the value returned to be null (through nullable columns or SQL aggregate functions such as MAX that can possible return a null value).   If there is no ResultPacker (such is the case when the query is created without a result class type specified), this null value is stored in the EagerResultList without any problem.  

However, when a result class type is specified when the query is created, a ResultPacker is instantiated and used to 'pack' each entry fetched from the result set before saving it in the EagerResultList's internal List structure.  The problem is that the ResultPacker.pack(Object result) method is not null-argument safe.  The first thing the method attempts is try call getClass() on its argument, which results in a NullPointerException in this situation:


java.lang.RuntimeException: <openjpa-2.0.2-SNAPSHOT-r422266:1334144M nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Failed to execute query ""select NULLABLE_LNG_DATA FROM JAGNullField WHERE NFD_ID =?"". Check the query syntax for correctness. See nested exception for details.
	at test.SimpleNullTest.test005(SimpleNullTest.java:152)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
	at org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
Caused by: <openjpa-2.0.2-SNAPSHOT-r422266:1334144M nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Failed to execute query ""select NULLABLE_LNG_DATA FROM JAGNullField WHERE NFD_ID =?"". Check the query syntax for correctness. See nested exception for details.
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:870)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:792)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:288)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302)
	at test.SimpleNullTest.test005(SimpleNullTest.java:148)
	... 25 more
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.kernel.ResultPacker.pack(ResultPacker.java:196)
	at org.apache.openjpa.jdbc.kernel.SQLProjectionResultObjectProvider.getResultObject(SQLProjectionResultObjectProvider.java:88)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:36)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1246)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1005)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:861)
	... 30 more",,,,,,,,,,,,,,,,,,,17/May/12 18:35;fyrewyld;OPENJPA-2195-2.0.x.patch;https://issues.apache.org/jira/secure/attachment/12527877/OPENJPA-2195-2.0.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,240171,,,Mon Aug 05 18:50:43 UTC 2013,,,,,,,0|i00xrz:,3404,,,,,,,,17/May/12 18:35;fyrewyld;OJ-2195 patch for 2.0.x,05/Aug/13 18:50;fyrewyld;Fixed by OJ-2267.,,,,,,,,,,,,,,,,,,,,,,,,,
QueryCache don't allow for misconfigurations,OPENJPA-2191,12555011,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,curtisr7,kalaspuffar,kalaspuffar,12/May/12 09:49,06/Jun/15 21:19,14/Mar/19 03:03,12/May/12 12:52,2.0.0,2.1.0,2.2.0,2.3.0,,,,,2.3.0,,,,,datacache,,,,0,,,,,,,,"Throws exception when initializing a timestamp evicting QueryCache if no classes are specified.

104  test  INFO   [main] openjpa.Enhance - You have enabled runtime enhancement, but have not specified the set of persistent classes.  OpenJPA must look for metadata for every loaded class, which might increase class load times significantly.
SLF4J: Failed to load class ""org.slf4j.impl.StaticLoggerBinder"".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
212  test  INFO   [main] openjpa.Runtime - OpenJPA dynamically loaded a validation provider.
292  test  INFO   [main] openjpa.Runtime - Starting OpenJPA 2.2.0
410  test  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.MySQLDictionary"".
Exception in thread ""main"" <openjpa-2.2.0-r422266:1244990 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: null
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:218)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:156)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:227)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:154)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:60)
	at org.ea.test.TestAdd.main(TestAdd.java:20)
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.datacache.AbstractQueryCache.initialize(AbstractQueryCache.java:112)
	at org.apache.openjpa.datacache.ConcurrentQueryCache.initialize(ConcurrentQueryCache.java:95)
	at org.apache.openjpa.datacache.DataCacheManagerImpl.initialize(DataCacheManagerImpl.java:64)
	at org.apache.openjpa.conf.OpenJPAConfigurationImpl.getDataCacheManagerInstance(OpenJPAConfigurationImpl.java:725)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.createDelegatingStoreManager(AbstractBrokerFactory.java:843)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.initializeBroker(AbstractBrokerFactory.java:226)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:212)
	... 5 more

<?xml version=""1.0"" encoding=""UTF-8""?>
<persistence version=""2.0"" xmlns=""http://java.sun.com/xml/ns/persistence"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"">
	<persistence-unit name=""test"" transaction-type=""RESOURCE_LOCAL"">
	    <properties>
	        <property name=""openjpa.ConnectionURL"" value=""jdbc:mysql://localhost:3306/test""/>
	        <property name=""openjpa.ConnectionUserName"" value=""root""/>
	        <property name=""openjpa.ConnectionPassword"" value=""password""/>
	        <property name=""openjpa.ConnectionDriverName"" value=""com.mysql.jdbc.Driver""/>
	        <property name=""openjpa.Log"" value=""DefaultLevel=INFO, Runtime=INFO, Tool=INFO, SQL=INFO""/>
	        <property name=""openjpa.ConnectionFactoryProperties"" value=""MaxActive=10,MaxIdle=5,MinIdle=2,MaxWait=1800000""/>
	        <property name=""openjpa.jdbc.DBDictionary"" value=""org.apache.openjpa.jdbc.sql.MySQLDictionary""/>
			<property name=""openjpa.jdbc.SynchronizeMappings"" value=""buildSchema(ForeignKeys=true)""/>
	        <property name=""openjpa.DataCache"" value=""true(CacheSize=1000, SoftReferenceSize=0)""/>
	        <property name=""openjpa.QueryCache"" value=""true(CacheSize=1000, SoftReferenceSize=0, EvictPolicy='timestamp')""/>
 	        <property name=""openjpa.DetachState"" value=""fetch-groups(DetachedStateField=true)""/>
	        <property name=""openjpa.jdbc.UpdateManager"" value=""operation-order""/>       		
	    </properties>
	</persistence-unit>
</persistence>",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-05-12 12:52:17.815,,,no_permission,,,,,,,,,,,,239265,,,Sat May 12 12:52:17 UTC 2012,,,,,,,0|i00xsv:,3408,,,,,,,,12/May/12 12:52;curtisr7;Committed revision 1337526 to trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,
metamodel generation with default package creates invalid class,OPENJPA-2187,12554482,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,curtisr7,jieryn,jieryn,09/May/12 12:57,06/Jun/15 21:19,14/Mar/19 03:03,11/May/12 18:41,2.2.0,,,,,,,,2.3.0,,,,,lib,,,,0,,,,,,,,"Default package @Entity gets wrong metamodel class generated:

{code}import javax.persistence.Basic;
import javax.persistence.Entity;

@Entity
public final class BuggyMetamodel
{
  @Basic
  private final String                                      string = ""OpenJPA Rocks!"";
}
{code}

produces

{code}/** 
 *  Generated by OpenJPA MetaModel Generator Tool.
**/

package ;

import javax.persistence.metamodel.SingularAttribute;

@javax.persistence.metamodel.StaticMetamodel
(value=BuggyMetamodel.class)
@javax.annotation.Generated
(value=""org.apache.openjpa.persistence.meta.AnnotationProcessor6"",date=""Wed May 09 08:49:27 EDT 2012"")
public class BuggyMetamodel_ {
    public static volatile SingularAttribute<BuggyMetamodel,String> string;
}
{code}

Please notice the ""package ;"" which is invalid Java code.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-05-11 18:41:48.964,,,no_permission,,,,,,,,,,,,238724,,,Sat May 12 14:07:12 UTC 2012,,,,,,,0|i00xtr:,3412,,,,,,,,11/May/12 18:41;curtisr7;Committed revision 1337325 to trunk,"11/May/12 18:42;curtisr7;Will you please try trunk to see if my change resolved your issue?

Thanks,
Rick","12/May/12 14:07;jieryn;I'll attempt it, I eyeballed the change and it looked good. It seems like this would be better, and more easily, tested with a dedicated unit test though.",,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA build broken in java7 / jdk-1.7,OPENJPA-2180,12553120,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,struberg,struberg,struberg,27/Apr/12 11:35,06/Jun/15 21:19,14/Mar/19 03:03,29/Oct/13 08:13,2.2.0,,,,,,,,2.3.0,,,,,build / infrastructure,,,,2,,,,,,,,"Currently I get a test error when compiling OpenJPA with jdk 1.7

Tests in error:
  testDirtyRefreshWithoutDataCacheAlwaysHitsDatabase(org.apache.openjpa.persistence.datacache.TestDataCacheBehavesIdentical)
  testCleanRefreshWithoutDataCacheDoesNotHitDatabase(org.apache.openjpa.persistence.datacache.TestDataCacheBehavesIdentical)
  testDeleteIsDetectedOnCleanRefreshWithoutLockWithoutDataCache(org.apache.openjpa.persistence.datacache.TestDataCacheBehavesIdentical)
  testDeleteIsDetectedOnCleanRefreshWithLockWithoutDataCache(org.apache.openjpa.persistence.datacache.TestDataCacheBehavesIdentical)




Here is one of the detailed logs:

  <testcase time=""0.205"" classname=""org.apache.openjpa.persistence.datacache.TestDataCacheBehavesIdentical"" name=""testDirtyRefreshWithoutDataCacheAlwaysHitsDatabase"">
    <error message=""The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred."" type=""&lt;openjpa-2.3.0-SNAPSHOT-r422266"">&lt;openjpa-2.3.0-SNAPSHOT-r422266:1331053 fatal store error&gt; org.apache.openjpa.persistence.RollbackException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
FailedObject: org.apache.openjpa.persistence.datacache.common.apps.PObject@3fc25500
        at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:594)
        at org.apache.openjpa.persistence.datacache.TestDataCacheBehavesIdentical.verifyRefresh(TestDataCacheBehavesIdentical.java:320)
        at org.apache.openjpa.persistence.datacache.TestDataCacheBehavesIdentical.testDirtyRefreshWithoutDataCacheAlwaysHitsDatabase(TestDataCacheBehavesIdentical.java:438)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runTest(AbstractPersistenceTestCase.java:579)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:566)
        at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:542)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:206)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.GeneratedMethodAccessor196.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:115)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:102)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:180)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:350)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1021)
Caused by: &lt;openjpa-2.3.0-SNAPSHOT-r422266:1331053 fatal store error&gt; org.apache.openjpa.persistence.EntityExistsException: The transaction has been rolled back.  See the nested exceptions for details on the errors that occurred.
FailedObject: org.apache.openjpa.persistence.datacache.common.apps.PObject@3fc25500
        at org.apache.openjpa.kernel.BrokerImpl.newFlushException(BrokerImpl.java:2339)
        at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2176)
        at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2074)
        at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1992)
        at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
        at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1516)
        at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:933)
        at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:570)
        ... 31 more
Caused by: &lt;openjpa-2.3.0-SNAPSHOT-r422266:1331053 fatal store error&gt; org.apache.openjpa.persistence.EntityExistsException: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by &apos;SQL120427103931820&apos; defined on &apos;L2_POBJECT&apos;. {prepstmnt 268651183 INSERT INTO L2_PObject (id, name, version) VALUES (?, ?, ?)} [code=20000, state=23505]
FailedObject: org.apache.openjpa.persistence.datacache.common.apps.PObject@3fc25500
        at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4910)
        at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4885)
        at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:136)
        at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:78)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:143)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:99)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:87)
        at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:550)
        at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:106)
        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:103)
        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:76)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:735)
        at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:131)
        ... 38 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by &apos;SQL120427103931820&apos; defined on &apos;L2_POBJECT&apos;. {prepstmnt 268651183 INSERT INTO L2_PObject (id, name, version) VALUES (?, ?, ?)} [code=20000, state=23505]
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:219)
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:195)
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$1000(LoggingConnectionDecorator.java:59)
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeUpdate(LoggingConnectionDecorator.java:1134)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:272)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeUpdate(JDBCStoreManager.java:1763)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.executeUpdate(PreparedStatementManagerImpl.java:267)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:118)
        ... 46 more
</error>

",Fedora-16 x86_64; Java HotSpot 1.7.0_04,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-04-30 15:24:03.832,,,no_permission,,,,,,,,,,,,237143,,,Tue Oct 29 08:13:38 UTC 2013,,,,,,,0|i00xvb:,3419,,,,,,,,"30/Apr/12 15:24;curtisr7;I haven't dug into this one, but I found if I change the annotation on org.apache.openjpa.persistence.datacache.common.apps.PObject.id from @GeneratedValue to @GeneratedValue(strategy=GenerationType.AUTO), the test passes.",29/Oct/13 08:13;struberg;This seems to work now.,,,,,,,,,,,,,,,,,,,,,,,,,
PostgresDictionary ,OPENJPA-2178,12552847,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,struberg,struberg,26/Apr/12 12:40,06/Jun/15 21:19,14/Mar/19 03:03,26/Apr/12 15:11,2.2.0,,,,,,,,2.3.0,,,,,,,,,0,,,,,,,,"We hit a problem that OpenJPA always rounds to the nearest 10ms for PostgreSQL. We found the following old issue in which a workaround got outlined in OPENJPA-433

But still the question remains: PostgreSQL is perfectly fine to store milliseconds, so why does the PostgresDictionary line 146 sets:
> datePrecision = CENTI;
?

The generated TIMESTAMP type in PostgreSQL should even be able to store microseconds! [1]
And that seems to be the case since quite some time now (1999) [2].

I'm really tempted to set this to MICRO; Anyone against it?


[1] http://www.postgresql.org/docs/9.0/interactive/datatype-datetime.html
[2] http://www.postgresql.org/docs/7.0/static/datatype1134.htm",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-04-26 14:36:56.501,,,no_permission,,,,,,,,,,,,236771,,,Thu Apr 26 14:47:20 UTC 2012,,,,,,,0|i00xvr:,3421,,,,,,,,"26/Apr/12 14:36;curtisr7;I vote to make the change, it seems like the right answer for Postgres. 

... that being said, are there older version of Postgres that don't support microsecond precision? I couldn't find any user manuals that are pre-6.3.","26/Apr/12 14:47;struberg;postgresql-6.3 was in 1998 I honestly do not expect that we need to implement that. 
And even if so: they can still use the trick outlined in OPENJPA-433, but now just do it the other way around.

If someone really has such an old postgresql or likes to round to 1/100 seconds for another reason, he could still add the following setting:

<property name=""openjpa.jdbc.DBDictionary"" value=""DatePrecision=CENTI""/>",,,,,,,,,,,,,,,,,,,,,,,,,
Result set mapping was not looked up when retrieving column data from a NamedNativeQuery,OPENJPA-2174,12551298,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,helenxu,helenxu,helenxu,17/Apr/12 20:40,31/May/12 13:44,14/Mar/19 03:03,31/May/12 13:41,2.1.0,2.2.0,,,,,,,2.1.2,2.2.1,2.3.0,,,jdbc,,,,0,,,,,,,,"Invalid index exception was thrown when it tried to retrieve the column data from the result set of a name native query. 

This is  because the attribute name defined in the entity is different from the actual column alas name defined in the query and  it didn't look up the result set mapping for the correct column name before retrieving the data.

the fix and test case is attached.

",OpenJPA 2.1.2,,,,,,,,,,,,,,,,,,26/Apr/12 18:17;helenxu;OPENJPA-2174-2.1.x.patch.txt;https://issues.apache.org/jira/secure/attachment/12524473/OPENJPA-2174-2.1.x.patch.txt,17/Apr/12 20:42;helenxu;OPENJPA_2124.patch.txt;https://issues.apache.org/jira/secure/attachment/12523017/OPENJPA_2124.patch.txt,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,236162,,,2012-04-17 20:40:17.0,,,Patch Available,,,,0|i00xwn:,3425,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
openjpa-all jar is missing slf4j runtime dependency,OPENJPA-2172,12550858,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,13/Apr/12 18:32,16/Apr/13 15:11,14/Mar/19 03:03,16/Apr/13 15:02,2.2.0,2.2.1,2.3.0,,,,,,2.2.2,2.3.0,,,,samples,validation,,,0,,,,,,,,"I just tried the JSE version of the OpenBooks example (../openjpa-examples/openbooks) and it turns out that we're missing the SLF4J runtime dependency in our openjpa-all jar file.  This SLF4J dependency comes about because of our dependency on Bean Validation (bval).  We're pulling in the SLF4J API from slf4j-api, but we're missing the runtime from slf4j-simple.

There are two resolutions to this.  We can modify the ../openjpa-all/pom.xml to include the following dependency:

            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-simple</artifactId>
                <version>${slf4jVersion}</version>
            </dependency>

Or, we can tell OpenJPA that OpenBooks does not depend on bean validation (which it doesn't).  We can do this via this additional configuration property in the persistence.xml for the OpenBooks sample:

    <validation-mode>NONE</validation-mode>

The most complete solution is to modify the pom.xml when building the openjpa-all jar.  The unfortunate thing with this approach is that we have already released 2.2.0 which already is missing this slf4j runtime.  Maybe we'll just have to add a ""readme"" to that download.  We can fix it in 2.2.x and trunk though.  And, if somebody hits this with the 2.2.0 release, hopefully they are not using bean validation and they can set the validation-mode to NONE.
",,,,,,,,,,,,,,OPENJPA-2370,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-04-15 13:45:07.713,,,no_permission,,,,,,,,,,,,235722,,,Tue Apr 16 14:56:13 UTC 2013,,,,,,,0|i07jdz:,41908,,,,,,,,"03/Jan/13 14:29;kwsutter;Based on a note from Sven Vollbehr <sven@vollbehr.eu>...

You reported in https://issues.apache.org/jira/browse/OPENJPA-2172 that the openjpa-all.jar should include the slf4j runtime binding also. This has the following side effect. Should I want to configure SLF4J as my logging backend and then use another runtime binding, say slf4j-jdk14. Having the runtime binding in openjpa-all.jar gives me totally random results due to the following error:

SLF4J: Class path contains multiple SLF4J bindings.
SLF4J: Found binding in [jar:file:/C:/Users/Sven/.m2/repository/org/apache/openjpa/openjpa-all/2.2.1/openjpa-all-2.2.1.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: Found binding in [jar:file:/C:/Users/Sven/.m2/repository/org/slf4j/slf4j-jdk14/1.7.2/slf4j-jdk14-1.7.2.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.

SLF4J does not support multiple bindings so having the runtime binding included in openjpa-all jar file is so not working here. Since the runtime binding is included INSIDE the jar file it cannot be excluded either. Clearly not a good thing to include it in the openjpa-all jar file wouldn’t you agree?

Can you please re-open this issue?","15/Apr/13 13:45;jira-bot;Commit 1468067 from kwsutter
[ https://svn.apache.org/r1468067 ]

OPENJPA-2172.  Remove the dependency on the slf4j runtime bundle from openjpa-all.jar.  Also, modified the persistence.xml files for the OpenBooks sample to set the Validation-Mode to None (since it's not being used).  This way, we can avoid the dependency altogether.","15/Apr/13 15:01;jira-bot;Commit 1468106 from kwsutter
[ https://svn.apache.org/r1468106 ]

OPENJPA-2172.  Modified the persistence.xml files to indicate the use of the 2.0 XSD files (in order to properly detect and support the <validation-mode> element).","15/Apr/13 15:06;jira-bot;Commit 1468108 from kwsutter
[ https://svn.apache.org/r1468108 ]

OPENJPA-2172.  Remove the dependency on the slf4j runtime bundle from openjpa-all.jar.  Also, modified the persistence.xml files for the OpenBooks sample to set the Validation-Mode to None (since it's not being used).  This way, we can avoid the dependency altogether.  This also required the update to the persistence.xml files to point at the JPA 2.0 xsd files.","16/Apr/13 14:53;jira-bot;Commit 1468447 from kwsutter
[ https://svn.apache.org/r1468447 ]

OPENJPA-2172.  In order to pass the TCK, we needed to add the slf4j dependency into the TCK pom.xml.","16/Apr/13 14:56;jira-bot;Commit 1468449 from kwsutter
[ https://svn.apache.org/r1468449 ]

OPENJPA-2172.  In order to pass the TCK, we needed to add the slf4j dependency into the TCK pom.xml.",,,,,,,,,,,,,,,,,,,,,
Multiple INSERT of the same row in batch update manager,OPENJPA-2170,12550430,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,10/Apr/12 19:29,11/Apr/12 19:09,14/Mar/19 03:03,11/Apr/12 19:09,2.2.0,2.3.0,,,,,,,2.3.0,,,,,jdbc,,,,0,,,,,,,,"When trying to persist multiple different entities to the data base using the batching update manager, if an INSERT failed, the update manager will erroronously attempt to INSERT the same row to the database again. E.g.

     em.persist(entity_type_1_id_1);   // failed with a SQLException on INSERT
     em.persist(entity_type_2_id_2);
     em.flush();

will cause 2 insert of :

    INSERT ENTITY_TYPE_1  ......  WHERE ID=""ID_1""
Failed with an SQLException and insert the same row again.
    INSERT ENTITY_TYPE_1  ......  WHERE ID=""ID_1""
  ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,235294,,,2012-04-10 19:29:11.0,,,,,,,0|i1dv9z:,289164,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lifecycle event callback occurs more often than expect,OPENJPA-2163,12548387,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,27/Mar/12 20:56,21/Sep/16 14:38,14/Mar/19 03:03,01/Apr/12 14:42,2.0.1,2.1.2,2.2.1,2.3.0,,,,,2.2.1,2.3.0,,,,kernel,,,,0,,,,,,,,"A problem was uncovered in a scenario where multiple EntityManager instances created from the same EntityManagerFactory, and each instance is initialized with a new instance of a LifecycleListener instance, i.e.

final EntityManager em = factory.createEntityManager();
final EntityManager em2 = factory.createEntityManager();
...
MyLifecycleListener l1 = new MyLifecycleListener();
MyLifecycleListener l2 = new MyLifecycleListener();
...
((OpenJPAEntityManagerSPI)em).addLifecycleListener(l1, null);
((OpenJPAEntityManagerSPI)em2).addLifecycleListener(l2, null);

When life cycle event occurs for a specific entity manager, all the listeners created under the emf are being invoked. The expected behavior is only the listener registered in the em from which the life cycle events are related should be called.
",,,,,,,,,,,,,,,,,,,28/Mar/12 20:20;allee8285;OPENJPA-2163.trunk.patch;https://issues.apache.org/jira/secure/attachment/12520303/OPENJPA-2163.trunk.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,233484,,,2012-03-27 20:56:55.0,,,Patch Available,,,,0|i1dvav:,289168,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Make some members of StateManagerImpl protected to allow for greater extensability,OPENJPA-2161,12548006,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,25/Mar/12 14:50,09/Oct/12 18:37,14/Mar/19 03:03,02/May/12 15:58,2.2.0,2.3.0,,,,,,,2.2.1,2.3.0,,,,kernel,,,,0,,,,,,,,With this JIRA I'm going to change a number of methods / fields to protected to allow for greater extensibility. ,,,,,,,,,,,,,,OPENJPA-2020,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,233103,,,Wed May 02 15:58:13 UTC 2012,,,,,,,0|i07je7:,41909,,,,,,,,02/May/12 15:58;curtisr7;Committed changes to trunk and 2.2.x.,,,,,,,,,,,,,,,,,,,,,,,,,,
LiteAutoDetach + DetachProxyFields=false can lead to Broker concurrency exceptions,OPENJPA-2158,12547441,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,21/Mar/12 18:58,09/Oct/12 18:37,14/Mar/19 03:03,21/Mar/12 19:08,2.1.1,2.2.0,2.3.0,,,,,,2.2.1,2.3.0,,,,kernel,,,,0,,,,,,,,"OPENJPA-2014 added support for allowing proxies to stay in place after detach, but these detached proxy instances still hold a reference to a StateManager that is no longer valid.

Exception data: <openjpa-2.2.1-SNAPSHOT-r422266:1244808 fatal general error> org.apache.openjpa.persistence.PersistenceException: Multiple concurrent threads attempted to access a single broker. By default brokers are not thread safe; if you require and/or intend a broker to be accessed by more than one thread, set the openjpa.Multithreaded property to true to override the default behavior.
	at org.apache.openjpa.kernel.BrokerImpl.endOperation(BrokerImpl.java:1956)
	at org.apache.openjpa.kernel.BrokerImpl.isActive(BrokerImpl.java:1904)
	at org.apache.openjpa.kernel.DelegatingBroker.isActive(DelegatingBroker.java:476)
	at org.apache.openjpa.persistence.EntityManagerImpl.isActive(EntityManagerImpl.java:677)
	at org.apache.openjpa.persistence.PersistenceExceptions$2.translate(PersistenceExceptions.java:76)
	at org.apache.openjpa.kernel.DelegatingQuery.translate(DelegatingQuery.java:99)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:544)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:286)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,232599,,,Wed Mar 21 19:08:39 UTC 2012,,,,,,,0|i07jef:,41910,,,,,,,,21/Mar/12 19:08;curtisr7;Committed code fix and new testcase to trunk and 2.2.x.,,,,,,,,,,,,,,,,,,,,,,,,,,
Fix bug in org.apache.openjpa.persistence.util.SourceCode to correctly generate imports.,OPENJPA-2156,12546817,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,16/Mar/12 16:41,11/Apr/12 17:48,14/Mar/19 03:03,16/Mar/12 16:46,2.2.0,2.3.0,,,,,,,2.2.1,2.3.0,,,,,,,,0,sourcecode,,,,,,,"In SourceCode we incorrectly ignore adding ClassNames who's package starts with java.util to the collection of imports. For example, when a generated source file uses a java.util.Map, an import won't be created.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-04-11 16:48:27.25,,,no_permission,,,,,,,,,,,,231975,,,Wed Apr 11 17:48:29 UTC 2012,,,,,,,0|i1dvbb:,289170,,,,,,,,16/Mar/12 16:46;curtisr7;Committed code changes to trunk and 2.2.x.,21/Mar/12 18:42;curtisr7;Also added support for generating a final class to trunk and 2.2.1.,"11/Apr/12 16:48;ppoddar@apache.org;> we incorrectly ignore adding ClassNames who's package starts with java.util 
where did you see that? I thought it was ""java.lang.*"" that was ignored.","11/Apr/12 17:48;curtisr7;> I thought it was ""java.lang.*"" that was ignored. 
You are correct that using java.lang.* classes won't generate an import... but that is a problem for some java.lang classes. ie: Map.

",,,,,,,,,,,,,,,,,,,,,,,
test-dynamic-enhancer profile failed for module more than one level deep,OPENJPA-2154,12546055,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,12/Mar/12 05:00,12/Mar/12 14:18,14/Mar/19 03:03,12/Mar/12 14:18,2.2.0,2.3.0,,,,,,,2.2.1,2.3.0,,,,build / infrastructure,,,,0,,,,,,,,"openjpa-examples, openjpa-integration and openjpa-tools modules has 2 level deep. Building using test-dynamic-enhancer profile failed with the following exception:

 [INFO] Surefire report directory: /root/TeamCity/buildAgent/work/be6440991bd1f943/openjpa-tools/openjpa-maven-plugin/target/surefire-reports
 Forking command line: /bin/sh -c cd /root/TeamCity/buildAgent/work/be6440991bd1f943/openjpa-tools/openjpa-maven-plugin && /opt/java/ibm/jdk6-sr9/jre/bin/java -Djava.security.manager -Djava.security.policy=/root/TeamCity/buildAgent/work/be6440991bd1f943/openjpa-tools/openjpa-maven-plugin/../openjpa-persistence-jdbc/src/test/resources/j2.security.test.policy -Dtest.basedir=/root/TeamCity/buildAgent/work/be6440991bd1f943/openjpa-tools/openjpa-maven-plugin/.. -Xmx1024m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -jar /root/TeamCity/buildAgent/temp/buildTmp/surefirebooter6037852198870421265.jar /root/TeamCity/buildAgent/temp/buildTmp/surefire2725633924036419124tmp /root/TeamCity/buildAgent/temp/buildTmp/surefire5635214270772122697tmp
 java.security.AccessControlException: Access denied (java.io.FilePermission /root/TeamCity/buildAgent/temp/buildTmp/surefire5635214270772122697tmp read)
 at java.security.AccessController.checkPermission(AccessController.java:108)
 at java.lang.SecurityManager.checkPermission(SecurityManager.java:544)
 at java.lang.SecurityManager.checkRead(SecurityManager.java:883)
 at java.io.File.exists(File.java:742)
 at org.apache.maven.surefire.booter.SurefireBooter.loadProperties(SurefireBooter.java:803)
 at org.apache.maven.surefire.booter.SurefireBooter.setSystemProperties(SurefireBooter.java:822)
 at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:922)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,231213,,,2012-03-12 05:00:38.0,,,,,,,0|i1dvbr:,289172,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NoSuchMethodException of DBCPDriverDataSource.newInstance(),OPENJPA-2153,12545916,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,09/Mar/12 21:57,28/Mar/12 07:12,14/Mar/19 03:03,12/Mar/12 14:19,2.2.0,2.3.0,,,,,,,2.2.1,2.3.0,,,,jdbc,,,,0,,,,,,,,"
  NoSuchMethodException:
  org.apache.openjpa.jdbc.schema.DBCPDriverDataSource.newInstance()

<openjpa-2.2.0-r422266:1244990 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: There were errors initializing your configuration: <openjpa-2.2.0-r422266:1244990 fatal user error> org.apache.openjpa.util.UserException: A connection could not be obtained for driver class ""org.postgresql.Driver"" and URL ""jdbc:postgresql://localhost/foo"".  You may have specified an invalid URL.
        at org.apache.openjpa.jdbc.schema.DataSourceFactory.newConnectException(DataSourceFactory.java:255)
        at org.apache.openjpa.jdbc.schema.DataSourceFactory.newDataSource(DataSourceFactory.java:123)
        at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.createConnectionFactory(JDBCConfigurationImpl.java:844)
        at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getConnectionFactory(JDBCConfigurationImpl.java:732)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.apache.openjpa.lib.conf.ConfigurationImpl.instantiateAll(ConfigurationImpl.java:295)
        at org.apache.openjpa.conf.OpenJPAConfigurationImpl.instantiateAll(OpenJPAConfigurationImpl.java:1671)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.makeReadOnly(AbstractBrokerFactory.java:646)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:203)
        at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:156)
        at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:227)
        at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:154)
        at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:60)
        at org.example.FooServiceTest.before(FooServiceTest.java:24)
Caused by: org.apache.commons.lang.exception.NestableRuntimeException: An instance of the class ""class org.apache.openjpa.jdbc.schema.DBCPDriverDataSource"" could not be instantiated.  Make sure the class has a public no-args constructor.
        at org.apache.openjpa.lib.conf.Configurations.newInstance(Configurations.java:240)
        at org.apache.openjpa.lib.conf.ObjectValue.newInstance(ObjectValue.java:124)
        at org.apache.openjpa.lib.conf.PluginValue.instantiate(PluginValue.java:103)
        at org.apache.openjpa.lib.conf.ObjectValue.instantiate(ObjectValue.java:83)
        at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.newDriverDataSourceInstance(JDBCConfigurationImpl.java:639)
        at org.apache.openjpa.jdbc.schema.DataSourceFactory.newDataSource(DataSourceFactory.java:89)
        ... 46 more
Caused by: java.lang.InstantiationException: java.lang.NoSuchMethodException: org.apache.openjpa.jdbc.schema.DBCPDriverDataSource.newInstance()
        at org.apache.openjpa.lib.util.J2DoPrivHelper$11.run(J2DoPrivHelper.java:377)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.apache.openjpa.lib.conf.Configurations.newInstance(Configurations.java:234)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-03-28 07:12:00.25,,,no_permission,,,,,,,,,,,,231098,,,Wed Mar 28 07:12:00 UTC 2012,,,,,,,0|i1dvbz:,289173,,,,,,,,28/Mar/12 07:12;lucidfox;Still occurs for me with openjpa-2.2.1-20120216.070224-1.jar.,,,,,,,,,,,,,,,,,,,,,,,,,,
Criteria.function adds wrong casts to parameters making it unsuable,OPENJPA-2149,12545137,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,allee8285,aviramsegal,aviramsegal,05/Mar/12 07:50,21/Sep/16 14:38,14/Mar/19 03:03,24/Aug/12 02:34,2.0.1,2.0.2,2.1.1,,,,,,2.0.2,2.1.2,2.2.1,2.3.0,,criteria,kernel,,,0,,,,,,,,"Criteria.function will generate an SQL with only the last parameter casted and to the wrong type.
		Expression<String> stPointFunc = cb.function(
				""db2gse.st_point"", 
				String.class,
				cb.literal(0.0),
				cb.literal(0.0),
				cb.literal(1003));
		
		Expression<Double> distanceFunc = cb.function(
				""db2gse.st_distance"", 
				Double.class, 
				stPointFunc, 
				usersLocations.get(""location""));
		
		criteriaQuery.select(usersLocations).where(cb.lessThan(distanceFunc, cb.literal(50.0)));

Will generate the following SQL:
(db2gse.st_distance(db2gse.st_point(?, ?, CAST(? AS DOUBLE)), t0.LOCATION) < ?)

Notice the 3rd parameter is an Integer and its being cast as Double.
The problem is in org.apache.openjpa.jdbc.kernel.exps.DatastoreFunction#appendTo

Line 54:  args.appendTo(sel, ctx, state, sql, 0);
Will append 3 ? to the sql buffer: ""(db2gse.st_distance(db2gse.st_point(?, ?, ?""

Then the loop in line 56-58
            for (int i = 1; i < vals.length; i++) {
                sql.addCastForParam(getOperator(), vals[i]);
            }
It becomes: ""(db2gse.st_distance(db2gse.st_point(?, ?, CAST(? AS DOUBLE)""


Starts with 1 (second parameter and not the first one), whil sql.addCastForParam only works for the last ? in the sql buffer, meaning the cast for the param at index 1 is added to the last ? and the method will not do anything else.

This issue leaves Criteria.function useless to me, I tried extending my DBDictionary to remove all the cast as a work around but the function became ambiguous.

Thanks in advance.

Found a temporary (working but ugly) workaround:
		Expression<String> stPointFunc = cb.function(
				""db2gse.st_point"", 
				String.class,
				cb.coalesce(cb.literal(0.0), cb.literal(0.0)),
				cb.coalesce(cb.literal(1.0), cb.literal(1.0)),
				cb.coalesce(cb.literal(1003), cb.literal(1003)));

coalesce uses raw value instead of parameters and makes it work (the same value twice becuase if I put cb.nullLiteral I get a NullPointerException, might be another bug)
","Standalone 2.0.0 and 2.0.1 downloaded from openjpa website, and on WebSphere 7 JPA2 feature pack 1.0.0.5 (contains OpenJPA 2.0.2)",,,,,,,,,,,,,,,,,,13/Jun/12 15:38;allee8285;OPENJPA-2149-2.0.x.patch;https://issues.apache.org/jira/secure/attachment/12531985/OPENJPA-2149-2.0.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,230323,,,2012-03-05 07:50:18.0,,,,,,,0|i0ywnr:,201761,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StateManager for Embeddable may throw Exception while initializing,OPENJPA-2146,12544327,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,fyrewyld,fyrewyld,27/Feb/12 22:17,21/Sep/16 14:38,14/Mar/19 03:03,03/May/12 15:06,2.0.0,2.0.1,2.0.2,2.1.0,2.1.1,2.1.2,2.2.0,2.2.1,2.0.2,2.1.2,2.2.1,2.3.0,,kernel,,,,0,,,,,,,,"When a complex graph of nested Embeddable are used in an application data model, an issue may surface when the OpenJPA provider tries to instantiate an internal state manager that represents the nested Embeddable. This issue results in an exception.  The Exception being thrown is based on a generalized assertion that the nested Embeddable does not have an identity associated to it since it is embedded in some entity which bears the identity.

Sample Exception:

<openjpa-2.0.2-SNAPSHOT-r422266:1084264 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Cannot manipulate identity of type ""<embeddable classname>"": it's identity type is unknown.                                                              
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,229564,,,2012-02-27 22:17:52.0,,,,,,,0|i1dvcn:,289176,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missing ASM depending jar in binary zip,OPENJPA-2145,12544299,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,27/Feb/12 19:22,27/Feb/12 22:01,14/Mar/19 03:03,27/Feb/12 22:01,2.2.0,2.2.1,2.3.0,,,,,,2.2.1,2.3.0,,,,agile,,,,0,,,,,,,,"Build artifact openjpa-project\target\site\downloads\apache-openjpa-2.*.*-SNAPSHOT-binary.zip is missing depending lib\asm-3.2.jar, which was introduced in OPENJPA-2085.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,229536,,,2012-02-27 19:22:14.0,,,,,,,0|i1dvcv:,289177,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Merge of a new object does not handle Entity Id field,OPENJPA-2142,12544008,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,dianner,dianner,dianner,24/Feb/12 15:44,08/May/12 14:26,14/Mar/19 03:03,08/May/12 14:25,2.2.1,2.3.0,,,,,,,2.2.1,2.3.0,,,,,,,,0,,,,,,,,"When a merge is done on a new object with an Id that contains an Entity, the following exception occurs:

<openjpa-2.2.1-SNAPSHOT-r422266:1292578 nonfatal user error> org.apache.openjpa.persistence.InvalidStateException: Attempt to change a primary key field of an instance that already has a final object id.  Only new, unflushed instances whose id you have not retrieved can have their primary keys changed.
FailedObject: hat.entities.Child@38d138d1
	at org.apache.openjpa.kernel.StateManagerImpl.assertNoPrimaryKeyChange(StateManagerImpl.java:2108)
	at org.apache.openjpa.kernel.StateManagerImpl.settingObjectField(StateManagerImpl.java:2043)
	at org.apache.openjpa.kernel.AttachStrategy.attachField(AttachStrategy.java:236)
	at org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:155)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:252)
	at org.apache.openjpa.kernel.AttachStrategy.attachCollection(AttachStrategy.java:370)
	at org.apache.openjpa.kernel.AttachStrategy.replaceList(AttachStrategy.java:431)
	at org.apache.openjpa.kernel.AttachStrategy.attachField(AttachStrategy.java:255)
	at org.apache.openjpa.kernel.AttachManager.handleCascade(AttachManager.java:267)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:241)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:105)
	at org.apache.openjpa.kernel.BrokerImpl.attach(BrokerImpl.java:3474)
	at org.apache.openjpa.kernel.DelegatingBroker.attach(DelegatingBroker.java:1214)
	at org.apache.openjpa.persistence.EntityManagerImpl.merge(EntityManagerImpl.java:878)
	...

During the merge, a copy is made of the original object, with a copy of the key fields. But, if a key field is an Entity, it is not copied, causing this exception in later processing. The fix is to attach this field immediately after the original object is copied.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-04-25 15:10:24.591,,,no_permission,,,,,,,,,,,,229246,,,Wed Apr 25 15:10:24 UTC 2012,,,,,,,0|i1dvdb:,289179,,,,,,,,25/Apr/12 14:15;dianner;Reopen to commit changes for earlier releases,25/Apr/12 15:05;dianner;In 2.0.x there is a 2nd problem in this merge scenario. BrokerImpl.getObjectId() returns null when the StateManager in the pc object is null. This is fixed in subsequent releases by calling ApplicationIds.create(). This fix will be backported to 2.0.x in this JIRA to complete the merge fix.,"25/Apr/12 15:10;curtisr7;Can you also port the testcases from trunk to 2.2.x ?

Thanks,
Rick",,,,,,,,,,,,,,,,,,,,,,,,
Locking tests issue many warnings about the use of a duplicate pu name,OPENJPA-2140,12543759,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,techhusky,techhusky,techhusky,22/Feb/12 22:44,22/Feb/12 22:48,14/Mar/19 03:03,22/Feb/12 22:48,2.3.0,,,,,,,,2.3.0,,,,,build / infrastructure,,,22/Feb/12 00:00,0,,,,,,,,"The openjpa-persistence-locking module includes a persistence.xml which uses pu name ""test"".  This pu name is used in the base persistence.xml from openjpa-persistence-jdbc.  Since both are on the classpath, this leads to a bunch of messages in the build log indicating that there's a duplicate pu.  I'm modifying the o-p-l module to use a unique pu name.",,3600,3600,,0%,3600,3600,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,228998,,,Wed Feb 22 22:48:02 UTC 2012,,,,,,,0|i1dvdr:,289181,,,,,,,,22/Feb/12 22:48;techhusky;Fix committed under revision 1292564.,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE when using LiteAutoDetach ,OPENJPA-2136,12543556,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,21/Feb/12 20:18,09/Oct/12 18:36,14/Mar/19 03:03,21/Feb/12 21:28,2.0.0,2.1.1,2.2.0,2.3.0,,,,,2.2.1,2.3.0,,,,kernel,,,,0,,,,,,,,"I encountered a NPE[2] today when using the LiteAutoDetach[1] configuration property. The steps required to cause this problem is as follows:

- Configure LiteAutoDetach for your PU.
- Find a non-transactional Entity.
- Clear the EntityManager.
- Begin / commit transaction.

The problem is that LiteAutoDetach doesn't properly clean up the EntityManager while it is performing lite detachment. State is left in BrokerImpl._pending set which is then incorrectly used post em.clear. It also appears that there are a number of other BrokerImpl datastructures that *should* have been cleaned up on clear / detachall. 

[1] http://openjpa.apache.org/builds/latest/docs/docbook/manual.html#ref_guide_detach_state
[2] Caused by: <openjpa-2.2.0-SNAPSHOT-r422266:1244602 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: null
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1998)
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:81)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1514)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:933)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:570)
	... 24 more
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.Customer.pcProvideField(Customer.java)
	at org.apache.openjpa.kernel.StateManagerImpl.provideField(StateManagerImpl.java:3161)
	at org.apache.openjpa.kernel.StateManagerImpl.preFlush(StateManagerImpl.java:2980)
	at org.apache.openjpa.kernel.PDirtyState.beforeFlush(PDirtyState.java:38)
	at org.apache.openjpa.kernel.StateManagerImpl.beforeFlush(StateManagerImpl.java:1053)
	at org.apache.openjpa.kernel.BrokerImpl.flush(BrokerImpl.java:2112)
	at org.apache.openjpa.kernel.BrokerImpl.flushSafe(BrokerImpl.java:2072)
	at org.apache.openjpa.kernel.BrokerImpl.beforeCompletion(BrokerImpl.java:1990)
	... 28 more",,,,,,,,,,,,,,OPENJPA-1545,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,228795,,,Tue Feb 21 21:27:49 UTC 2012,,,,,,,0|i07jen:,41911,,,,,,,,21/Feb/12 21:15;curtisr7;Committed revision 1292034 to trunk.,21/Feb/12 21:27;curtisr7;Committed revision 1292040 to 2.2.x.,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA doesn't find custom mappings with an applicable class loader,OPENJPA-2133,12542708,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,jpaheath,jpaheath,15/Feb/12 16:16,21/Sep/16 14:37,14/Mar/19 03:03,07/May/12 14:51,2.1.1,,,,,,,,1.2.3,2.0.2,2.1.2,2.2.1,2.3.0,,,,,0,,,,,,,,"JIRA OPENJPA-758 addressed a class loader issue where ValueHandlers could not be found by an applicable class loader. The fix was specific to ValueHandlers. However, the same issue occurs for other customer mappings (e.g. ClassStrategy, DiscriminatorStrategy, etc). Basically, mappings handled by MappingRepository. I will attach a patch with my proposed changes. The fix is in the same pattern as was done in the fix for JIRA OPENJPA-758, please see this JIRA for more details. ",,,,,,,,,,,,,,,,,,,15/Feb/12 16:18;jpaheath;OPENJPA-2133-2.1.x.patch;https://issues.apache.org/jira/secure/attachment/12514653/OPENJPA-2133-2.1.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,227994,,,2012-02-15 16:16:04.0,,,Patch Available,,,,0|i1dven:,289185,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Traversal of a OneToMany relationship returns an empty list when InheritanceType.JOINED or SINGLE_TABLE is used.,OPENJPA-2132,12542594,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,dianner,jpaheath,jpaheath,14/Feb/12 20:48,09/Oct/12 18:17,14/Mar/19 03:03,09/Oct/12 18:17,2.0.1,2.1.1,2.2.0,,,,,,2.1.2,2.2.1,2.3.0,,,query,,,,0,,,,,,,,"I will include a test, named 'OneManyJoinableTest.test' which recreates the issue of this JIRA.  Basically though, the test consists of a parent class defined with '@Inheritance(strategy=InheritanceType.JOINED)'.  One of the subclasses in the hierarchy contains a (bidirectional) OneToMany relationship.  When traversing the ManyToOne side of the relations, all works well.  But when traversing the OneToMany side an empty list is returned.  When running the test, it can be seen that OpenJPA generate incorrect SQL, as follows:

SELECT t1.id, t0.id, t2.id, t3.id, t1.name FROM UMLType t0, UMLNamed t1, UMLClass t2, UMLPrimitiveType t3 WHERE t0.OWNERPACKAGE_ID = ? AND t2.id IS NULL AND t3.id IS NULL AND t0.id = t1.id AND t0.id = t2.id(+) AND t0.id = t3.id(+)

Note that the 't2.id IS NULL AND t3.id IS NULL' seems suspect.

This same test passes on OpenJPA 1.2.x but fails on OpenJPA 2.0.x on wards.  



",,,,,,,,,,,,,,,,,,,14/Feb/12 20:49;jpaheath;OneManyJoinableTest.test;https://issues.apache.org/jira/secure/attachment/12514546/OneManyJoinableTest.test,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,227880,,,2012-02-14 20:48:29.0,,,,,,,0|i07jfr:,41916,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missing IN or OUT parameter exception with OracleDictionary,OPENJPA-2131,12542592,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,zilin_chen,zilin_chen,14/Feb/12 20:23,21/Sep/16 14:38,14/Mar/19 03:03,05/Apr/12 14:07,2.1.1,,,,,,,,2.0.2,2.1.2,2.2.1.1,2.2.3,2.3.0,jdbc,,,,0,,,,,,,,"We have generate query with 

Query q = em.createQuery(""select e._name, e._id, sum(case when e._status=:pending then e._count else 0 end) from Exceptions e, Historty h where e._guid = :guid and .....
then set paramenters for both :pending (in select) and :guid (in where), and call q.setMaxResults(100);

with DB2, everything works fine, and DBDictionary.getSelects() and SQLBuffer.append() will invoke correctly and set parameter of :pending

with Oracle implementation, OracleDictionary.getSelects(Select sel, boolean distinctIdentifiers, boolean forUpdate) will invoke and SQLBuffer.getSQL() get to call (as two if checks are not satisfied and gos to create a new SQLBuffer instance), but this time :pending parameter will missing to add to _param List,
Eventually, we'll get Missing IN or OUT parameter exception from to execute query by preparedStatement 

This bug exist in both this branch and trunk.
We have a work around, after SQLBuffer.getSQL() call, add some code to reset _param list.",Windows with Oracle 11g,,,,,,,,,,,,,,,,,,04/Apr/12 17:12;allee8285;OPENJPA-2131.22x.patch;https://issues.apache.org/jira/secure/attachment/12521344/OPENJPA-2131.22x.patch,15/Feb/12 21:27;zilin_chen;OracleInOutParameterIssue.patch;https://issues.apache.org/jira/secure/attachment/12514711/OracleInOutParameterIssue.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-04-03 18:59:07.867,,,no_permission,,,,,,,,,,,,227878,,,Mon Dec 01 16:49:42 UTC 2014,,,Patch Available,,,,0|i0yu33:,201344,,,,,,,,"15/Feb/12 21:06;zilin_chen;Here is code snapshot of our work around

1, in the method below of org.apache.openjpa.jdbc.sql.OracleDictionary.java  (branch 2.1.x)

protected SQLBuffer getSelects(Select sel, boolean distinctIdentifiers,
        boolean forUpdate) { 
....
            if (alias instanceof SQLBuffer){
                asString = ((SQLBuffer) alias).getSQL();   
                selectSQL.appendParamOnly((SQLBuffer) alias); //add line to set parameters
            }else{
                asString = alias.toString();
            }


2, org.apache.openjpa.jdbc.sql.SQLBuffer.java  (branch 2.1.x)

From line 110 - 136
 add a work around method appendParamOnly() and overload method append() to call updated append(SQLBuffer buf, int sqlIndex, int paramIndex,
        boolean subsels, boolean paramOnly)  which will append _sql based on passin boolean paramOnly.
  
    /** 
     * Append parameters only of the given buffer at the given positions.
     */
    public SQLBuffer appendParamOnly(SQLBuffer buf) {
    	append(buf, _sql.length(), (_params == null) ? 0 : _params.size(),
                true, true);
        return this;
    }
    
    /**
     * Append all SQL and parameters of the given buffer at the given positions.
     */
    private void append(SQLBuffer buf, int sqlIndex, int paramIndex,
        boolean subsels) {
    	append(buf, sqlIndex, paramIndex, subsels, false);
    }

    /**
     * Append parameters and/or SQL of the given buffer at the given positions.
     */
    private void append(SQLBuffer buf, int sqlIndex, int paramIndex,
        boolean subsels, boolean paramOnly) {
        if (subsels) {
            // only allow appending of buffers with subselects, not insertion
            if (_subsels != null && !_subsels.isEmpty()
                && sqlIndex != _sql.length())
                throw new IllegalStateException();
            if (buf._subsels != null && !buf._subsels.isEmpty()) {
                if (sqlIndex != _sql.length())
                    throw new IllegalStateException();
                if (_subsels == null)
                    _subsels = new ArrayList(buf._subsels.size());
                for (int i = 0; i < buf._subsels.size(); i++)
                    _subsels.add(((Subselect) buf._subsels.get(i)).
                        clone(sqlIndex, paramIndex));
            }
        }
        if(!paramOnly){
	        if (sqlIndex == _sql.length())
	            _sql.append(buf._sql.toString());
	        else
	            _sql.insert(sqlIndex, buf._sql.toString());
        }
.....","03/Apr/12 18:59;allee8285;Zilin,

I tried your patch and the junit passed for most dbs including Oracle 10g. However I got the 13 additional errors in TestComplexQueries using Oracle 11g with a stack similar to the following:

TestComplexQueries.testComplex1 (org.apache.openjpa.persistence.query)
    « Hide stacktrace
    <openjpa-2.2.1-SNAPSHOT-r422266:1309047M nonfatal user error> org.apache.openjpa.persistence.ArgumentException: null
        at org.apache.openjpa.kernel.QueryImpl.deleteInMemory(QueryImpl.java:1042)
        at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeDelete(ExpressionStoreQuery.java:792)
        at org.apache.openjpa.kernel.QueryImpl.delete(QueryImpl.java:1025)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:822)
        at org.apache.openjpa.kernel.QueryImpl.deleteAll(QueryImpl.java:888)
        at org.apache.openjpa.kernel.QueryImpl.deleteAll(QueryImpl.java:884)
        at org.apache.openjpa.kernel.DelegatingQuery.deleteAll(DelegatingQuery.java:558)
        at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:374)
        at org.apache.openjpa.persistence.common.utils.AbstractTestCase.deleteAll(AbstractTestCase.java:191)
        at org.apache.openjpa.persistence.common.utils.AbstractTestCase.deleteAll(AbstractTestCase.java:202)
        at org.apache.openjpa.persistence.query.TestComplexQueries.clear(TestComplexQueries.java:66)
        at org.apache.openjpa.persistence.query.TestComplexQueries.setUp(TestComplexQueries.java:57)
        at junit.framework.TestCase.runBare(TestCase.java:125)
        at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:566)
        at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:542)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:206)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.GeneratedMethodAccessor54.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:600)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:115)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:102)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:180)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:600)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:350)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1021)
    Caused by: java.lang.ArrayIndexOutOfBoundsException
        at oracle.jdbc.driver.T4CSocketInputStreamWrapper.readLongMSB(T4CSocketInputStreamWrapper.java:201)
        at oracle.jdbc.driver.T4CMAREngine.buffer2Value(T4CMAREngine.java:2413)
        at oracle.jdbc.driver.T4CMAREngine.unmarshalUB4(T4CMAREngine.java:1353)
        at oracle.jdbc.driver.T4CMAREngine.unmarshalSB4(T4CMAREngine.java:1331)
        at oracle.jdbc.driver.T4CTTIoac.unmarshal(T4CTTIoac.java:201)
        at oracle.jdbc.driver.T4C8TTIuds.unmarshal(T4C8TTIuds.java:139)
        at oracle.jdbc.driver.T4CTTIdcb.receiveCommon(T4CTTIdcb.java:200)
        at oracle.jdbc.driver.T4CTTIdcb.receive(T4CTTIdcb.java:144)
        at oracle.jdbc.driver.T4C8Oall.readDCB(T4C8Oall.java:771)
        at oracle.jdbc.driver.T4CTTIfun.receive(T4CTTIfun.java:346)
        at oracle.jdbc.driver.T4CTTIfun.doRPC(T4CTTIfun.java:186)
        at oracle.jdbc.driver.T4C8Oall.doOALL(T4C8Oall.java:521)
        at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:205)
        at oracle.jdbc.driver.T4CPreparedStatement.executeForDescribe(T4CPreparedStatement.java:861)
        at oracle.jdbc.driver.OracleStatement.executeMaybeDescribe(OracleStatement.java:1145)
        at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1267)
        at oracle.jdbc.driver.OraclePreparedStatement.executeInternal(OraclePreparedStatement.java:3449)
        at oracle.jdbc.driver.OraclePreparedStatement.executeQuery(OraclePreparedStatement.java:3493)
        at oracle.jdbc.driver.OraclePreparedStatementWrapper.executeQuery(OraclePreparedStatementWrapper.java:1491)
        at org.apache.commons.dbcp.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:96)
        at org.apache.commons.dbcp.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:96)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:267)
        at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeQuery(LoggingConnectionDecorator.java:1116)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:265)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeQuery(JDBCStoreManager.java:1750)
        at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:255)
        at org.apache.openjpa.jdbc.sql.SelectImpl.executeQuery(SelectImpl.java:499)
        at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:424)
        at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:391)
        at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:427)
        at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:230)
        at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:220)
        at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:94)
        at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:34)
        at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1251)
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1007)
        at org.apache.openjpa.kernel.QueryImpl.deleteInMemory(QueryImpl.java:1031)
        ... 34 more
    ------- Stderr: -------
    0  TestConv  INFO   [main] openjpa.Runtime - Starting OpenJPA 2.2.1-SNAPSHOT
    1  TestConv  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.OracleDictionary"".
    71  TestConv  WARN   [main] openjpa.MetaData - OpenJPA cannot map field ""org.apache.openjpa.persistence.query.common.apps.RuntimeTest1.selfOneMany"" efficiently.  It is of an unsupported type. The field value will be serialized to a BLOB by default.

Albert Lee.","04/Apr/12 17:08;allee8285;The additional failures have nothing to do with the fix. It is caused by a JAXB problem got fixed in jaxb 2.1 (See http://www.java.net/node/661561).

After updated openjpa pom.xml to use 2.2.1 version of jaxb, the problem goes away.

Albert Lee.",04/Apr/12 17:12;allee8285;Commit Zilin patch in 2.3.0. Attach 2.2.1 patch here for posterity.,"31/Jul/14 16:47;jira-bot;Commit 1614935 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1614935 ]

OPENJPA-2131: Missing IN or OUT parameter exception with OracleDictionary - back ported Albert Lee's trunk commit.","31/Jul/14 17:05;jira-bot;Commit 1614937 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1614937 ]

OPENJPA-2131: Missing IN or OUT parameter exception with OracleDictionary - back ported Albert Lee's trunk commit.","31/Jul/14 17:16;jira-bot;Commit 1614939 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1614939 ]

OPENJPA-2131: Missing IN or OUT parameter exception with OracleDictionary - back ported Albert Lee's trunk commit.","01/Dec/14 16:49;jira-bot;Commit 1642710 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1642710 ]

OPENJPA-2131: Missing IN or OUT parameter exception with OracleDictionary - added generated serialversionid",,,,,,,,,,,,,,,,,,,
Minor performance improvements for Connection and ResultSet processing,OPENJPA-2123,12541862,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,08/Feb/12 19:27,09/Oct/12 18:15,14/Mar/19 03:03,09/Oct/12 18:15,2.2.1,2.3.0,,,,,,,2.2.1,2.3.0,,,,jdbc,performance,,,0,,,,,,,,"Came across a few items that could help with performance in certain scenarios.  I'll document each one as I determine the proper resolution.  The first one is that we were preparing the ability to print the SQL parameters even if no configuration properties were set requesting that capability.  This resulted in String and StringBuffer operations that were extra overhead on every interaction with the Connection.

More to come...",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,227149,,,Wed Feb 22 19:27:47 UTC 2012,,,,,,,0|i07jfz:,41917,,,,,,,,"22/Feb/12 17:24;kwsutter;Found another minor improvement that is indirectly related to Connection and ResultSet processing...  Whenever setQueryTimeout is processed with the DB2Dictionary, we make a call to a private method to determine the level or version of DB2 that we're talking with.  This method is expensive due to the string manipulation that is performed.  Since we have already determine the level of DB2 during the connectedConfiguration() initialization, we can be more efficient by just checking the value of db2ServerType instead of calling isDB2ZOSV8xOrLater().","22/Feb/12 19:27;kwsutter;There may be occasions where String columns in a database contain large amounts of unnecessary trailing whitespace.  To alleviate the movement and processing of this whitespace, I am introducing a DBDictionary property to optionally trim this trailing whitespace after retrieving a String field from a ResultSet.  The default value for this new property (DBDictionary.trimStringColumns) will be ""false"" to allow existing applications to continue executing as they have today.  But, for those applications where the removal of this whitespace can provide a performance benefit, this property can be set to ""true"" and then trim() will be called on the String result before returning it to the Entity.",,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError with Java 7 when using javaagent or dynamic container enhancement,OPENJPA-2122,12541722,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,08/Feb/12 00:47,05/Oct/12 18:50,14/Mar/19 03:03,08/Feb/12 01:00,2.2.0,,,,,,,,2.2.0,,,,,Enhance,kernel,,,0,,,,,,,,"In a Java 7 runtime environment, the javaagent mechanism for enhancing the Entity classes was not properly detecting a Java 7 class file.  Thus, the final stack map table fixups were not performed by ASM.  The Entity class would end up with a VerifyError similar to this when being loaded:

Caused by: java.lang.VerifyError: JVMVRFY012 stack shape inconsistent; class=mypackage/PersistentJPA, method=...",,,,,,,,,,,,,,OPENJPA-2240,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,227009,,,2012-02-08 00:47:33.0,,,,,,,0|i05fhr:,29607,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Update org.apache.openjpa.persistence.util.SourceCode,OPENJPA-2119,12540917,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,02/Feb/12 13:10,09/Feb/12 15:26,14/Mar/19 03:03,09/Feb/12 15:26,2.2.0,,,,,,,,2.2.0,,,,,lib,,,,0,,,,,,,,While working with SourceCode I've encountered a number of bugs and a few missing features.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,226270,,,Thu Feb 09 15:26:52 UTC 2012,,,,,,,0|i1dvfz:,289191,,,,,,,,"08/Feb/12 22:38;curtisr7;Committed revision 1242154 to trunk. 

I'm going to keep this open for the time being as I might need to add additional features / fix other bugs.",09/Feb/12 15:26;curtisr7;Resolving this issue so that we can get the 2.2.0 release rolling.,,,,,,,,,,,,,,,,,,,,,,,,,
Prepared SQL query does not handle collection-valued parameter where collection is empty,OPENJPA-2118,12540446,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,jpaheath,jpaheath,30/Jan/12 22:14,31/May/12 01:49,14/Mar/19 03:03,31/May/12 01:49,2.0.0,2.1.0,2.2.0,,,,,,2.0.2,2.1.2,2.2.1,2.3.0,,sql,,,,0,,,,,,,,"In PreparedQueryImpl.setCollectionValuedParameter, we do a '%n' but don't check for n==0, as can be seen here:

    private void setCollectionValuedParameter(Map<Integer,Object> result, 
        Collection values, int[] indices, Object param) {
        int n = values.size();
        Object[] array = values.toArray();
        if (n > indices.length || indices.length%n != 0) {    <---------------------line 389 in 2.0.x


When n==0, the following exception will occur:

Exception data: java.lang.ArithmeticException: divide by zero
        at org.apache.openjpa.jdbc.kernel.PreparedQueryImpl.setCollectionValuedParameter(PreparedQueryImpl.java:389)

I will upload a test to reproduce this issue and a proposed fix in the next day or two.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,225859,,,2012-01-30 22:14:15.0,,,,,,,0|i1dvg7:,289192,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
XML overriding column names for 1xM attributes causes exception.,OPENJPA-2117,12539944,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,26/Jan/12 18:19,10/Apr/13 20:48,14/Mar/19 03:03,10/Apr/13 20:48,1.2.3,2.0.2,2.1.1,2.2.0,,,,,1.2.3,2.2.0,,,,jdbc,,,,0,,,,,,,,"Entity with 1xm relationship define in orm.xml causes the following exception during emf.createEntityManager.

+    //Removing the XML from the orm.xml file, and using this fixes the issue:
+    //@OneToMany(fetch=FetchType.LAZY,cascade=CascadeType.ALL)
+    private List<XMLManyToOneEntity>  xmlManyToOneList = new ArrayList<XMLManyToOneEntity>(0);

And this mapping in the orm.xml:

+              <one-to-many name=""xmlManyToOneList"" fetch=""LAZY"">
+            <join-column name=""IDENTITY"" />
+                 <cascade>
+                    <cascade-all/>
+                 </cascade>

<openjpa-2.2.0-SNAPSHOT-r422266:1235624 fatal user error> org.apache.openjpa.persistence.ArgumentException: You have supplied columns for ""org.apache.openjpa.persistence.arrays.model.XMLOneToManyEntity.xmlManyToOneList"", but this mapping cannot have columns in this context.
	at org.apache.openjpa.jdbc.meta.MappingInfo.assertNoSchemaComponents(MappingInfo.java:382)
	at org.apache.openjpa.jdbc.meta.strats.RelationToManyTableFieldStrategy.map(RelationToManyTableFieldStrategy.java:97)
	at org.apache.openjpa.jdbc.meta.strats.RelationCollectionTableFieldStrategy.map(RelationCollectionTableFieldStrategy.java:95)
	at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:146)
	at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:82)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:496)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:461)
	at org.apache.openjpa.jdbc.meta.ClassMapping.resolveMapping(ClassMapping.java:865)
	at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1802)
	at org.apache.openjpa.meta.MetaDataRepository.processBuffer(MetaDataRepository.java:821)
	at org.apache.openjpa.meta.MetaDataRepository.resolveMapping(MetaDataRepository.java:776)
	at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:656)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:410)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:383)
	at org.apache.openjpa.jdbc.meta.MappingRepository.getMapping(MappingRepository.java:352)
	at org.apache.openjpa.jdbc.meta.MappingTool.getMapping(MappingTool.java:682)
	at org.apache.openjpa.jdbc.meta.MappingTool.buildSchema(MappingTool.java:754)
	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:652)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:154)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,225447,,,2012-01-26 18:19:22.0,,,,,,,0|i1duzz:,289119,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE during eager-fetching of simple m:n (ManyToMany) relation,OPENJPA-2112,12538772,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,evomaster,evomaster,18/Jan/12 10:28,05/Jul/17 06:58,14/Mar/19 03:03,18/Jan/12 15:46,2.1.1,,,,,,,,,,,,,jpa,,,,0,collection,eager,fetching,nullpointer,project,sample,UnenhancedClasses,"Hi,

in case of ManyToMany eager join unidirectional join, a nullpointer exception is thrown:

Exception in thread ""main"" <openjpa-2.1.1-r422266:1148538 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: null
FailedObject: select t from Itemlist t [java.lang.String]
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:1008)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:907)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1041)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:280)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2381)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:274)
	at org.apache.openjpa.jdbc.kernel.InstanceResultObjectProvider.getResultObject(InstanceResultObjectProvider.java:59)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:36)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1251)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1007)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:863)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:794)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:315)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:331)
	at de.meyerwerft.test.ItemTester.getItemlist_Items(ItemTester.java:102)
	at de.meyerwerft.test.ItemTester.main(ItemTester.java:19)
Caused by: java.lang.NullPointerException
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.setInverseRelation(JDBCStoreManager.java:480)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:440)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:333)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:112)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1027)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:985)
	... 16 more


Given relations:

- Itemlist 
- Item 
- Itemlist_Item


Properties set:

			<property name=""openjpa.jdbc.SynchronizeMappings"" value=""buildSchema"" />
			<property name=""openjpa.RuntimeUnenhancedClasses"" value=""supported"" />


",,,,,,,,,,,,,,,,,,,18/Jan/12 10:29;evomaster;Eager_Bug.zip;https://issues.apache.org/jira/secure/attachment/12510969/Eager_Bug.zip,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-01-18 15:46:41.395,,,no_permission,,,,,,,,,,,,224275,,,Wed Jul 05 06:58:48 UTC 2017,,,,,,,0|i1dv0n:,289122,,,,,,,,"18/Jan/12 15:46;curtisr7;I hate to say this but I the most timely solution to this problem is to not set openjpa.RuntimeUnenhancedClasses=supported. RuntimeUnenhancedClasses is a half baked feature that has numerous documented issues and no one is going to get to this anytime soon.  Please take a look at these links [1][2] which detail other enhancement strategies.

I'm closing this issue because we don't intend on making subclassing usable in the near future. We will reopen if/when we decide to tackle that work. 

Thanks,
Rick

[1] http://webspherepersistence.blogspot.com/2009/02/openjpa-enhancement.html
[2] http://openjpa.apache.org/entity-enhancement.html","05/Jul/17 06:58;anuradhag30;Hello Team, any resolution to this issue. We are facing similar issue in our project work and looking for a solution.",,,,,,,,,,,,,,,,,,,,,,,,,
Abstract entity causes standard openjpa collection proxies to be injected even if custom collections are used.,OPENJPA-2110,12538690,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,johannes.leimer,johannes.leimer,17/Jan/12 20:04,11/Apr/12 14:27,14/Mar/19 03:03,11/Apr/12 13:42,1.2.2,2.1.1,,,,,,,2.3.0,,,,,kernel,,,,0,"abstract,",collection,custom,project,"proxy,",sample,,"When using an abstract entity, all collections defined in this super class are incorrectly filled in with standard OpenJPA collection implementations. I'd like to have my own collection implementation inside my entities.

E.g.: private Set<Item> items = new MyHashSet<Item>();
should be a specialized collection proxy, but when an abstract entity comes in only the standard OpenJPA collection proxy is used.

I proved this statement by creating two Eclipse sample projects which you can find in the attachments of this ticket. This problem occures in both of the newest version of OpenJPA.
To execute the JUnit test go to src/openjpa/test/FailingTest.java and hit run. You will see an error displayed in the console. To get this test case green only openjpa.model.AbstractCategory has to be ""unabstract"". Just remove ""abstract"" in its class definition.

I hope my informations help you to fix this issue in a reasonable time.",Java SE 1.6,,,,,,,,,,,,,,,,,,17/Jan/12 20:30;johannes.leimer;openjpa.1.2.2.proxybug.zip;https://issues.apache.org/jira/secure/attachment/12510896/openjpa.1.2.2.proxybug.zip,17/Jan/12 20:30;johannes.leimer;openjpa.2.1.1.proxybug.zip;https://issues.apache.org/jira/secure/attachment/12510897/openjpa.2.1.1.proxybug.zip,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-04-11 13:41:56.293,,,no_permission,,,,,,,,,,,,224193,,,Wed Apr 11 14:27:43 UTC 2012,,,,,,,0|i1dv0v:,289123,,,,,,,,"11/Apr/12 13:41;curtisr7;ommitted testcase and code fix to trunk at revision 1324759.

","11/Apr/12 13:42;curtisr7;Johannes -- 

Thanks for the complete testcase! Sorry about taking so long to fix this one. 

Thanks,
Rick","11/Apr/12 14:26;johannes.leimer;Great job Rick.
Thank you for your time.

I think it's good manner to provide a test case. TDD for the win :-)
Anyway, thank you for your acknowledgment.

Kind Regards,
Johannes",11/Apr/12 14:27;johannes.leimer;verified test case,,,,,,,,,,,,,,,,,,,,,,,
ManagedCache conflict due adding an entity 2 times in the same query.,OPENJPA-2107,12538078,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,struberg,struberg,11/Jan/12 17:53,01/Jun/12 17:50,14/Mar/19 03:03,01/Jun/12 17:50,2.0.1,2.1.0,2.2.0,,,,,,1.2.3,2.0.2,2.1.2,2.2.0,,kernel,,,,0,,,,,,,,"I have a complex query which creates the following error:

<openjpa-2.2.0-tiss-2-rexported nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Cannot load object with id ""26301"".  Instance ""at.ac.tuwien.tiss.curriculum.be.entities.DefaultCourse@6e267b76"" with the same id already exists in the L1 cache.  This can occur when you assign an existing id to a new instance, and before flushing attempt to load the existing instance for that id.
FailedObject: at.ac.tuwien.tiss.curriculum.be.entities.DefaultCourse-26301
	at org.apache.openjpa.kernel.ManagedCache.add(ManagedCache.java:126)
	at org.apache.openjpa.kernel.BrokerImpl.setStateManager(BrokerImpl.java:4117)
	at org.apache.openjpa.kernel.StateManagerImpl.initialize(StateManagerImpl.java:391)
	at org.apache.openjpa.kernel.StateManagerImpl.initialize(StateManagerImpl.java:340)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:378)

It seems that this entity gets loaded from the db twice in the same query.

While hitting the problem, the StateManagers have the following _flags:

orig _flags= 602 = 0010 0101 1010 SAVE LOADED READ_LOCKED OID_ASSIGNED FLUSHED  
sm   _flags= 16  = 0000 0001 0000 READ_LOCKED

And it is really only 1 instance which makes this problem. If I set the 'orig' variable to null in the debugger, the test runs fine.",,,,,,,,,,,,,,OPENJPA-2051,,,,,12/Jan/12 16:25;curtisr7;OPENJPA-2107.patch;https://issues.apache.org/jira/secure/attachment/12510384/OPENJPA-2107.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-01-12 16:25:56.69,,,no_permission,,,,,,,,,,,,223584,,,Fri Jan 13 23:02:59 UTC 2012,,,,,,,0|i1dv1j:,289126,,,,,,,,"12/Jan/12 13:04;struberg;I now locally reproduced this with a simple Entity. The problematic pattern is to create an entity instance, em.persist it and do a query containing this new entity in the _same_ transaction! The effect only appears if other entities exists which would be returned by the query.


{code}
em.getTransaction().begin();

Semester sem = new Semester();
sem.setYear(2120);
sem.setSeason(SemesterDTO.Season.S);
em.persist(sem);

Query q = em.createQuery(""select s from Semester as s where s.season=:season"", Semester.class);
q.setParameter(""season"", SemesterDTO.Season.S);
List<Semester> semesters = q.getResultList();
Assert.assertTrue(semesters.size() > 1); <-- this line crashes!
{code}

I'm currently using the following properties in our persistence.xml

            <property name=""openjpa.DynamicEnhancementAgent"" value=""false""/>

            <!-- disable prepared statement caching -->
            <property name=""openjpa.jdbc.QuerySQLCache"" value=""false""/>

            <property name=""openjpa.DataCache"" value=""false""/>

            <property name=""openjpa.Log"" value=""log4j""/>
            <property name=""openjpa.PostLoadOnMerge"" value=""true"" />
            <property name=""openjpa.DetachState"" value=""loaded(DetachedStateField=true)""/>
            <property name=""openjpa.Compatibility"" value=""IgnoreDetachedStateFieldForProxySerialization=true""/>

            <property name=""openjpa.jdbc.MappingDefaults""
                      value=""ForeignKeyDeleteAction=restrict, JoinForeignKeyDeleteAction=restrict""/>

            <!-- use class per table strategy -->
            <property name=""openjpa.Sequence"" value=""class-table(Table=SEQUENCES, Increment=20, InitialValue=10000)""/>

","12/Jan/12 16:25;curtisr7;Mark -

It looks like we put this bug in with OPENJPA-2051. Give this patch a try.

Note, I haven't had time to try to run this patch through the entire test bucket yet.","12/Jan/12 22:09;struberg;Tested and verified. Looks good - txs 4 this quick patch!
Can you please commit it?","12/Jan/12 23:02;curtisr7;I'll need to spend a few more cycles tomorrow to make sure this isn't going to introduce any other problems... if all goes well, I'll get it in tomorrow afternoon.",13/Jan/12 07:47;struberg;Yes. We also must make a unit test which fails before we apply the patch and works afterwards!,13/Jan/12 21:57;curtisr7;This bug was introduced by OPENJPA-2051,"13/Jan/12 23:01;curtisr7;Committed revision 1231375 to trunk.

The root issue is that we only need to reset the Broker flag which indicates if the context has been flushed when we are initializing a new StateManager.

I'm going to leave this issue Open (and assign it to Heath) as it needs to get fixed in 2.0.x and 2.1.x.",13/Jan/12 23:02;curtisr7;Updated fix and affects version.,,,,,,,,,,,,,,,,,,,
Document changes no longer being uploaded,OPENJPA-2105,12537336,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,dianner,dianner,dianner,05/Jan/12 14:55,02/Feb/12 18:04,14/Mar/19 03:03,02/Feb/12 18:03,2.2.0,,,,,,,,2.2.0,,,,,,,,,0,,,,,,,,"Changes to the manual are no longer being uploaded to the web page. OPENJPA-2091 made a change to the directory structure in the openjpa-project pom.xml. As a result, the assembly.xml is no longer finding the documents. A corresponding change needs to be made in the assembly.xml and the update.xml ant files. Also, the web page links need to be changed.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,222844,,,2012-01-05 14:55:41.0,,,,,,,0|i1dv1z:,289128,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BindParameter is not a valid query parameter as processed in DBDictionary's setUnknown(),OPENJPA-2104,12537245,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,04/Jan/12 21:39,05/Jan/12 15:32,14/Mar/19 03:03,05/Jan/12 15:32,2.2.0,,,,,,,,2.2.0,,,,,jdbc,,,,0,,,,,,,,"After introduction of BindParameter, I am getting the following exception:

<error message=""The specified parameter of type ""class org.apache.openjpa.jdbc.sql.BindParameter"" is not a valid query parameter."" type=""org.apache.openjpa.persistence.ArgumentException"">
<openjpa-2.2.0-SNAPSHOT-r422266:1226933 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: The specified parameter of type ""class org.apache.openjpa.jdbc.sql.BindParameter"" is not a valid query parameter.
	at org.apache.openjpa.jdbc.sql.DBDictionary.setUnknown(DBDictionary.java:1458)
	at com.ibm.ws.persistence.pdq.meta.PDQParameterHandler.handleSQLBuffer(PDQParameterHandler.java:59)
	at com.ibm.ws.persistence.pdq.meta.PDQBaseData.update(PDQBaseData.java:239)
	at com.ibm.ws.persistence.pdq.kernel.PDQJDBCStoreQuery.executeUpdate(PDQJDBCStoreQuery.java:61)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeBulkOperation(JDBCStoreQuery.java:577)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreQuery.executeDelete(JDBCStoreQuery.java:491)
	at org.apache.openjpa.kernel.ExpressionStoreQuery$DataStoreExecutor.executeDelete(ExpressionStoreQuery.java:789)
	at org.apache.openjpa.kernel.QueryImpl.delete(QueryImpl.java:1025)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:865)
	at org.apache.openjpa.kernel.QueryImpl.deleteAll(QueryImpl.java:892)
	at org.apache.openjpa.kernel.DelegatingQuery.deleteAll(DelegatingQuery.java:574)
	at org.apache.openjpa.persistence.QueryImpl.executeUpdate(QueryImpl.java:374)

Looks like the setUnknown method needs to recognize the new BindParameter type, like Sized and Calendard:

        if (val instanceof Sized) {
            sized = (Sized) val;
            val = sized.value;
        } else if (val instanceof Calendard) {
            cald = (Calendard) val;
            val = cald.value;
        }

and extract its actual value before call out to the setters.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,222754,,,2012-01-04 21:39:33.0,,,,,,,0|i1dv27:,289129,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
URLs which contains spaces are not properly handled by OpenJPA.,OPENJPA-2102,12536471,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jpaheath,jpaheath,jpaheath,28/Dec/11 04:57,21/Sep/16 14:38,14/Mar/19 03:03,31/May/12 13:48,2.0.1,2.1.2,2.2.0,,,,,,2.1.2,2.3.0,,,,,,,,0,,,,,,,,"Take the following lines of code in AbstractCFMetaDataFactory:

if (puUrlString != null && urlString.indexOf(puUrlString) != -1)
    urls.add(url);

When either 'urlString' of puUrlString is encoded, and the other is not, the 'indexOf' will fail even if the URLs are the same if both are either encoded or decoded.  Let me explain:
The 'urlString' is effectively obtained from the ClassLoader, and the puUrlString is obtained from the OpenJPA configuration.  If the user's URL path contains spaces in it (' '), the URL may be encoded with '%20' (see the URL and URI javadoc).  The Classloader is likely to return encoded URLs.  However, given that the two URLs come from different places, it is not guaranteed that both URLs will be encoded.  If one URL is encoded (e.g. encoded with a %20 for spaces) and the other URL is not encoded (e.g. the URL contains spaces), the above 'indexOf' will fail even though technically the two URLs may ultimately represent the same location when both are encoded (or decoded).  When the 'indexOf' fails the URL is not added to the list of URLs to process which has downstream effects in that necessary meta data is missing.  For example, in the issue I'm working I saw the following exception due to missing meta data:

Caused by: org.apache.openjpa.persistence.ArgumentException: Type       
""class testcases.res.ejb.subscriber.SubscriberBehavior"" loaded by       
com.xxx.xx.classloader.CompoundClassLoader@221e275[appwar:RES Test      
Subscriber]                                                             
   Local ClassPath: .......                         
   Parent: com.xxx.xx.classloader.ProtectionClassLoader@47d3d6          
   does not have persistence metadata.     
 at org.apache.openjpa.jdbc.meta.MappingTool.getMapping(MappingTool.java:687)                                                               
 at org.apache.openjpa.jdbc.meta.MappingTool.buildSchema(MappingTool.java:753)                                                               
 at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:651)  
 at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:154)                                            
 at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:164)                                            
 at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:122)                                            
 at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:210)                                        
 at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:156)                                      
 at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:227)                  


Thanks,

Heath Thomann",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,222154,,,2011-12-28 04:57:17.0,,,,,,,0|i1dv2n:,289131,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PersistenceProductDerivation overwrites the RemoteCommitProvider configuration,OPENJPA-2101,12536421,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,paquilino,paquilino,27/Dec/11 15:05,02/Feb/12 17:19,14/Mar/19 03:03,05/Jan/12 14:33,2.1.1,2.2.0,,,,,,,2.2.0,,,,,kernel,,,,0,,,,,,,,"If you set the property openjpa.RemoteCommitProvider to a value distinct from the default (for example ""tcp"" or ""jms""), this value is overwritted with the default ""sjvm"".

PersistenceProductDerivation uses a incorrect conditional to check if the value is empty. In this code:

               // If the datacache is enabled, make sure we have a RemoteCommitProvider
               String dc = oconf.getDataCache();
               String rcp = oconf.getRemoteCommitProvider();
               // If the datacache is set and is something other than false
               if (dc != null && dc.equals(""false"") == false) {
                   // If RCP is null or empty, set it to sjvm.
                   if (rcp == null || (rcp != null && rcp.equals("""") == false)) {
                       oconf.setRemoteCommitProvider(""sjvm"");
                   }
               }

The last conditional must be

if (rcp == null || (rcp != null && rcp.equals(""""))) {
",,7200,7200,,0%,7200,7200,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-01-05 14:33:59.311,,,no_permission,,,,,,,,,,,,222104,,,Thu Feb 02 17:19:00 UTC 2012,,,,,,,0|i1dv2v:,289132,,,,,,,,05/Jan/12 14:33;curtisr7;Pinaki committed revision 1224948 to trunk to resolve this issue.,02/Feb/12 17:19;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,,
openjpa-maven-plugin fails to create SQL for entities which contain enums,OPENJPA-2100,12536413,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,struberg,struberg,27/Dec/11 10:31,02/Feb/12 17:22,14/Mar/19 03:03,27/Dec/11 11:16,2.2.0,,,,,,,,2.2.0,,,,,build / infrastructure,,,,0,,,,,,,,"This bug seems to have been introduced while cleaning up some openjpa-maven-plugin compiler warnings in r1091279 / OPENJPA-1934.

When you try to invoke the MappingTool with mvn openjpa:sql you will get the following failure:

[ERROR] Failed to execute goal org.apache.openjpa:openjpa-maven-plugin:2.2.0-SNAPSHOT:sql (mappingtool) on project enhance: Execution mappingtool of goal org.apache.openjpa:openjpa-maven-plugin:2.2.0-SNAPSHOT:sql failed: Type ""class org.apache.openjpa.tools.maven.testentity.TestEntity$SampleEnum"" loaded by java.net.URLClassLoader@49c1e1e7 does not have persistence metadata. -> [Help 1]
org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.openjpa:openjpa-maven-plugin:2.2.0-SNAPSHOT:sql (mappingtool) on project enhance: Execution mappingtool of goal org.apache.openjpa:openjpa-maven-plugin:2.2.0-SNAPSHOT:sql failed: Type ""class org.apache.openjpa.tools.maven.testentity.TestEntity$SampleEnum"" loaded by java.net.URLClassLoader@49c1e1e7 does not have persistence metadata.
...
Caused by: <openjpa-2.2.0-tiss-1-r422266:1213958M fatal user error> org.apache.openjpa.util.MetaDataException: Type ""class at.ac.tuwien.tiss.mobility.be.common.entities.Deadline$Type"" loaded by java.net.URLClassLoader@5054c2b8 does not have persistence metadata.
	at org.apache.openjpa.jdbc.meta.MappingTool.getMapping(MappingTool.java:688)
	at org.apache.openjpa.jdbc.meta.MappingTool.buildSchema(MappingTool.java:754)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-02-02 17:22:58.064,,,no_permission,,,,,,,,,,,,222096,,,Thu Feb 02 17:22:58 UTC 2012,,,,,,,0|i1dv33:,289133,,,,,,,,"27/Dec/11 10:38;struberg;found the bug. The reason was that the iterator.remove() got dropped, thus the whole  AbstractOpenJpaMappingToolMojo#filterPersistenceCapable was useless now.   
See the JavaDoc comment why this is necessary:

/*
 * Filter out all classes which are not PersistenceCapable.
 * This is needed since the MappingTool fails if it gets non-persistent capable classes.
 */",27/Dec/11 11:16;struberg;fixed in r1224894.,02/Feb/12 17:22;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,
GRAVE: Unable to inject field : [protected javax.persistence.EntityManager,OPENJPA-2097,12535862,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,esteveavi,esteveavi,20/Dec/11 16:07,20/Dec/11 16:22,14/Mar/19 03:03,20/Dec/11 16:22,2.1.1,,,,,,,,,,,,,jpa,,,,0,jpa,,,,,,,"GRAVE: Unable to inject field : [protected javax.persistence.EntityManager org.apache.webbeans.jsf2.TestDao.em]
javax.persistence.PersistenceException: Explicit persistence provider error(s) occurred for ""myDataBase"" after trying the following discovered implementations: org.apache.openjpa.persistence.PersistenceProvi
derImpl from provider: org.apache.openjpa.persistence.PersistenceProviderImpl
        at javax.persistence.Persistence.createPersistenceException(Persistence.java:244)
        at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:186)
        at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:72)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceProcessor.getPersistenceUnit(StandaloneResourceProcessor.java:140)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceProcessor.getPersistenceContext(StandaloneResourceProcessor.java:153)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceProcessor.getEntityManager(StandaloneResourceProcessor.java:69)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceInjectionService.getResourceReference(StandaloneResourceInjectionService.java:96)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceInjectionService.injectJavaEEResources(StandaloneResourceInjectionService.java:140)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectResources(AbstractInjectionTargetBean.java:432)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.createDefaultInstance(AbstractInjectionTargetBean.java:144)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.createInstance(AbstractInjectionTargetBean.java:114)
        at org.apache.webbeans.component.AbstractOwbBean.createNewInstance(AbstractOwbBean.java:234)
        at org.apache.webbeans.portable.creation.AbstractProducer.produce(AbstractProducer.java:79)
        at org.apache.webbeans.component.InjectionTargetWrapper.produce(InjectionTargetWrapper.java:139)
        at org.apache.webbeans.component.AbstractOwbBean.create(AbstractOwbBean.java:181)
        at org.apache.webbeans.context.DependentContext.getInstance(DependentContext.java:69)
        at org.apache.webbeans.context.AbstractContext.get(AbstractContext.java:190)
        at org.apache.webbeans.container.BeanManagerImpl.getReference(BeanManagerImpl.java:953)
        at org.apache.webbeans.container.BeanManagerImpl.getInjectableReference(BeanManagerImpl.java:834)
        at org.apache.webbeans.inject.AbstractInjectable.inject(AbstractInjectable.java:133)
        at org.apache.webbeans.inject.InjectableField.doInjection(InjectableField.java:59)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectField(AbstractInjectionTargetBean.java:384)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectFields(AbstractInjectionTargetBean.java:321)
        at org.apache.webbeans.portable.creation.InjectionTargetProducer.inject(InjectionTargetProducer.java:94)
        at org.apache.webbeans.component.InjectionTargetWrapper.inject(InjectionTargetWrapper.java:79)
        at org.apache.webbeans.component.AbstractOwbBean.create(AbstractOwbBean.java:182)
        at org.apache.webbeans.context.DependentContext.getInstance(DependentContext.java:69)
        at org.apache.webbeans.context.AbstractContext.get(AbstractContext.java:190)
        at org.apache.webbeans.container.BeanManagerImpl.getReference(BeanManagerImpl.java:953)
        at org.apache.webbeans.container.BeanManagerImpl.getInjectableReference(BeanManagerImpl.java:834)
        at org.apache.webbeans.inject.AbstractInjectable.inject(AbstractInjectable.java:133)
        at org.apache.webbeans.inject.InjectableField.doInjection(InjectableField.java:59)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectField(AbstractInjectionTargetBean.java:384)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectFields(AbstractInjectionTargetBean.java:321)
        at org.apache.webbeans.portable.creation.InjectionTargetProducer.inject(InjectionTargetProducer.java:94)
        at org.apache.webbeans.component.InjectionTargetWrapper.inject(InjectionTargetWrapper.java:79)
        at org.apache.webbeans.component.AbstractOwbBean.create(AbstractOwbBean.java:182)
        at org.apache.webbeans.context.creational.BeanInstanceBag.create(BeanInstanceBag.java:80)
        at org.apache.webbeans.context.AbstractContext.getInstance(AbstractContext.java:225)
        at org.apache.webbeans.context.AbstractContext.get(AbstractContext.java:190)
        at org.apache.webbeans.intercept.NormalScopedBeanInterceptorHandler.getContextualInstance(NormalScopedBeanInterceptorHandler.java:159)
        at org.apache.webbeans.intercept.NormalScopedBeanInterceptorHandler.invoke(NormalScopedBeanInterceptorHandler.java:119)
        at org.apache.webbeans.jsf2.TestBean_$$_javassist_28.getComment(TestBean_$$_javassist_28.java)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at javax.el.BeanELResolver.getValue(BeanELResolver.java:305)
        at javax.el.CompositeELResolver.getValue(CompositeELResolver.java:188)
        at org.apache.myfaces.el.unified.resolver.FacesCompositeELResolver.getValue(FacesCompositeELResolver.java:142)
        at com.sun.el.parser.AstValue.getValue(AstValue.java:120)
        at com.sun.el.parser.AstValue.getValue(AstValue.java:167)
        at com.sun.el.ValueExpressionImpl.getValue(ValueExpressionImpl.java:224)
        at org.apache.webbeans.el10.EL10ValueExpression.getValue(EL10ValueExpression.java:59)
        at org.apache.myfaces.view.facelets.el.TagValueExpression.getValue(TagValueExpression.java:85)
        at javax.faces.component._DeltaStateHelper.eval(_DeltaStateHelper.java:243)
        at javax.faces.component.UIOutput.getValue(UIOutput.java:71)
        at org.apache.myfaces.shared_impl.renderkit.RendererUtils.getValue(RendererUtils.java:343)
        at org.apache.myfaces.shared_impl.renderkit.RendererUtils.getStringValue(RendererUtils.java:295)
        at org.apache.myfaces.shared_impl.renderkit.html.HtmlTextRendererBase.renderOutput(HtmlTextRendererBase.java:92)
        at org.apache.myfaces.shared_impl.renderkit.html.HtmlTextRendererBase.encodeEnd(HtmlTextRendererBase.java:79)
        at javax.faces.component.UIComponentBase.encodeEnd(UIComponentBase.java:519)
        at javax.faces.component.UIComponent.encodeAll(UIComponent.java:628)
        at javax.faces.component.UIComponent.encodeAll(UIComponent.java:624)
        at javax.faces.component.UIComponent.encodeAll(UIComponent.java:624)
        at javax.faces.component.UIComponent.encodeAll(UIComponent.java:624)
        at org.apache.myfaces.view.facelets.FaceletViewDeclarationLanguage.renderView(FaceletViewDeclarationLanguage.java:1329)
        at org.apache.myfaces.application.ViewHandlerImpl.renderView(ViewHandlerImpl.java:264)
        at javax.faces.application.ViewHandlerWrapper.renderView(ViewHandlerWrapper.java:59)
        at javax.faces.application.ViewHandlerWrapper.renderView(ViewHandlerWrapper.java:59)
        at org.apache.myfaces.lifecycle.RenderResponseExecutor.execute(RenderResponseExecutor.java:85)
        at org.apache.myfaces.lifecycle.LifecycleImpl.render(LifecycleImpl.java:239)
        at org.apache.myfaces.extensions.cdi.jsf2.impl.listener.phase.CodiLifecycleWrapper.render(CodiLifecycleWrapper.java:126)
        at javax.faces.webapp.FacesServlet.service(FacesServlet.java:191)
        at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:575)
        at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:488)
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:119)
        at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:483)
        at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:233)
        at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1061)
        at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:417)
        at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:192)
        at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:995)
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:117)
        at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:250)
        at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:149)
        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:111)
        at org.eclipse.jetty.server.Server.handle(Server.java:350)
        at org.eclipse.jetty.server.AbstractHttpConnection.handleRequest(AbstractHttpConnection.java:431)
        at org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler.headerComplete(AbstractHttpConnection.java:896)
        at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:647)
        at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:233)
        at org.eclipse.jetty.server.AsyncHttpConnection.handle(AsyncHttpConnection.java:68)
        at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:609)
        at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:45)
        at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:598)
        at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:533)
        at java.lang.Thread.run(Thread.java:619)
Caused by: <openjpa-2.1.1-r422266:1148538 fatal user error> org.apache.openjpa.persistence.ArgumentException: Could not invoke the static newInstance method on the named factory class ""org.apache.openjpa.jdb
c.kernel.JDBCBrokerFactory"".
        at org.apache.openjpa.kernel.Bootstrap.newBrokerFactory(Bootstrap.java:76)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.getBrokerFactory(PersistenceProviderImpl.java:151)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:95)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:157)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:66)
        at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:152)
        ... 96 more
Caused by: <openjpa-2.1.1-r422266:1148538 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: This configuration disallows runtime optimization, but the following listed types were not enh
anced at build time or at class load time with a javaagent: ""
org.apache.webbeans.jsf2.Test"".
        at org.apache.openjpa.enhance.ManagedClassSubclasser.prepareUnenhancedClasses(ManagedClassSubclasser.java:116)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.loadPersistentTypes(AbstractBrokerFactory.java:315)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.initializeBroker(AbstractBrokerFactory.java:239)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:213)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:186)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.postCreationCallback(AbstractBrokerFactory.java:855)
        at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.postCreationCallback(JDBCBrokerFactory.java:105)
        at org.apache.openjpa.kernel.Bootstrap.newBrokerFactory(Bootstrap.java:67)
        ... 101 more
20-dic-2011 17:02:15 org.apache.webbeans.component.ManagedBean injectResources
GRAVE: An error occured while injecting Java EE Resources for the bean instance : [org.apache.webbeans.jsf2.TestDao@1c94b51]
20-dic-2011 17:02:15 org.apache.myfaces.view.facelets.FaceletViewDeclarationLanguage handleRenderException
GRAVE: Error Rendering View[/test.xhtml]
javax.faces.FacesException: Could not retrieve value of component with path : {Component-Path : [Class: javax.faces.component.UIViewRoot,ViewId: /test.xhtml][Class: javax.faces.component.html.HtmlBody,Id: j_
id2114509110_7e08d902][Class: javax.faces.component.html.HtmlForm,Id: form][Class: javax.faces.component.html.HtmlOutputText,Id: j_id2114509110_7e08d943]}
        at org.apache.myfaces.shared_impl.renderkit.RendererUtils.getValue(RendererUtils.java:347)
        at org.apache.myfaces.shared_impl.renderkit.RendererUtils.getStringValue(RendererUtils.java:295)
        at org.apache.myfaces.shared_impl.renderkit.html.HtmlTextRendererBase.renderOutput(HtmlTextRendererBase.java:92)
        at org.apache.myfaces.shared_impl.renderkit.html.HtmlTextRendererBase.encodeEnd(HtmlTextRendererBase.java:79)
        at javax.faces.component.UIComponentBase.encodeEnd(UIComponentBase.java:519)
        at javax.faces.component.UIComponent.encodeAll(UIComponent.java:628)
        at javax.faces.component.UIComponent.encodeAll(UIComponent.java:624)
        at javax.faces.component.UIComponent.encodeAll(UIComponent.java:624)
        at javax.faces.component.UIComponent.encodeAll(UIComponent.java:624)
        at org.apache.myfaces.view.facelets.FaceletViewDeclarationLanguage.renderView(FaceletViewDeclarationLanguage.java:1329)
        at org.apache.myfaces.application.ViewHandlerImpl.renderView(ViewHandlerImpl.java:264)
        at javax.faces.application.ViewHandlerWrapper.renderView(ViewHandlerWrapper.java:59)
        at javax.faces.application.ViewHandlerWrapper.renderView(ViewHandlerWrapper.java:59)
        at org.apache.myfaces.lifecycle.RenderResponseExecutor.execute(RenderResponseExecutor.java:85)
        at org.apache.myfaces.lifecycle.LifecycleImpl.render(LifecycleImpl.java:239)
        at org.apache.myfaces.extensions.cdi.jsf2.impl.listener.phase.CodiLifecycleWrapper.render(CodiLifecycleWrapper.java:126)
        at javax.faces.webapp.FacesServlet.service(FacesServlet.java:191)
        at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:575)
        at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:488)
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:119)
        at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:483)
        at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:233)
        at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1061)
        at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:417)
        at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:192)
        at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:995)
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:117)
        at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:250)
        at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:149)
        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:111)
        at org.eclipse.jetty.server.Server.handle(Server.java:350)
        at org.eclipse.jetty.server.AbstractHttpConnection.handleRequest(AbstractHttpConnection.java:431)
        at org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler.headerComplete(AbstractHttpConnection.java:896)
        at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:647)
        at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:233)
        at org.eclipse.jetty.server.AsyncHttpConnection.handle(AsyncHttpConnection.java:68)
        at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:609)
        at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:45)
        at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:598)
        at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:533)
        at java.lang.Thread.run(Thread.java:619)
Caused by: javax.el.ELException: /test.xhtml at line 30 and column 47 value=""#{testBean.comment}"": <openjpa-2.1.1-r422266:1148538 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: This c
onfiguration disallows runtime optimization, but the following listed types were not enhanced at build time or at class load time with a javaagent: ""
org.apache.webbeans.jsf2.Test"".
        at org.apache.myfaces.view.facelets.el.TagValueExpression.getValue(TagValueExpression.java:93)
        at javax.faces.component._DeltaStateHelper.eval(_DeltaStateHelper.java:243)
        at javax.faces.component.UIOutput.getValue(UIOutput.java:71)
        at org.apache.myfaces.shared_impl.renderkit.RendererUtils.getValue(RendererUtils.java:343)
        ... 40 more
Caused by: <openjpa-2.1.1-r422266:1148538 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: This configuration disallows runtime optimization, but the following listed types were not enh
anced at build time or at class load time with a javaagent: ""
org.apache.webbeans.jsf2.Test"".
        at org.apache.openjpa.enhance.ManagedClassSubclasser.prepareUnenhancedClasses(ManagedClassSubclasser.java:116)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.loadPersistentTypes(AbstractBrokerFactory.java:315)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.initializeBroker(AbstractBrokerFactory.java:239)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:213)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:186)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.postCreationCallback(AbstractBrokerFactory.java:855)
        at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.postCreationCallback(JDBCBrokerFactory.java:105)
        at org.apache.openjpa.kernel.Bootstrap.newBrokerFactory(Bootstrap.java:67)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.getBrokerFactory(PersistenceProviderImpl.java:151)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:95)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:157)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:66)
        at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:152)
        at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:72)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceProcessor.getPersistenceUnit(StandaloneResourceProcessor.java:140)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceProcessor.getPersistenceContext(StandaloneResourceProcessor.java:153)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceProcessor.getEntityManager(StandaloneResourceProcessor.java:69)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceInjectionService.getResourceReference(StandaloneResourceInjectionService.java:96)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceInjectionService.injectJavaEEResources(StandaloneResourceInjectionService.java:140)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectResources(AbstractInjectionTargetBean.java:432)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.createDefaultInstance(AbstractInjectionTargetBean.java:144)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.createInstance(AbstractInjectionTargetBean.java:114)
        at org.apache.webbeans.component.AbstractOwbBean.createNewInstance(AbstractOwbBean.java:234)
        at org.apache.webbeans.portable.creation.AbstractProducer.produce(AbstractProducer.java:79)
        at org.apache.webbeans.component.InjectionTargetWrapper.produce(InjectionTargetWrapper.java:139)
        at org.apache.webbeans.component.AbstractOwbBean.create(AbstractOwbBean.java:181)
        at org.apache.webbeans.context.DependentContext.getInstance(DependentContext.java:69)
        at org.apache.webbeans.context.AbstractContext.get(AbstractContext.java:190)
        at org.apache.webbeans.container.BeanManagerImpl.getReference(BeanManagerImpl.java:953)
        at org.apache.webbeans.container.BeanManagerImpl.getInjectableReference(BeanManagerImpl.java:834)
        at org.apache.webbeans.inject.AbstractInjectable.inject(AbstractInjectable.java:133)
        at org.apache.webbeans.inject.InjectableField.doInjection(InjectableField.java:59)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectField(AbstractInjectionTargetBean.java:384)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectFields(AbstractInjectionTargetBean.java:321)
        at org.apache.webbeans.portable.creation.InjectionTargetProducer.inject(InjectionTargetProducer.java:94)
        at org.apache.webbeans.component.InjectionTargetWrapper.inject(InjectionTargetWrapper.java:79)
        at org.apache.webbeans.component.AbstractOwbBean.create(AbstractOwbBean.java:182)
        at org.apache.webbeans.context.DependentContext.getInstance(DependentContext.java:69)
        at org.apache.webbeans.context.AbstractContext.get(AbstractContext.java:190)
        at org.apache.webbeans.container.BeanManagerImpl.getReference(BeanManagerImpl.java:953)
        at org.apache.webbeans.container.BeanManagerImpl.getInjectableReference(BeanManagerImpl.java:834)
        at org.apache.webbeans.inject.AbstractInjectable.inject(AbstractInjectable.java:133)
        at org.apache.webbeans.inject.InjectableField.doInjection(InjectableField.java:59)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectField(AbstractInjectionTargetBean.java:384)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectFields(AbstractInjectionTargetBean.java:321)
        at org.apache.webbeans.portable.creation.InjectionTargetProducer.inject(InjectionTargetProducer.java:94)
        at org.apache.webbeans.component.InjectionTargetWrapper.inject(InjectionTargetWrapper.java:79)
        at org.apache.webbeans.component.AbstractOwbBean.create(AbstractOwbBean.java:182)
        at org.apache.webbeans.context.creational.BeanInstanceBag.create(BeanInstanceBag.java:80)
        at org.apache.webbeans.context.AbstractContext.getInstance(AbstractContext.java:225)
        at org.apache.webbeans.context.AbstractContext.get(AbstractContext.java:190)
        at org.apache.webbeans.intercept.NormalScopedBeanInterceptorHandler.getContextualInstance(NormalScopedBeanInterceptorHandler.java:159)
        at org.apache.webbeans.intercept.NormalScopedBeanInterceptorHandler.invoke(NormalScopedBeanInterceptorHandler.java:119)
        at org.apache.webbeans.jsf2.TestBean_$$_javassist_28.getComment(TestBean_$$_javassist_28.java)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at javax.el.BeanELResolver.getValue(BeanELResolver.java:305)
        at javax.el.CompositeELResolver.getValue(CompositeELResolver.java:188)
        at org.apache.myfaces.el.unified.resolver.FacesCompositeELResolver.getValue(FacesCompositeELResolver.java:142)
        at com.sun.el.parser.AstValue.getValue(AstValue.java:120)
        at com.sun.el.parser.AstValue.getValue(AstValue.java:167)
        at com.sun.el.ValueExpressionImpl.getValue(ValueExpressionImpl.java:224)
        at org.apache.webbeans.el10.EL10ValueExpression.getValue(EL10ValueExpression.java:59)
        at org.apache.myfaces.view.facelets.el.TagValueExpression.getValue(TagValueExpression.java:85)
        ... 43 more
20-dic-2011 17:02:15 org.apache.myfaces.renderkit.ErrorPageWriter handleThrowable
GRAVE: An exception occurred
javax.faces.FacesException: <openjpa-2.1.1-r422266:1148538 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: This configuration disallows runtime optimization, but the following listed t
ypes were not enhanced at build time or at class load time with a javaagent: ""
org.apache.webbeans.jsf2.Test"".
        at org.apache.myfaces.shared_impl.context.ExceptionHandlerImpl.wrap(ExceptionHandlerImpl.java:241)
        at org.apache.myfaces.shared_impl.context.ExceptionHandlerImpl.handle(ExceptionHandlerImpl.java:156)
        at org.apache.myfaces.lifecycle.LifecycleImpl.render(LifecycleImpl.java:258)
        at org.apache.myfaces.extensions.cdi.jsf2.impl.listener.phase.CodiLifecycleWrapper.render(CodiLifecycleWrapper.java:126)
        at javax.faces.webapp.FacesServlet.service(FacesServlet.java:191)
        at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:575)
        at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:488)
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:119)
        at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:483)
        at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:233)
        at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1061)
        at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:417)
        at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:192)
        at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:995)
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:117)
        at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:250)
        at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:149)
        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:111)
        at org.eclipse.jetty.server.Server.handle(Server.java:350)
        at org.eclipse.jetty.server.AbstractHttpConnection.handleRequest(AbstractHttpConnection.java:431)
        at org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler.headerComplete(AbstractHttpConnection.java:896)
        at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:647)
        at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:233)
        at org.eclipse.jetty.server.AsyncHttpConnection.handle(AsyncHttpConnection.java:68)
        at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:609)
        at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:45)
        at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:598)
        at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:533)
        at java.lang.Thread.run(Thread.java:619)
Caused by: <openjpa-2.1.1-r422266:1148538 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: This configuration disallows runtime optimization, but the following listed types were not enh
anced at build time or at class load time with a javaagent: ""
org.apache.webbeans.jsf2.Test"".
        at org.apache.openjpa.enhance.ManagedClassSubclasser.prepareUnenhancedClasses(ManagedClassSubclasser.java:116)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.loadPersistentTypes(AbstractBrokerFactory.java:315)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.initializeBroker(AbstractBrokerFactory.java:239)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:213)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:186)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.postCreationCallback(AbstractBrokerFactory.java:855)
        at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.postCreationCallback(JDBCBrokerFactory.java:105)
        at org.apache.openjpa.kernel.Bootstrap.newBrokerFactory(Bootstrap.java:67)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.getBrokerFactory(PersistenceProviderImpl.java:151)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:95)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:157)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:66)
        at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:152)
        at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:72)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceProcessor.getPersistenceUnit(StandaloneResourceProcessor.java:140)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceProcessor.getPersistenceContext(StandaloneResourceProcessor.java:153)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceProcessor.getEntityManager(StandaloneResourceProcessor.java:69)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceInjectionService.getResourceReference(StandaloneResourceInjectionService.java:96)
        at org.apache.webbeans.resource.spi.se.StandaloneResourceInjectionService.injectJavaEEResources(StandaloneResourceInjectionService.java:140)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectResources(AbstractInjectionTargetBean.java:432)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.createDefaultInstance(AbstractInjectionTargetBean.java:144)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.createInstance(AbstractInjectionTargetBean.java:114)
        at org.apache.webbeans.component.AbstractOwbBean.createNewInstance(AbstractOwbBean.java:234)
        at org.apache.webbeans.portable.creation.AbstractProducer.produce(AbstractProducer.java:79)
        at org.apache.webbeans.component.InjectionTargetWrapper.produce(InjectionTargetWrapper.java:139)
        at org.apache.webbeans.component.AbstractOwbBean.create(AbstractOwbBean.java:181)
        at org.apache.webbeans.context.DependentContext.getInstance(DependentContext.java:69)
        at org.apache.webbeans.context.AbstractContext.get(AbstractContext.java:190)
        at org.apache.webbeans.container.BeanManagerImpl.getReference(BeanManagerImpl.java:953)
        at org.apache.webbeans.container.BeanManagerImpl.getInjectableReference(BeanManagerImpl.java:834)
        at org.apache.webbeans.inject.AbstractInjectable.inject(AbstractInjectable.java:133)
        at org.apache.webbeans.inject.InjectableField.doInjection(InjectableField.java:59)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectField(AbstractInjectionTargetBean.java:384)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectFields(AbstractInjectionTargetBean.java:321)
        at org.apache.webbeans.portable.creation.InjectionTargetProducer.inject(InjectionTargetProducer.java:94)
        at org.apache.webbeans.component.InjectionTargetWrapper.inject(InjectionTargetWrapper.java:79)
        at org.apache.webbeans.component.AbstractOwbBean.create(AbstractOwbBean.java:182)
        at org.apache.webbeans.context.DependentContext.getInstance(DependentContext.java:69)
        at org.apache.webbeans.context.AbstractContext.get(AbstractContext.java:190)
        at org.apache.webbeans.container.BeanManagerImpl.getReference(BeanManagerImpl.java:953)
        at org.apache.webbeans.container.BeanManagerImpl.getInjectableReference(BeanManagerImpl.java:834)
        at org.apache.webbeans.inject.AbstractInjectable.inject(AbstractInjectable.java:133)
        at org.apache.webbeans.inject.InjectableField.doInjection(InjectableField.java:59)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectField(AbstractInjectionTargetBean.java:384)
        at org.apache.webbeans.component.AbstractInjectionTargetBean.injectFields(AbstractInjectionTargetBean.java:321)
        at org.apache.webbeans.portable.creation.InjectionTargetProducer.inject(InjectionTargetProducer.java:94)
        at org.apache.webbeans.component.InjectionTargetWrapper.inject(InjectionTargetWrapper.java:79)
        at org.apache.webbeans.component.AbstractOwbBean.create(AbstractOwbBean.java:182)
        at org.apache.webbeans.context.creational.BeanInstanceBag.create(BeanInstanceBag.java:80)
        at org.apache.webbeans.context.AbstractContext.getInstance(AbstractContext.java:225)
        at org.apache.webbeans.context.AbstractContext.get(AbstractContext.java:190)
        at org.apache.webbeans.intercept.NormalScopedBeanInterceptorHandler.getContextualInstance(NormalScopedBeanInterceptorHandler.java:159)
        at org.apache.webbeans.intercept.NormalScopedBeanInterceptorHandler.invoke(NormalScopedBeanInterceptorHandler.java:119)
        at org.apache.webbeans.jsf2.TestBean_$$_javassist_28.getComment(TestBean_$$_javassist_28.java)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at javax.el.BeanELResolver.getValue(BeanELResolver.java:305)
        at javax.el.CompositeELResolver.getValue(CompositeELResolver.java:188)
        at org.apache.myfaces.el.unified.resolver.FacesCompositeELResolver.getValue(FacesCompositeELResolver.java:142)
        at com.sun.el.parser.AstValue.getValue(AstValue.java:120)
        at com.sun.el.parser.AstValue.getValue(AstValue.java:167)
        at com.sun.el.ValueExpressionImpl.getValue(ValueExpressionImpl.java:224)
        at org.apache.webbeans.el10.EL10ValueExpression.getValue(EL10ValueExpression.java:59)
        at org.apache.myfaces.view.facelets.el.TagValueExpression.getValue(TagValueExpression.java:85)
        at javax.faces.component._DeltaStateHelper.eval(_DeltaStateHelper.java:243)
        at javax.faces.component.UIOutput.getValue(UIOutput.java:71)
        at org.apache.myfaces.shared_impl.renderkit.RendererUtils.getValue(RendererUtils.java:343)
        at org.apache.myfaces.shared_impl.renderkit.RendererUtils.getStringValue(RendererUtils.java:295)
        at org.apache.myfaces.shared_impl.renderkit.html.HtmlTextRendererBase.renderOutput(HtmlTextRendererBase.java:92)
        at org.apache.myfaces.shared_impl.renderkit.html.HtmlTextRendererBase.encodeEnd(HtmlTextRendererBase.java:79)
        at javax.faces.component.UIComponentBase.encodeEnd(UIComponentBase.java:519)
        at javax.faces.component.UIComponent.encodeAll(UIComponent.java:628)
        at javax.faces.component.UIComponent.encodeAll(UIComponent.java:624)
        at javax.faces.component.UIComponent.encodeAll(UIComponent.java:624)
        at javax.faces.component.UIComponent.encodeAll(UIComponent.java:624)
        at org.apache.myfaces.view.facelets.FaceletViewDeclarationLanguage.renderView(FaceletViewDeclarationLanguage.java:1329)
        at org.apache.myfaces.application.ViewHandlerImpl.renderView(ViewHandlerImpl.java:264)
        at javax.faces.application.ViewHandlerWrapper.renderView(ViewHandlerWrapper.java:59)
        at javax.faces.application.ViewHandlerWrapper.renderView(ViewHandlerWrapper.java:59)
        at org.apache.myfaces.lifecycle.RenderResponseExecutor.execute(RenderResponseExecutor.java:85)
        at org.apache.myfaces.lifecycle.LifecycleImpl.render(LifecycleImpl.java:239)
        ... 26 more
","Jetty 8 and Tomcat 7
JPA 2.1.1
CODI 1.0.3
OpenWebBeans 1.1.3
MyFaces Last",,,,,,,,,,,,,,,,,,20/Dec/11 16:13;esteveavi;owb.rar;https://issues.apache.org/jira/secure/attachment/12508095/owb.rar,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-12-20 16:22:21.542,,,no_permission,,,,,,,,,,,,221545,,,Tue Dec 20 16:22:21 UTC 2011,,,,,,,0|i1dv3j:,289135,,,,,,,,20/Dec/11 16:13;esteveavi;Project example,"20/Dec/11 16:22;curtisr7;As the Exception states, you didn't enhance your Entities. Please review the following link[1] detailing how to run the enhancer.

I'm closing this JIRA as there is no bug here. If you have additional questions, please utilize the users mailing list[2].

[ but the following listed types were not enhanced at build time or at class load time with a javaagent: ""org.apache.webbeans.jsf2.Test"". ]

[1] http://openjpa.apache.org/entity-enhancement.html
[2] http://openjpa.apache.org/mailing-lists.html",,,,,,,,,,,,,,,,,,,,,,,,,
Unhandled exception thrown from within an Externalizer method causes incorrect/incomplete SQL to be generated/executed.,OPENJPA-2095,12535520,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jpaheath,jpaheath,jpaheath,16/Dec/11 22:22,02/May/13 02:29,14/Mar/19 03:03,01/Jun/12 16:07,1.2.3,2.0.2,2.1.2,2.2.0,,,,,1.2.3,2.0.2,2.1.2,2.2.1,2.3.0,sql,,,,0,,,,,,,,"I've re-created an issue with Externalizers.  That is, when the Externalizer method (i.e. the method listed in the @Externalizer) causes/throws an exception, OpenJPA generates, and executes, incorrect/incomplete SQL.  To better explain, let me describe some test code snippets which are from the test I'll provide.  First, take this entity:

@Entity
public class TestItem implements Serializable {
.....
	@org.apache.openjpa.persistence.Persistent
	@org.apache.openjpa.persistence.Externalizer(""check"")
	private TestExternal ext;


And take the following class TestExternal:

public static class TestExternal {
.....
	public String check() throws Exception {
		throw new PersistenceException(""test exception externalizer"");



With this code, lets look at the case where we persist a new TestItem, and the case where we update an existing one.  When we create a new TestItem and persist it, OpenJPA generates and executes the following SQL:

INSERT INTO TESTITEM (data) VALUES (?)

However, this SQL should be generated:

INSERT INTO TESTITEM (iref, data, ext, name) VALUES (?, ?, ?, ?)

When we update an existing TestItem, OpenJPA generates, and executes, the following SQL:

UPDATE TESTITEM SET data = ?

However, this SQL should be generated:

UPDATE TESTITEM SET data = ? WHERE iref = ?

Because an unhandled exception is thrown by the Externalizer method, the transaction will be rolled back.  However, if the SQL were to actually commit, every row in TestItem would be updated with the value in 'data'.  Furthermore, in the case where there are hundreds/thousands of rows in the DB, the execution of the SQL may take a long time to complete and will maintain a lock on the TestItem table during the execution, possibly locking out other clients.

I've included a simple test, named ExternalizerTest.zip, which demonstrates the issue.

Thanks,

Heath",,,,,,,,,,,,,,,,,,OPENJPA-828,16/Dec/11 22:23;jpaheath;ExternalizerTest.zip;https://issues.apache.org/jira/secure/attachment/12507737/ExternalizerTest.zip,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-04-24 14:22:40.08,,,no_permission,,,,,,,,,,,,221204,,,Tue Apr 24 14:22:40 UTC 2012,,,,,,,0|i1dv3z:,289137,,,,,,,,16/Dec/11 22:23;jpaheath;Test to reproduce the issue described in the description.,24/Apr/12 14:22;helenxu;it will throw class cast exception if OPENJPA-828 is not back ported,,,,,,,,,,,,,,,,,,,,,,,,,
Metadata processing needs to support jar:file URLs that address Jar directories,OPENJPA-2094,12535036,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,fyrewyld,fyrewyld,13/Dec/11 21:24,21/Sep/16 20:17,14/Mar/19 03:03,02/Dec/13 20:38,,,,,,,,,2.2.0,2.2.1,2.2.2,2.3.0,2.4.0,lib,,,,0,,,,,,,,"The JPA specification makes the following assertion about PersistenceUnitInfo's PersistenceUnitRootUrl value:

/**
 * Returns the URL for the jar file or directory that is the
 * root of the persistence unit. (If the persistence unit is
 * rooted in the WEB-INF/classes directory, this will be the
 * URL of that directory.)
 * The URL will either be a file: URL referring to a jar file
 * or referring to a directory that contains an exploded jar
 * file, or some other URL from which an InputStream in jar
 * format can be obtained.
 *
 * @return a URL referring to a jar file or directory.
 */
public URL getPersistenceUnitRootUrl();

Currently, OpenJPA supports the following URL patterns:
  1) file: URL which addresses a jar file or an exploded jar file (directory)
  2) jar: URL which addresses a jar file that terminates with ""!/"" (i.e., jar:file:somepath/myjar!/)
  3) Any URL that ends with "".jar""

What it does not support is a jar URL of this pattern: jar:file:somepath/myjar!/WEB-INF/classes
OpenJPA's AbstractCFMetaDataFactory.parsePersistentTypeNames() method will find that the
URL doesn't match the three scenarios listed above, and defaults to attempting to parse it as an
XML file, which is obviously not an appropriate behavior for processing a Jar file.

The ""jar:file:somepath/myjar!/WEB-INF/classes"" pattern must be supported to accommodate
J2EE application servers that pass such a URL into PersistenceUnitInfo._persistenceUnitRootUrl",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,220720,,,2011-12-13 21:24:47.0,,,,,,,0|i1dv47:,289138,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unmapped fields silently treated as transient,OPENJPA-2083,12533177,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,drwoods,hwellmann,hwellmann,29/Nov/11 19:26,02/Feb/12 17:19,14/Mar/19 03:03,03/Jan/12 18:46,2.1.1,,,,,,,,2.2.0,,,,,jpa,,,,0,,,,,,,,"The JPA 2.0 spec requires any non-static non-transient entity field to be persistent unless explicitly mapped as transient by a @Transient annotation or the equivalent XML.

OpenJPA 2.1.1 silently treats some unmapped non-primitive fields as transient instead of throwing an exception or at least logging a warning.

Example:

@Entity
public class City {

    @Id
    private String name;

    private Integer population;

    private java.util.concurrent.Executor executor;

    // getters and setters
}
",,,,,,,,,,,,,,,,,,,30/Dec/11 19:54;jtnowosatka;OPENJPA-2083.patch;https://issues.apache.org/jira/secure/attachment/12508950/OPENJPA-2083.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-11-30 00:16:17.229,,,no_permission,,,,,,,,,,,,218905,,,Thu Feb 02 17:19:53 UTC 2012,,,Patch Available,,,,0|i1dv6f:,289148,,,,,,,,"30/Nov/11 00:16;kwsutter;FYI, the OpenJPA manual documents slightly different behavior:

""2.14.  Persistent Field Defaults

In the absence of any of the annotations above, JPA defines the following default behavior for declared fields:

 o   Fields declared static, transient, or final default to non-persistent.

 o   Fields of any primitive type, primitive wrapper type, java.lang.String, byte[], Byte[], char[], Character[], java.math.BigDecimal, java.math.BigInteger, java.util.Date, java.util.Calendar, java.sql.Date, java.sql.Timestamp, or any Serializable type default to persistent, as if annotated with @Basic.

 o   Fields of an embeddable type default to persistent, as if annotated with @Embedded.

 o   All other fields default to non-persistent. 

Note that according to these defaults, all relations between entities must be annotated explicitly. Without an annotation, a relation field will default to serialized storage if the related entity type is serializable, or will default to being non-persistent if not.""

At least this explains the OpenJPA behavior.  But, now we have to resolve this behavior against the JPA spec-defined behavior...","01/Dec/11 20:18;curtisr7;Kevin / Harold -

Thoughts on the correct 'fix' for this issue? I'm leaning toward a warning message...

Thanks,
Rick","02/Dec/11 16:10;kwsutter;I think a warning message would be an excellent first step.  At least it would highlight to users that OpenJPA may not be doing the processing that you are expecting (or vice versa).  This could still potentially be raised as a spec violation, but that's splitting hairs in my opinion.  So, let's highlight the processing with a warning message and say we're done.","30/Dec/11 19:54;jtnowosatka;Patch adds a warning message when dealing with unmapped non-primitive fields stating that ""the fields are not default persistent and do not have any annotations. and will be treated as non-persistent. If they fields should be persistent, annotate them with the appropriately. Otherwise, mark them as transient.""",03/Jan/12 18:46;drwoods;Committed revision 1226910.,02/Feb/12 17:19;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,
Pom references to org.codehaus.mojo openjpa-maven-plugin cause problems,OPENJPA-2077,12532202,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,dianner,dianner,dianner,21/Nov/11 19:37,02/Feb/12 17:19,14/Mar/19 03:03,26/Nov/11 23:07,2.2.0,,,,,,,,2.2.0,,,,,,,,,0,,,,,,,,"I made a change to XMLPersistenceMetaDataParser, adding a call to StringUtils.endsWithIgnoreCase().It worked fine in eclipse. But it failed with a maven build with a NoSuchMethodException. StringUtils is in commons-lang. This method is introduced  in version 2.4 The openjpa-parent pom.xml does specify version 2.4, so it should work. But, it also specifies org.codehaus.mojo openjpa-maven-plugin. Investigation discovered that this is pulling in commons-lang version 2.1,which is being used and gives the exception.

I've discussed this with several people. The consensus is that the openjpa-maven-plugin that was introduced by OPENJPA-1934 was meant as a replacement for the codehaus version. So, I've changed multiple pom files, replacing references to the codehaus version with the apache version. I've tested these changes on a complete build and it works fine.

I'll wait a day or 2 before committing, in case someone knows of a problem with this.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-02-02 17:19:19.749,,,no_permission,,,,,,,,,,,,217938,,,Thu Feb 02 17:19:19 UTC 2012,,,,,,,0|i0knrr:,118668,,,,,,,,02/Feb/12 17:19;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,,,
Minor fix-ups to messages,OPENJPA-2076,12531801,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,kwsutter,kwsutter,kwsutter,17/Nov/11 14:45,06/Feb/12 15:58,14/Mar/19 03:03,06/Feb/12 15:58,2.2.0,,,,,,,,2.2.0,,,,,logging,,,,0,,,,,,,,Found a few minor areas of improvement for our messages.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,217537,,,Mon Feb 06 15:58:31 UTC 2012,,,,,,,0|i1dv7r:,289154,,,,,,,,02/Feb/12 19:34;kwsutter;These are done for this time period.  Closing the issue.,06/Feb/12 15:54;kwsutter;Minor update for an Apache header message.,06/Feb/12 15:58;kwsutter;Resolve and close again...,,,,,,,,,,,,,,,,,,,,,,,,
MappingTools requires live connection to DB2 server to retrieve default schema name,OPENJPA-2073,12531097,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,11/Nov/11 07:34,12/Nov/11 17:17,14/Mar/19 03:03,12/Nov/11 17:17,2.2.0,,,,,,,,2.2.0,,,,,jdbc,,,,0,,,,,,,,"OPENJPA-1975 deferred extraction of default schema name for DB2 from connectedConfiguration() to getDefaultSchemaName(). This change requires a live connection to the DB2 server. As a result, the following exception will be observed if no connection is available and failed the MappingTool -sa action:

517  TestJPA  TRACE  [main] openjpa.MetaData - Clearing metadata repository ""org.apache.openjpa.jdbc.meta.MappingRepository@f00301e1"".
Exception in thread ""main"" <openjpa-2.2.0-SNAPSHOT-r422266:1183674 fatal user error> org.apache.openjpa.util.UserException: A JDBC Driver or
 DataSource class name must be specified in the ConnectionDriverName property. Available properties in configuration are ""org.apache.openjpa
.jdbc.conf.JDBCConfigurationImpl@79d81a68"".
        at org.apache.openjpa.jdbc.schema.DataSourceFactory.newDataSource(DataSourceFactory.java:74)
        at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.createConnectionFactory(JDBCConfigurationImpl.java:844)
        at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getConnectionFactory(JDBCConfigurationImpl.java:732)
        at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getDataSource(JDBCConfigurationImpl.java:872)
        at org.apache.openjpa.jdbc.sql.DB2Dictionary.getConnection(DB2Dictionary.java:1162)
        at org.apache.openjpa.jdbc.sql.DB2Dictionary.getDefaultSchemaName(DB2Dictionary.java:1109)
        at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:492)
        at org.apache.openjpa.jdbc.schema.SchemaTool.build(SchemaTool.java:419)
        at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:348)
        at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:505)
        at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:1089)
        at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:1000)
        at org.apache.openjpa.jdbc.meta.MappingTool$1.run(MappingTool.java:937)
        at org.apache.openjpa.lib.conf.Configurations.launchRunnable(Configurations.java:741)
        at org.apache.openjpa.lib.conf.Configurations.runAgainstAllAnchors(Configurations.java:731)
        at org.apache.openjpa.jdbc.meta.MappingTool.main(MappingTool.java:932)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,216835,,,2011-11-11 07:34:56.0,,,,,,,0|i1dv8f:,289157,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
InvalidStateException deleting an instance with a timestamp in its primary key,OPENJPA-2072,12530831,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,helenxu,ericci,ericci,09/Nov/11 08:12,15/Sep/16 14:28,14/Mar/19 03:03,01/Jun/12 17:37,1.2.1,1.2.2,1.2.3,,,,,,1.2.3,2.0.2,2.1.2,2.2.1,2.3.0,,,,,0,,,,,,,,"Attempting to remove an instance that has a timestamp field in its primary key results in this error:
org.apache.openjpa.persistence.InvalidStateException: Operation attempted on a deleted instance.

Suppose I have this table:
CREATE TABLE test_tsp (
   t Timestamp,
   desc char(30)
)

containing just the following row:
INSERT INTO test_tsp(T,DESC) VALUES ( CURRENT_TIMESTAMP, 'one')

the table is mapped to this JPA Entity
@Entity
@Table(name=""TEST_TSP"")
public class TestTsp implements Serializable {
 private static final long serialVersionUID = -5756434331459759089L;
 @Column(name=""T"")
 @Id
 private Timestamp idTsp;

 @Column(name=""DESC"")
 private String desc;

 public TestTsp() {
  super();
 }
...getters and setters here...
}

and the following code attempts a delete of the row I've inserted

 Query query = em.createQuery(""select t from TestTsp t where t.desc='one'"");
 List<TestTsp> list = query.getResultList();
 for (TestTsp t : list) {
  em.remove(t);
 }

Here is the error I get:
...
Caused by: <openjpa-1.2.2-r422266:898935 nonfatal user error> org.apache.openjpa.persistence.InvalidStateException: Operation attempted on a deleted instance.
FailedObject: org.apache.openjpa.enhance.provatsp$TestTsp$pcsubclass@3c0b655a
        at org.apache.openjpa.kernel.PCState.error(PCState.java:443)
        at org.apache.openjpa.kernel.PDeletedState.beforeOptimisticWrite(PDeletedState.java:76)
        at org.apache.openjpa.kernel.StateManagerImpl.dirty(StateManagerImpl.java:1575)
        at org.apache.openjpa.kernel.StateManagerImpl.dirty(StateManagerImpl.java:1515)
        at org.apache.openjpa.util.Proxies.dirty(Proxies.java:66)
        at org.apache.openjpa.util.java$sql$Timestamp$proxy.setNanos(Unknown Source)
        at org.apache.openjpa.jdbc.sql.DBDictionary.setTimestamp(DBDictionary.java:1144)
        at org.apache.openjpa.jdbc.sql.DBDictionary.setTyped(DBDictionary.java:1282)
        at org.apache.openjpa.jdbc.sql.RowImpl.flush(RowImpl.java:890)
        at org.apache.openjpa.jdbc.sql.RowImpl.flush(RowImpl.java:850)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushAndUpdate(PreparedStatementManagerImpl.java:118)
        at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushAndUpdate(BatchingPreparedStatementManagerImpl.java:82)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flushInternal(PreparedStatementManagerImpl.java:89)
        at org.apache.openjpa.jdbc.kernel.PreparedStatementManagerImpl.flush(PreparedStatementManagerImpl.java:72)
        at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:543)
        at org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager.flush(ConstraintUpdateManager.java:119)
        at org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager.flush(BatchingConstraintUpdateManager.java:59)
        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:89)
        at org.apache.openjpa.jdbc.kernel.AbstractUpdateManager.flush(AbstractUpdateManager.java:72)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.flush(JDBCStoreManager.java:721)
        at org.apache.openjpa.kernel.DelegatingStoreManager.flush(DelegatingStoreManager.java:130)
        ... 40 more

N.B.: the error doesn't happen if the primary key annotation (@Id) is moved on the other field of the entity, which is not a timestamp but a char:
 @Column(name=""T"")
 private Timestamp idTsp;

 @Column(name=""DESC"")
 @Id
 private String desc;
","Linux, JUnit + Spring and HSQLDB in a case; Windows, WebSphere and DB2 in another case",,,,,,,,,,,,,,,,,,02/May/12 15:54;helenxu;OPENJPA-2072Patch;https://issues.apache.org/jira/secure/attachment/12525308/OPENJPA-2072Patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-05-02 15:52:57.726,,,no_permission,,,,,,,,,,,,216569,,,Wed May 02 15:52:57 UTC 2012,,,Patch Available,,,,0|i1dv8n:,289158,,,,,,,,"02/May/12 15:52;helenxu;Before it set the time stamp value to the delete prepared statement, it will set the nanosecond of the time stamp based on the precision.  This setting triggered the dirty update on PDeletedState and caused the invalid state error being generated.

here is the code path

	PDeletedState.beforeOptimisticWrite(StateManagerImpl, int, boolean) line: 76	
	StateManagerImpl.dirty(int, Boolean, boolean) line: 1546	
	StateManagerImpl.dirty(int) line: 1485	
	Proxies.dirty(Proxy, boolean) line: 66	
	java$sql$Timestamp$proxy.setNanos(int) line: not available	
	DB2Dictionary(DBDictionary).setTimestamp(PreparedStatement, int, Timestamp, Calendar, Column) line: 1103	
	DB2Dictionary(DBDictionary).setTyped(PreparedStatement, int, Object, Column, int, JDBCStore) line: 1241	
	PrimaryRow(RowImpl).flush(PreparedStatement, int, DBDictionary, JDBCStore) line: 888	
	PrimaryRow(RowImpl).flush(PreparedStatement, DBDictionary, JDBCStore) line: 848	
	PreparedStatementManagerImpl.flushInternal(RowImpl) line: 95	
	PreparedStatementManagerImpl.flush(RowImpl) line: 73	
	ConstraintUpdateManager.flush(Collection, PreparedStatementManager) line: 543	
	ConstraintUpdateManager.flush(RowManager, PreparedStatementManager, Collection) line: 119	
	ConstraintUpdateManager(AbstractUpdateManager).flush(Collection, JDBCStore, PreparedStatementManager) line: 89	
	ConstraintUpdateManager(AbstractUpdateManager).flush(Collection, JDBCStore) line: 72	
	JDBCStoreManager.flush(Collection) line: 514	
	ROPStoreManager(DelegatingStoreManager).flush(Collection) line: 130	
	FinalizingBrokerImpl(BrokerImpl).flush(int) line: 1956	
	FinalizingBrokerImpl(BrokerImpl).flushSafe(int) line: 1854	
	FinalizingBrokerImpl(BrokerImpl).beforeCompletion() line: 1772	
	LocalManagedRuntime.commit() line: 81	
	FinalizingBrokerImpl(BrokerImpl).commit() line: 1294	
	DelegatingBroker.commit() line: 861	
	EntityManagerImpl.commit() line: 408

Fix and test case attached.",,,,,,,,,,,,,,,,,,,,,,,,,,
NPE during ResultPacker interface processing,OPENJPA-2071,12530781,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,08/Nov/11 23:06,11/Jan/12 19:45,14/Mar/19 03:03,09/Nov/11 19:04,2.2.0,,,,,,,,2.2.0,,,,,kernel,,,,0,,,,,,,,"Got the following NPE from ResultPacker process.

Failed to execute query ""SELECT name FROM root.JPADeptBean WHERE deptno >= ?"". Check the query syntax for correctness. See nested exception for details.

<openjpa-2.2.0-SNAPSHOT-r422266:1198001 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Failed to execute query ""SELECT name FROM root.JPADeptBean WHERE deptno >= ?"". Check the query syntax for correctness. See nested exception for details.
at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:872)
at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:794)
at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:315)
at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:331)
at com.ibm.ws.query.tests.ano.JUNativeQueryTest.testSelectName(JUNativeQueryTest.java:271)
Caused by: java.lang.NullPointerException
at org.apache.openjpa.kernel.ResultPacker.isInterface(ResultPacker.java:176)
at org.apache.openjpa.kernel.ResultPacker.<init>(ResultPacker.java:122)
at org.apache.openjpa.kernel.ResultPacker.<init>(ResultPacker.java:114)
at org.apache.openjpa.jdbc.kernel.SQLProjectionResultObjectProvider.<init>(SQLProjectionResultObjectProvider.java:67)
at org.apache.openjpa.jdbc.kernel.SQLStoreQuery$SQLExecutor.executeQuery(SQLStoreQuery.java:232)
at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1005)
at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:863)

I believe it is related to additional interface check from OPENJPA-2065
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,216519,,,2011-11-08 23:06:13.0,,,,,,,0|i1dv8v:,289159,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error processing while populating Metamodel classes needs improvement,OPENJPA-2070,12530585,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,07/Nov/11 15:36,18/Apr/13 17:33,14/Mar/19 03:03,11/Nov/11 13:54,2.2.0,,,,,,,,2.2.0,,,,,criteria,,,,0,,,,,,,,"The MetamodelImpl.populate() method needs some improvements in the error processing arena.  This scenario is coming about due to the changes in OPENJPA-2027.  If our current 2.2.x runtime implementation runs against a metamodel class that was generated prior to the fix in OPENJPA-2027, the exception produced does not show what the error was (and we're missing the ""caused by"" exception).  These updates will help identify the root cause issue.",,,,,,,,,,,,,,OPENJPA-2027,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-02-02 17:16:11.639,,,no_permission,,,,,,,,,,,,216323,,,Thu Apr 18 17:33:47 UTC 2013,,,,,,,0|i1dv93:,289160,,,,,,,,02/Feb/12 17:16;allee8285;Close issue in preparation for 2.2.0 release.,"18/Apr/13 17:33;jira-bot;Commit 1469488 from hthomann
[ https://svn.apache.org/r1469488 ]

OPENJPA-2070: Error processing while populating Metamodel classes needs improvement.  Back-ported to 2.1.x Kevin Sutter's trunk changes.",,,,,,,,,,,,,,,,,,,,,,,,,
Natvie sequence problems uncovered after OPENJPA-1376,OPENJPA-2069,12530384,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,04/Nov/11 21:33,09/Jul/12 14:42,14/Mar/19 03:03,14/Nov/11 15:44,2.1.2,2.2.0,,,,,,,2.2.0,,,,,jdbc,kernel,,,0,,,,,,,,"After OPENJPA-1376 commits, it uncovered a few issues, some old and some new.

1. Backward compatibility - Previous, openjpa relies on the native sequence to provide the next value based on the sequence's INCREMENT BY setting. Now that openjpa manages the next sequence value and allocation size, if the db sequence is manually created that does not match the application's increment and allocation size, committing a new entity may result a constraint violation exception when new sequence value is requested that crossed the allocation boundary.  This behavior is indirectly documented in the migration consideration section in the user manual, but it would be better if this can be handled automatically or at least to provide a compatibility option to honor previous behavior.

2. Initial value always start with the same value (default to 1) - In NativeJDBCSeq, the _initial, _increment and _allocate are used for the CREATE SEQUENCE generation for SynchronizeMapping function. For existing db sequence, next returns whatever managed by the db sequence. After the commit, next will first return the_nextValue value in NativeJDBCSeq until _maxValue is reached, then it go to db to get the sequence's next value, which may be ways off from the current _maxValue.

3. _nextValue not handled proper when crossing _allocate boundary - When NativeJDBCSeq's _nextValue exceeds the _maxValue boundary, it queries db's sequence for the next incremental value and assign directly as the next return value. It works for incrementBy = 1 but for some value (e.g. 3), the difference of the before and after cross boundary values may NOT be the _increment value.
",,,,,,,,,,,,,,OPENJPA-2196,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,216122,,,2011-11-04 21:33:04.0,,,,,,,0|i1dv9b:,289161,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"A 'length' of '-1' passed to PreparedStatement.setBinaryStream can cause an exception on some, but not all, JDBC drivers.",OPENJPA-2067,12529315,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jpaheath,jpaheath,jpaheath,28/Oct/11 20:45,01/Jun/12 17:59,14/Mar/19 03:03,01/Jun/12 17:59,1.2.3,2.0.2,2.1.2,2.2.0,,,,,1.2.3,2.0.2,2.1.2,2.2.1,2.3.0,jdbc,sql,,,0,,,,,,,,"I recently worked on an issue where a JDBC driver is throwing an exception when attempting to persists an InputStream:

Caused by: <openjpa-1.2.3-SNAPSHOT-r422266:1152904 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: String or buffer length not valid.
FailedObject: prepstmnt 1608671202 UPDATE PMYPJRK SET lastModificationDate = ?, fileLength = ?, fileName = ?, inputStream = ? WHERE id = ? [org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement]
.........
Caused by: java.sql.SQLException: String or buffer length not valid.
	at com.ibm.as400.access.JDError.throwSQLException(JDError.java:415)
	at com.ibm.as400.access.AS400JDBCPreparedStatement.setBinaryStream(AS400JDBCPreparedStatement.java:2098)
	at com.ibm.ws.rsadapter.jdbc.WSJdbcPreparedStatement.setBinaryStream(WSJdbcPreparedStatement.java:1444)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.setBinaryStream(DelegatingPreparedStatement.java:340)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.setBinaryStream(LoggingConnectionDecorator.java:1104)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.setBinaryStream(DelegatingPreparedStatement.java:340)
	at org.apache.openjpa.jdbc.sql.DBDictionary.setBinaryStream(DBDictionary.java:875)
	at org.apache.openjpa.jdbc.sql.DBDictionary.setTyped(DBDictionary.java:1244)
	at org.apache.openjpa.jdbc.sql.RowImpl.flush(RowImpl.java:890)
	at org.apache.openjpa.jdbc.sql.RowImpl.flush(RowImpl.java:850)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushSingleRow(BatchingPreparedStatementManagerImpl.java:249)
	at org.apache.openjpa.jdbc.kernel.BatchingPreparedStatementManagerImpl.flushBatch(BatchingPreparedStatementManagerImpl.java:157)
	... 138 more



This exception occurs because the particular JDBC driver checks the value of the 'length' variable passed to the 'PreparedStatement.setBinaryStream' method:

setBinaryStream(int parameterIndex, InputStream x, int length) 

The 'length' parameter of method 'setBinaryStream' is supposed to be the length of the InputStream parameter.  OpenJPA code is passing a value of '-1' for the length as the length is not known.  Some JDBC drivers allow this value.  Technically speaking the javadoc for 'PreparedStatement.setBinaryStream' doesn't state that a negative value is not acceptable or what should happen when a negative length is passed to 'setBinaryStream' (which is likely why some drivers allow a negative value and others do not).  On the other hand, it doesn't make sense for a length of an InputStream to be negative.  Given this, and the fact that OpenJPA is not aware of the length of the stream, I'll work on a solution which uses a JDBC 4.0 version of 'setBinaryStream' which doesn't take a length.  The fix will of course require JDK 6 + JDBC 4.0 driver runtime.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,215175,,,2011-10-28 20:45:42.0,,,,,,,0|i1dutz:,289092,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Edge case in openJPA-1227. openJPA fails to create a join and thus returns wrong data when a collection is selected from superclass and another field is selected from subclass twoor more levels down the hierarchy.,OPENJPA-2066,12528797,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,rpalache,rpalache,rpalache,26/Oct/11 00:39,21/Sep/16 14:21,14/Mar/19 03:03,06/Nov/11 15:38,1.1.0,2.1.1,2.2.0,,,,,,1.2.0,2.2.0,,,,,,,,0,,,,,,,,"openJPA-1227 fixes the wrong SQL generation error when superclass contains an eager to-many field, and this is the only field selected in the superclass, and when one or more fields are selected in the subclass, openjpa fails to create a join between the subclass and superclass. But the issue still remains when one or more fields are selected from subclasses two levels down the hierarchy.

Example:
GrandChildClass extends ChildChildClass extends ChildClass extends ParentClass.

When I select a filed from GrandChildClass and a to-many field from ParentClass then openjpa fails to create a join between the classes.",,,,,,,,,,,,,,,,,,,26/Oct/11 00:44;rpalache;OPENJPA2066_11x.diff;https://issues.apache.org/jira/secure/attachment/12500790/OPENJPA2066_11x.diff,26/Oct/11 00:46;rpalache;OPENJPA2066_trunk.diff;https://issues.apache.org/jira/secure/attachment/12500791/OPENJPA2066_trunk.diff,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2011-11-05 17:26:29.262,,,no_permission,,,,,,,,,,,,214657,,,Sat Nov 05 17:27:56 UTC 2011,,,Patch Available,,,,0|i1duu7:,289093,,,,,,,,"26/Oct/11 00:44;rpalache;Patch contributed by Hiroki Tateno.
Test case contributed by Ravi Palacherla.","26/Oct/11 00:46;rpalache;Patch contributed by Hiroki Tateno.
TestCase contributed by Ravi Palacherla.",05/Nov/11 17:26;curtisr7;Assigning to Ravi.,05/Nov/11 17:27;curtisr7;Update fix versions.,"05/Nov/11 17:27;curtisr7;Ravi -

If you are complete with this JIRA, please mark it as resolved.

Thanks,
Rick",,,,,,,,,,,,,,,,,,,,,,
"JPA 2.0 Spec. Violation? EntityManager#createNamedQuery(String, Class) bombs with non-entity Class parameter",OPENJPA-2065,12528728,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,ljnelson,ljnelson,25/Oct/11 18:01,02/Feb/12 17:15,14/Mar/19 03:03,05/Nov/11 16:53,2.1.0,2.1.1,2.2.0,,,,,,2.2.0,,,,,jpa,,,,0,specification,,,,,,,"Suppose we have an interface, A.

Suppose we have a JPA-compliant entity class, B, that implements A.

This construction will fail at runtime:

final TypedQuery<A> q = em.createNamedQuery(""someNamedQuery"", A.class);

Hibernate and EclipseLink both accept this construction.

I don't see anywhere in the JPA specification that the class parameter must denote an entity type.",,,,,,,,,,,,,,OPENJPA-2071,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-10-26 19:17:50.405,,,no_permission,,,,,,,,,,,,214588,,,Thu Feb 02 17:15:01 UTC 2012,,,,,,,0|i1duuf:,289094,,,,,,,,"26/Oct/11 19:17;kwsutter;Laird,
This does look to be a valid request, but I don't think it's a spec compliance issue.  According to section 2.11.3, non-entity classes (interfaces) can not be passed as arguments to EM and Query methods:

""Non-entity classes cannot be passed as arguments to methods of the EntityManager or Query
interfaces[24] and cannot bear mapping information.""

An easy work around for now is to not utilize the TypedQuery support and cast the results instead.  Not great, but it's workable until a better solution is developed.

BTW, having both EclipseLink and Hibernate support this does add to the weight of resolving this JIRA...  :-)

Thanks,
Kevin","26/Oct/11 19:32;ljnelson;That would imply among other things that this too is illegal:

final TypedQuery<Long> q = em.createNamedQuery(""someQueryThatReturnsAnAggregateOrCOUNTResult"", Long.class);

And this:

final TypedQuery<Object[]> q = em.createNamedQuery(""someQueryThatReturnsAnObjectArrayBecauseOfStuffInTheSelectClause"", Object[].class);

Is that really the case?  Section 2.11 has very narrow scope.  2.11.3 would seem to have been conceived of within the bounds of that scope, not within the bounds of the entire specification.  Nevertheless, there it is.  That is really unfortunate.  I'll ask the sleepy users@jpa-spec.java.net list, where I appear to be the only poster, what they think.","26/Oct/11 19:50;kwsutter;Fair enough, Laird.  :-)  I didn't say it wasn't a valid request.  I was just looking for a ""get out of jail free"" card for the spec violation statement...  Thanks again for bringing this to our attention.","26/Oct/11 20:02;ljnelson;Sure; not trying to be difficult.  Thanks for the quick response, and the pointers to 2.11.3.  I'm guessing that this section (2.11.3) was created before there was a TypedQuery-returning method on EntityManager, and that the spec. authors would probably modify it if it were brought to their attention.",05/Nov/11 16:13;curtisr7;Updating fix/affects  version.,"05/Nov/11 16:53;curtisr7;Pinaki committed a code fix, and I committed a unit test. Marking issue as resolved.",02/Feb/12 17:15;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,
Missing localizer.properties for org.apache.openjpa.persistence.util.SourceCode,OPENJPA-2059,12527104,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,13/Oct/11 21:30,25/Oct/11 19:44,14/Mar/19 03:03,25/Oct/11 19:44,2.1.2,2.2.0,,,,,,,2.2.0,,,,,criteria,,,,0,,,,,,,,The localized message file needed for package org.apache.openjpa.persistence.util is missing. This mainly supports the 7-8 messages referenced by SourceCode.java,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,85474,,,Thu Oct 13 21:45:00 UTC 2011,,,,,,,0|i1duvj:,289099,,,,,,,,"13/Oct/11 21:45;allee8285;The missing messages are:

_loc.get(""src-duplicate-field"", field, this)
_loc.get(""src-duplicate-method"", method, this)
_loc.get(""src-invalid-method"",m)
_loc.get(""src-invalid-type"", name)
_loc.get(""src-invalid-field"",f)
",,,,,,,,,,,,,,,,,,,,,,,,,,
Postgres V9.1 issue with LIKE clause and Escape Strings,OPENJPA-2056,12525645,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,milosz,gbjbaaha,gbjbaaha,04/Oct/11 10:41,02/Feb/12 17:14,14/Mar/19 03:03,09/Oct/11 11:17,2.0.0,2.0.1,2.1.1,,,,,,2.2.0,,,,,jdbc,sql,,,0,,,,,,,,"Noticed an issue with the Postgres DBDictionary definition after updating Postgres from version 8.4 to 9.1:-

Here's what you get in the Postgres trace file when executing some JPA driven queries where an SQL LIKE is involved:-

2011-09-30 14:29:41 BST ERROR:  invalid escape string
2011-09-30 14:29:41 BST HINT:  Escape string must be empty or one character.
2011-09-30 14:29:41 BST STATEMENT:  SELECT t0.id, t0.identificationMask, t0.productName FROM DBTYPE t0 WHERE (t0.identificationMask LIKE $1 ESCAPE '\\')
2011-09-30 14:29:41 BST ERROR:  current transaction is aborted, commands ignored until end of transaction block

This appears to be down to a change the Postgres project have made to escape string handling:-
  http://www.postgresql.org/docs/9.1/static/release-9-1.html (see section E.2.2.1)

You appear to be able to override the default DBDictionary setting for this as follows to get things working again:-
<property name=""openjpa.jdbc.DBDictionary"" value=""postgres(SearchStringEscape=\)""/>

So, does this mean OpenJPA needs a version dependent dictionary definition for Postgres from now on? Anybody got any better solutions or care to confirm what I'm seeing?

I've also posted this to the Postgres JDBC mailing list in case they have any comments. ",Running against a Postgres database at version 9.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-10-04 23:50:17.856,,,no_permission,,,,,,,,,,,,44266,,,Thu Feb 02 17:14:27 UTC 2012,,,,,,,0|i1duvz:,289101,,,,,,,,"04/Oct/11 10:52;gbjbaaha;I think there are several solutions to this problem, but ideally we need something that is backwards compatible with previous Postgres releases. I'm no expect on the internals of OpenJPA, but here are some suggestions:

1. Determine from the current connection the setting of ""standard_conforming_strings"" (Needs SQL statement ""SHOW standard_conforming_strings;""). This can then be used to influence the escape string to being either ""\\"" or ""\\\\"" in the Dictionary impl as required. ASFAIK Postgres at V9.1 returns ""ON"" and earlier releases return ""OFF"".

Here are some links to the Postgres documentation covering this topic:-
  http://www.postgresql.org/docs/9.1/interactive/runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS
  http://www.postgresql.org/docs/9.1/interactive/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS-ESCAPE

2. Use an explicitly escaped string like E'\\' to force escape interpretation, making the string independent of the standards_conforming_strings param.

Until this is fixed, there are several workarounds for the problem:-

1. Set a property in the persistence.xml as follows to override the default PGDictionary setting:-
    <property name=""openjpa.jdbc.DBDictionary"" value=""postgres(SearchStringEscape=\)""/>
2. In the Postgres configuration file (postgresql.conf) make the setting under ""VERSION/PLATFORM COMPATIBILITY"" :-
  standard_conforming_strings = off

Option 1 is preferred as not all users may have access to the Postgres configuration files.
","04/Oct/11 23:50;ringerc;Note that standard_conforming_strings was introduced in PostgreSQL 8.2. While this is the oldest release still supported by the PostgreSQL team, and will be exiting support in December this year, people seem to routinely run old and unsupported releases. Questions about PostgreSQL 7.4 are not uncommon on the mailing list. On prior versions, ""SHOW standard_conforming_strings"" will report an error.

It's not particularly likely that people running such ancient versions of PostgreSQL will upgrade OpenJPA, but in an org where DBA/sysadmin is very separate from dev, or where legacy and actively maintained apps coexist in the same DBs, it's not impossible. It's worth handling.

I think the escape string syntax E'' was introduced in PostgreSQL 8.1, but haven't tested to verify that. You should probably not rely on it if people using ancient versions is a realistic possibility.

The best answer will probably be to always escape strings. Just ""SELECT version()"" to decide whether the explicit escape-string syntax should be used, or if, as older versions that lack standard_conforming_strings, all strings should be assumed to be subject to escape processing. That makes OpenJPA independent of the standard_conforming_strings parameter.

It's also important to be aware of the backslash_quote parameter, which is another compatibility option that can cause pain. Escape single quotes by doubling them, not by using \', to avoid issues with this. backslash_quote exists as far back as at least PostgreSQL 7.4, as does support for SQL-standard '' style quote escapes. If OpenJPA currently escapes quotes using \' this should be changed to avoid another potential bug.

I know all this is ugly; transitioning toward better standards conformance often is in cases where no 100%-compatible approach can exist. Unfortunately, standard_conforming_strings will be a wart for quite a long time and it is a setting people DO mess with, so it's important to handle it.","09/Oct/11 11:28;milosz;Hi Andrew & Craig. Thanks for the extensive information. The escape string now depends on PostgreSQL version:
1. 9.0 and older use '\\'.
2. 9.1 and later use '\'.

I expect this to be a good solution for the vast majority of users. Those with PostgreSQL 9.0 and older who have set standard_conforming_strings to ON can use the SearchStringEscape property workaround proposed by Andrew. Also, setting a DBDictionary property called RequiresSearchStringEscapeForLike to false might help in such cases.",02/Feb/12 17:14;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA service is not properly registered for tracking by OSGi persistence tracker,OPENJPA-2053,12525194,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,techhusky,techhusky,techhusky,29/Sep/11 14:58,28/Mar/12 15:30,14/Mar/19 03:03,28/Mar/12 15:30,2.0.0,,,,,,,,2.2.0,,,,,osgi,,,29/Sep/11 00:00,0,openjpa,"osgi,",,,,,,"The Geronimo JPA spec api bundle provides a mechanism that allows JPA providers that register as an OSGi service to be tracked.  The provider services can then be enumerated through an OSGi-enabled persistence resolver (also in the spec bundle).  This works fine (sort of) if only OpenJPA is the only provider registered, but breaks as soon another provider bundle registers in the environment.  

The issue is that the OpenJPA service registration mechanism does not specify a property required by the persistence tracker to distinguish one provider from another.",OpenJPA + OSGi,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,40022,,,Thu Sep 29 15:12:37 UTC 2011,,,,,,,0|i1duwn:,289104,,,,,,,,29/Sep/11 15:12;techhusky;Committed fix to trunk under revision 1177327. ,,,,,,,,,,,,,,,,,,,,,,,,,,
Entities in a relationship are not properly cascaded after a EntityManager.flush is executed.,OPENJPA-2051,12523252,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jpaheath,jpaheath,jpaheath,15/Sep/11 21:12,06/Mar/13 20:28,14/Mar/19 03:03,01/Jun/12 17:47,2.0.0,2.1.1,2.2.0,,,,,,1.2.3,2.0.2,2.1.2,2.2.0,,,,,,0,,,,,,,,"I've found a scenario where upon transaction commit, certain entities which should be persisted via a cascade operation are not present in the database.  To properly describe this issue, let me start by first introducing a few entities, and then list a snippet of a test which uses these entities to recreate an issue with cascading entities.  That said, take the following three entities:

public class Vertex {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long oid;

    @OneToMany(mappedBy = ""source"", cascade = CascadeType.ALL)
    private List<Edge> outgoing;

    @OneToMany(mappedBy = ""target"", cascade = CascadeType.ALL)
    private List<Edge> incoming;

    @ManyToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = ""TYPE_OID"")
    private VertexType type;

    public Edge newEdge( Vertex target ) {
        Edge t = new Edge( this );
        outgoing.add( t );
        t.setTarget( target );
        return t;
    }
.........


public class VertexType {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)    
    private long oid;

    @OneToMany(mappedBy = ""type"", cascade = CascadeType.ALL)
    List<Vertex> instances;

    private String name;
.........


public class Edge {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long oid;

    @ManyToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = ""SOURCE_OID"")
    private Vertex source;

    @ManyToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = ""TARGET_OID"")
    private Vertex target;
.........



Before describing the test case, let me point out a couple important things about these entities.  First you will notice that each entity contains a generated id.  Second, notice that there are multiple relationships between these entities. 

Now let me introduce the test: 

EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();

tx.begin();
em.flush();

VertexType defaultType = new VertexType( ""default"" );
VertexType specialType = new VertexType( ""special"" );

em.persist(defaultType);
em.persist(specialType);

Vertex src = new Vertex( defaultType );
Vertex target = new Vertex( specialType );

Edge t = src.newEdge( target );
assertNotNull( t );

em.persist(src);
tx.commit();


Notice that one of the first things the test does is to perform a flush.  This may seem slightly odd, however this flush is important to cause the issue.  We could execute a query or some other operation which would cause a flush under the covers, however, calling a flush directly makes it clear that a flush has occurred when looking at the rest of the test.  

With the entities and test case in place, let me now describe the issue.  After this test case executes, there should exist in the database two Vertex, two VertexType, and one Edge given the cascade type defined in the entities.  However, I find that one of the Vertex is missing.  

In working with Rick Curtis on this issue, he found that the 'flush' at the beginning of the test had an effect on the cascade persist at the end of the test.  That is, when 'flush' is called, this causes the '_flags' variable in BrokerImpl to be set to flushed as follows:

_flags |= FLAG_FLUSHED;

This of course effects the return value of the method BrokerImpl.hasFlushed:

    private boolean hasFlushed() {
        return (_flags & FLAG_FLUSHED) != 0;
    }

I will now describe how the return value of this method effects the outcome of the test.  However, in an effort of time I am going to skip over some details which I'll leave as an exercise for the reader to figure out (e.g. execute the test in a debugger).  Basically this has an effect on SingleFieldManager.persist when called by StateManagerImpl.cascadePersist.  That is, SingleFieldManager.persist makes a call to method 'isDetached' on the broker here:

 case JavaTypes.PC_UNTYPED:
     if (!_broker.isDetachedNew() && _broker.isDetached(objval))
         return; // allow but ignore
     _broker.persist(objval, true, call);
     break;

Code within 'isDetached' eventually makes a call to 'hasFlushed'.  Given that 'hasFlushed' returns true, it ultimately effects the result of 'isDetached' and thus causing the persist method in the previously posted code block to be skipped.  Again, I'm glossing over some details, but the code path described is also affected by the fact that the ids in these entities are auto generated.


In order to resolve this problem, we feel the best solution is to change the '_flags' variable to indicate a flush has not occurred.  To that end, we propose adding the assignment '_flags &= ~FLAG_FLUSHED'
to this portion of code in BrokerImpl.setStateManager:

     case STATUS_INIT:
     	   _flags &= ~FLAG_FLUSHED;
         _cache.add(sm);
         break;


In addition, this new assignment will be gated by a compatibility property.

I've included a test patch, named 'CascadePersistIssue.test.patch' which replicates the issue.
",,,,,,,,,,,,,,,,,,,15/Sep/11 21:14;jpaheath;CascadePersistIssue.test.patch;https://issues.apache.org/jira/secure/attachment/12494695/CascadePersistIssue.test.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2275,,,Wed Mar 06 20:28:39 UTC 2013,,,,,,,0|i1dux3:,289106,,,,,,,,15/Sep/11 21:14;jpaheath;Attaching a test case which replicates the issue described.,"06/Mar/13 20:28;jpaheath;Note that prior to 2.2.1.x/2.2.x, the code of this fix is enabled with the following system property:

<property name=""openjpa.Compatibility"" value=""resetFlushFlagForCascadePersist=true""/>

Thanks,

Heath",,,,,,,,,,,,,,,,,,,,,,,,,
NAME is a valid column name for H2 databases.,OPENJPA-2045,12521063,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jtnowosatka,mikedd,mikedd,01/Sep/11 14:03,15/Sep/11 13:29,14/Mar/19 03:03,15/Sep/11 13:29,2.1.0,2.2.0,,,,,,,2.2.0,,,,,jdbc,,,,0,,,,,,,,"This issue was originally reported on the users mailing list : http://openjpa.208410.n2.nabble.com/GenerationType-TABLE-question-column-name-suffixed-with-0-td6729676.html. 

The H2 DBDictionary is picking up the default list of invalid column names from openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc, which includes ""NAME"". As a result we're trying to fix the column so that it contains a valid identifier, and end up with the wrong value. 

Users can work around the problem by delimiting columns in their annotations or xml mapping files, for example : 
@javax.persistence.TableGenerator(
    name = ""fred"", 
    table = ""jpa_sequence"", 
    pkColumnName = ""\""name\"""", 
    valueColumnName = ""last_value"", 
    pkColumnValue = ""fred"", 
    allocationSize = 500)

To fix the problem we need to either remove NAME from the default list, or manually remove it in the H2 Dictionary. Some additional investigation may be needed to determine whether this is a problem for other databases too. 
",,,,,,,,,,,,,,,,,,,14/Sep/11 21:16;jtnowosatka;OPENJPA-2045.patch;https://issues.apache.org/jira/secure/attachment/12494523/OPENJPA-2045.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-09-14 21:16:24.814,,,no_permission,,,,,,,,,,,,2281,,,Thu Sep 15 13:29:44 UTC 2011,,,,,,,0|i1duyf:,289112,,,,,,,,"14/Sep/11 21:16;jtnowosatka;I did some research and it seems that for only a few databases is ""NAME"" as a reserved keyword.
Access
FoxPro
Informix
Pointbase

Thus, I have opted to remove ""NAME"" from the list of common reserved words and made it specific to each database listed above. The attached patch does just this.",15/Sep/11 13:29;mikedd;Thanks for the patch. This should be included the next nightly snapshot. ,,,,,,,,,,,,,,,,,,,,,,,,,
Invalid header in MetaModel classes generated by AnnotationProcessor,OPENJPA-2044,12520095,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Trivial,Fixed,kwsutter,dalelane,dalelane,25/Aug/11 11:30,03/Feb/12 16:21,14/Mar/19 03:03,02/Feb/12 19:35,2.0.1,2.1.1,2.2.0,,,,,,2.2.0,,,,,criteria,,,,0,openjpa,,,,,,,"The documentation at http://openjpa.apache.org/builds/latest/docs/manual/ch13s04.html talks about an option available in org.apache.openjpa.persistence.meta.AnnotationProcessor6:

-Aopenjpa.header=<url> : A url whose content will appear as comment header to the generated file(s). 

This option does not work.

If I give it a URL - either an http or a file URL - it doesn't put the contents from these URLs into the header of the generated files. It puts something like:

sun.net.www. content.text.PlainTextInputStream@9ea09ea 

in the header instead.


I suspect that the AnnotationProcessor is essentially doing:

URL headerurl = new URL(<openjpa.header value>);
String newHeaderComment = headerurl.getContent().toString();

The getContent() is returning an InputStream - as documented here in the absence of a content handler factory: http://download.oracle.com/javase/6/docs/api/java/net/URLConnection.html#getContent()

Then the toString() call just returns the string representation of the instance of the InputStream object. 

I think the AnnotationProcessor should read from the stream instead?",Any,1800,1800,,0%,1800,1800,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-10-12 18:16:06.922,,,no_permission,,,,,,,,,,,,2282,,,Fri Feb 03 16:21:49 UTC 2012,,,,,,,0|i1duyn:,289113,,,,,,,,12/Oct/11 18:16;kwsutter;Dale was right on with his comments.  The openjpa.header property on the AnnotationProcessor was not being processed correctly.  I am in the process of correcting this.,"13/Oct/11 13:26;ppoddar@apache.org;If you are fixing this, please put the fix of reading the content of an URL into openjpa-lib/...../Files.java","13/Oct/11 13:45;kwsutter;I already committed the changes to trunk.  Since the original URL processing code was localized to AnnotationProcessor6, I followed the same pattern.  Moving this type of simple change to Files seemed like overkill.  And, since the actual processing of the stream into Comment format is pretty unique to the SourceCode file, I really didn't see a need to generalize it for Files.",17/Oct/11 13:48;dalelane;Tried the fix from a nightly snapshot - it fixed the problem for us. The MetaModel classes are now being generated correctly. Many thanks.,02/Feb/12 19:35;kwsutter;Resolved in trunk (2.2.0-SNAPSHOT).,03/Feb/12 16:21;allee8285;Close issue in-preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,
FKs for EAGER fields that are not in the current fetchplan aren't selected,OPENJPA-2039,12518519,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,10/Aug/11 22:03,02/Feb/12 17:13,14/Mar/19 03:03,16/Aug/11 19:07,2.1.1,2.2.0,,,,,,,2.2.0,,,,,jdbc,,,,0,,,,,,,,"I am testing a scenario where I have an Entity with a number of eager/lazy relationships and at runtime, using a FetchPlan, I want to mark all relationships as lazy. I was able to hack around a bug reported previously on this list about not being able to remove fields from a fetch plan by creating a new fetch plan, removing the default fetch group, and re-adding all fields you want back into the new fetch plan. This all seems to work.

I found that owned *toOne relationships that are marked as lazy via annotations we will select the foreign keys. If the relationships were marked as eager, we don't select the foreign keys. This is where I believe the bug is. In JDBCStoreManager.optSelect(...) we have a bit of code that looks to see if a field is a not a part of the default fetch group, and if it was not removed explicitly. This is wrong because for the sake of the load that is in progress, I'm not using the default fetch group.

With this JIRA I'd like to remove the two conditionals '!fm.isInDefaultFetchGroup() && !fm.isDefaultFetchGroupExplicit()' so that we will load the fks for lazy and eager marked fields.

This seems safe enough to do as worst case, we will select an extra field from a table that we are already selecting from. Best case, when accessing a lazy collection, we will issue a select by FK rather than a select with a join.
",,,,,,,,,,,,,,,,,,,10/Aug/11 22:36;curtisr7;OPENJPA-2039.failingtest.patch;https://issues.apache.org/jira/secure/attachment/12490043/OPENJPA-2039.failingtest.patch,10/Aug/11 22:09;curtisr7;OPENJPA-2039.patch;https://issues.apache.org/jira/secure/attachment/12490040/OPENJPA-2039.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2011-08-15 19:24:34.763,,,no_permission,,,,,,,,,,,,2287,,,Thu Feb 02 17:13:09 UTC 2012,,,,,,,0|i1duzj:,289117,,,,,,,,10/Aug/11 22:09;curtisr7;Attaching the code change and a testcase.,10/Aug/11 22:36;curtisr7;Attaching another patch with the changes required to fix the one failing testcase.,15/Aug/11 16:36;curtisr7;Committed revision 1157903 to trunk.,"15/Aug/11 19:24;ppoddar@apache.org;I have not tracked the details of this issue. But simply looking at the commit, I have few concerns.

1. The new boolean flag introduced IgnoreFKSelect is not in the *right* place. The *right* (by existing
design discipline) of any such configuration is *not* JDBCStoreManager, but JDBCFetchPlan/FetchConfiguration.
I know it is a bit of extra work to carry that getter/setter, copying the state in FetchConfiguration.copy(),
but I still request the committer to take that extra work to introduce this new option.

2. A bit of JavaDoc comment will be helpful. 

3. A doc update is necessary.



","15/Aug/11 19:35;curtisr7;> 1. ...The *right* (by existing design discipline) of any such configuration is *not* JDBCStoreManager, but JDBCFetchPlan/FetchConfiguration. 

Yes! I really struggled trying to figure out where to put this configuration. I never considered FetchConfiguration, I'll take a look at that shortly here.",15/Aug/11 21:01;curtisr7;Reopening to address Pinaki's comments.,"15/Aug/11 23:03;ppoddar@apache.org;Looks OK to me.
Perhaps I would 
a) change the doc comments on the interface to be more clear/elaborate in the user terms.
b) add an empty line between methods","16/Aug/11 14:10;curtisr7;> a) change the doc comments on the interface to be more clear/elaborate in the user terms. 

That's where I'm stumbling. I really wouldn't expect most users to have the understanding of OpenJPA to want to control this aspect of loading. I only ran into this because of some of the trickery I'm trying to get working. 

If you get a chance, take a look at the unit test that I put together of this change.",16/Aug/11 19:07;curtisr7;Resolving issue.,02/Feb/12 17:13;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,
Do not include schema name when calculating table name length by default. ,OPENJPA-2038,12518481,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,10/Aug/11 17:10,17/Aug/11 08:51,14/Mar/19 03:03,10/Aug/11 21:33,2.1.1,,,,,,,,2.1.2,,,,,jdbc,,,,0,,,,,,,,The fix for OPENJPA-1725 was overly cautious and should have defaulted to the correct behavior for 2.1.1. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2288,,,2011-08-10 17:10:27.0,,,,,,,0|i1duzr:,289118,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"DynamicEnhancer should look for tools.jar in java.home/lib for all JDKs, not just the IBM SDK.",OPENJPA-2036,12515578,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,jpyeron,jpyeron,27/Jul/11 21:22,02/Feb/12 17:12,14/Mar/19 03:03,28/Jul/11 15:04,2.1.0,,,,,,,,2.2.0,,,,,Enhance,,,,0,patch,,,,,,,"

FINE: java.home=C:\Program Files\Java\jdk1.6.0_26\jre
Jul 27, 2011 5:21:15 PM com.carefirst.fep.local.commons.model.claim.TestClaimModels setUp
FINE: javaHomeFile=C:\Program Files\Java\jdk1.6.0_26\jre
Jul 27, 2011 5:21:15 PM com.carefirst.fep.local.commons.model.claim.TestClaimModels setUp
FINE: toolsJarFile=C:\Program Files\Java\jdk1.6.0_26\jre\lib\tools.jar
Jul 27, 2011 5:21:15 PM com.carefirst.fep.local.commons.model.claim.TestClaimModels setUp
FINE: toolsJarFile.exists()=false
Jul 27, 2011 5:21:15 PM com.carefirst.fep.local.commons.model.claim.TestClaimModels setUp
FINE: absPath=C:\Program Files\Java\jdk1.6.0_26\jre
Jul 27, 2011 5:21:15 PM com.carefirst.fep.local.commons.model.claim.TestClaimModels setUp
FINE: sfx=\jre
Jul 27, 2011 5:21:15 PM com.carefirst.fep.local.commons.model.claim.TestClaimModels setUp
FINE: absPath.endsWith(File.separator + ""jre"")=true
Jul 27, 2011 5:21:15 PM com.carefirst.fep.local.commons.model.claim.TestClaimModels setUp
FINE: javaHomeFile=C:\Program Files\Java\jdk1.6.0_26
Jul 27, 2011 5:21:15 PM com.carefirst.fep.local.commons.model.claim.TestClaimModels setUp
FINE: toolsJarFile=C:\Program Files\Java\jdk1.6.0_26\lib\tools.jar
Jul 27, 2011 5:21:15 PM com.carefirst.fep.local.commons.model.claim.TestClaimModels setUp
FINE: toolsJarFile.exists()=true
Jul 27, 2011 5:21:15 PM com.carefirst.fep.local.commons.model.claim.TestClaimModels$1 trace
FINE: JPA:org.apache.openjpa.enhance.InstrumentationFactory.getInstrumentation() _inst:sun.instrument.InstrumentationImpl@d8d9850 _dynamicallyInstall:true
Jul 27, 2011 5:21:15 PM com.carefirst.fep.local.commons.model.claim.TestClaimModels setUp
FINE: initialiazing openJPA javaagent... sun.instrument.InstrumentationImpl@d8d9850
Jul 27, 2011 5:21:15 PM com.carefirst.fep.local.commons.model.claim.TestClaimModels setUp
FINE: factory created


",XP 64bit Sun/Oracle JDK 64 bit 1.6.0_26,,,,,,,,,,,,,,,,,,28/Jul/11 14:34;mikedd;OPENJPA-2036.diff.txt;https://issues.apache.org/jira/secure/attachment/12488108/OPENJPA-2036.diff.txt,27/Jul/11 21:23;jpyeron;openjpa-enhancer-findtools-fix.jar;https://issues.apache.org/jira/secure/attachment/12488030/openjpa-enhancer-findtools-fix.jar,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2011-07-28 14:32:55.332,,,no_permission,,,,,,,,,,,,2290,,,Thu Feb 02 17:12:45 UTC 2012,,,Patch Available,,,,0|i0z0xz:,202455,,,,,,,,"27/Jul/11 21:23;jpyeron;sorry it is not in patch form, can patchify it on the weekend.",28/Jul/11 14:32;mikedd;I've taken the liberty of rewording the summary. Basically what the patch does is remove the check for the IBM JDK and unconditionally look for tools.jar in ${JAVA_HOME}/lib.,28/Jul/11 14:34;mikedd;Attaching patch based on the jar previously attached. ,"28/Jul/11 15:04;mikedd;Thanks for the patch. 

This change will show up in the nightly snapshots for 2.2.0. Please give one of them a try and let us know if it worked.",02/Feb/12 17:12;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,
Update H2 Database sql error codes as per the changes in v1.3.154,OPENJPA-2034,12514992,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,prashantbhat,prashantbhat,22/Jul/11 06:33,02/Feb/12 17:11,14/Mar/19 03:03,22/Jul/11 19:21,2.1.0,,,,,,,,2.2.0,,,,,jdbc,sql,,,0,,,,,,,,"SQL error state codes have been changed in H2 1.3.154 [1] With this change, many openjpa-jdbc-tests were failing. I've update the sql-error-state-codes.xml to use the correct codes, so it'll be great if the patch is reviewed and applied, Thanks.

Regards,
Prashant

[1] http://www.h2database.com/html/changelog.html",H2 v1.3.154 or higher,,,,,,,,,,,,,,,,,,22/Jul/11 17:43;prashantbhat;OPENJPA-2034.patch;https://issues.apache.org/jira/secure/attachment/12487458/OPENJPA-2034.patch,22/Jul/11 06:35;prashantbhat;OPENJPA-2034.patch;https://issues.apache.org/jira/secure/attachment/12487399/OPENJPA-2034.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2011-07-22 13:39:41.442,,,no_permission,,,,,,,,,,,,2292,,,Thu Feb 02 17:11:57 UTC 2012,,,Patch Available,,,,0|i0z0x3:,202451,,,,,,,,22/Jul/11 06:35;prashantbhat;Patch attached,"22/Jul/11 13:39;mikedd;Prashant, in the patch you removed some of the old state codes (e.g 23001 for object-exists).  Were these values correct for older versions of H2? 

What I'm getting at here is whether we can support the older versions of H2 with these changes.","22/Jul/11 17:43;prashantbhat;Yes, they were mostly working, except for locking tests. And it's good to keep the previous codes also, so the older H2 releases will still be supported. I've updated the patch accordingly. Thanks for the review.",22/Jul/11 19:21;mikedd;Thanks for the patch. The changes will show up in the next nightly snapshot for 2.2.0. ,02/Feb/12 17:11;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,
Metamodel genereated at runtime expects ListAttribute for all arrays - not just PersistentCollections. ,OPENJPA-2027,12513018,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,06/Jul/11 18:03,02/May/13 02:29,14/Mar/19 03:03,06/Jul/11 19:24,2.1.0,,,,,,,,2.2.0,,,,,,,,,0,,,,,,,,"This is the runtime portion of the problem reported in OPENJPA-2025. 

The problem here is that every array is treated as a list attribute. If the array is annotated with the @PersistentCollection annotation it makes sense to treat it like the other collection types, but in the case of an un-annotated byte[] (blob), or char[] (varchar), it makes more sense to use a SingularAttribute.  

",,,,,,,,,,,,,,OPENJPA-2060,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-04-18 17:08:41.345,,,no_permission,,,,,,,,,,,,2299,,,Thu Apr 18 17:08:41 UTC 2013,,,,,,,0|i0z0bz:,202356,,,,,,,,"18/Apr/13 17:08;jira-bot;Commit 1469452 from hthomann
[ https://svn.apache.org/r1469452 ]

OPENJPA-2027: Metamodel genereated at runtime expects ListAttribute for all arrays - not just PersistentCollections.  Back-ported Mike Dick's trunk changes to 2.1.x; made Compatibility property default to true.",,,,,,,,,,,,,,,,,,,,,,,,,,
"Byte[] and Char[] should be treated as SingularAttributes, not lists by the metamodel generator",OPENJPA-2025,12512342,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,30/Jun/11 16:09,02/Jul/13 19:43,14/Mar/19 03:03,06/Jul/11 19:24,2.1.0,,,,,,,,2.2.0,,,,,tooling,,,,0,,,,,,,,"Per discussion on the mailing list, the generated metamodel code treats all arrays as persistent collections. This does not make sense for byte[] or char[], but has merit for other types. ",,,,,,,,,,,,,,OPENJPA-2060,,,,OPENJPA-2027,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-07-06 19:46:55.414,,,no_permission,,,,,,,,,,,,2301,,,Tue Jul 02 19:43:09 UTC 2013,,,,,,,0|i1duov:,289069,,,,,,,,06/Jul/11 19:46;ppoddar@apache.org;Neat. I thought it would be more complex :),"31/Oct/11 14:41;kwsutter;As a reference, the mailing list discussion that created this JIRA is documented here:
http://openjpa.208410.n2.nabble.com/Metamodel-generates-ListAttribute-for-arrays-instead-of-SingularAttribute-tc6529049.html","17/Apr/13 23:18;jira-bot;Commit 1469097 from hthomann
[ https://svn.apache.org/r1469097 ]

OPENJPA-2025: Byte[] and Char[] should be treated as SingularAttributes, not lists by the metamodel generator  - merged Mike Dick's trunk changes to 2.1.x","28/Jun/13 16:55;jira-bot;Commit 1497841 from [~fyrewyld]
[ https://svn.apache.org/r1497841 ]

OPENJPA-2025: Add Compatibility option to AnnotationProcessor6 tool so that the default generated class can be processed cleanly by the default runtime processor","02/Jul/13 19:35;jpaheath;Hi Joe!  Thanks much for the Compatibility option to enable the code in AnnotationProcessor6.  As a user, how do I make use of this new option and the code gated by it? :)

Thanks,

Heath","02/Jul/13 19:43;fyrewyld;Add this to the javac command: -Aopenjpa.Compatibility=UseListAttributeForArrays={true or false}, ie.

-Aopenjpa.Compatibility=UseListAttributeForArrays=false",,,,,,,,,,,,,,,,,,,,,
Reversemappingtooltask with oracle is failing like in OPENJPA-1940 previous bug,OPENJPA-2022,12511536,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,semora,semora,25/Jun/11 18:55,06/Jun/15 14:24,14/Mar/19 03:03,17/Feb/14 20:39,2.1.0,2.1.1,2.2.0,,,,,,2.4.0,,,,,tooling,,,,1,,,,,,,,"When running either of the versions of the reversemappingtool as reported in the 1940 bug as fixed, i get the same error as in 2.1.0 :

[reversemappingtool] 2363  openjpa  INFO   [main] openjpa.Tool - ReverseMappingTool : generating classes.
[reversemappingtool] 2365  openjpa  INFO   [main] openjpa.MetaData - Table ""RMTOOLS.""AppUsers"""" could not be reverse mapped.  This means that the table does not have a primary key (primary keys are required to establish unique identifiers for all persistent objects) and does not match a known pattern for a table used for cross-reference or value collections.
[reversemappingtool] 2366  openjpa  INFO   [main] openjpa.MetaData - Table ""RMTOOLS.""CredentialTypes"""" could not be reverse mapped.  This means that the table does not have a primary key (primary keys are required to establish unique identifiers for all persistent objects) and does not match a known pattern for a table used for cross-reference or value collections.
[reversemappingtool] 2366  openjpa  INFO   [main] openjpa.MetaData - Table ""RMTOOLS.""Credentials"""" could not be reverse mapped.  This means that the table does not have a primary key (primary keys are required to establish unique identifiers for all persistent objects) and does not match a known pattern for a table used for cross-reference or value collections.

this happens for all my tables. Is it possible this bug was reintroduced?


thanks","Woking on a windows pc with a oracle 10g express database, eclipse helios, using oracle 11.2.0.2 driver. ",,,,,,,,,,,,,,,,,,20/Nov/13 06:47;jzwolak;OPENJPA-2022-trunk.patch;https://issues.apache.org/jira/secure/attachment/12614806/OPENJPA-2022-trunk.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-06-27 14:59:09.774,,,no_permission,,,,,,,,,,,,2304,,,Mon Feb 17 20:39:17 UTC 2014,,,,,,,0|i1dupj:,289072,,,,,,,,27/Jun/11 14:59;mikedd;Could you run the OpenJPAVersion command and post the results here. Also if you could post the DDL for one of the tables that can't be reverse mapped that might help us to narrow down the problem. ,"27/Jun/11 19:54;semora;Hi, my database is at home so i will have to get back to you for the DDL, 

however, here is the output of the openjpaversion...

     [java] OpenJPA 2.1.1-SNAPSHOT
     [java] version id: openjpa-2.1.1-SNAPSHOT-r422266:1134440
     [java] Apache svn revision: 422266:1134440
     [java] os.name: Windows 7
     [java] os.version: 6.1
     [java] os.arch: x86
     [java] java.version: 1.6.0
     [java] java.vendor: IBM Corporation
     [java] java.class.path:
     [java] 	C:\Data\workspace\openJPADBMapping
     [java] 	C:\Data\workspace\openJPADBMapping\lib\ojdbc6.jar
     [java] 	C:\Data\workspace\openJPADBMapping\lib\openjpa-all-2.1.1-SNAPSHOT.jar
     [java] user.dir: C:\Data\workspace\openJPADBMapping\src","28/Jun/11 01:16;semora;here is the ddl for 3 of my tables

ALTER TABLE RMTOOLS.""AppUsers""
 DROP PRIMARY KEY CASCADE;
DROP TABLE RMTOOLS.""AppUsers"" CASCADE CONSTRAINTS;

CREATE TABLE RMTOOLS.""AppUsers""
(
  ""AppUser""        NUMBER(12)                   NOT NULL,
  ""Name""           VARCHAR2(100 BYTE)           NOT NULL,
  ""Email""          VARCHAR2(100 BYTE)           NOT NULL,
  ""Creation_Date""  DATE                         NOT NULL,
  ""pager""          VARCHAR2(100 BYTE),
  ""LDAPuserId""     VARCHAR2(100 BYTE)           NOT NULL,
  ""Active""         VARCHAR2(5 BYTE)             NOT NULL
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;


CREATE UNIQUE INDEX RMTOOLS.""Key8"" ON RMTOOLS.""AppUsers""
(""AppUser"")
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
NOPARALLEL;


ALTER TABLE RMTOOLS.""AppUsers"" ADD (
  CONSTRAINT ""Key8""
 PRIMARY KEY
 (""AppUser"")
    USING INDEX 
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
               ));



ALTER TABLE RMTOOLS.""Credentials""
 DROP PRIMARY KEY CASCADE;
DROP TABLE RMTOOLS.""Credentials"" CASCADE CONSTRAINTS;

CREATE TABLE RMTOOLS.""Credentials""
(
  CREDENTIAL        NUMBER(12),
  USERNAME          VARCHAR2(50 BYTE) CONSTRAINT SYS_C004201 NOT NULL,
  PASSWORD          VARCHAR2(50 BYTE),
  KEY               VARCHAR2(200 BYTE),
  LABEL             VARCHAR2(25 BYTE),
  ""CredentialType""  NUMBER(12)                  NOT NULL
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;


CREATE UNIQUE INDEX RMTOOLS.CREDENTIALS_PK ON RMTOOLS.""Credentials""
(CREDENTIAL)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
NOPARALLEL;


CREATE UNIQUE INDEX RMTOOLS.SYS_C004204 ON RMTOOLS.""Credentials""
(LABEL)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
NOPARALLEL;


ALTER TABLE RMTOOLS.""Credentials"" ADD (
  CONSTRAINT CREDENTIALS_PK
 PRIMARY KEY
 (CREDENTIAL)
    USING INDEX 
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
               ),
  CONSTRAINT SYS_C004204
 UNIQUE (LABEL)
    USING INDEX 
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
               ));

ALTER TABLE RMTOOLS.""Credentials"" ADD (
  CONSTRAINT ""Relationship12"" 
 FOREIGN KEY (""CredentialType"") 
 REFERENCES RMTOOLS.""CredentialTypes"" (""CredentialType""));



ALTER TABLE RMTOOLS.""CredentialTypes""
 DROP PRIMARY KEY CASCADE;
DROP TABLE RMTOOLS.""CredentialTypes"" CASCADE CONSTRAINTS;

CREATE TABLE RMTOOLS.""CredentialTypes""
(
  ""CredentialType""  NUMBER(12)                  NOT NULL,
  ""Label""           VARCHAR2(100 BYTE),
  ""Type""            VARCHAR2(100 BYTE)          NOT NULL
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;


CREATE UNIQUE INDEX RMTOOLS.""Key2"" ON RMTOOLS.""CredentialTypes""
(""CredentialType"")
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
NOPARALLEL;


ALTER TABLE RMTOOLS.""CredentialTypes"" ADD (
  CONSTRAINT ""Key2""
 PRIMARY KEY
 (""CredentialType"")
    USING INDEX 
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
               ));
","28/Jun/11 14:56;mikedd;Do you specify the schemas and table names when you invoke the reverse mapping tool? 

There's definitely a problem here - I'm not sure it's the same problem as 1940, or if something has changed upstream that prevents the code I changed in 1940 from executing though. ","29/Jun/11 01:02;semora;I use an ant task and i added the schema name in my persistence.xml 

here is my build.xml : 

<?xml version=""1.0"" encoding=""UTF-8""?>
<project name=""rmtools"" default=""reverse-map-schema"">
       	<path id=""classpath""
    	        description=""The classpath to use for compiling and running"">
    	        <pathelement path=""../""/>
    	        <fileset  dir=""../"">
    	            <include name=""lib/openjpa-all-2.1.1-SNAPSHOT.jar""/>
    	            <include name=""lib/ojdbc6.jar""/>
    	        </fileset>
    	    </path>
    <target name=""reverse-map-schema"" description=""Generate java files from the database schema"">
    	
    	<java fork=""true"" failonerror=""yes"" classname=""org.apache.openjpa.conf.OpenJPAVersion"" classpathref=""classpath""/>
        <!-- now run the tool to generate java files from the db schema -->
        <taskdef name=""reversemappingtool"" classpathref=""classpath"" classname=""org.apache.openjpa.jdbc.ant.ReverseMappingToolTask""/>
        <reversemappingtool package=""com.rmtools.util.dao"" directory=""../src"" innerIdentityClasses=""true"">
              <codeformat tabSpaces=""4"" spaceBeforeParen=""false"" braceOnSameLine=""true""/>
        </reversemappingtool>
	
     
    </target>
</project>


here is my persistence.xml  :

<?xml version=""1.0"" encoding=""UTF-8""?>
<persistence xmlns=""http://java.sun.com/xml/ns/persistence""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
    version=""1.0"">
  <persistence-unit name=""openjpa"">
    <provider>org.apache.openjpa.persistence.PersistenceProviderImpl</provider>
 <class>com.rmtools.dao.beans.AppUsers</class>
 
    <properties>
      <property name=""openjpa.ConnectionURL"" value=""jdbc:oracle:thin:@192.168.1.102:1521:xe""/>
      <property name=""openjpa.ConnectionDriverName"" value=""oracle.jdbc.OracleDriver""/>
      <property name=""openjpa.ConnectionUserName"" value=""xxxx""/>
      <property name=""openjpa.ConnectionPassword"" value=""xxxx""/>
      <property name=""openjpa.jdbc.Schema"" value=""rmtools""/>
      <property name=""openjpa.Log"" value=""DefaultLevel=TRACE, Tool=TRACE,org.apache.openjpa.jdbc.Schema=TRACE""/>
    </properties>
  </persistence-unit>
</persistence>


",29/Jun/11 17:33;sujua;I get the same error on 2.0.1. Is there a target version where this will be fixed?,"30/Jun/11 02:59;mikedd;I didn't get a chance to look at this today, and I don't have access to Oracle from home. For a target version it really depends on what the fix is. At a bare minimum it'll be fixed in a 2.2.0 nightly build. ",03/Feb/12 16:54;allee8285;Move fix version to 2.3.0 in preparation for 2.2.0 release.,"12/Nov/13 20:12;jzwolak;I'm also having this same issue in 2.2.2, 2.2.0, 2.1.1, and 2.3.0-snapshot (Oct 24th, 2013).

Here's the DDL and the OpenJPA generated schema.xml for one table (this schema.xml was generated with the 2.3.0 snapshot, but I'm pretty sure it looks identical for 2.2.2, 2.2.0, and 2.1.1).

SCHEMA:
{code}
        <table name=""MODELS"">
            <column name=""MODEL_ID"" type=""decimal"" type-name=""NUMBER"" not-null=""true"" size=""22""/>
            <column name=""MODEL_DESCRIPTION"" type=""varchar"" type-name=""VARCHAR2"" not-null=""true"" size=""240""/>
            <column name=""PERSON_ID"" type=""decimal"" type-name=""NUMBER"" not-null=""true"" size=""22""/>
            <column name=""VERSION_NUM"" type=""decimal"" type-name=""NUMBER"" size=""22""/>
            <column name=""VERSION_DESC"" type=""varchar"" type-name=""VARCHAR2"" size=""80""/>
            <column name=""VERSION_DATE"" type=""timestamp"" type-name=""DATE"" default=""sysdate"" size=""7""/>
            <column name=""LOCK_FLAG"" type=""varchar"" type-name=""VARCHAR2"" size=""1""/>
            <column name=""BASE_MODEL_ID"" type=""decimal"" type-name=""NUMBER"" size=""22""/>
            <column name=""PRIVATE_FLAG"" type=""varchar"" type-name=""VARCHAR2"" size=""1""/>
            <column name=""SECURITY_LEVEL"" type=""decimal"" type-name=""NUMBER"" size=""22""/>
            <column name=""LAST_MODIFIED"" type=""timestamp"" type-name=""TIMESTAMP(6)"" default=""sysdate"" size=""11"" decimal-digits=""6""/>
            <fk name=""MODL_MODL_FK"" delete-action=""restrict"" to-table=""PROCESSDB_DEV.MODELS"" column=""BASE_MODEL_ID""/>
            <fk name=""MODL_PERS_FK"" delete-action=""restrict"" to-table=""PROCESSDB_DEV.PERSONS"" column=""PERSON_ID""/>
            <index name=""MODL_PERS_FK_I"" column=""PERSON_ID""/>
            <index name=""MODL_PK"" unique=""true"" column=""MODEL_ID""/>
        </table>
{code}

DDL:
{code}
  CREATE TABLE ""PROCESSDB_DEV"".""MODELS"" 
   (	""MODEL_ID"" NUMBER NOT NULL ENABLE, 
	""MODEL_DESCRIPTION"" VARCHAR2(240 BYTE) NOT NULL ENABLE, 
	""PERSON_ID"" NUMBER NOT NULL ENABLE, 
	""VERSION_NUM"" NUMBER, 
	""VERSION_DESC"" VARCHAR2(80 BYTE), 
	""VERSION_DATE"" DATE DEFAULT sysdate, 
	""LOCK_FLAG"" VARCHAR2(1 BYTE), 
	""BASE_MODEL_ID"" NUMBER, 
	""PRIVATE_FLAG"" VARCHAR2(1 BYTE), 
	""SECURITY_LEVEL"" NUMBER, 
	""LAST_MODIFIED"" TIMESTAMP (6) DEFAULT sysdate, 
	 CONSTRAINT ""MODL_PK"" PRIMARY KEY (""MODEL_ID"")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE ""USERS""  ENABLE, 
	 CONSTRAINT ""MODL_MODL_FK"" FOREIGN KEY (""BASE_MODEL_ID"")
	  REFERENCES ""PROCESSDB_DEV"".""MODELS"" (""MODEL_ID"") ENABLE NOVALIDATE, 
	 CONSTRAINT ""MODL_PERS_FK"" FOREIGN KEY (""PERSON_ID"")
	  REFERENCES ""PROCESSDB_DEV"".""PERSONS"" (""PERSON_ID"") ENABLE NOVALIDATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE ""USERS"" ;

  CREATE INDEX ""PROCESSDB_DEV"".""MODL_PERS_FK_I"" ON ""PROCESSDB_DEV"".""MODELS"" (""PERSON_ID"") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE ""USERS"" ;
{code}","20/Nov/13 06:47;jzwolak;This patch fixed the problem for me.  Based on the comments in this issue, I think my problem is the same as the original issue reported, but I cannot test for the original reporter.

The problem is on line 695 of org.apache.openjpa.jdbc.schema.SchemaGenerator

which starts the primary key generation and looks like
schemaName = DBIdentifier.trimToNull(schemaName);

But should look more like the code for indices (line 760) and foreign keys:
schemaName = DBIdentifier.trimToNull(idxs[i].getSchemaIdentifier());","13/Feb/14 18:33;ayl2;The attached patch also worked for me. Why hasn't it been applied to trunk?

https://svn.apache.org/repos/asf/openjpa/trunk/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","17/Feb/14 20:38;jira-bot;Commit 1569106 from [~curtisr7] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1569106 ]

OPENJPA-2022 : Minor change to SchemaGenerator. Patch contributed by Jason Zwolak.",17/Feb/14 20:39;curtisr7;Committed revision 1569106 to trunk. Thanks for the patch Jason.,,,,,,,,,,,,,,
Cannot bind String[] to ParameterExpression for path.in(parameter),OPENJPA-2018,12510474,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,oliver.gierke,oliver.gierke,15/Jun/11 17:08,27/May/16 13:46,14/Mar/19 03:03,28/Oct/13 18:49,2.1.0,,,,,,,,2.3.0,,,,,jpa,,,,1,binding,criteria_api,jpa,,,,,"Given the following code:
{code}
User user = new User(""Dave"", ""Matthews"", ""foo@bar.de"");
em.persist(user);
em.flush();

CriteriaBuilder builder = em.getCriteriaBuilder();

CriteriaQuery<User> criteria = builder.createQuery(User.class);
Root<User> root = criteria.from(User.class);
criteria.where(root.get(""firstname"").in(builder.parameter(String[].class)));

TypedQuery<User> query = em.createQuery(criteria);
for (ParameterExpression parameter : criteria.getParameters()) {
  query.setParameter(parameter, new String[] {""Dave"", ""Carter""});
}

List<User> result = query.getResultList();
assertThat(result.isEmpty(), is(false));
{code}

I get a

{code}
<openjpa-2.0.0-r422266:935683 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: The specified parameter of type ""class [Ljava.lang.String;"" is not a valid query parameter.
{code}

Using {{Collection}} as {{ParameterExpression}} type and binding the parameters via {{Arrays.asList(...)}} works fine.",,,,,,,,,,,,,,,,,,,23/Oct/13 21:12;romain.manni-bucau;OPENJPA-2018-test-update.patch;https://issues.apache.org/jira/secure/attachment/12609921/OPENJPA-2018-test-update.patch,28/Oct/13 15:05;struberg;OPENJPA-2018-test2.patch;https://issues.apache.org/jira/secure/attachment/12610572/OPENJPA-2018-test2.patch,25/Oct/13 14:33;romain.manni-bucau;OPENJPA-2018-with-array.patch;https://issues.apache.org/jira/secure/attachment/12610323/OPENJPA-2018-with-array.patch,23/Oct/13 06:37;romain.manni-bucau;OPENJPA-2018.patch;https://issues.apache.org/jira/secure/attachment/12609811/OPENJPA-2018.patch,25/Oct/13 15:17;romain.manni-bucau;missingpatch.patch;https://issues.apache.org/jira/secure/attachment/12610328/missingpatch.patch,22/Oct/13 15:49;oliver.gierke;openjpa-2018.zip;https://issues.apache.org/jira/secure/attachment/12609672/openjpa-2018.zip,,,,,,,6.0,,,,,,,,,,,,,,,,,,,2013-10-22 15:21:33.813,,,no_permission,,,,,,,,,,,,2308,,,Fri May 27 13:46:17 UTC 2016,,,,,,,0|i1dupz:,289074,,,,,,,,"02/Feb/12 17:07;oliver.gierke;It does not seem to work with collections as well:

CriteriaBuilder builder = em.getCriteriaBuilder();

CriteriaQuery<User> criteriaQuery = builder.createQuery(User.class);
Root<User> root = criteriaQuery.from(User.class);
criteriaQuery.where(root.<Integer> get(""id"").in(builder.parameter(Collection.class)));

TypedQuery<User> query = em.createQuery(criteriaQuery);
for (Parameter parameter : query.getParameters()) {
	query.setParameter(parameter, Arrays.asList(1, 2));
}

List<User> resultList = query.getResultList();

This fails with:

<openjpa-2.0.0-r422266:935683 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Filter invalid. Cannot compare field id of type java.lang.Integer to value of type java.util.Collection. Numeric comparisons must be between numeric types only. To enable such comparisons for backwards-compatibility, add ""QuotedNumbersInQueries=true"" to the org.apache.openjpa.Compatibility setting in your configuration.

Tried against 2.0 as well as 2.1. Don't quite get why OpenJPA tries to compare the integer against the collection instead of its values.",22/Oct/13 13:17;oliver.gierke;Any update here? This ticket is more than 2 years old and effectively a violation of the spec.,"22/Oct/13 15:21;romain.manni-bucau;Hi Olivier,

do you care attaching a sample with a failling test reproducing it? (seems you have it not that far)",22/Oct/13 15:49;oliver.gierke;Sample project to show binding fail with both arrays and a collection. Run mvn clean test to see it fail.,"23/Oct/13 06:37;romain.manni-bucau;Proposed patch

@Olivier: thank you for the sample, it really helps","23/Oct/13 19:41;curtisr7;My only comment on the patch is in regards to the unit test. For future reference, don't use openjpa.RuntimeUnenhancedClasses. That is a very buggy feature and we really should be discouraging usage of it. Also try to follow the test case pattern outlined by SingleEMTestCase / SingleEMFTestCase. This way you'll get enhancement for free, and the test will work across all of the different supported databases.","23/Oct/13 21:12;romain.manni-bucau;updating the test.

Note: I kept supported for runtime unenhancedclass cause ATM the parent is not hacking classloaders to do enhancement in test (it relies on mvn AFAIK) so it is not easy to work on tests without it and for this test this is enough.",23/Oct/13 21:23;curtisr7;When developing/running unit tests in your IDE you can use the javaagent and when the tests are run with maven the Entities will be enhanced as part of the build. ,25/Oct/13 14:33;romain.manni-bucau;Same patch with a better handling of array in all cases (was working with the sample of Olivier but not with the bind using a name/position case),"25/Oct/13 15:13;jira-bot;Commit 1535760 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1535760 ]

OPENJPA-2018 correctly handle select IN with arrays

txs to rmannibucau for the patch.
Applied with minor changes",25/Oct/13 15:17;romain.manni-bucau;missingpatch.patch is a diff between what Mark applied and what was in my last patch to handle array too in all cases,"25/Oct/13 18:51;jira-bot;Commit 1535816 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1535816 ]

OPENJPA-2018  correctly handle select IN with arrays

txs to rmannibucau for the patch.
Applied with minor changes","25/Oct/13 19:00;curtisr7;[~struberg] -- It looks like you committed an earlier version of Romain's patch, but I still have a couple issues with it (the latest version).

+            ""javax.persistence.provider"", PersistenceProviderImpl.class.getName(),
+            ""openjpa.RuntimeUnenhancedClasses"", ""supported"",
+            ""openjpa.ConnectionURL"", ""jdbc:derby:memory:openjpa2018;create=true"",
+            ""openjpa.ConnectionDriverName"", ""org.apache.derby.jdbc.EmbeddedDriver"");
+        em = emf.createEntityManager();

#1) RuntimeUnenhancedClasses is a feature we always tell users to stay away from. We should NEVER condone it's usage. It is buggy, and should have never made it into the codebase.

#2) Don't specify database connection details in the test setup method. These properties will be passed in at runtime via Maven, or if running in Eclipse, via SystemProperties. 

#3) You shouldn't need to specify the persistence provider implementation class.

","25/Oct/13 19:19;struberg;agree, slipped through. Will fix it.","25/Oct/13 19:40;jira-bot;Commit 1535838 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1535838 ]

OPENJPA-2018 improve unit test setup","25/Oct/13 19:45;jira-bot;Commit 1535839 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1535839 ]

OPENJPA-2018 improve unit test setup","26/Oct/13 20:59;jira-bot;Commit 1536036 from [~allee8285] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1536036 ]

OPENJPA-2018 add svn:eol-style=native property","27/Oct/13 09:53;struberg;Romain, your latest patch uses  Literal.TYPE_COLLECTION for arrays. 
I fear this is not a valid approach as the other direction also is used in our codebase.

e.g. in criteria.Expressions line 1486 (toKernelExpression) there is still 

{code}
.. else if (((Literal)val2).getParseType() == Literal.TYPE_COLLECTION) {
     Collection coll = (Collection)((Literal)val2).getValue();
{code}

Of course we can just do n instanceof but I think this is kind of dirty. I wonder whether we should introduce a dedicated Literal.TYPE_ARRAY to make the code cleaner.","28/Oct/13 15:05;struberg;also add a few tests for JPQL to make sure we broke nothing. 
Wonder if this did work in the past ...","28/Oct/13 17:43;jira-bot;Commit 1536439 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1536439 ]

OPENJPA-2018 fix handling of Arrays in Select IN statements","28/Oct/13 17:59;jira-bot;Commit 1536453 from [~struberg] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1536453 ]

OPENJPA-2018 fix handling of Arrays in Select IN statements",28/Oct/13 18:16;struberg;would be happy about a review. The latest sources from trunk and 2.3.x should both fix the issues.,"07/Mar/14 17:05;oliver.gierke;This still seems to be broken for in 2.3.0 in case you refer to the parameter by name. This works:

CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<User> criteriaQuery = builder.createQuery(User.class);
Root<User> root = criteriaQuery.from(User.class);
ParameterExpression<Collection> parameter = builder.parameter(Collection.class);
criteriaQuery.where(root.<Integer> get(""id"").in(parameter));
TypedQuery<User> query = em.createQuery(criteriaQuery);
query.setParameter(parameter, Arrays.asList(1, 2));
List<User> resultList = query.getResultList();

this doesn't:

CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<User> criteriaQuery = builder.createQuery(User.class);
Root<User> root = criteriaQuery.from(User.class);
criteriaQuery.where(root.<Integer> get(""id"").in(builder.parameter(Collection.class, ""ids"")));
TypedQuery<User> query = em.createQuery(criteriaQuery);
query.setParameter(""ids"", Arrays.asList(1, 2));
List<User> resultList = query.getResultList();

The latter again fails with the exception:

Filter invalid. Cannot compare field id of type java.lang.Integer to value of type java.util.List. Numeric comparisons must be between numeric types only. To enable such comparisons for backwards-compatibility, add ""QuotedNumbersInQueries=true"" to the org.apache.openjpa.Compatibility setting in your configuration.; nested exception is <openjpa-2.3.0-r422266:1540826 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Filter invalid. Cannot compare field id of type java.lang.Integer to value of type java.util.Collection. Numeric comparisons must be between numeric types only. To enable such comparisons for backwards-compatibility, add ""QuotedNumbersInQueries=true"" to the org.apache.openjpa.Compatibility setting in your configuration.","09/Jan/15 17:20;jira-bot;Commit 1650604 from [~struberg] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1650604 ]

OPENJPA-2018 improve readability",27/May/16 12:24;oliver.gierke;I'd like to remove the workaround we have in Spring Data JPA for this bug. Should we reopen this one or create a new ticket? See my comment above from two years ago.,27/May/16 13:46;romain.manni-bucau;[~oliver.gierke] please reopen a new one (you can just reference this one and copy your last comment) to ensure we track versions properly,
ClassCastException when base entity class has InheritanceType.SINGLE_TABLE base with multiple entity subclasses,OPENJPA-2015,12509757,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,09/Jun/11 20:04,11/Jan/12 19:45,14/Mar/19 03:03,09/Jun/11 20:12,1.2.2,1.2.3,,,,,,,1.2.3,,,,,jpa,,,,0,,,,,,,,"If multiple entity subclasses extends a entity base class using InheritanceType.SINGLE_TABLE, with mx1 relation from base class to itself, a ClassCastException may occur when the mx1 collection is not empty due to a problem in discriminating the proper entity subclass type.

Caused by: java.lang.ClassCastException: problem.domain.InputItemRecord
	at problem.domain.InputBatchHeaderRecord.pcReplaceField(InputBatchHeaderRecord.java)
	at org.apache.openjpa.kernel.StateManagerImpl.replaceField(StateManagerImpl.java:3041)
	at org.apache.openjpa.kernel.StateManagerImpl.storeObjectField(StateManagerImpl.java:2473)
	at org.apache.openjpa.kernel.StateManagerImpl.storeObject(StateManagerImpl.java:2463)
	at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.loadEagerJoin(RelationFieldStrategy.java:541)
	at org.apache.openjpa.jdbc.meta.FieldMapping.loadEagerJoin(FieldMapping.java:807)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1052)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1012)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:378)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:278)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:913)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:871)
	... 38 more

For example:

@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = ""DISCRIMATOR"", discriminatorType = DiscriminatorType.INTEGER)
@DiscriminatorValue(""99"")
public class NachaInputRecord {

    @Id
    public long identifier;
   
    @ManyToOne(cascade = CascadeType.MERGE,fetch=FetchType.EAGER)
    @ForeignKey
    @JoinColumn(name = ""PARENT_ID"")
    private NachaInputRecord parent;
....

@Entity
@DiscriminatorValue(""6"")
public class InputItemRecord extends NachaInputRecord {
.....

@Entity
@DiscriminatorValue(""8"")
public class InputBatchControlRecord extends NachaInputRecord {
.....",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2311,,,2011-06-09 20:04:21.0,,,,,,,0|i1duqn:,289077,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
columnDefinition for TEXT types ends up in wrong sql statement,OPENJPA-2013,12509670,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,mikedd,jhohlfeld,jhohlfeld,09/Jun/11 06:52,13/Jul/11 16:11,14/Mar/19 03:03,09/Jun/11 14:58,2.1.0,,,,,,,,2.2.0,,,,,jpa,sql,,,0,@Column,columnDefinition,jpa,,,,,"When using Hsqldb or Derby in in-memory mode, the generated create statements wil be using a dimension declaration on columns with type TEXT, which seems to be invalid.

Entity definition:
[...]
@Column(columnDefinition = ""TEXT"")
public String getText() {
    return text;
}
[...]

OpenJPA hsqldb TRACE:
807  relege-testcycle  TRACE  [main] openjpa.jdbc.SQL - <t 1227469025, conn 2083747981> executing stmnt 389001391 CREATE TABLE houses_descriptions (id INTEGER NOT NULL, locale VARCHAR(5), name VARCHAR(255), text TEXT(255), house_id INTEGER, PRIMARY KEY (id))

Testing this with a MySQL DB (5.1), the problem does not occur. Here, sql create statements are formed without the dimension declaration on TEXT types:

OpenJPA mysql TRACE:
1017  relege-development  TRACE  [main] openjpa.jdbc.SQL - <t 1372096729, conn 680220284> executing stmnt 1406860207 CREATE TABLE houses_descriptions (id INTEGER NOT NULL, locale VARCHAR(5), name VARCHAR(255), text TEXT, house_id INTEGER, PRIMARY KEY (id)) TYPE = innodb
","Ubuntu Natty (11.04), JDK 6",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-06-09 14:58:27.171,,,no_permission,,,,,,,,,,,,2313,,,Thu Jun 09 14:58:27 UTC 2011,,,,,,,0|i0ywmf:,201755,,,,,,,,09/Jun/11 14:58;mikedd;Fixed in trunk. Should be in the nightly snapshots tomorrow. ,,,,,,,,,,,,,,,,,,,,,,,,,,
Prevent reparsing annotation metadata for queries,OPENJPA-2011,12509650,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,08/Jun/11 22:06,27/Jul/11 21:32,14/Mar/19 03:03,27/Jul/11 21:32,2.0.1,2.1.0,,,,,,,2.0.2,2.1.2,2.2.0,,,query,,,,0,,,,,,,,Re-parsing entity annotations when processing query meta data can override mapping information from an XML mapping file. Adding a compatibility option to disable this processing resolves the problem.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2315,,,2011-06-08 22:06:43.0,,,,,,,0|i0z0dr:,202364,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Duplicate meta data warning logged due to parsing the same location twice,OPENJPA-2010,12509634,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,08/Jun/11 20:10,27/Jul/11 19:09,14/Mar/19 03:03,27/Jul/11 19:09,2.0.1,2.1.0,,,,,,,2.0.2,2.1.2,2.2.0,,,kernel,,,,0,,,,,,,,"I've only seen this when entities are defined in an XML mapping file, and then only in some difficult to replicate classloader environments.

The same XML mapping file may be parsed more than one time, resulting in a misleading warning message about duplicate metadata. The metadata is in fact identical, and does not indicate a problem. 

To detect this condition we can store the source file and line number where the meta data was defined, and only issue the warning if the metadata is defined in a different location. 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2316,,,2011-06-08 20:10:10.0,,,,,,,0|i0z0b3:,202352,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA does not work with native queries in a distributed (Slice) environment,OPENJPA-2008,12509380,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,chaos907,chaos907,06/Jun/11 19:13,02/Feb/12 17:10,14/Mar/19 03:03,08/Aug/11 18:40,2.1.0,,,,,,,,2.2.0,,,,,slice,,,,1,,,,,,,,"When trying to create a native query in a distributed (slice) environment, an exception is thrown because there is no ExpressionParser for language openJPA.SQL for a distributed query.","Slice, Tomcat 6, MySql 5.5, openJPA 2.1",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-02-02 17:10:34.589,,,no_permission,,,,,,,,,,,,2318,,,Thu Feb 02 17:10:34 UTC 2012,,,,,,,0|i0zbxb:,204234,,,,,,,,"08/Aug/11 18:40;chaos907;Issue has been resolved in revision 1135806.

Tested with the following query and the query worked, count works, and sorting works:

SELECT DISTINCT u.uid, u.studentid, u.firstname, u.lastname, u.username, u.lastlogintime, count(DISTINCT e.uid) FROM roles r
    INNER JOIN userroles ur ON ur.roleID = r.uid
    INNER JOIN users u ON ur.userID = u.uid
    AND r.namefield IN (?1)
    AND u.lastname LIKE ?2
    AND u.firstname LIKE ?3
    AND u.studentid LIKE ?4
    AND u.isactive IS TRUE
    LEFT JOIN courseenrollments e ON e.userID = u.uid
    AND e.schoolyearID = ?5
    AND e.enddate IS NULL
GROUP BY u.uid, u.studentid, u.firstname, u.lastname, u.username, u.lastlogintime
ORDER BY u.uid",02/Feb/12 17:10;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,,
"Setting query hint ""openjpa.FetchPlan.Isolation"" results in misleading warning",OPENJPA-2007,12508346,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,techhusky,techhusky,techhusky,25/May/11 19:51,02/Feb/12 17:10,14/Mar/19 03:03,26/May/11 17:58,2.0.0,2.0.1,2.1.0,2.2.0,,,,,2.2.0,,,,,jdbc,,,,0,,,,,,,,"Setting query hint ""openjpa.FetchPlan.Isolation"" on a query results in this misleading warning being printed in the log:

WARN   [main] openjpa.Runtime - ""openjpa.FetchPlan.Isolation"" is not a supported query hint. May be you meant ""openjpa.FetchPlan.LRSSize""?

The supported hint map in JDBCPersistenceProductDerivation adds key openjpa.FetchPlan.TransactionIsolation, which is incorrect.  It should be adding openjpa.FetchPlan.Isolation instead.

Note: Even though a warning is issued, provided the database supports query-level isolation level switching, the hint handler does apply the isolation level to the query.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-02-02 17:10:11.23,,,no_permission,,,,,,,,,,,,2319,,,Thu Feb 02 17:10:11 UTC 2012,,,,,,,0|i1durb:,289080,,,,,,,,25/May/11 21:36;techhusky;Still working on a jUnit for this issue.  It is quirky since the behavior change is primarily the absence of a warning in the log.,26/May/11 17:58;techhusky;Fixed in trunk.,02/Feb/12 17:10;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,
Sequence generated ids may fail to get assigned when flushing a graph with bi-directional relationships,OPENJPA-2006,12508321,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,25/May/11 14:59,03/Feb/12 17:08,14/Mar/19 03:03,03/Feb/12 17:07,1.2.2,2.1.0,2.2.0,,,,,,1.2.3,2.0.2,2.1.2,2.2.0,,kernel,,,,0,,,,,,,,"Flushing a multi-level graph with many bi-directional relationships can result in SQL exceptions due to sequence-generated IDs of some leaf entities not getting assigned during pre-flush.  Sequence-generated id's require an additional ID population step which happens during pre-flush.  OpenJPA's state transitioning during a pre-flush can fail to pre-flush child entities when certain bi-directional traversals occur.  The proposed fix is if flushing, perform the pre-flush on entities that may have moved from provisional to new state (as a result of a previous traversal) without being properly pre-flushed.  If the entity was previously pre-flushed, it will have been tagged as such and the operation will simply return.  Otherwise, it'll pre-flush the entity and all child entities, generating IDs in the process.  On Oracle, the SQL exception below is a symptom of the problem.  An ID has not been assigned to an entity and as a result, OpenJPA is attempting to insert NULL into an ID field.

Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: ORA-01400: cannot insert NULL into (""SCOTT"".""FL_ASSIGN"".""ASSIGN_ID"")
 {prepstmnt 577905266 INSERT INTO FL_ASSIGN (ASSIGN_ID, ASSIGN_TEXT, TOPIC_ID) VALUES (?, ?, ?) [params=?, ?, ?]} [code=1400, state=23000]",,,,,,,,,,,,,,,,,,,25/May/11 16:29;techhusky;OPENJPA-2006.1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12480425/OPENJPA-2006.1.2.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2320,,,Wed May 25 16:29:13 UTC 2011,,,,,,,0|i1durj:,289081,,,,,,,,25/May/11 16:29;techhusky;Attaching patch for 1.2.x stream.,,,,,,,,,,,,,,,,,,,,,,,,,,
PostgresDictionary.isOwnedSequence needs a null check,OPENJPA-2005,12508229,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mlilback,mlilback,24/May/11 18:24,13/Jul/11 16:11,14/Mar/19 03:03,26/May/11 13:29,2.1.0,,,,,,,,2.2.0,,,,,jdbc,,,,0,,,,,,,,"In PostgresDictionary.java, Line 430 calls buildNames(strName) to get a String[][]. Right below this, a for loop references namePairs.length. However, buildNames can return null, which results in a NullPointerException. While this is inside a try/catch, it still fills my logs up with warning messages (10 stack traces at launch for a single table with a sequence). Skipping the loop when namePairs is null would solve this.",,300,300,,0%,300,300,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-05-25 14:00:29.095,,,no_permission,,,,,,,,,,,,2321,,,Thu May 26 13:29:15 UTC 2011,,,,,,,0|i1durr:,289082,,,,,,,,25/May/11 14:00;mikedd;Thanks for reporting this. Do you have an example of what strName is when you get the failure? ,26/May/11 13:29;mikedd;Just checked in the changes to trunk. If you enable trace logging you'll still see some messages - but at least they won't include the stack trace. If having trace messages is an issue reopen the JIRA and I'll remove at least one of them. ,,,,,,,,,,,,,,,,,,,,,,,,,
"Wrong PostgreSQL data type for REAL - ""float8"", must be ""float4""",OPENJPA-2000,12507216,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,jtnowosatka,s.mironov,s.mironov,14/May/11 11:40,02/Feb/12 17:09,14/Mar/19 03:03,21/Jul/11 21:58,2.1.0,,,,,,,,2.2.0,,,,,jdbc,sql,,,0,,,,,,,,"In PostgresDictionary type names for SQL REAL and DOUBLE types are specified as:
        realTypeName = ""FLOAT8"";
        doubleTypeName = ""DOUBLE PRECISION"";
From PostgreSQL manual:
double precision: float8, double precision floating-point number (8 bytes)
real: float4, single precision floating-point number (4 bytes)

realTypeName must be ""FLOAT4"".",PostgreSQL,300,300,,0%,300,300,,,,,,,,,,,,21/Jul/11 15:24;jtnowosatka;OPENJPA-2000.patch;https://issues.apache.org/jira/secure/attachment/12487313/OPENJPA-2000.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-07-21 15:24:09.65,,,no_permission,,,,,,,,,,,,2326,,,Thu Feb 02 17:09:41 UTC 2012,,,,,,,0|i1dusv:,289087,,,,,,,,21/Jul/11 15:24;jtnowosatka;Attached patch changes realTypeName to FLOAT4,21/Jul/11 21:58;mikedd;Thanks for the patch. ,02/Feb/12 17:09;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA Samples fail on MacOS X,OPENJPA-1996,12506760,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,fyrewyld,fyrewyld,fyrewyld,10/May/11 19:37,15/Sep/16 14:28,14/Mar/19 03:03,11/Jul/11 15:22,2.1.0,,,,,,,,1.2.3,2.0.2,2.1.1,2.2.0,,samples,,,,0,,,,,,,,"It was reported on the OpenJPA User Forum that the samples were not working on the MacOS X architecture.  I downloaded a copy and gave it a ran, and sure enough, it did not work.  Basically, the problem was in the derby build itself, which attempted to load sun/security/pkcs11/SunPKCS11 and the MacOS X version of the class is apparently different enough from the version Derby was built against to be incompatible causing the LinkageError that I noted in the derby log:

java.lang.LinkageError: loader (instance of  sun/misc/Launcher$ExtClassLoader): attempted  duplicate class definition for name: ""sun/security/pkcs11/SunPKCS11""
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:616)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:283)
	at java.net.URLClassLoader.access$000(URLClassLoader.java:58)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:197)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at sun.misc.Launcher$ExtClassLoader.findClass(Launcher.java:229)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:307)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:296)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
	at sun.security.jca.ProviderConfig$4.run(ProviderConfig.java:253)
	at java.security.AccessController.doPrivileged(Native Method)
	at sun.security.jca.ProviderConfig.doLoadProvider(ProviderConfig.java:244)
	at sun.security.jca.ProviderConfig.getProvider(ProviderConfig.java:224)
	at sun.security.jca.ProviderList.getProvider(ProviderList.java:215)
	at sun.security.jca.ProviderList.getService(ProviderList.java:313)
	at sun.security.jca.GetInstance.getInstance(GetInstance.java:140)
	at java.security.Security.getImpl(Security.java:659)
	at java.security.MessageDigest.getInstance(MessageDigest.java:129)
	at java.io.ObjectStreamClass.computeDefaultSUID(ObjectStreamClass.java:1759)
	at java.io.ObjectStreamClass.access$100(ObjectStreamClass.java:52)
	at java.io.ObjectStreamClass$1.run(ObjectStreamClass.java:205)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.io.ObjectStreamClass.getSerialVersionUID(ObjectStreamClass.java:202)
	at java.io.ObjectStreamClass.writeNonProxy(ObjectStreamClass.java:667)
	at java.io.ObjectOutputStream.writeClassDescriptor(ObjectOutputStream.java:648)
	at java.io.ObjectOutputStream.writeNonProxyDesc(ObjectOutputStream.java:1253)
	at java.io.ObjectOutputStream.writeClassDesc(ObjectOutputStream.java:1211)
	at java.io.ObjectOutputStream.writeArray(ObjectOutputStream.java:1290)
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1154)
	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:330)
	at org.apache.derby.iapi.services.io.FormatIdOutputStream.writeObject(Unknown Source)
	at org.apache.derby.iapi.services.io.FormatableHashtable.writeExternal(Unknown Source)
	at org.apache.derby.iapi.services.io.FormatIdOutputStream.writeObject(Unknown Source)
	at org.apache.derby.impl.sql.catalog.DDColumnDependableFinder.writeExternal(Unknown Source)
	at org.apache.derby.iapi.services.io.FormatIdOutputStream.writeObject(Unknown Source)
	at org.apache.derby.iapi.types.UserType.writeExternal(Unknown Source)
	at org.apache.derby.impl.store.raw.data.StoredPage.logColumn(Unknown Source)
	at org.apache.derby.impl.store.raw.data.StoredPage.logRow(Unknown Source)
	at org.apache.derby.impl.store.raw.data.InsertOperation.writeOptionalDataToBuffer(Unknown Source)
	at org.apache.derby.impl.store.raw.data.InsertOperation.<init>(Unknown Source)
	at org.apache.derby.impl.store.raw.data.LoggableActions.actionInsert(Unknown Source)
	at org.apache.derby.impl.store.raw.data.BasePage.insertNoOverflow(Unknown Source)
	at org.apache.derby.impl.store.raw.data.BasePage.insertAtSlot(Unknown Source)
	at org.apache.derby.impl.store.raw.data.StoredPage.insertAtSlot(Unknown Source)
	at org.apache.derby.impl.store.raw.data.BasePage.insert(Unknown Source)
	at org.apache.derby.impl.store.access.heap.HeapController.doInsert(Unknown Source)
	at org.apache.derby.impl.store.access.heap.HeapController.insertAndFetchLocation(Unknown Source)
	at org.apache.derby.impl.sql.catalog.TabInfoImpl.insertRowListImpl(Unknown Source)
	at org.apache.derby.impl.sql.catalog.TabInfoImpl.insertRow(Unknown Source)
	at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.addDescriptor(Unknown Source)
	at org.apache.derby.impl.sql.depend.BasicDependencyManager.addDependency(Unknown Source)
	at org.apache.derby.impl.sql.depend.BasicDependencyManager.copyDependencies(Unknown Source)
	at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.compileStatement(Unknown Source)
	at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.prepareAndRelease(Unknown Source)
	at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(Unknown Source)
	at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(Unknown Source)
	at org.apache.derby.impl.sql.compile.ExecSPSNode.generate(Unknown Source)
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(Unknown Source)
	at org.apache.derby.impl.sql.GenericStatement.prepare(Unknown Source)
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.<init>(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement20.<init>(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement30.<init>(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement40.<init>(Unknown Source)
	at org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareMetaDataStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.prepareSPS(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQueryUsingSystemTables(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.doGetCols(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getColumns(Unknown Source)
	at org.apache.commons.dbcp.DelegatingDatabaseMetaData.getColumns(DelegatingDatabaseMetaData.java:218)
	at org.apache.openjpa.lib.jdbc.DelegatingDatabaseMetaData.getColumns(DelegatingDatabaseMetaData.java:145)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingDatabaseMetaData.getColumns(LoggingConnectionDecorator.java:776)
	at org.apache.openjpa.lib.jdbc.DelegatingDatabaseMetaData.getColumns(DelegatingDatabaseMetaData.java:145)
	at org.apache.openjpa.jdbc.sql.DBDictionary.getColumns(DBDictionary.java:4061)
	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateTables(SchemaGenerator.java:524)
	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateSchema(SchemaGenerator.java:364)
	at org.apache.openjpa.jdbc.schema.SchemaGenerator.generateSchemas(SchemaGenerator.java:300)
	at org.apache.openjpa.jdbc.schema.SchemaTool.getDBSchemaGroup(SchemaTool.java:1163)
	at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:363)
	at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:340)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:505)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:456)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:160)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:164)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:122)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:210)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:156)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:227)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:154)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:60)
	at hellojpa.Main.main(Main.java:43)

I was able to resolve the issue by changing the classpath to reference an install of Derby that is shipped with every install of MacOS X (in /usr/share/derby).  Opening this JIRA issue to update the OpenJPA samples so that they will choose the version of Derby that comes pre-installed on MacOS X.",MacOS X 1.6.x,3600,3600,,0%,3600,3600,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-03-17 21:42:09.612,,,no_permission,,,,,,,,,,,,2331,,,Wed Apr 11 19:35:32 UTC 2012,,,,,,,0|i1dutj:,289090,,,,,,,,"11/Apr/12 19:35;binhn;I got same problem with Lion 10.7.3, openjpa 2.2.0. The classpath looks right when I echo it out  /mywork/apache-openjpa-2.2.0/examples/simple:/mywork/apache-openjpa-2.2.0/openjpa-all-2.2.0.jar:/usr/share/derby/lib/derby.jar ",,,,,,,,,,,,,,,,,,,,,,,,,,
JPQL Queries do not support mixing positional and named parameters,OPENJPA-1995,12506673,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,10/May/11 02:40,10/May/11 13:32,14/Mar/19 03:03,10/May/11 13:32,,,,,,,,,,,,,,jpa,query,,,0,,,,,,,,"Pinaki mentioned this condition in OPENJPA-1992, opening a separate issue to track the problem. 

The JPA spec indicates that positional and named parameters should not be mixed. From limited testing I believe queries like this do not work on trunk. To be consistent we should throw an exception when such a query is detected and inform the user of what went wrong. ",,,,,,,,,,,,,,OPENJPA-1992,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2332,,,2011-05-10 02:40:36.0,,,,,,,0|i1dutr:,289091,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Index is a reserved word for MySQL ,OPENJPA-1994,12506318,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,05/May/11 18:00,05/May/11 19:51,14/Mar/19 03:03,05/May/11 19:51,,,,,,,,,2.2.0,,,,,jdbc,,,,0,,,,,,,,Found during unit testing. Index is a reserved word for MySQL and should be added to the list in MySQLDictionary. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2333,,,2011-05-05 18:00:55.0,,,,,,,0|i0z5lr:,203210,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.ArrayIndexOutOfBoundsException if positional parameter are not started from 1,OPENJPA-1992,12506151,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,hanhongfang,hanhongfang,04/May/11 09:40,13/Jul/11 16:11,14/Mar/19 03:03,09/May/11 13:46,2.1.0,,,,,,,,2.2.0,,,,,kernel,,,,0,,,,,,,,"Query q = em.createQuery(""SELECT x FROM Magazine x WHERE x.title = ?2 and x.price > ?3"");
q.setParameter(2, ""JDJ"").setParameter(3, 25.0);

When the query is executed, java.lang.ArrayIndexOutOfBoundsException will be thrown. Since ""JDJ"" and ""25.0"" will be stored in arr[0] and arr[1] (when arr.size =2) but the query execution code tries to get them via arr[2] and arr[3].",,,,,,,,,,,,,,,,,,,06/May/11 06:23;hanhongfang;Main.java;https://issues.apache.org/jira/secure/attachment/12478374/Main.java,04/May/11 09:42;hanhongfang;OPENJPA-1992.patch;https://issues.apache.org/jira/secure/attachment/12478144/OPENJPA-1992.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2011-05-05 13:30:34.19,,,no_permission,,,,,,,,,,,,2335,,,Fri May 13 14:46:32 UTC 2011,,,,,,,0|i0z0jz:,202392,,,,,,,,"04/May/11 09:42;hanhongfang;Patch is attached, please help to review. Thanks in advance!",04/May/11 09:46;hanhongfang;Just for information. the problem doesn't exist in openjpa 1.2.2.,"05/May/11 13:30;mikedd;Thanks for the patch. Could you also provide a testcase the reproduces the error? 

The JPA spec does indicate that input parameters will start with 1 (section 4.6.4.1), but we should at least fail in a more informative way. ","06/May/11 06:22;hanhongfang;Hi Michael,

This exception can be reproduced with the hellojpa sample by following Getting Started with the Eclipse steps on http://openjpa.apache.org/getting-started.html. After step 10, replace the Main.java with the attached copy of Main.java, and then rerun step 9.

I noticed that spec indicates that input parameters will start with 1 in both JPA spec(section 4.6.4.1) and EJB spec(section 9.2.6.4), but this exception blocks our TCK, which expects ""SELECT x FROM Magazine x WHERE x.title = ?2 and x.price > ?3"" can be successfully processed.",06/May/11 06:23;hanhongfang;Attached modified Main.java for problem re-creation.,"06/May/11 21:55;mikedd;Hi Han,

Which TCK are you talking about? OpenJPA 2.1.0 passed the JPA 1.0 and 2.0 TCKs prior to release. I'm assuming you're talking about a different test suite? ","06/May/11 22:23;ppoddar@apache.org;The binding parameter indexing, ordering and naming are somewhat sensitive to many implicit assumptions throughout our codebase. It is made more sensitive after we introduced Prepared Query Caches that rebinds parameters (that originally could have been named) to SQL (that only accepts integral parameter). The index of parameters affects the kernel and also note that kernel internals can insert its own parameters that are invisible to the user application. 

Please be careful with a change unless it is broken for regular, spec-compliant use case. If for example we allow numeric parameters *not* to begin with 1 and be monotonic and continuous, nothing stops a user to specific ""SELECT a FROM A a where a.name=?100234 and A.something=?34562"" -- it will get real hairy to support such an innovative user :) 

An informative error message when integral parameters violate *any* of the following
  a) start with 1
  b) monotonic
  c) continuous
is all that is required to keep life simple, code uncomplicated and majority of user satisfied.",07/May/11 19:35;mikedd;I agree. This is about detection and producing an informative error message. At this time I don't think we can or should support numeric parameters that start at any point. ,"09/May/11 13:46;mikedd;While in theory we could support positional parameters that do not start with 1, or contain gaps I don't think there's a compelling reason to add such support. 

We should not throw an ArrayIndexOutOfBoundsException during query execution though. I've checked in changes that will detect the condition when the query is created and throw a UserException that explains why the query string is bad.","12/May/11 22:36;dblevins;From what I recall from EJB 3.0 when that group still had JPA, is that the intent of ""input parameters are numbered starting from 1"" is to simply say 1 as opposed to 0.  The line that reads ""the same parameter can be used more than once in the query string"", should simply read ""the same parameter can be used zero or more times in the query string"".  That was the intent as far as I recall.

Not even printf requires you to use all your input parameters.  It's ok to skip some, even the first one.  The 'start at 1' is for the input side, not the output side (in this case the query itself)

For example:

{code}
public class PositionalParametersTest extends TestCase {

    public void testPattern() throws Exception {

        final String query = ""SELECT $2 FROM $3 AS $2"";

        final String result = ""one two three four"".replaceFirst(""(one) (two) (three) (four)"", query);

        assertEquals(""SELECT two FROM three AS two"", result);
    }

    public void testFormatter() throws Exception {

        final String query = ""SELECT %2$s FROM %3$s AS %2$s"";

        final String result = String.format(query, ""one"", ""two"", ""three"", ""four"");

        assertEquals(""SELECT two FROM three AS two"", result);
    }
}
{code}

It is very very useful to be able to edit any part of a query string while trying to get things right or debugging.  One of those things you don't do because you want to, but because you're trying to get to where you want to go.

Being able to tweak query strings without recompiling code is a pretty useful thing all on its own.
","13/May/11 02:24;dblevins;So here's what I got.  Perspective of Linda is that ""attempting to bind a parameter that did not correspond to a parameter in the query is intended to cause an exception.""  She didn't comment on how strict we should be with the 1 thing.  Certainly the spec says 1 in no uncertain terms.

I ran a test with Hibernate and EclipseLink and both of them will allow this:

    Query query = entityManager.createQuery(""SELECT m from Movie as m WHERE m.title = ?2 AND m.year = ?4"");
    query.setParameter(2, ""Foo"");
    query.setParameter(4, 2011);
    return query.getResultList();

Both of them will throw an exception from the setParameter method if the index doesn't exist, but neither cares what numbers you do or don't use beyond that.

So at this point I would just have to say you're in the clear from a letter of the spec perspective, but in terms of practicality (editing huge queries can take hours and relabeling index continuously just slows you down) and in compatibility with current EclipseLink and Hibernate implementations and past OpenJPA versions, it would be great to at least get a vendor specific flag to turn on/off the strict behavior.

If we had something that could be set at the unit level, that would be a very big help to us and potentially other users migrating or upgrading.
","13/May/11 14:46;mikedd;I'd be fine with opening a new improvement to allow this, and if there is sufficient interest we'd look into it. Pinaki's point about the prepared SQL cache is particularly concerning (for me at least). I suspect any changes we make in this area will affect the cache as well. In the current implementation (and probably in previous releases) this sort of query will not work as expected (beyond the ArrayIndex exception). 

It's just my personal opinion, but I think it's unlikely that there will be many queries that use positional parameters and do not already start at one. I suspect most of those are copy / paste jobs from JDBC prepared statements which do start at 1. Those that aren't copied or pasted from existing statements would probably prefer the named parameter support (which is more friendly anyway). I could be all wet here though - and I can see where it would be a real pain if you had to go back and update the positional args. 
",,,,,,,,,,,,,,,
*ToOne relationships specified as LAZY in xml aren't honored,OPENJPA-1989,12505434,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,28/Apr/11 15:55,13/Jul/11 16:11,14/Mar/19 03:03,11/May/11 16:27,2.1.0,2.2.0,,,,,,,2.1.1,2.2.0,,,,,,,,0,,,,,,,,"While doing some testing I found that trying to override a [*]ToOne mapping as LAZY doesn't work. It is a simple change to the XML parser where when we find a ToOne element with a fetch specified, we need to explicitly set whether it is in the default fetch group.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2338,,,Wed Jul 13 16:11:23 UTC 2011,,,,,,,0|i0z5hz:,203193,,,,,,,,28/Apr/11 16:02;curtisr7;Committed revision 1097517 to trunk.,11/May/11 14:19;curtisr7;Reopening this issue as my previous change introduced a bug.,"11/May/11 16:25;curtisr7;I fixed a bug where in JDBCStoreManager we rely on the return value from FieldMetaData.isDefaultFetchGroupExplicit() to tell us when we can perform an optimization. This optimization is to select the foreign id field(if they exist) of a Lazy relationship. Due to my previous change, the explicit flag was getting incorrectly changed when overriding mapping info via xml. Now XML vs Annotations should behave the same in this scenario.

Committed revision 1101951 to trunk.",13/Jul/11 16:11;curtisr7;Closing resolved issues.,,,,,,,,,,,,,,,,,,,,,,,
openjpa does not process persistence unit default <cascade-persist>,OPENJPA-1988,12505432,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,fyrewyld,dianner,dianner,28/Apr/11 15:46,21/Sep/16 20:17,14/Mar/19 03:03,03/Nov/14 21:23,2.2.0,2.3.0,,,,,,,2.2.1.1,2.2.3,2.4.0,,,,,,,0,,,,,,,,"For a ManyToMany relationship, I attempted to use the following in the orm to persist the related entities:

    <persistence-unit-metadata>
        <persistence-unit-defaults>
            <delimited-identifiers/>
        </persistence-unit-defaults>
    </persistence-unit-metadata>

Although openjpa appears to find this, it doesn't use it in an em.persist(). It does work, however, if I put cascade=CascadeType.persist on the @ManyToMany annotation of the entity that is specifically persisted.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-02-02 17:27:30.319,,,no_permission,,,,,,,,,,,,2339,,,Thu Apr 16 23:35:00 UTC 2015,,,,,,,0|i1dufb:,289026,,,,,,,,02/Feb/12 17:27;allee8285;Change fix version in preparation of 2.2.0 release.,"18/Mar/14 20:31;jira-bot;Commit 1579029 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1579029 ]

OPENJPA-1988: OpenJPA does not process persistence unit default <cascade-persist>","18/Mar/14 21:20;jira-bot;Commit 1579042 from [~fyrewyld] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1579042 ]

OPENJPA-1988: OpenJPA does not process persistence unit default <cascade-persist>","16/May/14 19:11;jira-bot;Commit 1595310 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1595310 ]

OPENJPA-1988: OpenJPA does not process persistence unit default <cascade-persist>","03/Nov/14 16:42;jira-bot;Commit 1636387 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1636387 ]

OPENJPA-1988: openjpa does not process persistence unit default <cascade-persist>","03/Nov/14 18:41;jira-bot;Commit 1636415 from [~fyrewyld] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1636415 ]

OPENJPA-1988: openjpa does not process persistence unit default <cascade-persist>","03/Nov/14 19:23;jira-bot;Commit 1636422 from [~fyrewyld] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1636422 ]

OPENJPA-1988: openjpa does not process persistence unit default <cascade-persist>","03/Nov/14 21:22;jira-bot;Commit 1636446 from [~fyrewyld] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1636446 ]

OPENJPA-1988: openjpa does not process persistence unit default <cascade-persist>","26/Nov/14 19:51;jira-bot;Commit 1641906 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1641906 ]

OPENJPA-1988: openjpa does not process persistence unit default <cascade-persist>","30/Nov/14 15:52;jira-bot;Commit 1642555 from [~fyrewyld] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1642555 ]

OPENJPA-1988: openjpa does not process persistence unit default <cascade-persist>","13/Apr/15 20:29;jira-bot;Commit 1673275 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1673275 ]

OPENJPA-1988: Made an update to the test case for this JIRA, i.e. merged r1641906 from 2.2.x to 2.2.1.x.","13/Apr/15 20:32;jira-bot;Commit 1673276 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1673276 ]

OPENJPA-1988: Made an update to the test case for this JIRA, i.e. merged r1641906 from 2.2.x to trunk.","13/Apr/15 23:00;jira-bot;Commit 1673310 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1673310 ]

OPENJPA-1988: Made an update to the test case for this JIRA, i.e. merged r1642555 from 2.2.x to 2.2.1.x.","16/Apr/15 23:35;jira-bot;Commit 1674167 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1674167 ]

OPENJPA-1988: Made an update to the test case for this JIRA, i.e. merged r1642555 from 2.2.x to trunk",,,,,,,,,,,,,
Postgres / Ingres does not support null table for getImportedKeys,OPENJPA-1987,12505419,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,28/Apr/11 13:44,13/Jul/11 16:11,14/Mar/19 03:03,28/Apr/11 14:06,2.2.0,,,,,,,,2.2.0,,,,,jdbc,,,,0,,,,,,,,The unit test bucket fails on Postgres due to the setting for getImportedKeys. Changing it to false resolves the problem. ,,3600,3600,,0%,3600,3600,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2340,,,2011-04-28 13:44:10.0,,,,,,,0|i1dufj:,289027,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Extra queries being generated when cascading a persist,OPENJPA-1986,12505332,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,27/Apr/11 16:44,24/Mar/14 16:43,14/Mar/19 03:03,27/Apr/11 19:22,2.0.1,2.1.0,2.2.0,,,,,,2.1.1,2.2.0,,,,performance,,,,0,,,,,,,,"I found a scenario where extra queries were being generated while cascading a persist to a new Entity. See the following example:

@Entity
public class CascadePersistEntity implements Serializable {
    private static final long serialVersionUID = -8290604110046006897L;

    @Id
    long id;

    @OneToOne(cascade = CascadeType.ALL)
    CascadePersistEntity other;
...
}

and the following scenario:
CascadePersistEntity cpe1 = new CascadePersistEntity(1);
CascadePersistEntity cpe2 = new CascadePersistEntity(2);
cpe1.setOther(cpe2);
em.persist(cpe1);

This results in two inserts and one select. The extra select is what I'm going to get rid of with this JIRA.",,,,,,,,,,,,,,,,,,,27/Apr/11 16:54;curtisr7;OPENJPA-1986.patch;https://issues.apache.org/jira/secure/attachment/12477565/OPENJPA-1986.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-03-24 16:14:13.43,,,no_permission,,,,,,,,,,,,2341,,,Mon Mar 24 16:43:41 UTC 2014,,,,,,,0|i0z0qf:,202421,,,,,,,,27/Apr/11 16:52;curtisr7;Since this could change the behavior of some existing applications I'm going to put in a compatibility property that will allow us to revert the change.,27/Apr/11 16:54;curtisr7;Attaching a code change and test case.,27/Apr/11 19:16;curtisr7;Committed revision 1097209 to trunk.,27/Apr/11 19:22;curtisr7;Committed changes to trunk.,"28/Apr/11 19:50;curtisr7;When porting this code back to 2.1.x, we need to make sure to flip the compatibility option so we don't break any existing applications.",13/Jul/11 16:11;curtisr7;Closing resolved issues.,"24/Mar/14 16:14;jira-bot;Commit 1580898 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1580898 ]

OPENJPA-1986: Extra queries being generated when cascading a persist - added another/similar check to the ones added by Rick.","24/Mar/14 16:29;jira-bot;Commit 1580903 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1580903 ]

OPENJPA-1986: Extra queries being generated when cascading a persist - added another/similar check to the ones added by Rick.","24/Mar/14 16:35;jira-bot;Commit 1580907 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1580907 ]

OPENJPA-1986: Extra queries being generated when cascading a persist - added another/similar check to the ones added by Rick.","24/Mar/14 16:38;jira-bot;Commit 1580909 from [~jpaheath] in branch 'openjpa/branches/2.3.x'
[ https://svn.apache.org/r1580909 ]

OPENJPA-1986: Extra queries being generated when cascading a persist - added another/similar check to the ones added by Rick.","24/Mar/14 16:43;jira-bot;Commit 1580913 from [~jpaheath] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1580913 ]

OPENJPA-1986: Extra queries being generated when cascading a persist - added another/similar check to the ones added by Rick.",,,,,,,,,,,,,,,,
ClassCastException in max(Timestamp) function on PostgreSQL,OPENJPA-1985,12505188,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,mikedd,s.mironov,s.mironov,26/Apr/11 12:42,13/Jul/11 16:11,14/Mar/19 03:03,27/Apr/11 20:56,2.1.0,,,,,,,,2.1.1,2.2.0,,,,jdbc,kernel,,,0,,,,,,,,"Works perfectly in OpenJPA 2.0.1.

Regression in OpenJPA 2.1.0, 100% reproducible exception.

Exception:
SEVERE: Failed to execute query ""select max(h.loadTimestamp) from Header h where h.code=?1 and h.period=?2"". Check the query syntax for correctness. See nested exception for details. 
<openjpa-2.1.0-r422266:1071316 nonfatal user error> 
org.apache.openjpa.persistence.ArgumentException: Failed to execute query ""select max(h.loadTimestamp) from Header h where h.code=?1 and h.period=?2"". Check the query syntax for correctness. See nested 
exception for details. 
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:872) 
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:794) 
        at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542) 
        at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:305) 
        at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:319) 
        at org.apache.openjpa.persistence.QueryImpl.getSingleResult(QueryImpl.java:343) 
        ... my code ... 
Caused by: java.lang.ClassCastException: Cannot convert object 
""2011-04-25 15:48:31+02"" of type ""class org.postgresql.util.PGobject"" 
into an instance of ""class java.sql.Timestamp"". 
        at org.apache.openjpa.kernel.Filters.convert(Filters.java:336) 
        at org.apache.openjpa.kernel.Filters.convert(Filters.java:265) 
        at org.apache.openjpa.jdbc.kernel.exps.UnaryOp.load(UnaryOp.java:125) 
        at org.apache.openjpa.jdbc.kernel.ProjectionResultObjectProvider.getResultObject(ProjectionResultObjectProvider.java:78) 
        at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.getResultObject(QueryImpl.java:2075) 
        at org.apache.openjpa.kernel.QueryImpl.singleResult(QueryImpl.java:1330) 
        at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1242) 
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1007) 
        at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:863) 
        ... 12 more 

Entity:
@Entity 
@Table(name = ""headers"") 
@DataCache(enabled = false) 
public class Header { 
    @Id 
    @GeneratedValue 
    private long id; 

    @Column(nullable = false) 
    private String code; 

    @Column(nullable = false) 
    private int period; 

    @Column(nullable = false) 
    @Temporal(TemporalType.TIMESTAMP) 
    private Timestamp loadTimestamp; 
... 
} 

Table (autogenerated by OpenJPA 2.0.1):
create table public.headers (
  id int8 not null,
  loadtimestamp abstime not null,
  period int4 not null,
  code varchar(255) not null,
  primary key (id)
);
","Windows 7 x64, Java 1.6.0_25, PostgreSQL 9.0.4 x64, PostgreSQL Native Driver PostgreSQL 9.0 JDBC4 (build 801)",,,,,,,,,,,,,OPENJPA-1710,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-04-27 03:29:53.553,,,no_permission,,,,,,,,,,,,2342,,,Wed Apr 27 20:56:28 UTC 2011,,,,,,,0|i0yvbj:,201544,,,,,,,,"27/Apr/11 03:29;mikedd;The short answer here is that the table was generated incorrectly on OpenJPA 2.0.1. OPENJPA-1726 changed the default timestamp type from ASBTIME to TIMESTAMP (ABSTIME was deprecated). 

As a quick workaround you can either change the table definition (ugly), or add the following property to persistence.xml :
        <property name=""openjpa.jdbc.DBDictionary"" value=""postgres(timestampTypeName=ABSTIME)""/>

The real fix will likely be to treat ABSTIME and TIMESTAMP identically.  ",27/Apr/11 20:56;mikedd;Should be fixed now. The latest nightly snapshots should be available tomorrow morning and will have this change. ,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect ViolationContraint getRootBean when removing bean with embedded entity validation,OPENJPA-1984,12505086,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,24/Apr/11 21:11,27/Apr/11 18:48,14/Mar/19 03:03,27/Apr/11 18:48,2.1.0,2.1.1,2.2.0,,,,,,2.2.0,,,,,kernel,,,,0,,,,,,,,"When bean validation is performed during em.remove() against an entity with embedded entity and if the failing constraint occurred in the embedded entity, the root bean set in the ValidationConstraint returns in the ViolationConstraintException is incorrectly set to the embbedded entity, whereas the top level entity is expected.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2343,,,2011-04-24 21:11:58.0,,,,,,,0|i1dufr:,289028,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Improper cleanup in SchemaGenerator,OPENJPA-1981,12504273,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,14/Apr/11 14:31,19/Apr/11 18:57,14/Mar/19 03:03,19/Apr/11 18:56,2.1.0,,,,,,,,2.2.0,,,,,jdbc,,,,0,,,,,,,,The SchemaGenerator tool should check whether the connection is open before calling close. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2346,,,2011-04-14 14:31:04.0,,,,,,,0|i0z4in:,203034,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Regression for non-standard joins with constant column values ,OPENJPA-1979,12504099,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,12/Apr/11 20:33,06/Jun/15 21:19,14/Mar/19 03:03,28/Mar/13 15:26,2.0.0,2.0.0-M1,,,,,,,2.3.0,,,,,jdbc,kernel,,,1,,,,,,,,"The non-standard join can use constant column values by enclosing them in single-quote character. This behavior is regressed. The likely cause of this regression is new delimiting support for schema elements introduced in JPA 2.0. The constant column value used to be detected during schema definition based on the assumption of the name being enclosed in single-quote. Due to introduction of delimiting capability, the constant value is now enclosed in double-quote followed by a single-quote.   

The visible effect is failure to define schema for non-standard join with constant values.",,,,,,,,,,,,,,,,,,,12/Apr/11 20:45;ppoddar@apache.org;OPENJPA-1979.patch.1.txt;https://issues.apache.org/jira/secure/attachment/12476166/OPENJPA-1979.patch.1.txt,12/Apr/11 20:37;ppoddar@apache.org;Test-1979.zip;https://issues.apache.org/jira/secure/attachment/12476160/Test-1979.zip,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2011-04-12 21:00:28.166,,,no_permission,,,,,,,,,,,,2348,,,Thu May 15 19:44:52 UTC 2014,,,,,,,0|i14l9b:,234908,,,,,,,,"12/Apr/11 20:37;ppoddar@apache.org;The test case uses non-standard join for schema definition.
The domain classes will fail to define database schema","12/Apr/11 20:45;ppoddar@apache.org;This is a patch to fix the problem. 
WARNING: Only partially tested.",12/Apr/11 21:00;techhusky;Hey Pinaki.  Your patch looks good to me.  We may need to look at the XML mapping parser as well.  It looks like we were sorely lacking a jUnit for this scenario...,"12/Apr/11 21:45;ppoddar@apache.org;> XML mapping parser as well. 
Yes, of course.

> lacking a jUnit f
The test case patch has ASF license granted. One can consider including it. The test case does not conform setUp() routine though.

Another couple of points:
a)   There are few more rules to determine whether a specification denotes constant-valued column (ref: MappingInfo.meregColumn(...) and assignment of the local boolean variable named 'constant'). The quick patch does not work out those rules.

b) The downstream effect of changing DBIdentifierType to CONSTANT instead of usual COLUMN not investigated. It was just done to stop the columnName being delimited. ","06/Oct/11 13:17;mspiro;I opened a duplicate issue OPENJPA-2054.

Pinaki, your patch handles only the case with a string constant but doesn`t handle numeric constants (beginning with a digit, a dot or a minus sign). ""Null"" should also be considered a constant. Shouldn't this be added? I think the parsing logic should be the same as in MappingInfo.mergeJoinColumn().","21/May/12 11:23;thirion;Hi.

I checked out version 2.2.0 and found that this patch wasn't applied yet.
Based on Micael's question, I modified the method as follows and I can confirm that it worked with constant values as numbers and text:

private Column newColumn(JoinColumn join) {
        Column col = new Column();
        if (!StringUtils.isEmpty(join.name()))
            col.setIdentifier(DBIdentifier.newColumn(join.name(), delimit()));
        if (!StringUtils.isEmpty(join.columnDefinition()))
            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(join.columnDefinition()));
//        if (!StringUtils.isEmpty(join.referencedColumnName())) //f fix from openjpa-1979
//            col.setTargetIdentifier(DBIdentifier.newColumn(join.referencedColumnName(), delimit()));
        String joinColumnName = join.referencedColumnName();
        if (!StringUtils.isEmpty(joinColumnName)) {
            boolean isConstant = joinColumnName.charAt(0) == '\'';
            if(!isConstant){
                if (joinColumnName.charAt(0) == '-'
                    || joinColumnName.charAt(0) == '.'
                    || Character.isDigit(joinColumnName.charAt(0))) {
                    isConstant = true;
                    try {
                        if (joinColumnName.indexOf('.') == -1){
                            new Integer(joinColumnName);
                        } else{
                            new Double(joinColumnName);
                        }
                    } catch (NumberFormatException nfe) {
                        throw new RuntimeException(""Constant Join Column is not a Valid Number: "" + joinColumnName
                                + "", Join: "" + join);
                    }
                } else if (""null"".equalsIgnoreCase(joinColumnName)){
                    isConstant = true;
                }
            }

            if (isConstant) {
                col.setTargetIdentifier(DBIdentifier.newConstant(joinColumnName));
            } else {
                col.setTargetIdentifier(DBIdentifier.newColumn(joinColumnName, delimit()));
            }
        }
        col.setNotNull(!join.nullable());
        col.setFlag(Column.FLAG_UNINSERTABLE, !join.insertable());
        col.setFlag(Column.FLAG_UNUPDATABLE, !join.updatable());
        return col;
    }","25/May/12 23:50;david minor;A similar fix is also needed for 'private static Column newColumn(ElementJoinColumn join, boolean delimit)', and possibly the other join annotations if they used to support constant joins.","11/Dec/12 14:31;pat_mccabe;Hello.  Is there any update on if/when this fix will be available ? 
","27/Mar/13 20:05;jira-bot;Commit 1461833 from [~ppoddar@apache.org]
[ https://svn.apache.org/r1461833 ]

OPENJPA-1979: reference column name starting with single-quote *not* delimited as they have special semantics for non-standard constant join","19/May/13 17:06;jira-bot;Commit 1484313 from hthomann
[ https://svn.apache.org/r1484313 ]

OPENJPA-1979: Regression for non-standard joins with constant column values - back ported to 2.1.x Pinaki Poddar's trunk changes.","19/May/13 17:53;jira-bot;Commit 1484322 from hthomann
[ https://svn.apache.org/r1484322 ]

OPENJPA-1979: Regression for non-standard joins with constant column values - back ported to 2.2.1.x Pinaki Poddar's trunk changes.","19/May/13 18:02;jira-bot;Commit 1484326 from hthomann
[ https://svn.apache.org/r1484326 ]

OPENJPA-1979: Regression for non-standard joins with constant column values - back ported to 2.2.x Pinaki Poddar's trunk changes.","15/May/14 19:44;byoder;I think it may still not be working for constant numeric values.  Maybe you fixed for constant string values, but I am still getting errors in 2.3.0 using hardcoded numbers:

<openjpa-2.3.0-r422266:1540826 fatal user error> org.apache.openjpa.persistence.ArgumentException: ""com.sscims.im.entity.IMSObject.refObject"" defines a target of """"14"""" for column ""entity_type_id"", but that target does not exist in table ""dbo.im_ims_obj"".

@ManyToOne(fetch=FetchType.LAZY)
@JoinTable(
        name=""im_ref"",
        joinColumns={
            @JoinColumn(name=""entity_type_id"", referencedColumnName=""14""),
            @JoinColumn(name=""entity_id"", referencedColumnName=""obj_type_id"")
        }
    )	
",,,,,,,,,,,,,,
Only obtain default schema name when needed (DB2),OPENJPA-1975,12503677,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,07/Apr/11 20:57,11/Nov/11 07:35,14/Mar/19 03:03,11/Apr/11 17:52,2.0.1,2.1.0,,,,,,,2.2.0,,,,,,,,,0,,,,,,,,"Currently the DB2 issues SQL to obtain the default schema name in DB2Dictionary.connectedConfiguration(). The value is only used by the SchemaTool, and the extra SQL has an impact in some environments.

The SQL can be delayed until the default schema name is needed, reducing some load on the DB. ",,,,,,,,,,,,,,OPENJPA-2073,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2352,,,2011-04-07 20:57:51.0,,,,,,,0|i0z5kv:,203206,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StackOverflowError when performing multiple subquery in collection field with eager fetch,OPENJPA-1974,12503268,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,takeshi.nishizawa,takeshi.nishizawa,04/Apr/11 10:20,02/Feb/12 17:08,14/Mar/19 03:03,05/Apr/11 16:39,2.1.0,2.2.0,,,,,,,2.2.0,,,,,jdbc,,,,0,,,,,,,,"When I run a JPQL with multiple subquery in @OneToMany annotated collection property with eager fetch configuration, StackOverflowError is thrown.

java.lang.StackOverflowError
	at org.apache.openjpa.jdbc.sql.SelectImpl.aliasSize(SelectImpl.java:2166)
	at org.apache.openjpa.jdbc.sql.SelectImpl.aliasSize(SelectImpl.java:2160)
	at org.apache.openjpa.jdbc.sql.SelectImpl.aliasSize(SelectImpl.java:2168)
	at org.apache.openjpa.jdbc.sql.SelectImpl.aliasSize(SelectImpl.java:2160)
	at org.apache.openjpa.jdbc.sql.SelectImpl.aliasSize(SelectImpl.java:2168)
	at org.apache.openjpa.jdbc.sql.SelectImpl.aliasSize(SelectImpl.java:2160)
	at org.apache.openjpa.jdbc.sql.SelectImpl.aliasSize(SelectImpl.java:2168)
        ...
","Windows, x86, JDK 1.6.0_22",,,,,,,,,,,,,,,,,,04/Apr/11 21:46;curtisr7;OPENJPA-1974.trunk.patch;https://issues.apache.org/jira/secure/attachment/12475433/OPENJPA-1974.trunk.patch,04/Apr/11 10:22;takeshi.nishizawa;subQueryBug.zip;https://issues.apache.org/jira/secure/attachment/12475345/subQueryBug.zip,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2011-04-04 14:04:08.213,,,no_permission,,,,,,,,,,,,2353,,,Thu Feb 02 17:08:28 UTC 2012,,,,,,,0|i1dugv:,289033,,,,,,,,"04/Apr/11 10:22;takeshi.nishizawa;Attached a test case which reproduces the issue.
",04/Apr/11 14:04;curtisr7;What version are you running on?,"04/Apr/11 21:46;curtisr7;Uploading a test case and test fix. All unit tests pass, but I want to sit on this change over night...

I'm uncertain of whether or not a call to org.apache.openjpa.jdbc.sql.SelectImpl.aliasSize() can/will originate from a non ""parent"" SelectImpl.  This is important to my change as to calculate the number of aliases I'm only looking at the SelectImpl object which aliasSize() was called and all of it's sub selects. ","05/Apr/11 16:38;curtisr7;Committed test / fix to trunk.

I ended up taking the SelectImpl.aliasSize( ... ) implementation from 1.2.x which was incorrectly refactored in the 2.0.x time.",05/Apr/11 16:39;curtisr7;Thanks for reporting the bug and uploading a testcase.,02/Feb/12 17:08;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,
CPU spinning forever at TreeMap.get in Schema.java ,OPENJPA-1970,12503044,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,rpalache,rpalache,rpalache,31/Mar/11 15:59,21/Sep/16 14:21,14/Mar/19 03:03,31/Mar/11 18:35,1.1.0,,,,,,,,1.2.0,,,,,jdbc,,,,0,,,,,,,,"CPU is spinning forever at TreeMap.get in schema.java.
The reason found to be because of structural modification of treemap outside a synchronized block.
Synchronizing the treemap is fixing the issue.
The issue can be reproduced with an openJPA test case but due to the nature of the problem, it is replicable intermittently on dual core machine.
Attached patch has the test case and also the test case is ignored in default runs because it will cause the tests to stuck at TreeMap.get.

This is seen in 1.1.x version of openJPA and hence uploading the patch only for that version.",openJPA 1.1.x,,,,,,,,,,,,,,,,,,31/Mar/11 16:06;rpalache;OPENJPA-1970.diff;https://issues.apache.org/jira/secure/attachment/12475118/OPENJPA-1970.diff,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-03-31 20:27:16.056,,,no_permission,,,,,,,,,,,,2357,,,Thu Mar 31 20:56:35 UTC 2011,,,Patch Available,,,,0|i0z5gv:,203188,,,,,,,,"31/Mar/11 16:06;rpalache;Changes in Schema.java contributed by Horoki Tateno.
",31/Mar/11 18:25;rpalache;Horoki Tateno has granted a license to the ASF,"31/Mar/11 20:27;curtisr7;Ravi -

If the test fails and causes the build to hang... don't we want that to happen? A test that isn't run doesn't really test much.

I see that this problem was only observed on 1.1.x, but did you try to recreate this problem on trunk?

Thanks,
Rick","31/Mar/11 20:56;rpalache;Rick,

The only issue in including the test case is there is a chance of OutOfMemory.
The test case uses 10 threads out of which 6 threads continuously add elements (1million) to TreeMap and 4 threads tries to retrieve the added elements.
So there is a chance that the test can run into OutOfMemory.

Even with the above setup Iam able to replicate the issue only on a dual core machine and if the issue is reproduced 1 out of 10 runs.
I have a wrapper shell script that runs the same test 10 times and I always see that one of these tests hang (CPU spin) at TreeMap.get.

Regarding running this test case on trunk, I did not encounter the issue on trunk (using same wrapped shell script), 
can not say that the issue does not exist in trunk but I did not see it happen while running the same test case in trunk.

Regards,
Ravi.",,,,,,,,,,,,,,,,,,,,,,,
SQLServer / DataDirect SQLCode=HYT00 not handled,OPENJPA-1969,12502905,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,30/Mar/11 17:39,05/Apr/11 21:08,14/Mar/19 03:03,05/Apr/11 21:08,2.1.0,2.1.1,2.2.0,,,,,,2.1.1,2.2.0,,,,sql,,,,0,,,,,,,,"When using SQLServer and DataDirect JDBC driver, HYT00 SQLCode was thrown from the DataDirect driver on client side time-out, however it is not being handled and caused the following exception to percolate to the client.

**Exception: Caught unexpected exception from find.
    org.apache.openjpa.persistence.PersistenceException:[DataDirect][SQLServer JDBC Driver]Execution timeout expired. {prepstmnt 47005644 SELECT t0.version, t1.id, t1.version, t1.ENTITYALAZY_ID, t1.strData, t0.strData FROM JPA20EMEntityA t0 WITH (UPDLOCK) LEFT OUTER JOIN JPA20EMEntityC t1 WITH (UPDLOCK) ON t0.id = t1.ENTITYA_ID WHERE t0.id = ? [params=?]} [code=0, state=HYT00]
FailedObject: 1 [org.apache.openjpa.util.IntId] [java.lang.String]
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4869)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4829)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:136)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:86)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:338)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.initialize(WsJpaJDBCStoreManager.java:149)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:112)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1026)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:984)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:901)
	at com.ibm.ws.persistence.kernel.WsJpaBrokerImpl.find(WsJpaBrokerImpl.java:212)
	at org.apache.openjpa.kernel.DelegatingBroker.find(DelegatingBroker.java:231)
	at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:502)
	at suite.r80.base.jpaspec.entitymanager.testlogic.FindLockTestLogic.testScenarioL009(FindLockTestLogic.java:2161)
    .....

Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: [DataDirect][SQLServer JDBC Driver]Execution timeout expired. {prepstmnt 47005644 SELECT t0.version, t1.id, t1.version, t1.ENTITYALAZY_ID, t1.strData, t0.strData FROM JPA20EMEntityA t0 WITH (UPDLOCK) LEFT OUTER JOIN JPA20EMEntityC t1 WITH (UPDLOCK) ON t0.id = t1.ENTITYA_ID WHERE t0.id = ? [params=?]} [code=0, state=HYT00]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:281)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:265)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$700(LoggingConnectionDecorator.java:72)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeQuery(LoggingConnectionDecorator.java:1183)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:284)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeQuery(JDBCStoreManager.java:1785)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:274)
	at org.apache.openjpa.jdbc.sql.SelectImpl.executeQuery(SelectImpl.java:499)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:424)
	at com.ibm.ws.persistence.jdbc.sql.SelectImpl.execute(SelectImpl.java:89)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:382)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.getInitializeStateResult(JDBCStoreManager.java:576)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:378)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:333)
	... 42 more
NestedThrowables:
java.sql.SQLTimeoutException: [DataDirect][SQLServer JDBC Driver]Execution timeout expired.
	at com.ddtek.jdbc.sqlserverbase.ddb7.b(Unknown Source)
	at com.ddtek.jdbc.sqlserverbase.ddb7.a(Unknown Source)
	at com.ddtek.jdbc.sqlserverbase.ddb6.b(Unknown Source)
	at com.ddtek.jdbc.sqlserverbase.ddb6.a(Unknown Source)
	at com.ddtek.jdbc.sqlserverbase.ddei.a(Unknown Source)
	at com.ddtek.jdbc.sqlserverbase.ddei.u(Unknown Source)
	at com.ddtek.jdbc.sqlserverbase.dddb.executeQuery(Unknown Source)
	at com.ddtek.jdbcx.sqlserverbase.ddm.executeQuery(Unknown Source)
	at com.ibm.ws.rsadapter.jdbc.WSJdbcPreparedStatement.pmiExecuteQuery(WSJdbcPreparedStatement.java:1129)
	at com.ibm.ws.rsadapter.jdbc.WSJdbcPreparedStatement.executeQuery(WSJdbcPreparedStatement.java:731)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:286)
	at org.apache.openjpa.lib.jdbc.JDBCEventConnectionDecorator$EventPreparedStatement.executeQuery(JDBCEventConnectionDecorator.java:270)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:284)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeQuery(LoggingConnectionDecorator.java:1181)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:284)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeQuery(JDBCStoreManager.java:1785)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:274)
	at org.apache.openjpa.jdbc.sql.SelectImpl.executeQuery(SelectImpl.java:499)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:424)
	at com.ibm.ws.persistence.jdbc.sql.SelectImpl.execute(SelectImpl.java:89)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:382)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.getInitializeStateResult(JDBCStoreManager.java:576)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:378)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:333)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.initialize(WsJpaJDBCStoreManager.java:149)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:112)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1026)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:984)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:901)
	at com.ibm.ws.persistence.kernel.WsJpaBrokerImpl.find(WsJpaBrokerImpl.java:212)
	at org.apache.openjpa.kernel.DelegatingBroker.find(DelegatingBroker.java:231)
	at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:502)
	at suite.r80.base.jpaspec.entitymanager.testlogic.FindLockTestLogic.testScenarioL009(FindLockTestLogic.java:2161)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2358,,,2011-03-30 17:39:19.0,,,,,,,0|i0z5jr:,203201,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SQLServerDictionery not using DATETIME2 for jdbc driver other than MS JDBC driver,OPENJPA-1968,12502735,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,29/Mar/11 16:23,05/Apr/11 21:09,14/Mar/19 03:03,05/Apr/11 21:09,2.1.0,2.1.1,2.2.0,,,,,,2.1.1,2.2.0,,,,sql,,,,0,,,,,,,,"Use of DATETIME2 db type for Date/Time/Timestamp should based on the SQLServer database version not driver type/vendor.

As a consequence, if version field is a Timestamp data type, you may get optimistic lock exception due to timestamp precision mismatch and hence update to entity may failed.",,,,,,,,,,,,,,,,,,,29/Mar/11 16:33;allee8285;OPENJPA-1968.patch;https://issues.apache.org/jira/secure/attachment/12474896/OPENJPA-1968.patch,30/Mar/11 15:35;allee8285;TestDDTimestamp.java;https://issues.apache.org/jira/secure/attachment/12474977/TestDDTimestamp.java,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2359,,,Wed Mar 30 15:31:26 UTC 2011,,,Patch Available,,,,0|i0z5iv:,203197,,,,,,,,"30/Mar/11 15:31;allee8285;Even with the current changes in OpenJPA, one may still get the optimistic lock exception due to a problem in the DataDirect 4.2 jdbc driver.  A case W103290127 was opened against DataDirect to get this fix. Attached is a test case that reproduce the problem for reference. The problem is openjpa attempts to perform an executeUpdate(""DELETE/UPDATE"") and the method returns 0 instead of 1 due to timestamp mismatch. As a result, openjpa translates this condition to an optimistic lock exception.",,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException when using JAXB and MetaModel annotation processor,OPENJPA-1965,12502386,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,25/Mar/11 14:46,13/Jul/11 16:11,14/Mar/19 03:03,25/Mar/11 14:54,2.0.0,2.1.0,2.2.0,,,,,,2.1.1,2.2.0,,,,tooling,,,,0,,,,,,,,"This is a problem that was reported by Marc Logemann on the users mailing list. Details from the email exchange:
-----
....
So i see a lot of metamodel classes got generated but during this process i got this:

   [javac] An annotation processor threw an uncaught exception.
   [javac] Consult the following stack trace for details.
   [javac] java.lang.ClassCastException: com.sun.tools.javac.code.Symbol$PackageSymbol cannot be cast to javax.lang.model.element.TypeElement
   [javac]     at org.apache.openjpa.persistence.meta.AnnotationProcessor6.process(AnnotationProcessor6.java:207)
   [javac]     at com.sun.tools.javac.processing.JavacProcessingEnvironment.callProcessor(JavacProcessingEnvironment.java:625)
   [javac]     at com.sun.tools.javac.processing.JavacProcessingEnvironment.discoverAndRunProcs(JavacProcessingEnvironment.java:554)
   [javac]     at com.sun.tools.javac.processing.JavacProcessingEnvironment.doProcessing(JavacProcessingEnvironment.java:699)
   [javac]     at com.sun.tools.javac.main.JavaCompiler.processAnnotations(JavaCompiler.java:981)
   [javac]     at com.sun.tools.javac.main.JavaCompiler.compile(JavaCompiler.java:727)
   [javac]     at com.sun.tools.javac.main.Main.compile(Main.java:353)
   [javac]     at com.sun.tools.javac.main.Main.compile(Main.java:279)
   [javac]     at com.sun.tools.javac.main.Main.compile(Main.java:270)
   [javac]     at com.sun.tools.javac.Main.compile(Main.java:69)
   [javac]     at com.sun.tools.javac.Main.main(Main.java:54)
....
-----

Details on how to recreate :
....
Hi,

this is nearly impossible because its not an Entity which makes the problem here. Its a package. I have no idea how to unit test that. Perhaps you can try creating
a simple package with JAXB generated classes in it and try to reproduce:

1) create a very simple XSD file
2) run the JAXB compiler via ANT (then you should have some classes in myweirdpackage)

   <target name=""JAXBCompiling"" description=""Compile main source tree java files"">
       <taskdef name=""xjc"" classname=""com.sun.tools.xjc.XJC2Task"" classpathref=""toolingclasspath""/>

       <xjc schema=""my.xsd"" destdir=""${src.dir}""  package=""domain.myweirdpackage""/>
 </target>

3) put at least one Entity in domain package (parent of myweirdpackage)
4) run the MetaModel compiling step",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-05-04 17:49:11.01,,,no_permission,,,,,,,,,,,,2363,,,Wed Jul 13 16:11:22 UTC 2011,,,,,,,0|i0z0nr:,202409,,,,,,,,25/Mar/11 14:48;curtisr7;Pinaki fixed this problem for trunk (2.2.0) in revision 1084944 .,04/May/11 17:49;mjarends;I am experiencing this same exception when generating metamodel classes for OpenJPA 2.0.2. Is this issue caused by having JAXB annotations in the same class file as JPA annotations or is it caused by something else. Is there a known workaround for the issue? Thanks.,04/May/11 18:00;curtisr7;Can you try running on trunk?,13/Jul/11 16:11;curtisr7;Closing resolved issues.,,,,,,,,,,,,,,,,,,,,,,,
openjpa.InitializeEagerly breaks bean-validation integration,OPENJPA-1960,12501521,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,gpetracek,gpetracek,15/Mar/11 23:19,02/Feb/12 17:07,14/Mar/19 03:03,22/Mar/11 20:51,2.1.0,2.2.0,,,,,,,2.2.0,,,,,kernel,validation,,,0,,,,,,,,"<property name=""openjpa.InitializeEagerly"" value=""true""/> breaks the bean-validation integration

AbstractBrokerFactory#makeReadOnly
evaluates conf.isInitializeEagerly() which returns true (due to the config) and calls _conf.setReadOnly(Configuration.INIT_STATE_FROZEN)
+ at the end of AbstractBrokerFactory#initializeBroker it gets called again

that causes:
the created BrokerFactory gets used as argument for PersistenceProviderImpl#loadValidator which fails (with a warning or an exception depending on the validation-mode configured in the persistence.xml) because the config is in state INIT_STATE_FROZEN",,,,,,,,,,,,,,,,,,,18/Mar/11 16:09;curtisr7;OPENJPA-1960-test_fix.jar;https://issues.apache.org/jira/secure/attachment/12474011/OPENJPA-1960-test_fix.jar,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-03-16 00:43:05.444,,,no_permission,,,,,,,,,,,,2368,,,Thu Feb 02 17:07:46 UTC 2012,,,,,,,0|i0z5fz:,203184,,,,,,,,"16/Mar/11 00:43;curtisr7;What is the exception / warning that you are getting?

Thanks,
Rick","16/Mar/11 02:19;gpetracek;with the default validation mode (== auto):
WARN   [btpool0-1] openjpa.Runtime - Could not create the optional validation provider. Reason returned: ""Can not modify ""LifecycleEventManager"" because the property is not dynamic and the current configuration is read-only.""

in case of <validation-mode>CALLBACK</validation-mode> it is:
Caused by: java.lang.RuntimeException: Can not modify ""LifecycleEventManager"" because the property is not dynamic and the current configuration is read-only.
	at org.apache.openjpa.lib.conf.Value.assertChangeable(Value.java:480)
	at org.apache.openjpa.lib.conf.PluginValue.setString(PluginValue.java:135)
	at org.apache.openjpa.conf.OpenJPAConfigurationImpl.setLifecycleEventManager(OpenJPAConfigurationImpl.java:1742)
	at org.apache.openjpa.persistence.validation.ValidationUtils.setupValidation(ValidationUtils.java:103)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.loadValidator(PersistenceProviderImpl.java:325)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:104)
","18/Mar/11 16:09;curtisr7;Attaching a test fix. The jar has a patch file of the changes, and the compiled .class change.","18/Mar/11 16:10;curtisr7;Gerhard -

Please give the attached patch a try. 

I really don't like the change, but I want to make sure I am looking at fixing the same path that you are reporting. Once I get the thumbs up from you I'll see about fixing this another way.

Thanks,
Rick",18/Mar/11 21:11;gpetracek;your bypass of #assertChangeable works,22/Mar/11 20:51;curtisr7;Committed revision 1084349 to trunk.,02/Feb/12 17:07;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,
RuntimeExceptionTranslator should be transient in DelegatingQuery,OPENJPA-1959,12501261,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,12/Mar/11 19:04,13/Jul/11 16:11,14/Mar/19 03:03,12/Mar/11 19:15,1.2.2,2.0.1,2.1.0,2.2.0,,,,,2.1.1,2.2.0,,,,kernel,,,,0,,,,,,,,RuntimeExceptionTranslator contains a reference to an EntityManager which may not be serializable. ,,3600,3600,,0%,3600,3600,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-03-13 08:42:30.792,,,no_permission,,,,,,,,,,,,2369,,,Sun Mar 13 08:42:30 UTC 2011,,,,,,,0|i0z0lb:,202398,,,,,,,,"13/Mar/11 08:42;milosz;Changed fix version to 2.1.1 since 2.1.0 is already released.
",,,,,,,,,,,,,,,,,,,,,,,,,,
IndexOutOfBoundsException in BatchingPreparedStatementManagerImpl,OPENJPA-1958,12501250,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,12/Mar/11 16:11,13/Jul/11 16:11,14/Mar/19 03:03,12/Mar/11 18:46,1.2.2,2.0.1,2.1.0,2.2.0,,,,,2.1.1,2.2.0,,,,jdbc,,,,0,,,,,,,,Under rare conditions the batchedRows in the batching prepared statement manager may be empty by the time we process an SQLException. In this case an IndexOutOfBoundsException occurs. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,2370,,,2011-03-12 16:11:16.0,,,,,,,0|i0z0fz:,202374,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
XML overriding column names for ArrayList attributes causes exception.,OPENJPA-1957,12500828,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,jpaheath,jpaheath,09/Mar/11 00:11,26/Jan/12 18:20,14/Mar/19 03:03,09/Mar/11 22:48,1.2.2,2.0.1,2.1.0,,,,,,1.2.3,2.0.2,2.1.1,2.2.0,,jdbc,,,,0,,,,,,,,"Take an entity class similar to the following:

public class MyEntity implements Serializable {
   protected String _id;
   protected ArrayList<String> myStrings = new ArrayList<String>();
.......

and a corresponding XML mapping in orm.xml:

  	<entity class=""somepackage.MyEntity"" access=""FIELD"">
		<table name=""MY_TABLE""/>
		<attributes>
			<id name=""_id"">
				<column name=""MYENTITY_ID"" nullable=""false"" />
			</id>
          <basic name=""myStrings"">
            <column name=""MY_STRINGS""/>
            <lob/>
         </basic>
		</attributes>
	</entity>


With this configuration, the following exception can occur:

org.apache.openjpa.persistence.ArgumentException: You have supplied columns for ""somepackage.MyEntity.myStrings<element:class java.lang.String>"", but this mapping cannot have columns in this context.
	at org.apache.openjpa.jdbc.meta.MappingInfo.assertNoSchemaComponents(MappingInfo.java:327)
	at org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy.map(HandlerFieldStrategy.java:77)
	at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:121)
	at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:80)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:454)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:419)
	at org.apache.openjpa.jdbc.meta.ClassMapping.resolveNonRelationMappings(ClassMapping.java:881)
	at org.apache.openjpa.jdbc.meta.MappingRepository.prepareMapping(MappingRepository.java:418)
..............
",,,,,,,,,,,,,,,,OPENJPA-2117,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-01-21 16:47:24.747,,,no_permission,,,,,,,,,,,,2371,,,Sat Jan 21 16:47:24 UTC 2012,,,,,,,0|i1duiv:,289042,,,,,,,,"20/Jan/12 20:02;jpaheath;Hi!  I have a test (to be included) where I see the same exception which was fixed via this JIRA:

<openjpa-1.2.3-SNAPSHOT-r422266:1176024 fatal user error> org.apache.openjpa.persistence.ArgumentException: You have supplied columns for ""org.apache.openjpa.persistence.arrays.model.XMLOneToManyEntity.xmlManyToOneList"", but this mapping cannot have columns in this context.
	at org.apache.openjpa.jdbc.meta.MappingInfo.assertNoSchemaComponents(MappingInfo.java:327)
	at org.apache.openjpa.jdbc.meta.strats.RelationToManyTableFieldStrategy.map(RelationToManyTableFieldStrategy.java:96)
	at org.apache.openjpa.jdbc.meta.strats.RelationCollectionTableFieldStrategy.map(RelationCollectionTableFieldStrategy.java:94)
	at org.apache.openjpa.jdbc.meta.FieldMapping.setStrategy(FieldMapping.java:121)
	at org.apache.openjpa.jdbc.meta.RuntimeStrategyInstaller.installStrategy(RuntimeStrategyInstaller.java:80)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolveMapping(FieldMapping.java:454)
	at org.apache.openjpa.jdbc.meta.FieldMapping.resolve(FieldMapping.java:419)
	at org.apache.openjpa.jdbc.meta.ClassMapping.resolveMapping(ClassMapping.java:855)
	at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1651)
	at org.apache.openjpa.meta.MetaDataRepository.processBuffer(MetaDataRepository.java:812)
	at org.apache.openjpa.meta.MetaDataRepository.resolveMapping(MetaDataRepository.java:772)
	at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:650)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:393)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataLocking(MetaDataRepository.java:366)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:360)
	at org.apache.openjpa.jdbc.meta.MappingRepository.getMapping(MappingRepository.java:356)
	at org.apache.openjpa.jdbc.meta.MappingTool.getMapping(MappingTool.java:676)
	at org.apache.openjpa.jdbc.meta.MappingTool.buildSchema(MappingTool.java:748)
	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:646)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:153)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:119)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:189)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:192)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:145)
	at org.apache.openjpa.persistence.arrays.TestXMLOneToManyEntity.testExceptionArrayAsLob(TestXMLOneToManyEntity.java:34)
	.......................

I see the same exception when I run my test on trunk.  The kicker is, if I back out the changes made in this JIRA, on both 1.2.x and trunk, my test passes!!  :-(  Of course, with the code changes backed out, the test Mike created for the JIRA fails.  So something is not quite right/complete about this fix.  

Attached is a test, named  ""XMLMappingIssue-trunk.test"" which you can simply apply to any OpenJPA release.  I'd assume that if we fix this issue on trunk the same fix would apply to 1.2.x........although, the fix Mike made to 1.2.x is for some reason a bit different than the one he made to trunk so we may want to keep this in mind and become familiar with the differences.

Does anyone have any thoughts here?

Thanks,

Heath","21/Jan/12 16:47;mikedd;I'd need to see the testcase to comment. From memory, there's nothing functionally different between the changes in 1.2.x or any other release. The annotation parser class was refactored for new annotations in JPA 2.0 and I just slotted this code around that. 

",,,,,,,,,,,,,,,,,,,,,,,,,
"missing key ""cant-set-value"" in localizer properties org.apache.openjpa.jdbc.meta.strats",OPENJPA-1951,12499589,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,vvidovic,vvidovic,24/Feb/11 12:38,13/Jul/11 16:11,14/Mar/19 03:03,24/Feb/11 14:47,2.0.1,,,,,,,,2.0.2,2.1.0,2.2.0,,,jdbc,,,,0,,,,,,,,"Key cant-set-value is missing in properties file org.apache.openjpa.jdbc.meta.strats in openjpa-jdbc-2.0.1.jar so we don't get descriptive message in case this exception occurs.
To reproduce it set some field as not nullable in jpa and try to update it with null value.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-02-24 14:39:14.241,,,no_permission,,,,,,,,,,,,68154,,,Thu Feb 24 17:49:25 UTC 2011,,,,,,,0|i0z0rz:,202428,,,,,,,,24/Feb/11 13:15;vvidovic;This key is present in 2.1.0 version (4 days ago) but this version is compiled with java 1.6 and we can't use it in our environment (WebSphere 6.1).,"24/Feb/11 14:39;kwsutter;Hi.  Even though OpenJPA 2.1.x is built with Java 6, it *should* still run okay with Java 5.  You won't have access to the MetaModel annotation processor (code generation), but that wouldn't be new for your environment.  I am in the process of updating this old article [1] to explain how to use OpenJPA 2.x in WebSphere v6.1 environment (non-managed, of course) and I have not had any problems running the samples and tests in this environment.  The updated article should be posted soon on Developer Works.

I'm not trying to justify not fixing this in OpenJPA 2.0.x, but I thought I would let you know that I think the OpenJPA 2.1.x driver would work for you as well.

[1]  http://www.ibm.com/developerworks/websphere/techjournal/0612_barcia/0612_barcia.html","24/Feb/11 14:47;mikedd;This issue was originally reported on the users mailing list:
http://markmail.org/message/mfsloxguhitlrrsn

This issue has already been fixed in 

2.0.x: revision 1068004
2.1.x: revision 1068002
trunk: revision 1067989","24/Feb/11 15:04;vvidovic;Unfortunately an OpenJPA 2.1.x can't be used with jdk 1.5, here is a simple test which can prove that:
java -cp openjpa-jdbc-2.1.0.jar org.apache.openjpa.jdbc.meta.MappingTool
The java class could not be loaded. java.lang.UnsupportedClassVersionError: (org/apache/openjpa/jdbc/meta/MappingTool) bad major version at offset=6

And this stops us from using new version in a current project :(",24/Feb/11 16:16;mikedd;OpenJPA 2.0.2 should work for you - when it's released. I can give you a patch for the openjpa jar if you need something in the mean time (or you can grab a snapshot build for 2.0.2). ,"24/Feb/11 16:38;kwsutter;You are correct, Vedran.  My mistake.  All of my testing and experimentation was with OpenJPA 2.0.x.  The OpenJPA 2.1.x (and beyond) binaries require Java 6 for the runtime.  Thanks for the clarification.","24/Feb/11 17:49;vvidovic;For now I temporarily copied a properties file in our project to override one in a jar package (and added a missing key, copied from 2.1.0 version). We will switch to 2.0.2 when it becomes available from a maven2 repo.

Thanks for a quick fix :)",,,,,,,,,,,,,,,,,,,,
Extra select statements executed when version column is null. ,OPENJPA-1944,12499043,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,mikedd,mikedd,18/Feb/11 14:37,02/Feb/12 17:07,14/Mar/19 03:03,22/Mar/11 21:07,1.2.2,2.1.0,,,,,,,2.1.1,2.2.0,,,,,,,,0,,,,,,,,"This problem was originally reported on the users mailing list by Diego Cattelan. Link to the thread :http://openjpa.208410.n2.nabble.com/N-query-problem-with-Version-td6027619.html

The problem occurs if a null value is returned for an entity's version field. In this case OpenJPA will issue a second select statement to re-fetch the version, potentially resulting in a lot of repetitive SQL statements. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-03-22 14:37:07.655,,,no_permission,,,,,,,,,,,,162164,,,Thu Feb 02 17:07:12 UTC 2012,,,,,,,0|i1dul3:,289052,,,,,,,,22/Mar/11 14:37;curtisr7;Reopening this JIRA as it needs a bit more work.,22/Mar/11 17:32;curtisr7;The previous change that Mike committed causes an OLE if an Entity with a null version is updated. The change I'm going to commit shortly here reverts the previous commit and looks to see if a null version field has been loaded before going back to the DB. ,22/Mar/11 21:07;curtisr7;Checked changes into 2.1.x and trunk,02/Feb/12 17:07;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,
Query timeout hint not honored consistently when pessimistic lock is issued to database requires multi-statements locking scheme,OPENJPA-1943,12498950,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,17/Feb/11 21:01,18/Feb/11 19:38,14/Mar/19 03:03,18/Feb/11 19:38,2.0.1,2.1.0,2.2.0,,,,,,2.1.1,2.2.0,,,,jpa,kernel,,,0,,,,,,,,"Query timeout and lock timeout values are stored in fetch plan/configuration. Due to semantic difference between the Query and em API, separate fetch plan/configuration objects are attached to QueryImpl and EntityManagerImpl. 

When pessimistic lock is enforced by the provider to a query, if the underlying data base requires to generate multiple SQL statements, the timeout value from the QueryImpl is used to execute the data portion of the SQL statements but the timeout value from the EntityManagerImpl is used to issue the ""FOR UPDATE"" lock to the related table. This caused the discrepancy that the query timeout is NOT being honored. As a result, some database may wait forever and caused a ""hung"" scenario even the query timeout value is set. 
    

",,,,,,,,,,,,,,,,,,,18/Feb/11 16:36;allee8285;OPENJPA-1943.patch;https://issues.apache.org/jira/secure/attachment/12471421/OPENJPA-1943.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162163,,,2011-02-17 21:01:00.0,,,Patch Available,,,,0|i0z627:,203284,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ReverseMapping tool does not find primary keys with Oracle,OPENJPA-1940,12498801,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,16/Feb/11 19:42,28/Jun/11 18:07,14/Mar/19 03:03,21/Feb/11 21:35,2.1.0,,,,,,,,2.1.1,2.2.0,,,,jdbc,,,,0,,,,,,,,"When running the reverse mapping tool on Oracle we are unable to identify the primary key column for a table. 

The root cause is the prepared statement generated by OracleDictionary. The parameter value uses the qualified name for the table instead of the unqualified name (e.g. SCOTT.SimpleEntity instead of SimpleEntity). 

The output of the tool will look something like this : 

669  persistence-tests  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.OracleDictionary"".
3128  persistence-tests  INFO   [main] openjpa.Tool - ReverseMappingTool : generating classes.
3132  persistence-tests  INFO   [main] openjpa.MetaData - Table ""SCOTT.SIMPLEENTITY"" could not be reverse mapped.  This means that the table does not have a primary key (primary keys are required to establish unique identifiers for all persistent objects) and does not match a known pattern for a table used for cross-reference or value collections.
3133  persistence-tests  INFO   [main] openjpa.Tool - Generating annotations.
3282  persistence-tests  INFO   [main] openjpa.Tool - Writing generated class source code.
3283  persistence-tests  INFO   [main] openjpa.Tool - Writing generated metadata.

",,0,0,,0%,0,0,,,,,,,OPENJPA-2022,,,,,16/Feb/11 19:54;mikedd;ASF.LICENSE.NOT.GRANTED--OPENJPA-1940.diff.txt;https://issues.apache.org/jira/secure/attachment/12471219/ASF.LICENSE.NOT.GRANTED--OPENJPA-1940.diff.txt,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,69841,,,2011-02-16 19:42:31.0,,,Patch Available,,,,0|i0z0an:,202350,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
index identifier max length for DB2 v9 is 128. ,OPENJPA-1939,12498581,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,14/Feb/11 22:30,21/Feb/11 21:40,14/Mar/19 03:03,21/Feb/11 19:46,1.2.2,2.0.1,2.1.0,,,,,,2.1.1,2.2.0,,,,jdbc,,,,0,,,,,,,,"The index indentifier limit for DB2 is 128 for db2 v9 but only 18 for earlier versions of DB2. We already detect the db2 level in the dictionary, this is just a matter of setting the appropriate value.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162161,,,Wed Feb 16 16:33:08 UTC 2011,,,,,,,0|i1dulr:,289055,,,,,,,,16/Feb/11 16:33;mikedd;Seeing some unit test problems with this change. Removing from 2.1.0 for now. ,,,,,,,,,,,,,,,,,,,,,,,,,,
Typo of time data type in SQLServerdictionary for MSSQL 2008,OPENJPA-1938,12498188,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,allee8285,allee8285,10/Feb/11 03:06,10/Feb/11 20:55,14/Mar/19 03:03,10/Feb/11 20:55,2.1.0,2.2.0,,,,,,,2.1.0,2.2.0,,,,sql,,,,0,,,,,,,,"Test case failures in TestTemporalTypeQueryParameterBinding due to timeTypeName in SQLServerDictionary.

See OPENJPA-1759 for the original feature support.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162160,,,2011-02-10 03:06:42.0,,,,,,,0|i1dulz:,289056,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Informix lock exceptions are not mapped properly by OpenJPA,OPENJPA-1935,12497418,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,02/Feb/11 04:13,02/Feb/12 17:06,14/Mar/19 03:03,15/Feb/11 21:26,2.1.0,2.2.0,,,,,,,2.1.0,2.2.0,,,,jdbc,,,,0,exception,Informix,lock,,,,,"Locking type failures are not mapped correctly when using Informix with OpenJPA.  When a SQLException with generic sql state value 'IX000' is returned, it gets mapped to a query exception.  Instead, the underlying SQLException(s) should be inspected for specific lock or lock timeout sql codes to determine the correct exception type.",Informix IDS 10 and IDS 11,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-02-02 21:37:36.674,,,no_permission,,,,,,,,,,,,162157,,,Thu Feb 02 17:06:32 UTC 2012,,,,,,,0|i1dumn:,289059,,,,,,,,02/Feb/11 21:37;ppoddar@apache.org;IX000 is specified as query error for Informix in sql-error-state-codes.xml. See DBDictionary.narrow(...) to overwrite for Informix.,"02/Feb/11 22:31;techhusky;Thanks, Pinaki.  I have a fix brewing down the DBDictionary.narrow path.  It actually overwrites matchErrorState (called by narrow to determine the exception type) and fixes isFatalException which is also semi-broken in the Informix dictionary.  I just need to finish cleaning up the jUnits before posting a fix...  :-)",02/Feb/12 17:06;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,
Documentation corrections,OPENJPA-1932,12497153,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,milosz,milosz,milosz,30/Jan/11 10:38,02/Feb/12 17:05,14/Mar/19 03:03,05/Jan/12 10:54,2.1.0,,,,,,,,2.2.0,,,,,docs,,,,0,,,,,,,,"This issue can be used for updates to user manual, javadoc, localizers to correct things like spelling or to make editorial changes.",,,,,,,,,,,OPENJPA-1510,,,OPENJPA-1520,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-07-21 21:56:00.177,,,no_permission,,,,,,,,,,,,67222,,,Thu Feb 02 17:05:57 UTC 2012,,,,,,,0|i1du7j:,288991,,,,,,,,"30/Jan/11 10:46;milosz;Why did we revert some of JSE 6 javadoc links back to JSE 5 in OPENJPA-1520?
","21/Jul/11 21:56;mikedd;I know this is late, but I think the JSE 6 links were broken to illustrate that you could use a JRE 5 runtime, even though we require JDK6 to build OpenJPA. 

If there's another reason I'd be interested in hearing it. Thanks going through an updating all of these. ",02/Feb/12 17:05;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,
Resolving factory method does not allow method overriding,OPENJPA-1928,12496199,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,curtisr7,esargisson,esargisson,20/Jan/11 23:43,02/Feb/12 17:05,14/Mar/19 03:03,22/Mar/11 18:24,1.2.1,2.0.1,,,,,,,2.2.0,,,,,kernel,,,,0,,,,,,,,"If a get method is annotated with @Factory then the method cannot be overridden with a method which take different parameters. The system randomly selects one of the several methods with the same name which may or may not take the type which will be provided.

For example:
        @Persistent(optional = false)
	@Column(name = ""STATUS"")
	@Externalizer(""getName"")
	@Factory(""valueOf"")
	public OrderStatus getStatus() {
		return this.status;
	}

public class OrderStatus {
   public static OrderStatus valueOf(final int ordinal) {
        return valueOf(ordinal, OrderStatus.class);
    }
    
    public static OrderStatus valueOf(final String name) {
        return valueOf(name, OrderStatus.class);
    }
}

Actual results:
valueOf(String) may or may not be selected.

Expected results:
valueOf(String) should always be selected.

The provided patches fix this defect by applying the method invocation conversion rules from the Java Language Specification, 3rd Ed. This means that widening primitive, boxing and unboxing conversions are all respected.",,,,,,,,,,,,,,,,,,,20/Jan/11 23:48;esargisson;OPENJPA-1928-1.2.1.patch;https://issues.apache.org/jira/secure/attachment/12468923/OPENJPA-1928-1.2.1.patch,20/Jan/11 23:48;esargisson;OPENJPA-1928-r1061099.patch;https://issues.apache.org/jira/secure/attachment/12468924/OPENJPA-1928-r1061099.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2011-03-22 18:24:25.789,,,no_permission,,,,,,,,,,,,162152,,,Thu Feb 02 17:05:04 UTC 2012,,,Patch Available,,,,0|i1du8f:,288995,,,,,,,,"22/Mar/11 18:24;curtisr7;Committed revision 1084280 to trunk. 

Thanks for the contribution Edward!",02/Feb/12 17:05;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,,
Allow flexible (non-standard) syntax for collection-valued parameters in IN() expresseion of  JPQL query,OPENJPA-1923,12495627,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,14/Jan/11 21:52,02/Feb/12 17:04,14/Mar/19 03:03,31/Jan/11 17:00,,,,,,,,,2.1.0,2.2.0,,,,query,,,,0,,,,,,,,"IN expression in JPQL query is defined in BNF as:

in_expression ::= {state_field_path_expression | type_discriminator} [NOT] IN { ( in_item {, in_item}* ) | (subquery) | collection_valued_input_parameter }  

The parentheses are used for comma-separated in_term, but no parentheses around collection_valued_input_parameter. OpenJPA 2.0 adheres to this syntax and hence raises exception for
String jpql = ""select a from Address a where a.zip in (:p)"";
em.createQuery(jpql).setParameter(p, Array.asList(12345, 23456));

java.lang.IllegalArgumentException:Invalid input parameter ""p"". A collection valued parameter syntax may incorrectly used in the query string. If the parameter is parenthesized, remove the parentheses and try again.

However, earlier OpenJPA versions supported parentheses around the parameter. 

This issue will reinstate the behavior such that both queries
""select a from Address a where a.zip in (:p)"";
""select a from Address a where a.zip in  :p"";

will be valid when parameter p is bound to a collection or list value.  

The unlikely case of binding a single value to ""select a from Address a where a.zip in (:p)"" will be disallowed. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-01-31 17:00:38.443,,,no_permission,,,,,,,,,,,,162147,,,Thu Feb 02 17:04:18 UTC 2012,,,,,,,0|i1du9b:,288999,,,,,,,,31/Jan/11 17:00;mikedd;Resolving to prepare for 2.1.0 release. ,02/Feb/12 17:04;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,,
MetaDataRepository.preload() ignores class loader returned by PersistenceUnitInfo.getClassLoader(),OPENJPA-1918,12494845,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,wolfgang.glas@ev-i.at,wolfgang.glas@ev-i.at,06/Jan/11 14:11,02/Feb/12 17:03,14/Mar/19 03:03,06/Jan/11 22:11,2.0.1,2.1.0,2.2.0,,,,,,2.1.0,2.2.0,,,,kernel,,,,0,,,,,,,,"We are using openjpa inside an OSGi container together with

   openjpa.MetaDataRepository"" value=""Preload=true""

We pass the appliation class loeader as part of our PersistenceUnitInfo implementation by returning it from PersistenceUnitInfo.getClassLoader().

However, the code in MetaDataRepository.preload() only uses the context class loader and not the class loader from PersistenceUnitInfo, which leades to ClassNotFoundExpcetions like mentioned at the end of this report.

A fix might be quite easily establihed by appending the return value of PersistenceUnitInfo.getClassLoader() to the list of claas loaders participating in the MultiClassLoader set up in
  
  MetaDataRepository.java:310ff

In the meanwhile, we are additionally setting our classloader as context loader during the creation of the EntityManagerFactory by PersistenceProvider.createContainerEntityManagerFactory(), but a fix in MetaDatRepository.preload() is highly appreciated.

  TIA for fixing this,

   Wolfgang

Stack trace:

org.osgi.service.blueprint.container.ComponentDefinitionException: Error when instantiating bean entityManagerFactory of class null
	at org.apache.aries.blueprint.container.BeanRecipe.getInstance(BeanRecipe.java:233)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
	at org.apache.aries.blueprint.container.BeanRecipe.internalCreate(BeanRecipe.java:726)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
	at org.apache.aries.blueprint.di.AbstractRecipe.create(AbstractRecipe.java:64)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
	at org.apache.aries.blueprint.container.BlueprintRepository.createInstances(BlueprintRepository.java:219)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
	at org.apache.aries.blueprint.container.BlueprintRepository.createAll(BlueprintRepository.java:147)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.instantiateEagerComponents(BlueprintContainerImpl.java:624)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.doRun(BlueprintContainerImpl.java:315)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.run(BlueprintContainerImpl.java:213)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)[:1.6.0_20]
	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)[:1.6.0_20]
	at java.util.concurrent.FutureTask.run(FutureTask.java:166)[:1.6.0_20]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:165)[:1.6.0_20]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:266)[:1.6.0_20]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)[:1.6.0_20]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)[:1.6.0_20]
	at java.lang.Thread.run(Thread.java:636)[:1.6.0_20]
Caused by: <openjpa-2.0.1-r422266:989424 fatal user error> org.apache.openjpa.persistence.ArgumentException: Unexpected error during early loading of entity metadata during initialization. See nested stacktrace for details.	  
	at org.apache.openjpa.meta.MetaDataRepository.preload(MetaDataRepository.java:331)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.preloadMetaDataRepository(PersistenceProviderImpl.java:280)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:211)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createContainerEntityManagerFactory(PersistenceProviderImpl.java:65)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)[:1.6.0_20]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)[:1.6.0_20]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[:1.6.0_20]
	at java.lang.reflect.Method.invoke(Method.java:616)[:1.6.0_20]
	at org.apache.aries.blueprint.container.AbstractServiceReferenceRecipe$JdkProxyFactory$1.invoke(AbstractServiceReferenceRecipe.java:632)
	at $Proxy67.createContainerEntityManagerFactory(Unknown Source)
	at org.clazzes.util.jpa.provider.EntityManagerFactoryFactory.newEntityManagerFactory(EntityManagerFactoryFactory.java:108)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)[:1.6.0_20]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)[:1.6.0_20]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[:1.6.0_20]
	at java.lang.reflect.Method.invoke(Method.java:616)[:1.6.0_20]
	at org.apache.aries.blueprint.utils.ReflectionUtils.invoke(ReflectionUtils.java:221)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
	at org.apache.aries.blueprint.container.BeanRecipe.invoke(BeanRecipe.java:844)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
	at org.apache.aries.blueprint.container.BeanRecipe.getInstance(BeanRecipe.java:231)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
	... 15 more
Caused by: java.security.PrivilegedActionException: java.lang.ClassNotFoundException: org.clazzes.fancymail.server.entities.EMail
	at java.security.AccessController.doPrivileged(Native Method)[:1.6.0_20]
	at org.apache.openjpa.meta.MetaDataRepository.preload(MetaDataRepository.java:326)
	... 32 more
Caused by: java.lang.ClassNotFoundException: org.clazzes.fancymail.server.entities.EMail
	at org.apache.openjpa.lib.util.MultiClassLoader.findClass(MultiClassLoader.java:216)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:321)[:1.6.0_20]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:266)[:1.6.0_20]
	at java.lang.Class.forName0(Native Method)[:1.6.0_20]
	at java.lang.Class.forName(Class.java:264)[:1.6.0_20]
	at org.apache.openjpa.lib.util.J2DoPrivHelper$4.run(J2DoPrivHelper.java:233)
	at org.apache.openjpa.lib.util.J2DoPrivHelper$4.run(J2DoPrivHelper.java:231)
	... 34 more

","apache-karaf-2.1.0, openjdk-1.6.0b20",,,,,,,,,,,,,,,,,,06/Jan/11 22:33;curtisr7;OPENJPA-1918.2.patch;https://issues.apache.org/jira/secure/attachment/12467676/OPENJPA-1918.2.patch,06/Jan/11 16:16;curtisr7;openjpa-1918.1-trunk.jar;https://issues.apache.org/jira/secure/attachment/12467643/openjpa-1918.1-trunk.jar,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2011-01-06 15:57:42.75,,,no_permission,,,,,,,,,,,,162142,,,Thu Feb 02 17:03:42 UTC 2012,,,,,,,0|i0z327:,202798,,,,,,,,06/Jan/11 15:57;curtisr7;Would you be able to try out a patch for 2.1.x or trunk?,06/Jan/11 16:16;curtisr7;Please give this patch a try. It should work on 2.1.x and trunk.... it might even work for 2.0.x.,"06/Jan/11 16:31;wolfgang.glas@ev-i.at;Rick,

ThX for having alook at my issue, I sure will try out any patch. I've now checked out the 2.1.x branch an I will hopefully be able to compile the stuff.

Right now it looks like I have a good mileage ;-)

I had to increase my ulimit for the  maximal number of open files in order to get teh enhance test up and running, ithis ok ? :-/

And 2.1.0 as a target milestone looks quite OK for me.

  Best regards, Wolfgang","06/Jan/11 16:35;wolfgang.glas@ev-i.at;Rick, could you please supply the patch as an output of 'svn diff' or 'diff -u', so I can apply it to my working copy of the 2.1.x branch ?

TIA, Wolfgang","06/Jan/11 19:01;curtisr7;Wolfgang -

Take a peek inside the jar... the patch is there.

Thanks,
Rick","06/Jan/11 22:11;wolfgang.glas@ev-i.at;Fixed by Rick's patch, works like acharm for me ;-)","06/Jan/11 22:12;wolfgang.glas@ev-i.at;Rick, Thanks for your patch, forgot to mention, that I applis it to 2.1.x branch an now I don't need the context class laoder workaround anymore.","06/Jan/11 22:33;curtisr7;Wolfgang -

Can I have you also try with this patch? I re-ordered the classloaders because I'm quite paranoid that I'm going to break others with this change. Please confirm that this also fixes your problem.

Thanks so much!

Rick","06/Jan/11 22:49;wolfgang.glas@ev-i.at;Second version works for me, too ;-)

In apache-karaf the standard context class laoder is a boot delegation class loader from teh framework essentially exposing system and framework classes. The bundle class loader ait atop of this boot delgation class loader, so the order in your patch should not cause majot headaches insode apache-karaf.

Sorry for setting the issue to resolved so fast :-/

  Wolfgang",02/Feb/12 17:03;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,
missing license header,OPENJPA-1915,12494606,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,struberg,struberg,04/Jan/11 15:07,04/Jan/11 15:36,14/Mar/19 03:03,04/Jan/11 15:36,2.2.0,,,,,,,,2.2.0,,,,,,,,,0,,,,,,,,a few files miss the ALv2 license headers thus leading to a build error,,,,,,,,,,,,,,,,,,,04/Jan/11 15:12;struberg;OPENJPA-1915.patch;https://issues.apache.org/jira/secure/attachment/12467426/OPENJPA-1915.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-01-04 15:09:51.697,,,no_permission,,,,,,,,,,,,162139,,,Tue Jan 04 15:12:07 UTC 2011,,,,,,,0|i0z2z3:,202784,,,,,,,,04/Jan/11 15:09;curtisr7;It looks like Fay missed a couple headers with her latest commit... sorry I missed the build break. I'll get it cleaned up asap.,04/Jan/11 15:12;struberg;patch for adding the license headers,,,,,,,,,,,,,,,,,,,,,,,,,
enhancer generates invalid code if fetch-groups is activated,OPENJPA-1912,12494520,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,mikedd,struberg,struberg,03/Jan/11 19:48,17/May/13 23:42,14/Mar/19 03:03,16/Feb/11 02:12,2.0.0,2.0.1,2.1.0,,,,,,2.2.0,,,,,Enhance,,,,0,,,,,,,,"If openjpa.DetachState =fetch-groups is used, the enhancer will add a 'implements Externalizable' + writeExternal + readExternal.

The problem is, that writeExternal and readExternal will also try to externalize the private members of any given superclass. Thus we get a runtime Exception that we are not allowed to access those fields.

Example:

@Entity
public abstract class AbstractGroup {
   ...
    @Temporal(TemporalType.TIMESTAMP)
    @TrackChanges
    private Date applicationBegin;
 ...
}

and 

@Entity
public class Group extends AbstractGroup {
...
}

will result in the following code (decompiled with jad):

    public void writeExternal(ObjectOutput objectoutput)
        throws IOException
    {
        pcWriteUnmanaged(objectoutput);
        if(pcStateManager != null)
        {
            if(pcStateManager.writeDetached(objectoutput))
                return;
        } else
        {
            objectoutput.writeObject(pcGetDetachedState());
            objectoutput.writeObject(null);
        }
        objectoutput.writeObject(applicationBegin);
        objectoutput.writeObject(applicationEnd);
        objectoutput.writeObject(applicationLocked);
        objectoutput.writeObject(approvalRequired);
 ...

",,,,,,,,,,,,,,OPENJPA-1704,,,,,26/Jan/11 20:24;struberg;OPENJPA-1912-enhancer.patch;https://issues.apache.org/jira/secure/attachment/12469465/OPENJPA-1912-enhancer.patch,26/Jan/11 13:54;struberg;OPENJPA-1912-fix-wo_cleanup-2.patch;https://issues.apache.org/jira/secure/attachment/12469421/OPENJPA-1912-fix-wo_cleanup-2.patch,26/Jan/11 01:14;struberg;OPENJPA-1912-fix-wo_cleanup.patch;https://issues.apache.org/jira/secure/attachment/12469367/OPENJPA-1912-fix-wo_cleanup.patch,09/Feb/11 03:08;mikedd;OPENJPA-1912-mdd.diff.txt;https://issues.apache.org/jira/secure/attachment/12470655/OPENJPA-1912-mdd.diff.txt,24/Jan/11 16:47;struberg;OPENJPA-1912-test.patch;https://issues.apache.org/jira/secure/attachment/12469174/OPENJPA-1912-test.patch,,,,,,,,5.0,,,,,,,,,,,,,,,,,,,2011-01-25 23:41:01.464,,,no_permission,,,,,,,,,,,,68166,,,Fri May 17 23:42:11 UTC 2013,,,,,,,0|i0yw07:,201655,,,,,,,,03/Jan/11 19:49;struberg;my naive question first: why do we need Externalizable at all? In any other case a simple Serializable works well.,"24/Jan/11 12:13;struberg;It seems this has nothing to do with fetch-groups, but will always be generated if DetachedStateField=true gets used.

My configuration currently: <property name=""openjpa.DetachState"" value=""loaded(DetachedStateField=true)""/>

","24/Jan/11 16:47;struberg;This unit test demontstrates the problem. I get the following output:

java.lang.IllegalAccessError: tried to access field org.apache.openjpa.enhance.EnhancedSuperClass.id from class org.apache.openjpa.enhance.EnhancedSubClass
	at org.apache.openjpa.enhance.EnhancedSubClass.writeExternal(EnhancedSubClass.java)
	at java.io.ObjectOutputStream.writeExternalData(ObjectOutputStream.java:1421)
	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1390)
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1150)
	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:326)
	at org.apache.openjpa.enhance.TestClassHierarchyEnhancement.serializeObject(TestClassHierarchyEnhancement.java:58)
	at org.apache.openjpa.enhance.TestClassHierarchyEnhancement.testSerialize(TestClassHierarchyEnhancement.java:50)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runTest(AbstractPersistenceTestCase.java:573)
","25/Jan/11 20:22;struberg;oki, starting with that stuff now.

current classes just generate a

readExternal() and writeExternal which first externalizes some OpenJPA specific fields like the pcStateManager, et al and then comes the single fields.

For providing something like super.readYourOwnStuff() we need to split the fields from the rest.

So I'll start with introducing 2 new methods readExternalFields() and writeExternalFields() which might then invoke the super.readExternalFields().

Any objections or tips?","25/Jan/11 23:41;curtisr7;> Any objections or tips? 
Goodluck... Serp is a fun one!

I'll try to get some time tomorrow to take a peek at this one.","25/Jan/11 23:44;struberg;nah, I already fixed bytecode issues in javassist and did lots of the bc stuff for OpenWebBeans - so yes, it is tricky, but I guess I can make it ;)","26/Jan/11 01:04;struberg;got it roughly working, but I'm not sure about whether the pcWriteUnmanaged also should get executed on the superclass?","26/Jan/11 01:14;struberg;Hi!

This patch fixes the issue but still needs a cleanup (finally removing old unused code and stuff).

Please review! It runs fine with a few test cases and I'll test it in my real world project tomorrow morning.

good night,
strub",26/Jan/11 13:17;struberg;figured that I still have a few bugs with deserialisation. Currently investigating...,"26/Jan/11 13:35;struberg;found the problem. StateManagerImpl#writeDetached writes the fields of the superclass first, and only then the fields of the subclasses.
",26/Jan/11 13:54;struberg;this patch now de-externalises in the correct order. I also added a few tests for it,"26/Jan/11 20:24;struberg;oops, I forgot to also attach the enhancer parts for making the test work.

sorry :/ (have way too many files dirty already ...)","08/Feb/11 20:06;struberg;Rick, Mike, did you find a chance to test this patch already? I'm slowly running out of control about all my patches... Since the patches depend on each other to some degree, I cannot really continue anymore. If you don't find the time to work on it then please ping me. In this case I'll continue maintaining my patches via a fork of the github mirror rather than juggling svn patches (which are hell to apply...).

txs and LieGrue,
strub","08/Feb/11 21:19;mikedd;Mark, haven't had a chance to look yet. Will take a closer look tonight and at least get you an ETA. ","09/Feb/11 02:50;mikedd;I see what you mean about patch management. I'm not sure I've applied the patches correctly. Is there a specific order, or could you make one all inclusive patch? ","09/Feb/11 03:08;mikedd;I think this is a unified patch - check that it matches yours. 

If so the patch looks good. I don't know serp well enough for errors to jump out at me, but the generated bytecode looks correct. 

There's some cleanup to be done (e.g. we generally don't use @author tags), but assuming none of the unit tests break I think we can commit this patch. ","09/Feb/11 07:02;struberg;Txs Mike!
I'll try to apply it and run a full suite now.","09/Feb/11 09:18;struberg;patch looks fine so far but /org/apache/openjpa/enhance/persistence1.xml is missing. Please see my enhancer.patch for this part.

A few notes:
1.) I use //X to comment out 'temporaryily'. This means either a TODO or it needs to be clarified. 
2.) The patch assumes that all parent classes must belong to the same persistence unit and therefore also contains the generated writeExternalFields and readExternalFields methods.Is this assumption true, or are there situations where parent.readExternalFields() is invalid?",09/Feb/11 11:27;struberg;oops comment should have gone to OPENJPA-1933,09/Feb/11 12:40;struberg;I found a (pretty uncommon but theoretically possible) situation where this might happen. If a superclass is defined in a jar which didn't got rebuilt and the subclass entity got enhanced via a new version of JPA. Do we take care about such pathological situations? I mean it would have crashed with the old system anyway...,"09/Feb/11 15:15;mikedd;It would be nice to handle such a case gracefully. In such an environment I think there will be other problems. Rick added some code in OPENJPA-1707 to detect downlevel entities when the enhancer runs, but I don't remember the exact problem he saw. ","09/Feb/11 16:07;struberg;If OPENJPA-1707 is already implemented then it should also work for this tweak if we increment the PCEnhancer.ENHANCER_VERSION, isn't ?
","11/Feb/11 22:29;mikedd;You're right. I thought it only checked when the PCEnhancer was executed, but after looking at the code it's the MetaDataRepository that triggers the check. ","12/Oct/11 13:39;ylangisc;Is there any reason why this changeset is not backported to the other branches (1.2.x, 2.0.x)?","17/May/13 21:23;jira-bot;Commit 1483996 from hthomann
[ https://svn.apache.org/r1483996 ]

OPENJPA-1912: Generate externalizable methods correctly for super and subclasses - back ported to 2.1.x Mark Struberg's trunk changes.","17/May/13 23:42;jira-bot;Commit 1484028 from hthomann
[ https://svn.apache.org/r1484028 ]

OPENJPA-1912: Generate externalizable methods correctly for super and subclasses - back ported to 2.0.x Mark Struberg's trunk changes.",
InvalidStateException is thrown when merge an entity with derived identiy,OPENJPA-1911,12494510,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,03/Jan/11 18:51,15/Feb/11 21:01,14/Mar/19 03:03,15/Feb/11 21:01,1.0.4,1.2.2,2.0.1,2.1.0,2.2.0,,,,1.2.3,1.3.0,2.0.2,2.1.0,2.2.0,kernel,,,,0,,,,,,,,"<openjpa-2.0.2-SNAPSHOT-r422266:1027632M nonfatal user error> org.apache.openjpa.persistence.InvalidStateException: Attempt to change a primary key field of an instance that already has a final object id.  Only new, unflushed instances whose id you have not retrieved can have their primary keys changed.
FailedObject: org.apache.openjpa.persistence.xs.AccountingHierarchyRate-TESTING::1
	at org.apache.openjpa.kernel.StateManagerImpl.assertNoPrimaryKeyChange(StateManagerImpl.java:2086)
	at org.apache.openjpa.kernel.StateManagerImpl.settingObjectField(StateManagerImpl.java:2020)
	at org.apache.openjpa.kernel.AttachStrategy.attachField(AttachStrategy.java:205)
	at org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:161)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:251)
	at org.apache.openjpa.kernel.AttachStrategy.attachCollection(AttachStrategy.java:339)
	at org.apache.openjpa.kernel.AttachStrategy.replaceList(AttachStrategy.java:399)
	at org.apache.openjpa.kernel.AttachStrategy.attachField(AttachStrategy.java:224)
	at org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:161)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:251)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:104)
	at org.apache.openjpa.kernel.BrokerImpl.attach(BrokerImpl.java:3400)
	at org.apache.openjpa.kernel.DelegatingBroker.attach(DelegatingBroker.java:1206)
	at org.apache.openjpa.persistence.EntityManagerImpl.merge(EntityManagerImpl.java:871)
	at org.apache.openjpa.persistence.xs.TestMergeComplexKey.test(TestMergeComplexKey.java:29)
",,,,,,,,,,,,,,,,,,,20/Jan/11 16:54;jpaheath;OPENJPA-1911-1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12468860/OPENJPA-1911-1.2.x.patch,20/Jan/11 16:54;jpaheath;OPENJPA-1911-1.3.x.patch;https://issues.apache.org/jira/secure/attachment/12468861/OPENJPA-1911-1.3.x.patch,20/Jan/11 16:54;jpaheath;OPENJPA-1911-2.0.x.patch;https://issues.apache.org/jira/secure/attachment/12468862/OPENJPA-1911-2.0.x.patch,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2011-01-20 16:54:58.471,,,no_permission,,,,,,,,,,,,162136,,,Thu Jan 20 16:54:58 UTC 2011,,,,,,,0|i0z773:,203468,,,,,,,,"20/Jan/11 16:54;jpaheath;Attaching patches for 1.2.x, 1.3.x, and 2.0.x.

Thanks,

Heath",,,,,,,,,,,,,,,,,,,,,,,,,,
openjpa uses application ClassLoader for resolving BrokerFactory (revisited),OPENJPA-1910,12494449,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,wolfgang.glas@ev-i.at,wolfgang.glas@ev-i.at,02/Jan/11 16:51,02/Feb/12 17:02,14/Mar/19 03:03,11/Jan/11 19:30,2.0.1,2.1.0,2.2.0,,,,,,2.1.0,2.2.0,,,,osgi,,,,0,,,,,,,,"We are using openjpa-2.0.1 with a thin wrapper inside apache-karaf.

The wrapper essentially sets the context class loader to the class loader of the application bundle and then calls 

   PersistenceProvider.createEntityManagerFactory(String emName, Map map)

on the service exported by openjpa.

We get an exception like cited at the end of this report, which is pretty much the same issue than OPENJPA-1491, where the exception occurred in the alternate method

    PersistenceProvider.createContainerEntityManagerFactory(PersistenceUnitInfo pui, Map m)

The code in

 org.apache.openjpa.persistence.PersistenceProviderImpl.getBrokerFactory(PersistenceProviderImpl.java:148)

reads

            BrokerFactory factory = getBrokerFactory(cp, poolValue, null);

, which is exactly the same issue as in OPENJPA-1491, because the null CLassLoader causes the underlying code to use the context class loader, which is set to the class loader of the application and not the class loader of the openjpa bundle.

  Replacing the above mentioned line by

            BrokerFactory factory = getBrokerFactory(cp, poolValue, BundleUtils.getBundleClassLoader());
 
would fix this issue as in OPENJPA-1491.

(remark: BundleUtils.getBundleClassLoader() return null outside OSGi contexts, so this code works outside OSGi, too....)

  Best regards,

   Wolfgang

My stack trace is:

org.osgi.service.blueprint.container.ComponentDefinitionException: Error when instantiating bean entityManagerFactory of class null
        at org.apache.aries.blueprint.container.BeanRecipe.getInstance(BeanRecipe.java:233)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
        at org.apache.aries.blueprint.container.BeanRecipe.internalCreate(BeanRecipe.java:726)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
        at org.apache.aries.blueprint.di.AbstractRecipe.create(AbstractRecipe.java:64)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
        at org.apache.aries.blueprint.container.BlueprintRepository.createInstances(BlueprintRepository.java:219)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPS
HOT]
        at org.apache.aries.blueprint.container.BlueprintRepository.createAll(BlueprintRepository.java:147)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
        at org.apache.aries.blueprint.container.BlueprintContainerImpl.instantiateEagerComponents(BlueprintContainerImpl.java:624)[7:org.apache.aries.blueprint:0.3.0
.incubating-SNAPSHOT]
        at org.apache.aries.blueprint.container.BlueprintContainerImpl.doRun(BlueprintContainerImpl.java:315)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
        at org.apache.aries.blueprint.container.BlueprintContainerImpl.run(BlueprintContainerImpl.java:213)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)[:1.6.0_20]
        at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)[:1.6.0_20]
        at java.util.concurrent.FutureTask.run(FutureTask.java:166)[:1.6.0_20]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:165)[:1.6.0_20]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:266)[:1.6.0_20]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)[:1.6.0_20]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)[:1.6.0_20]
        at java.lang.Thread.run(Thread.java:636)[:1.6.0_20]
Caused by: <openjpa-2.0.1-r422266:989424 fatal user error> org.apache.openjpa.persistence.ArgumentException: Could not invoke the static newInstance method on the na
med factory class ""<<openjpa-2.0.1-r422266:989424 fatal user error> org.apache.openjpa.util.UserException: The named BrokerFactory ""org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory"" is not valid.>"".
        at org.apache.openjpa.kernel.Bootstrap.newBrokerFactory(Bootstrap.java:70)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.getBrokerFactory(PersistenceProviderImpl.java:148)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:94)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:154)
        at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:65)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)[:1.6.0_20]
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)[:1.6.0_20]
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[:1.6.0_20]
        at java.lang.reflect.Method.invoke(Method.java:616)[:1.6.0_20]
        at org.apache.aries.blueprint.container.AbstractServiceReferenceRecipe$JdkProxyFactory$1.invoke(AbstractServiceReferenceRecipe.java:632)
        at $Proxy48.createEntityManagerFactory(Unknown Source)
        at org.clazzes.util.jpa.provider.EntityManagerFactoryFactory.newEntityManagerFactory(EntityManagerFactoryFactory.java:67)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)[:1.6.0_20]
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)[:1.6.0_20]
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[:1.6.0_20]
        at java.lang.reflect.Method.invoke(Method.java:616)[:1.6.0_20]
        at org.apache.aries.blueprint.utils.ReflectionUtils.invoke(ReflectionUtils.java:221)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
        at org.apache.aries.blueprint.container.BeanRecipe.invoke(BeanRecipe.java:844)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
        at org.apache.aries.blueprint.container.BeanRecipe.getInstance(BeanRecipe.java:231)[7:org.apache.aries.blueprint:0.3.0.incubating-SNAPSHOT]
        ... 15 more
Caused by: <openjpa-2.0.1-r422266:989424 fatal user error> org.apache.openjpa.persistence.ArgumentException: The named BrokerFactory ""org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory"" is not valid.
        at org.apache.openjpa.kernel.Bootstrap.getFactoryClass(Bootstrap.java:159)
        at org.apache.openjpa.kernel.Bootstrap.invokeFactory(Bootstrap.java:111)
        at org.apache.openjpa.kernel.Bootstrap.newBrokerFactory(Bootstrap.java:62)
        ... 33 more
Caused by: java.lang.ClassNotFoundException: org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory
        at java.net.URLClassLoader$1.run(URLClassLoader.java:217)[:1.6.0_20]
        at java.security.AccessController.doPrivileged(Native Method)[:1.6.0_20]
        at java.net.URLClassLoader.findClass(URLClassLoader.java:205)[:1.6.0_20]
        at java.lang.ClassLoader.loadClass(ClassLoader.java:321)[:1.6.0_20]
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:294)[:1.6.0_20]
        at java.lang.ClassLoader.loadClass(ClassLoader.java:266)[:1.6.0_20]
        at java.lang.Class.forName0(Native Method)[:1.6.0_20]
        at java.lang.Class.forName(Class.java:264)[:1.6.0_20]
        at org.apache.openjpa.kernel.Bootstrap.getFactoryClass(Bootstrap.java:157)
        ... 35 more
","apache-karaf 2.1.0,  openjdk-1.6.0b18",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-01-11 19:30:39.458,,,no_permission,,,,,,,,,,,,162135,,,Thu Feb 02 17:02:43 UTC 2012,,,,,,,0|i0z31j:,202795,,,,,,,,11/Jan/11 19:30;curtisr7;Committed changes to 2.1.x and trunk.,02/Feb/12 17:02;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,,
enhance unit tests with the correct persistence.xml,OPENJPA-1909,12494363,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,struberg,struberg,31/Dec/10 12:50,13/Jul/11 16:11,14/Mar/19 03:03,07/Jan/11 15:31,2.0.0,2.0.1,2.1.0,,,,,,2.1.0,2.2.0,,,,build / infrastructure,,,,0,,,,,,,,"in OPENJPA-1900 I found out that we do not enhance our entities with the configuration which get used later while running the unit tests.

But enhancing sometimes has a huge implication on the behaviour! Thus we should always try to use the same persistence.xml for enhancing as we do for running the unit tests.

This small patch fixes the usage for our proxy tests which use openjpa.DetachState=fetch-groups (leading to Externalizable entities)",,0,0,,0%,0,0,,,,,,,,,,,,31/Dec/10 12:51;struberg;OPENJPA-1909.patch;https://issues.apache.org/jira/secure/attachment/12467220/OPENJPA-1909.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-01-07 15:27:43.913,,,no_permission,,,,,,,,,,,,68162,,,Fri Jan 07 15:44:15 UTC 2011,,,Patch Available,,,,0|i0z0ov:,202414,,,,,,,,"07/Jan/11 15:27;mikedd;Is the update to the maven plugin version needed here? I'm not opposed to upgrading, but it seems extraneous for this problem. ","07/Jan/11 15:44;struberg;it's not needed, should get moved to an own issue.",,,,,,,,,,,,,,,,,,,,,,,,,
Issue info / warning message when connection retain mode is always,OPENJPA-1906,12493125,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,13/Dec/10 22:28,13/Jan/11 19:34,14/Mar/19 03:03,13/Jan/11 19:34,2.2.0,,,,,,,,2.1.0,2.2.0,,,,logging,,,,0,,,,,,,,"Many users see better performance when setting openjpa.ConnectionRetainMode to always. But they might not be aware of the consequences - the EntityManager must be closed in order to release the connection. 

In the case of application managed entity managers, the application should always close the EntityManager when it's done. But since this may or may not be obvious, it's a good idea to log an info message. 

In the case where the application cannot directly close the EntityManager (e.g. a Container Managed EntityManager), we should log a warning to let users know that each EntityManager may hold on to a connection for a long time. 

Unfortunately we can only detect whether the EMF is container managed, not the EM - but some warning is better than none. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162132,,,Wed Dec 15 16:15:37 UTC 2010,,,,,,,0|i1dubb:,289008,,,,,,,,15/Dec/10 16:15;mikedd;The change has been committed to trunk under revision 1045397. My typo in the commit message prevents it from linking here. ,,,,,,,,,,,,,,,,,,,,,,,,,,
jar-file validation should be deferred until after OpenJPA is confirmed to be the application's chosen provider,OPENJPA-1905,12492980,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,fyrewyld,fyrewyld,fyrewyld,10/Dec/10 21:37,25/Jan/11 20:24,14/Mar/19 03:03,25/Jan/11 20:24,1.2.0,1.2.1,1.2.2,2.0.0,2.0.1,,,,1.2.3,2.0.2,2.1.0,2.2.0,,usability,validation,,,0,,,,,,,,"While processing a persistence-unit definition in persistence.xml requested by an invocation of PersistenceProvider.createEntityManagerFactory(), validation of elements such as <jar-file> take place during the execution of the SAXParser.  If an entry named by the element does not exist, a GeneralException originating from the SAXException fails the createEMF() operation -- the expected and correct behavior in such a situation.

However, this validation occurs before OpenJPA checks to see if it is the JPA Provider requested by the Application.  This means that OpenJPA throws this Exception regardless to the fact that the PU may have defined a <persistence> element requesting a JPA provider other then OpenJPA -- instead of returning the expected null value as expected by the contract.

Thus, there needs to be a change where the first item validated is the requested provider, immediately returning null as per JPA Spec contract if OpenJPA is not the requested provider.  This would cause the error in the scenario described above to be reported by the requested JPA provider, instead of short-circuiting the process as can happen currently.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-01-12 23:03:14.975,,,no_permission,,,,,,,,,,,,162131,,,Thu Jan 20 20:10:32 UTC 2011,,,,,,,0|i1dubj:,289009,,,,,,,,"12/Jan/11 23:03;mikedd;If there's more work to be done for this issue please re-open, or open a sub task for the remaining work. ",20/Jan/11 20:10;mikedd;Reopening to make sure we don't lose track of this for 2.0.x.,,,,,,,,,,,,,,,,,,,,,,,,,
"OptimisticLockException during refresh(*,PESSIMISTIC_*) with eagar fetch on relationship fields",OPENJPA-1904,12492771,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,08/Dec/10 22:20,10/Dec/10 22:08,14/Mar/19 03:03,10/Dec/10 22:08,2.0.2,2.1.0,2.2.0,,,,,,2.1.0,2.2.0,,,,kernel,,,,0,,,,,,,,"refresh with PESSIMISTIC_* lock on an entity with eagerly fetched relationship may cause an OptimisticLockException to be thrown. For example

    org.apache.openjpa.persistence.OptimisticLockException:This operation failed for some instances.  See the nested exceptions array for details.
FailedObject: suite.jpafvt.commonentities.hr.Manager-1 [java.lang.String]
	at org.apache.openjpa.kernel.BrokerImpl.throwNestedExceptions(BrokerImpl.java:2514)
	at org.apache.openjpa.kernel.BrokerImpl.refreshInternal(BrokerImpl.java:3064)
	at org.apache.openjpa.kernel.BrokerImpl.refresh(BrokerImpl.java:2953)
	at org.apache.openjpa.kernel.DelegatingBroker.refresh(DelegatingBroker.java:1126)
	at org.apache.openjpa.persistence.EntityManagerImpl.refresh(EntityManagerImpl.java:770)
	at org.apache.openjpa.persistence.EntityManagerImpl.refresh(EntityManagerImpl.java:752)
	at suite.r80.base.jpaspec.entitymanager.testlogic.RefreshLockTestLogic.testScenarioL001(RefreshLockTestLogic.java:188)
	...........
Caused by:  org.apache.openjpa.persistence.OptimisticLockException: An optimistic lock violation was detected when flushing object instance ""An optimistic lock violation was detected when locking object instance. [java.lang.String]"" to the data store.  This indicates that the object was concurrently modified in another transaction.
FailedObject: 234 [java.lang.Long]
	at org.apache.openjpa.jdbc.kernel.MixedLockManager.optimisticLockInternal(MixedLockManager.java:116)
	at org.apache.openjpa.jdbc.kernel.PessimisticLockManager.lockInternal(PessimisticLockManager.java:111)
	at org.apache.openjpa.jdbc.kernel.MixedLockManager.lockInternal(MixedLockManager.java:72)
	at org.apache.openjpa.kernel.VersionLockManager.lock(VersionLockManager.java:84)
	at org.apache.openjpa.kernel.VersionLockManager.lock(VersionLockManager.java:70)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:966)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:902)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1041)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.load(WsJpaJDBCStoreManager.java:114)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:280)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2380)
	at org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy.loadEagerJoin(RelationFieldStrategy.java:706)
	at org.apache.openjpa.jdbc.meta.FieldMapping.loadEagerJoin(FieldMapping.java:922)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1111)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1092)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1092)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1067)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:688)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.load(WsJpaJDBCStoreManager.java:132)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:117)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:3045)
	at org.apache.openjpa.kernel.StateManagerImpl.load(StateManagerImpl.java:451)
	at org.apache.openjpa.kernel.BrokerImpl.transactional(BrokerImpl.java:3608)
	at org.apache.openjpa.kernel.VersionLockManager.optimisticLockInternal(VersionLockManager.java:111)
	at org.apache.openjpa.jdbc.kernel.MixedLockManager.optimisticLockInternal(MixedLockManager.java:108)
	at org.apache.openjpa.jdbc.kernel.PessimisticLockManager.lockInternal(PessimisticLockManager.java:111)
	at org.apache.openjpa.jdbc.kernel.MixedLockManager.lockInternal(MixedLockManager.java:72)
	at org.apache.openjpa.kernel.VersionLockManager.lock(VersionLockManager.java:84)
	at org.apache.openjpa.kernel.BrokerImpl.refreshInternal(BrokerImpl.java:3014)
	... 36 more
",,,,,,,,,,,,,,,,,,,08/Dec/10 22:30;allee8285;OPENJPA-1904.patch;https://issues.apache.org/jira/secure/attachment/12465848/OPENJPA-1904.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162130,,,2010-12-08 22:20:38.0,,,Patch Available,,,,0|i0z2zz:,202788,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Some queries only work the first time they are executed,OPENJPA-1903,12492529,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,centic,centic,06/Dec/10 19:05,03/Feb/12 19:28,14/Mar/19 03:03,03/Feb/12 19:28,2.0.1,,,,,,,,2.2.0,,,,,query,,,,0,,,,,,,,"I have a problem in my application where a query that sometimes returns data and sometimes not.

I have reduced it to the code as much as I could into an Eclipse project available at http://ubuntuone.com/p/S9n/

This happens with OpenJPA 2.0.1 as well as the daily snapshot from 2010-12-05 and an out-of-process Derby database.

Basically I have two Entities which both use multiple Ids to produce the Primary Key, ""Preis"" contains a foreign key on ""Website"":

@Entity
@IdClass(MandantAndNameIdentity.class)
public class Website {
    @Id
    private String mandant;
   
    @Id
    private String name;
...
}

@Entity
@IdClass(WebsiteProduktDatumIdentity.class)
public class Preis {
    @Id
    @ManyToOne(cascade = CascadeType.MERGE)
    private Website website;

    @Id
    @Basic
    private String datum;
...
}

I use the following to set up a website and a Preis:

        em.getTransaction().begin();

        Website website = em.merge(new Website(""Mandant"", ""Website""));

        em.merge(new Preis(website, DATUM));
       
        em.getTransaction().commit();

Afterwards, if I run the query as follows:

       TypedQuery<Preis> q = em.createQuery(
                ""select m from Preis m "" +
                ""where m.website.name = :website "", Preis.class);
       q.setParameter(""website"", website.getName());

this query works all the time, note that it uses website.name for matching, not the full Website-object.

However if I put the query as

        TypedQuery<Preis> q = em.createQuery(
                ""select m from Preis m "" +
                ""where m.website = :website "", Preis.class);
        q.setParameter(""website"", website);

it only works ONCE and then does not return any results any more!! See testcase DataAccessVerifyTest for details.

Discussion on the mailinglist seems to indicate that this is a bug. 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-12-07 22:50:45.564,,,no_permission,,,,,,,,,,,,59916,,,Fri Feb 03 19:28:54 UTC 2012,,,,,,,0|i1dubr:,289010,,,,,,,,"06/Dec/10 21:57;centic;setting a query-hint to disable caching makes the query run correctly multiple times:

		q.setHint(QueryHints.HINT_IGNORE_PREPARED_QUERY, queryString); 
","06/Dec/10 21:58;centic;OPENJPA-1750 discusses a similar issue, but the issue here is not fixed by using latest 2.1.0 snapshot builds.","07/Dec/10 22:50;ppoddar@apache.org;If your environment permits, try recent SVN commit r1043221 [1] on trunk.
If it does not, will suggest alternative, non-kosher way to test if the proposed change resolves the reported probiem.
It is a bug.

[1] http://openjpa.208410.n2.nabble.com/svn-commit-r1043221-openjpa-trunk-openjpa-jdbc-src-main-java-org-apache-openjpa-jdbc-kernel-Prepareda-td5813517.html
","09/Dec/10 19:48;centic;I tried todays snapshot build labeled openjpa-2.2.0-20101209.084750-4.jar but my standalone testcase still fails with the same error. 

I also tried to check out the source and add a testcase to the exsiting TestQueryCache testcase. Strangely there it works, although I use the same settings in the Entities and the same test-code! What could be the difference here? I see the following warning when running TestQueryCache, which might be related but which I cannot make much sense of: 

""Query ""select m from Child m where m.parent = :parent "" is removed from cache  excluded permanently. Query ""select m from Child m where m.parent = :parent "" is not cached because its result is not obtained by executing a select statement. This can happen if the query was evaluated in-memory. The result was provided by org.apache.openjpa.datacache.QueryCacheStoreQuery$CachingResultObjectProvider.  .""","03/Feb/12 19:28;allee8285;Confirmed with Pinaki, this issues is completed and can be closed.",,,,,,,,,,,,,,,,,,,,,,
SQLServer reserved words may not be used as identifiers,OPENJPA-1902,12491683,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,30/Nov/10 19:03,30/Nov/10 19:13,14/Mar/19 03:03,30/Nov/10 19:13,,,,,,,,,2.1.0,2.2.0,,,,,,,,0,,,,,,,,"Per MSDN docs : http://msdn.microsoft.com/en-us/library/ms189822.aspx, reserved words must be delimited in order to be used as column identifiers. This is causing problems with some unit tests. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162129,,,2010-11-30 19:03:25.0,,,,,,,0|i0z30f:,202790,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
QueryCacheStoreQuery$CachedObjectId that is not Serializable,OPENJPA-1901,12491654,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,kwsutter,kwsutter,30/Nov/10 16:29,21/Sep/16 14:38,14/Mar/19 03:03,06/Feb/12 23:38,2.0.0,2.0.1,,,,,,,2.0.2,2.1.2,2.2.0,2.3.0,,datacache,,,,0,,,,,,,,"In OpenJPA 2.0, OpenJPA tries to put the query result from JOIN query into query cache, in addition to put entities into data cache.
However, the QueryResult containes Object[] of org.apache.openjpa.datacache.QueryCacheStoreQuery$CachedObjectId that is not Serializable and cause this issue.
OpenJPA need to be fixed to make org.apache.openjpa.datacache.QueryCacheStoreQuery$CachedObjectId serializable.

Currently,  manually adding Serializable to the code works for measuring the performance, but we need a more permanent fix.

I also have a concern whether this type of fix has a ripple effect.  The CachedObjectId can easily be fixed to be Serializable, but it looks like other inner classes of QueryCacheStoreQuery are not Serializable either.  Do these (and potentially other attributes) need to be Serializable as well?  Do we need a Unit Test to verify this Serializable capability?

Final portion of call stack when the Exception happens:

Caused by: java.io.NotSerializableException: org.apache.openjpa.datacache.QueryCacheStoreQuery$CachedObjectId
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1113)
	at java.io.ObjectOutputStream.writeArray(ObjectOutputStream.java:1343)
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1107)
	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:325)
	at java.util.ArrayList.writeObject(ArrayList.java:595)
	at sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:618)
	at java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:972)
	at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1431)
	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1382)
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1111)
	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:325)

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162128,,,2010-11-30 16:29:30.0,,,,,,,0|i1dubz:,289011,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException when serializing an entity if DetachedStateField=true,OPENJPA-1900,12491624,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,struberg,struberg,30/Nov/10 09:20,02/Feb/12 17:02,14/Mar/19 03:03,17/Dec/10 12:20,2.0.1,2.1.0,2.2.0,,,,,,2.1.0,2.2.0,,,,kernel,,,,0,,,,,,,,"When using 

<property name=""openjpa.DetachState"" value=""fetch-groups(DetachedStateField=true)""/>

serializing an entity leads to the following Exception:

java.lang.ClassCastException: org.apache.openjpa.kernel.StateManagerImpl cannot be cast to org.apache.openjpa.kernel.DetachedStateManager
	at org.apache.openjpa.util.Proxies.writeReplace(Proxies.java:147)
	at org.apache.openjpa.util.java$util$Date$proxy.writeReplace(Unknown Source)
	at sun.reflect.GeneratedMethodAccessor176.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at java.io.ObjectStreamClass.invokeWriteReplace(ObjectStreamClass.java:1032)
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1107)
	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:326)
	at org.apache.openjpa.kernel.SingleFieldManager.serialize(SingleFieldManager.java:545)
	at org.apache.openjpa.kernel.StateManagerImpl.writeDetached(StateManagerImpl.java:1478)
	at at.ac.tuwien.tiss.curriculum.be.entities.CurriculumVersion.writeExternal(CurriculumVersion.java)
	at java.io.ObjectOutputStream.writeExternalData(ObjectOutputStream.java:1421)

This seems related to OPENJPA-1597",,,,,,,,,,,,,,,,,,,02/Dec/10 20:40;struberg;OPENJPA-1900-fix.patch;https://issues.apache.org/jira/secure/attachment/12465166/OPENJPA-1900-fix.patch,02/Dec/10 11:19;struberg;OPENJPA-1900-test-1.patch;https://issues.apache.org/jira/secure/attachment/12465129/OPENJPA-1900-test-1.patch,16/Dec/10 18:07;curtisr7;OPENJPA-1900.patch;https://issues.apache.org/jira/secure/attachment/12466397/OPENJPA-1900.patch,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2010-12-15 23:00:50.332,,,no_permission,,,,,,,,,,,,162127,,,Thu Feb 02 17:02:01 UTC 2012,,,,,,,0|i1duc7:,289012,,,,,,,,"01/Dec/10 11:16;struberg;I was still not able to reproduce this in a unit test, but from debugging my real world app it seems to happen when lazy loaded entities get serialized.","02/Dec/10 11:19;struberg;I tried to reproduce my problem with an unit test but had no luck so far. But the test now crashes with another issue.

testSerialization(org.apache.openjpa.persistence.proxy.TestEntitySerialize)  Time elapsed: 14.822 sec  <<< ERROR!
java.lang.NullPointerException
	at org.apache.openjpa.persistence.proxy.TestEntitySerialize.testSerialization(TestEntitySerialize.java:104)


The situation:
I added a 'previousAnnuity' to reflect the existence of a annuity predecessor. 
The data I create is a FixedAnnuity which gets superceeded by an EquityAnnuity.
I then load the last annuity (the EquityAnnuity) in one transaction. While having the EntityManager open, the previousAnnuity is available. But if I close the EntityManager, it suddenly dissapears (field get's reset to null).

Is this a spec like behaviour that entity members get deleted while closing the EntityManager?","02/Dec/10 12:24;struberg;actually it was my error, forgot to @OneToOne the field ... *slap*,  *coffeerefill*","02/Dec/10 19:53;struberg;think I know the difference between the openjpa-persistence-jdbc and my projects config. I use the openjpa-maven-plugin for enhancing my project and I get the Externalizable interface generated into my enhanced classes. This doesn't happen with the Annuity entities.

But the problem above only happens if StateManagerImpl#writeDetached get's invoked on an entity which is linked to multiple other entites...

Question: why do I get the Externalizable interface in my entities?","02/Dec/10 20:31;struberg;The Externalizable field gets added if I use the openjpa.DetachStage fetch-groups(DetachStateField=true)

This is an issues in our test suite currently - it uses different persistence.xml for enhancing (${project.build.testOutputDirectory}/META-INF/nopriv_persistence.xml) and running the tests (org/apache/openjpa/persistence/proxy/persistence1.xml)

Thus my test currently succeeds but only because this isn't a real world scenario.

PS: took me a while to figure this, but at least I'm now pretty deep into OpenJPA internals :D","02/Dec/10 20:40;struberg;this small patch fixes the behaviour. This needs a review of course, because I might have overseen some side effects... 
","15/Dec/10 23:00;curtisr7;Good work on this one. I just looked at your patches and you had to dig pretty deep to figure this out out. 

I have a few comments for you. I was able to recreate the CCE, but after applying the code fix I fail with a NPE coming from test code[1]. I'm not sure why that field is null but I'm guessing it has something to do with the DetachState setting. If I change fgs to loaded the NPE goes away.... Are you seeing the same benaviour?

Thanks,
Rick

[1]:407 ann.getPreviousAnnuity().setApprovedAt( new Date() ); -- getPreviousAnnuity() returns null","16/Dec/10 16:10;curtisr7;Mark -

It looks like I should have read through all of your comments... I added @OneToOne to Annuity.getPreviousAnnuity() and things are looking better now.

Thanks,
Rick
","16/Dec/10 16:12;struberg;Hi Rick! I'm currently compiling, so gimme an hour ;)
I'm online in #openjpa on freenode.","17/Dec/10 12:20;curtisr7;Resolved in 2.1.x and trunk.

Thanks for the patch Mark!",02/Feb/12 17:02;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,
Evict from L2 of a object causes secondary objects to never be loaded in graph,OPENJPA-1899,12491561,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Blocker,Fixed,curtisr7,rkrier,rkrier,29/Nov/10 17:12,31/Mar/11 21:09,14/Mar/19 03:03,31/Mar/11 21:09,2.0.0,,,,,,,,2.1.1,,,,,kernel,,,,0,,,,,,,,"I have a simple example.  A customer has a reference to an address and a (primary) contact (an extension of person).  Find the customer, get the contact and evict it from L2.  Now find the customer again using a new entity manager.  Begin a Tx and change the address of the contact and then call Customer.getPrimaryContact() (this is important)   Rollback the Tx.  Now find the customer again using another new EntityManager and call Customer.getPrimaryContact().getAddress().  The address associated with the contact is Null and not the original address as expected.  The same scenario works fine under OpenJPA 1.2.2.  

The reason this is a big problem for us is we use L2 caching in our application and the application is clustered.  The same problem occurs if different nodes in the cluster operate on the same objects.  In a cluster ""evict"" is not directly called, but the RemoteCommitProvider will evict the L2 and create the same problem.  

I have attached example code to reproduce the problem using a single JVM and calling Evict.  I also have another example where you can deploy the code on two nodes in a cluster and see the problem occurs that way as well.  Each example contains Unix shell scripts and Windows cmd files as well.  Each are paired for JPA 1.0 and JPA 2.0.  Again, the problem only occurs under JPA 2.0.

This is a block for us.  We cannot ship our product with this type of problem as it means objects and their graph can be corrupted.  
",N/A,,,,,,,,,,,,,,,,,,17/Dec/10 14:15;curtisr7;OPENJPA-1899.test.patch;https://issues.apache.org/jira/secure/attachment/12466462/OPENJPA-1899.test.patch,29/Nov/10 23:43;rkrier;evictproblem.zip;https://issues.apache.org/jira/secure/attachment/12464919/evictproblem.zip,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-11-29 20:29:05.879,,,no_permission,,,,,,,,,,,,162126,,,Thu Mar 31 21:03:59 UTC 2011,,,,,,,0|i0yvun:,201630,,,,,,,,"29/Nov/10 17:29;rkrier;Instructions:

Unzip the attached file.  In the conf directory, there is a file called schema_mysql.sql.  
1) Create a new MySQL database and install the tables in the script.  
2) Edit conf/openjpa.properties and set the openjpa.ConnectionProperties to your database.  
3) In the shell script and/or cmd files in the bin directory, change JAVA_HOME as appropriate for your environment.
4) Run bin/simple-evict-sjvm-1.0 and bin/simple-evict-sjvm-2.0.  You will see there is no problem under OpenJPA 1.0 but there is a problem 2.0.

You can also deploy the application on two nodes and run the two node tests on each node.  There are instructions given in each script on how to configure.  Basically you just need to edit the RemoteCommitProvider settings as appropriate on each node and run the tests on each node and follow the prompts given in the application.

Note: I removed openjpa-all-2.0.1.jar from the lib/openjpa2.0.1 in order to keep the size of this upload small enough to attach.

Bob","29/Nov/10 17:36;rkrier;One more thing to note:
1) The problem does not occur if L2 caching is not enabled. This is not a viable workaround for us.
2) The problem does not occur if eager fetching is used in the object graph instead of lazy.  This is not a viable workaround for us.

Bob","29/Nov/10 20:29;curtisr7;...thanks for the test case but we can't use it and probably shouldn't look at it? Can I have you re-upload your Entities / the test case and check the ""Grant license to ASF for inclusion in ASF works"" box when you upload. I'll use that info to create a OpenJPA unit test to more easily recreate the problem.",29/Nov/10 23:43;rkrier;Uploaded again with proper attachment license.,"29/Nov/10 23:49;rkrier;Hi Rick,

I have re-uploaded the test case zip file with the ASF inclusion option.
Let me know if you still have problems with it.  I can send it directly to
you if needed.

The entities are in src/com/foo/bar/models and the test cases are in
src/com/foo/bar/app.  It should be pretty straight forward to see what's
going on.  If something isn't clear, let me know and I'll be happy to
assist.

Thanks for your response on this.

Bob



----------------------------------------------------------------------------->>
-

","06/Dec/10 14:15;bkrier@us.axway.com;Hi Ric,

Has anyone had a chance to look into this issue?  Do you have everything
you need from me?

Thanks,

Bob

","17/Dec/10 14:08;curtisr7;Attaching a OpenJPA style unit test.... but I must be missing something because I'm getting a NPE from test code[1]. It looks like when you have openjpa.DetachState set to fgs, we null out the reference to primaryContact on rollback... if openjpa.DetachState is set to loaded, it seems to work properly?

Robert -- Can you look at the patch that I've posted to see if I missed something in my butchering of your test? 

Thanks,
Rick

[1]         System.out.println(""The address after rollback is: ""
            + (cust2.getPrimaryContact().getAddress() == null ? ""null"" : cust2.getPrimaryContact().getAddress() <- NPE from this line
                .getStreet()) + ""\n"");",17/Dec/10 14:15;curtisr7;Attaching a new patch with the correct name.,"17/Dec/10 16:13;bkrier@us.axway.com;
Thanks Rick, I'll look at it this morning.

Regards,

Bob


----------------------------------------------------------------------------->>
-

","17/Dec/10 18:24;bkrier@us.axway.com;Hi Ric,

What exactly do you want me to look at.  I've been trying to get Openjpa set
up with Maven and I'm having a lot of problems.  You comment about primary
contact getting nulled out after rollback is the problem I'm reporting.
That shouldn't be happening.

I've tried running my tests with openjpa.DetachState=loaded and it still
fails.  Again, everything works fine under OpenJPA 1.2.2.

Thanks and regards,

Bob 



https://issues.apache.org/jira/browse/OPENJPA-1899?page=com.atlassian.jira.pl>>
u
----------------------------------------------------------------------------->>

","17/Dec/10 18:57;curtisr7;Bob -

Just so we're clear, the problem you're reporting is that cust2.getPrimaryContact() returns null after calling rollback? The test that I posted also fails on 1.2.x.... so I must be missing something.

Thanks,
Rick","17/Dec/10 19:08;bkrier@us.axway.com;Yes that's the problem, however it doesn't fail under 1.2.2 for me.  If I
run EvictTest with 2.0.1 libraries, the output is as follows:

In order to run this test, you must configure the remote commit provider
setting for SJVM.
The address from first find is: This is the original street address
The address from second find is: This is the original street address
The address before rollback is: This is a new street address
The address after rollback is: This is the original street address
The address from third find is: null


If I run EvictTest with the 1.2.2 libraries, the output is as follows:

In order to run this test, you must configure the remote commit provider
setting for SJVM.
The address from first find is: This is the original street address
The address from second find is: This is the original street address
The address before rollback is: This is a new street address
The address after rollback is: This is the original street address
The address from third find is: This is the original street address

Make sense?



----------------------------------------------------------------------------->>
-

","17/Dec/10 19:16;curtisr7;Ok, my test must be not quite the same scenario..... I'm getting a NPE from EvictTest:49. The NPE is calling .getAddress() on a null getPrimaryContact().

Thanks,
Rick","17/Dec/10 19:22;bkrier@us.axway.com;No problem.  Thanks Rick.



----------------------------------------------------------------------------->>
-

","20/Dec/10 15:59;curtisr7;Robert -

I ran with your provided example this morning with 2.1.x and here is the result that I'm seeing:

C:\dev\jpa\tmp\evictproblem\bin>c:\java6-sun\bin\java.exe -cp ..\conf;..\classes;..\lib\jdbcdrivers\mysql-connector-java-3.1.13-bin.jar;..\lib\openjpa2.0.1\openjpa-all-2.1.0-SNAPSHOT.jar com.foo.bar.app.EvictTest

In order to run this test, you must configure the remote commit provider setting for SJVM.
58  evictproblem  INFO   [main] openjpa.Runtime - Starting OpenJPA 2.1.0-SNAPSHOT
139  evictproblem  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.MySQLDictionary"".
770  evictproblem  INFO   [main] openjpa.Runtime - The Entity ""com.foo.bar.models.Contact"" was enhanced at level ""2"", but the current level of enhancement is ""961,774"".
774  evictproblem  INFO   [main] openjpa.Runtime - A down level Entity was detected and logged. Please enable RUNTIME trace to see all down level Entities.
The address from first find is: This is the original street address
The address from second find is: This is the original street address
The address before rollback is: This is a new street address
The address after rollback is: This is the original street address
The address from third find is: This is the original street address

Thanks,
Rick","20/Dec/10 16:38;bkrier@us.axway.com;Hi Rick,

I just tried it with the 2.1.0 snapshot and you are correct, the problem
seems to be fixed.  Correct me if I'm wrong, but 2.1.0 is not officially
released yet, right?  Do you know what changes were made to fix this
problem?  Is it something I can back port into 2.0.1 easily?

Thanks!

Bob



----------------------------------------------------------------------------->>
-

","20/Dec/10 17:04;curtisr7;Bob -

Honestly I didn't spend any time looking at the test with 2.0.1, but nothing comes to mind that would have changed. Can I have you try one of the nightly 2.0.x snapshots? Then at least we can figure out if this is something that has already been fixed in the 2.0.x stream.

I'm in the middle of another JIRA currently, but I should have some time later on to take another look at this one.

Thanks,
Rick","20/Dec/10 17:09;bkrier@us.axway.com;Sure, I'll give it a try.



----------------------------------------------------------------------------->>
-

","20/Dec/10 20:21;bkrier@us.axway.com;Hi Rick,

I don't see any 2.0.x snapshots on OpenJPA's site.  Let me know if I can get
them some other way.

Bob



----------------------------------------------------------------------------->>
-

","20/Dec/10 20:39;bkrier@us.axway.com;Hi again,

I did find the 2.0.2 snapshot and tried it.  It fails.

The address from first find is: This is the original street address
The address from second find is: This is the original street address
The address before rollback is: This is a new street address
The address after rollback is: This is the original street address
The address from third find is: null



https://issues.apache.org/jira/browse/OPENJPA-1899?page=com.atlassian.jira.pl>>
u
gin.system.issuetabpanels:comment-tabpanel&focusedCommentId=12973256#action_1>>
2

","21/Dec/10 15:37;rkrier;Hi Rick,

Is there something you wanted me to look at?  The attachment doesn't come
through.

Bob



----------------------------------------------------------------------------->>
-

","21/Dec/10 15:40;curtisr7;Bob -

Sorry, no. I was removing the non-asf licensed attachment. I'm just digging into your issue now... hopefully I'll come up with something shortly here.

Thanks,
Rick","22/Dec/10 14:15;curtisr7;Bob -

I can't quite explain it yet, but OPENJPA-1884 is the change that fixed this problem in 2.1.x and trunk. It appears that we are putting a dirty entity back into the datacache.. I haven't completely got my head around this one yet, but I can fix the problem. That being said, 2.0.x is a WebSphere maintained branch and it might be tough to get this fix into that branch.

What are your thoughts on using 2.1.0 for your application? We haven't cut a release yet, but I expect we will shortly after the new year.

Thanks,
Rick","22/Dec/10 15:41;bkrier@us.axway.com;If it is early in the year that it is released, we can probably be fine with
that.  I would like to make the change locally for myself so our QA people
can test with the fix now.  Is there an easy way for me to diff the change
so I can modify my own copy of the class?

Thanks Rick!

Bob



----------------------------------------------------------------------------->>
-

","22/Dec/10 16:51;bkrier@us.axway.com;Never mind, I found the changes made.  I'm attempting to back port them to
2.0.1 and I'll try it out.  I'll keep you posted.

Bob 



https://issues.apache.org/jira/browse/OPENJPA-1899?page=com.atlassian.jira.pl>>
u
gin.system.issuetabpanels:comment-tabpanel&focusedCommentId=12974207#action_1>>
2

","22/Dec/10 18:18;bkrier@us.axway.com;Hi Rick,

I back ported the changes made for JIRA OPENJPA-1884 locally and it seemed
to fix the problem.  We should be able to live with it this way for now
until 2.1.0 is GA.  Thanks for all your help on this!!!

Have a great holiday!!!!

Bob



--------------------------------------------------------------------------->>>>
-

",31/Mar/11 21:03;curtisr7;This problem was fixed by OPENJPA-1884. Closing this issue.
"TestQueryMultiThreaded fails with OOME ""unable to create new native thread""",OPENJPA-1898,12491555,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,struberg,struberg,29/Nov/10 16:37,13/Jul/11 16:11,14/Mar/19 03:03,30/Nov/10 20:19,2.0.1,,,,,,,,2.1.0,2.2.0,,,,,,,,0,,,,,,,,"here comes the stacktrace:
<error message=""unable to create new native thread"" type=""java.lang.OutOfMemoryError"">java.lang.OutOfMemoryError: unable to create new native thread
        at java.lang.Thread.start0(Native Method)
        at java.lang.Thread.start(Thread.java:597)
        at org.apache.openjpa.slice.TestQueryMultiThreaded.testHeavyLoad(TestQueryMultiThreaded.java:236)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at junit.framework.TestCase.runTest(TestCase.java:154)

reducing the thread count to 800 should help to prevent this problem. This might be caused to the 1024 processes ulimit on most linux installations.",,,,,,,,,,,,,,,,,,,30/Nov/10 09:13;struberg;OPENJPA-1898.patch;https://issues.apache.org/jira/secure/attachment/12464947/OPENJPA-1898.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-11-30 20:19:44.863,,,no_permission,,,,,,,,,,,,68158,,,Tue Nov 30 20:19:44 UTC 2010,,,,,,,0|i0z0qv:,202423,,,,,,,,"30/Nov/10 09:13;struberg;reduce parallel threads from 1000 to 800. Now it's not very likely that any user hits the default 1024 threads limit, but we still have enough parallel loops running","30/Nov/10 20:19;mikedd;Thanks for the patch Mark, I've committed it to trunk and 2.1.x. 
",,,,,,,,,,,,,,,,,,,,,,,,,
Sybase reserved words may not be used as column names,OPENJPA-1897,12480699,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,23/Nov/10 17:29,13/Jul/11 16:11,14/Mar/19 03:03,23/Nov/10 20:08,2.0.1,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,Further investigation on reserved names for Sybase shows that few (if any) of the reserved words may be used as column names. Erring on the side of caution and disabling them all. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,68164,,,2010-11-23 17:29:49.0,,,,,,,0|i0z0nb:,202407,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA cannot store POJOs if a corresponding record already exists,OPENJPA-1896,12480685,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,cefn,cefn,23/Nov/10 16:32,02/Feb/12 17:01,14/Mar/19 03:03,10/Jan/11 22:11,2.0.1,2.1.0,2.2.0,,,,,,2.1.0,2.2.0,,,,,,,,0,,,,,,,,"If a POJO is created using a java constructor, merge() cannot store the newly constructed object's data if this means updating a pre-existing record with a matching identity.

This is a major bug since it means applications where the objects have a natural key cannot use OpenJPA. In my case the example was a filesystem; each crawl of the filesystem generates its own data objects with file path as the natural key. These objects then need to be stored into the database. Previous crawls may have encountered the same files, and the merge operation should cause the latest data from the POJO to be stored in the pre-existing record.

Instead, any attempt to execute either merge() or persist() on an independently constructed object with a matching record identity in the database triggers the same error in the database layer, since OpenJPA attempts to execute an insert for a pre-existing primary key, throwing...
org.apache.openjpa.lib.jdbc.ReportingSQLException: ERROR: duplicate key value violates unique constraint ""file_pkey"" {prepstmnt 32879825 INSERT INTO file (locationString, location, version, folder) VALUES (?, ?, ?, ?)  [params=?, ?, ?, ?]} [code=0, state=23505]

From discussion with Rick Curtis on the users@openjpa.apache.org list, this is because the version field on a POJO which is unmanaged is not yet set. 

An ASSUMPTION seems to be made that no such record exists in the database already since it wasn't loaded from the database in the first place, so a persist is attempted. Instead, I recommend the database is QUERIED TO FIND OUT if such a record already exists, and the version field is set correspondingly before attempting the merge() 

Here is the corresponding thread containing Ricks comments and links to an example in Github which can recreate the problem.

http://bit.ly/hfPjTI
","Eclipse, Sun Java 1.6, Ubuntu Lucid, Guice JPAPersistModule, build-time enhance.xml",,,,,,,,,,,,,,,,,,20/Dec/10 21:22;curtisr7;openjpa-1896.jar;https://issues.apache.org/jira/secure/attachment/12466659/openjpa-1896.jar,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-12-20 21:22:48.903,,,no_permission,,,,,,,,,,,,162125,,,Thu Feb 02 17:01:24 UTC 2012,,,,,,,0|i1ducf:,289013,,,,,,,,"23/Nov/10 16:37;cefn;I've changed the link to the mailing list thread above to be something which Jira's smart formatting doesn't break through incompetent parsing. 

So...

http://bit.ly/hfPjTI

...was previously...

http://mail-archives.apache.org/mod_mbox/openjpa-users/201011.mbox/%3CAANLkTi=tzs-nB6+NQQJmUcfbpCF_kzPnhOtLkYHvH+bM@mail.gmail.com%3E","20/Dec/10 21:22;curtisr7;Cefn -

Please try to merge this patch on top of your current openjpa jar. Please let me know if this fixes your problem... I'm not very excited about this approach, but I'll think about it while you try it out.

Thanks,
Rick","21/Dec/10 10:38;cefn;Sorry to let you down, Rick. I can't easily verify the patch. I no longer have a codebase incorporating OpenJPA as I switched to Hibernate. This bug just seemed too major to me, and made me wonder what else I would discover if I relied on OpenJPA.

I appreciate the work you've put in, and I hope it helps supporting other OpenJPA users who want to use POJOs with natural keys as the project gets wider adoption. I like a lot of the features which OpenJPA adds on top of JPA, but standards conformance is more important for the future of our project (switching easily between persistence frameworks). 

Focusing just on JPA functionality I found the OpenJPA enhancement process really complex and likely to introduce issues in deployment, (Hibernate just worked). However, this merge bug was the clincher because of the domain we're working on.","22/Dec/10 14:21;curtisr7;Cefn -

Well that sucks that you're leaving for hibernate... but I understand that you have a job that needs to get done. I'll be sure to have this one fixed so things are working when you give us another try in the future. :-)

Thanks,
Rick","22/Dec/10 19:17;curtisr7;This required two changes to get everything working :

1.] I updated the enhancer (PCEnhancer) so that when we are writing pcIsDetached() if we can't make a definitive answer, to return null. When merging an Entity and we don't know if it is detached, we will query for the Entity to see if we need to issue an UPDATE or an INSERT.

2.] *Note - This is the part that I'm not very excited about.... 

This change is required for an Entity which has a primitive @Version field. After applying fix [1] we now query the DB to see if these Entities exist. Now that we know that we're going to need to do an update, we look at the version field to see if the value is different than those in the DB. In the case of a non-primitive version field, it will be null and we know that it wasn't set. 

In the case of a primitive field, it will be initialized to the types default value. If the current version is greater than the default for the type we will incorrectly throw on optimistic lock exception. To fix the problem I was able to peer inside the Entity and check the value of the pcVersionInit field(added by the Enhancer to detect whether the version field was set, or if it is a default value). Unfortunately the value of this field isn't exposed on the PersistenceCapeable interface, so I had to use reflection.

After thinking some more about this, I have an edge case that I can't fix...

Lets say I have an Entity with an int version column and for whatever reason the value is 0. Now we find an Entity and stream it out to client 1. Next another client modifies that row so the version gets incremented to 1. Client 1 updates that data and sends it back to the server. At this time we have no state manager and we try to merge it back into the persistence context. This is the problem. We *should* get an OLE here because the current Entity has a version of 0 but the DB has a version of 1. We don't get an OLE because we will assume that the value of the version column is a defaulted value, not one that was actually set there. Make sense?

The net of this is that we should tell users to either make sure their version columns start with a value greater than 0, or to use non primitive types.",11/Jan/11 19:31;curtisr7;Committed changes to 2.1.x and trunk.,02/Feb/12 17:01;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,
Performance Improvement for SelectImpl,OPENJPA-1894,12480601,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,22/Nov/10 18:19,22/Nov/10 18:34,14/Mar/19 03:03,22/Nov/10 18:31,2.1.0,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,SelectImpl.getTableIndex() is allocating lots of String objects. The patch will reduce the number of String objects. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162123,,,2010-11-22 18:19:41.0,,,,,,,0|i0z913:,203765,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missing join clause in query with collection-table with two join-columns,OPENJPA-1893,12480591,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,pduroux,pduroux,22/Nov/10 16:33,22/Nov/10 21:50,14/Mar/19 03:03,22/Nov/10 21:50,2.0.1,,,,,,,,2.1.0,,,,,,,,,0,,,,,,,,"Considering the following mapping:

	<entity class=""Feature"">
		<table name=""features"" />
		<attributes>
			<embedded-id name=""id"" />
			<element-collection name=""attributes"">
				<collection-table name=""qualifiers"" />
			</element-collection>
		</attributes>
	</entity>

Without specifying any JoinColumn element in the CollectionTable element, I got the query:

(...) INNER JOIN qualifiers t3 ON t0.index = t3.FEATURE_INDEX AND t0.oid = t3.FEATURE_OID (...)

but changing the mapping by:
				<collection-table name=""qualifiers"">
					<join-column name=""oid"" />
					<join-column name=""index"" />
				</collection-table>

I got:

(...) INNER JOIN qualifiers t3 ON t0.index = t3.index (...)

where is missing the first JoinColumn.

",,,,,,,,,,,,,,,,,,,22/Nov/10 17:13;pduroux;Attribute.java;https://issues.apache.org/jira/secure/attachment/12460184/Attribute.java,22/Nov/10 17:13;pduroux;Feature.java;https://issues.apache.org/jira/secure/attachment/12460185/Feature.java,22/Nov/10 17:13;pduroux;FeatureId.java;https://issues.apache.org/jira/secure/attachment/12460186/FeatureId.java,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2010-11-22 17:02:14.11,,,no_permission,,,,,,,,,,,,162122,,,Mon Nov 22 17:13:21 UTC 2010,,,,,,,0|i0z8yf:,203753,,,,,,,,"22/Nov/10 17:02;faywang;Hi Patrice, 
   Could you post your Feature.java, your embedded id class, and embeddable class used in the element collection? Thanks!",22/Nov/10 17:13;pduroux;Here are the corresponding Java classes.,,,,,,,,,,,,,,,,,,,,,,,,,
Query trace may contain sensitive information and should not be logged by default.,OPENJPA-1886,12479974,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,15/Nov/10 16:24,13/Jul/11 16:11,14/Mar/19 03:03,16/Nov/10 22:19,2.0.2,2.1.0,,,,,,,2.1.0,,,,,logging,,,,0,,,,,,,,"This is the same problem as reported by OPENJPA-1678 except it is coming from openjpa.Query.

To recreate this problem, run org.apache.openjpa.persistence.querycache.TestQueryCache and enable ""openjpa.Log"",""Query=trace"". 

375  test  TRACE  [main] openjpa.Query - Executing query: [SELECT o FROM Entity1 o WHERE o.pk = :pk] with parameters: {pk=2}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,68165,,,Wed Jul 13 16:11:20 UTC 2011,,,,,,,0|i0z0cn:,202359,,,,,,,,"16/Nov/10 22:19;curtisr7;Commited the bug fix and a few new test cases.

I'm not real excited about how I had to fix this problem though... Currently we turn this behavior off/on by setting openjpa.ConnectionFactoryProperties=PrintParameters=true but ideally this would be configured via openjpa.Log=PrintParameters=true... but as I know Mike found out when trying to fix OPENJPA-1678, that isn't a trivial task.  If I understand the code correctly, to support PrintParameters on openjpa.Log we would need to modify the LogFactory interface, and potentially break any and all external implementers of that interface.

This isn't an ideal fix, but it does fix the reported problem.",13/Jul/11 16:11;curtisr7;Closing resolved issues.,,,,,,,,,,,,,,,,,,,,,,,,,
CacheStoreMode.REFRESH is not recognized for entity manager refresh operation,OPENJPA-1884,12479818,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,12/Nov/10 18:48,31/Mar/11 21:05,14/Mar/19 03:03,31/Mar/11 21:05,2.1.0,,,,,,,,2.1.1,,,,,datacache,,,,0,,,,,,,,"Specifying the ""javax.persistence.cache.storeMode"" property with value CacheStoreMode.REFRESH does not refresh the contents of the L2 cache when used with the em.refresh(entity, props) operation.

OPENJPA-1578 corrected this a similar issue for the em.find() operation, but not em.refresh().  A simple port of the changes from 1578 (which simply configure the store mode in the fetch plan) to the refresh operation did not correct the problem.  It appears that more work needs to be done in the underlying refresh logic to produce a cache refresh.",,,,,,,,,,,,,,,,,,,03/Dec/10 18:20;techhusky;OPENJPA-1884-jUnit.patch;https://issues.apache.org/jira/secure/attachment/12465256/OPENJPA-1884-jUnit.patch,06/Dec/10 15:57;techhusky;OPENJPA-1884.patch;https://issues.apache.org/jira/secure/attachment/12465381/OPENJPA-1884.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2011-03-31 21:05:32.074,,,no_permission,,,,,,,,,,,,162116,,,Thu Mar 31 21:05:32 UTC 2011,,,,,,,0|i0z5k7:,203203,,,,,,,,03/Dec/10 18:20;techhusky;Attaching a jUnit which demonstrates the issue.,"04/Dec/10 06:44;techhusky;Attaching fix and updated test code.  In addition to handling updates, this fix also purges entries from the L2 when the property javax.persistence.cache.storeMode is set to CacheStoreMode.REFRESH and the refresh operation determines the entity no longer exists in the underlying datastore/database.",06/Dec/10 15:57;techhusky;Attaching updated patch containing performance update that eliminates a cache get when storemode=bypass (the default).,31/Mar/11 21:05;curtisr7;Closing.,,,,,,,,,,,,,,,,,,,,,,,
NPE in DataCacheStoreManager when all types aren't cached,OPENJPA-1882,12479608,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,10/Nov/10 17:23,10/Nov/10 18:35,14/Mar/19 03:03,10/Nov/10 18:35,2.1.0,,,,,,,,2.1.0,,,,,datacache,,,,0,,,,,,,,"I found two NPEs in DataCacheStoreManager when the cache is enabled, but at least one type isn't being cached.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162114,,,Wed Nov 10 18:35:47 UTC 2010,,,,,,,0|i0z8vj:,203740,,,,,,,,10/Nov/10 18:35;curtisr7;Committed revision 1033637 to trunk,,,,,,,,,,,,,,,,,,,,,,,,,,
"Create ""completion"" message for the Enhancement processing",OPENJPA-1881,12479591,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,kwsutter,kwsutter,kwsutter,10/Nov/10 14:12,11/Nov/10 17:31,14/Mar/19 03:03,11/Nov/10 17:31,2.1.0,,,,,,,,2.1.0,,,,,Enhance,,,,0,,,,,,,,"The Enhance trace log outputs a message indicating whether enhancement is necessary or not (true or false).  And, if enhancement is necessary, a message is logged indicating that this process is starting and which classloader is being used.  But, there is no ""enhancement complete"" message.  And, following an idea from the WebSphere App Server, knowing the before and after byte size might be interesting.  So, this JIRA will be used to log a message similar to the following when the enhancement processing is complete:

719  TRACE  [main] openjpa.Enhance - Enhancement for ""my/entities/OrderlineJPA"" completed. Class size: [3,292/14,045]
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162113,,,2010-11-10 14:12:38.0,,,,,,,0|i1dudj:,289018,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Treat Oracle XMLType columns as XML,OPENJPA-1877,12479394,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,08/Nov/10 17:19,08/Nov/10 22:40,14/Mar/19 03:03,08/Nov/10 22:40,2.0.1,,,,,,,,1.3.0,2.0.2,2.1.0,,,jdbc,,,,0,,,,,,,,"OPENJPA-240 added the ability to detect XML columns based on their type name. This was removed in OPENJPA-846 in order to support databases (MySQL) which don't use a type name that includes XML. 

This issue will add the autodetection for Oracle's XMLType columns. ",,,,,,,,,,,,,,OPENJPA-240,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162109,,,2010-11-08 17:19:08.0,,,,,,,0|i0z8rr:,203723,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Slow JDBC tests,OPENJPA-1876,12479325,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,milosz,milosz,milosz,07/Nov/10 17:56,02/Feb/12 17:00,14/Mar/19 03:03,24/Jan/11 20:49,2.1.0,,,,,,,,2.2.0,,,,,,,,,0,,,,,,,,"Persistence JDBC tests and other database connected tests have been suffering from slow down starting somewhere in September 2010 [1]. I can see this in my environment as well as Hudson builds:

OpenJPA-trunk-deploy: Build #49 (Nov 7, 2010 6:46:34 AM): OpenJPA Persistence JDBC: 34 min

OpenJPA-20x-deploy: Build #23 (Nov 5, 2010 7:14:48 PM): OpenJPA Persistence JDBC: 10 min

As seen above, the trunk build executes much slower than the 2.0.x build yet the number of tests is roughly the same and there are no significant differences in execution times of modules that do not touch database.

[1] http://openjpa.208410.n2.nabble.com/Slow-JDBC-test-suite-tp5594040p5594040.html
",,,,,,,,,,,,,,OPENJPA-1764,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-11-16 18:51:18.257,,,no_permission,,,,,,,,,,,,162108,,,Thu Feb 02 17:00:23 UTC 2012,,,,,,,0|i1duef:,289022,,,,,,,,"16/Nov/10 18:51;curtisr7;I looked at which tests are taking a long time this afternoon and came up with this list ... these are all 10+ seconds. I'm not sure which of these can be attributed to the 'problem' tests, but they are the longest running.

Name									                                               Duration		Tests

TestClearableScheduler   (org.apache.openjpa.persistence.datacache)   		3m:01s,088ms  1
TestQueryTimeout (org.apache.openjpa.persistence.query)   		   		49s,306ms 	12
TestDaytrader (org.apache.openjpa.integration.daytrader) 			   		42s,167ms 	1
TestTimeoutException (org.apache.openjpa.persistence.query) 			        30s,222ms 	3
TestSJVMCache (org.apache.openjpa.persistence.datacache) 			        24s,390ms 	30
TestDataCachePCDataGenerator (org.apache.openjpa.persistence.datacache) 	23s,567ms 	30
TestTypesafeCriteria (org.apache.openjpa.persistence.criteria) 			        22s,802ms 	100
TestEnhancementWithMultiplePUs (org.apache.openjpa.enhance) 			18s,864ms 	3
TestJPQLSubquery (org.apache.openjpa.persistence.criteria) 			        14s,346ms 	59
TestTypeSafeCondExpression (org.apache.openjpa.persistence.criteria) 		13s,267ms 	55
TestEmbeddable (org.apache.openjpa.persistence.embed) 				        10s,862ms 	26","17/Nov/10 10:06;milosz;Hi Rick. These are indeed the longest ones but in fact all database related tests are gradually slowed down.

It might be related either to derby test profile or derby itself, since when I run the tests against another database, there is no slowdown.
","09/Jan/11 13:21;milosz;The direct cause is DELETE statements (without WHERE clause) gradually become slow on Derby while a test case is executed and we issue a lot of DELETEs at the beginning of most test methods.

The issue is related or caused by DBCP pooling auto-enablement because when I specify the properties in the old way:

<property>
  <name>openjpa.jdbc.DriverDataSource</name>
  <value>simple</value>
</property>
<dbcp.args>DriverClassName=org.apache.derby.jdbc.EmbeddedDriver,Url=jdbc:derby:target/database/openjpa-derby-database;create=true,Username=,Password=,MaxActive=10,MaxIdle=5,MinIdle=2,MaxWait=10000</dbcp.args>
<connection.driver.name>org.apache.commons.dbcp.BasicDataSource</connection.driver.name>

the execution time drops to the old level and JDBC log channel shows database and driver version as in 2.0.x branch.
","17/Jan/11 12:41;milosz;Narrowing further, the issue happens because we set connection properties (e.g. JDBC driver class) in the main pom.xml differently after implementing DBCP pooling auto-enablement. This impacts automatic Derby shutdown when closing a data source. Although we have always had set DerbyDictionary.shutdownOnClose set to true, we were not shutting Derby down in our tests. After the properties changed, we started doing the shutdown and this is slowing DELETE statements (but why?). It looks like the shutdown might be a good option for user applications but not for unit tests. Setting DerbyDictionary.shutdownOnClose=false should resolve the issue.

As for the lack of database and driver version message in the log, it is also caused by the properties change. However, it is quite a good thing here - it means OpenJPA is able to figure out DBDictionary class without connecting to the database.
",02/Feb/12 17:00;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,
Handle Oracle specific XML column type with @Lob annotation,OPENJPA-1874,12479205,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,05/Nov/10 14:30,08/Nov/10 22:41,14/Mar/19 03:03,08/Nov/10 22:41,1.2.2,2.0.0,2.0.1,,,,,,1.2.3,2.0.2,2.1.0,,,,,,,0,,,,,,,,The Oracle specific XMLType column type is not handled correctly if the field in the entity is annotated with @Lob. ,,,,,,,,,,,,,,OPENJPA-1289,,,OPENJPA-1877,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162107,,,2010-11-05 14:30:22.0,,,,,,,0|i1duen:,289023,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
EntityManager#merge sometimes passes wrong entity values to @PostLoad EntityListeners ,OPENJPA-1873,12479138,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,struberg,struberg,04/Nov/10 19:57,02/Feb/12 16:59,14/Mar/19 03:03,08/Dec/11 14:59,2.0.0,2.0.1,2.0.2,,,,,,2.2.0,,,,,kernel,,,,0,,,,,,,,"I've tested this with the latest from branches/2.0.x.

My entity has an @EntityListeners which observes the @PostLoad lifecycle event. This listener stores the 'old' values from the database for later use (see http://struberg.wordpress.com/2010/07/31/howto-changelog-with-jpa/ for the intention behind). All works well if the table has only a few rows. But if you add more rows, OpenJPA tries to optimize the access and only loads the @Version field + the dirty fields. In this case the merging seems to be wrong, because I get the NEW values from the dirty fields instead of the original values from the database passed to my @PostLoad method.

Did cost me a few grey hairs to track down the differences between the working and the broken scenarios here ;) But finally I was able to creat a unit test showing the problem

",,,,,,,,,,,,,,,,,,,08/Jan/11 00:43;struberg;OPENJPA-1873-fix1.patch;https://issues.apache.org/jira/secure/attachment/12467779/OPENJPA-1873-fix1.patch,08/Jan/11 12:46;struberg;OPENJPA-1873-fix2.patch;https://issues.apache.org/jira/secure/attachment/12467792/OPENJPA-1873-fix2.patch,07/Dec/11 19:02;struberg;OPENJPA-1873-fix3.patch;https://issues.apache.org/jira/secure/attachment/12506498/OPENJPA-1873-fix3.patch,04/Nov/10 19:59;struberg;OPENJPA-1873-unittest.patch;https://issues.apache.org/jira/secure/attachment/12458842/OPENJPA-1873-unittest.patch,07/Jan/11 17:17;curtisr7;openjpa-1873-hack-1.patch;https://issues.apache.org/jira/secure/attachment/12467741/openjpa-1873-hack-1.patch,09/Nov/10 16:32;struberg;postloadtest.zip;https://issues.apache.org/jira/secure/attachment/12459166/postloadtest.zip,,,,,,,6.0,,,,,,,,,,,,,,,,,,,2010-11-08 23:29:21.849,,,no_permission,,,,,,,,,,,,162106,,,Thu Feb 02 16:59:53 UTC 2012,,,,,,,0|i0z8wf:,203744,,,,,,,,"04/Nov/10 19:59;struberg;this unit test shows the problem. If you comment out value2 .. value12 in PostLoadListenerEntity.java, then all works fine.

In the meantime: is there a config option to disable this optimisation behaviour?","08/Nov/10 23:29;curtisr7;My first thoughts on this are that the merge operation shouldn't result in a postLoad() callback... Nothing from the DB is actually being placed in the persistence context.

The only reason OpenJPA is hitting the DB is to see if the merged Entity is dirty. In the case where there is no version, we need to hit the DB to compare the dirty fields to those in the DB. In the case where there is a version field, we will only load that field... not the entire Entity. ","08/Nov/10 23:40;struberg;Rick, the merge acutally does much more than simply loading the version field. It additionally loads all fields which are marked as 'dirty' from the database. 

From the spec 3.1.1 EntityManager Interface
Merge the state of the given entity into the
current persistence context.
@return the managed instance that the state was merged to

and 'managed instance' is a well defined term in this spec which afaik means an entity which got loaded from the database.

","09/Nov/10 12:08;struberg;I did further debugging.

In the DetachedStateManager #165 (right after the dirty check and reload of all those fields: Object origVersion = sm.getVersion(); ) the sm (StateManagerImpl) contains the correct entity values from the db in _pc!

of course they get replaced with the values from toAttach before the @PostLoad gets fired.

There are 2 options now:

a) dont fire the @PostLoad at all for EM#merge - because the load data in the event is definitely wrong currently
b) first merge the non-dirty fields back to the sm._pc before firing the @PostLoad event and then do the toAttach merge.

I'd obviously prefer option b ;)","09/Nov/10 13:56;curtisr7;Unfortunately option a.) gets my vote. 

Theoretically we shouldn't be hitting the DB at all for this Entity since we have a DetachedStateManager and we know which fields are dirty... so there isn't a need to load anything.","09/Nov/10 14:09;struberg;but it seems that EclipseLink and Hibernate both fire the @PostLoad event for a merge. 
And albeit it is not 100% clear from the spec, there is a lot evidence that this behaviour is intended.

edit: the wording from the PostLoad + merge (3.2.7.1) + 'managed instance' in the spec indicate that @PostLoad should get fired if the merging gets called on a detached entity which exists in the database.","09/Nov/10 15:30;kwsutter;Hi guys,
My two cents worth...  I don't think the spec indicates that the @PostLoad should get fired on a merge() operation.  I do agree that if the merge() operation requires loading from the database, then the @PostLoad should get fired.  But, I don't see in the spec where it says that the merge() operation demands a load from the database (and thus the @PostLoad).

Section 3.2.7.1 states:

""If X is a detached entity, the state of X is copied onto a pre-existing managed entity instance X'
of the same identity or a new managed copy X' of X is created.""

Since OpenJPA utilizes a ""detached state manager"", that would constitute a pre-existing managed entity instance and there would be no requirement to go to the database.  If you think about it, this would be a good thing to avoid extra, unnecessary trips to the database.

Now, if your detached entity does not use a ""detached state manger"" [1], then we probably have to go to the database (like the other providers) to load up the current state into a new managed copy and then merge in the updated values.  From side conversations with Rick, this processing may not be working quite right, but that's how I am reading the spec and the scenario described here.

The other interesting piece from 3.2.7.1 is this:

""Any Version columns used by the entity must be checked by the persistence runtime implementation
during the merge operation and/or at flush or commit time. In the absence of Version columns there is
no additional version checking done by the persistence provider runtime during the merge operation.""

Earlier comments by Rick seemed to indicate that the absence of an @Version field would be a reason to access the database during merge().  This paragraph seems to indicate that this version checking should not be done during merge()...

This looks to be a good problem.  I think we have an issue or two to resolve here.  We just need to come to a consensus.

Thanks,
Kevin

[1]  http://openjpa.apache.org/builds/2.0.1/apache-openjpa-2.0.1/docs/manual/manual.html#ref_guide_detach_state ","09/Nov/10 15:39;curtisr7;> but it seems that EclipseLink and Hibernate both fire the @PostLoad event for a merge. 
Point noted.

3.5.2 -- ""The PostLoad method for an entity is invoked after the entity has been loaded into the current persistence
context from the database or after the refresh operation has been applied to it.""

Most of my argument is based off the part which says ""from the database"". In the case of this merge, OpenJPA has a DetachedStateManager so we *shouldn't* need to hit to DB to see which fields are dirty. I think we have a bug here where we hit the DB even though we don't need to. 

I believe that the other providers aren't working per the spec. Upon merge being called, they may need to hit the DB to compare merged fields with those in the DB to see which are dirty/clean... but that data isn't actually loaded into the persistence context. They are loading data for the sake of version checking, not for loading in the context. 

I'll note that Pinaki wrote a blog post[1] quite some time back doing something very similar. It might be worth a read. It looks like the formatting is messed up so let me know if you want the full text.

Quite the hair splitting for this early in the morning :)

[1] http://webspherepersistence.blogspot.com/2009/01/auditing-with-openjpa.html",09/Nov/10 16:32;struberg;Hi! Just verified that @PostLoad gets fired in Hibernate. See the attached little maven project.,"12/Nov/10 16:30;curtisr7;@Mark -

Thoughts on Kevin's last post?

Thanks,
Rick","12/Nov/10 16:40;struberg;I'm very interested why OpenJPA currently loads the dirty fields from the database (in a manner which in the logs looks like it's doing multiple database interactions!) instead only _loading_ the version (if present). 

Fact: a @PostLoad must get called after loading from the database. Thus I'd say that it needs to get called even if entities only got loaded partly. But the spec also defines that the _entity_ from the db needs to get posted. Currently we get a mix between old and new values in @PostLoad which (I think we agree) is wrong.

Also quoting from the spec posted above:
""In the absence of Version columns there is no additional version checking done by the persistence provider runtime during the merge operation.""

I interpret is that in reverse it should be checked on #merge if an @Version is present.","12/Nov/10 17:31;curtisr7;> I'm very interested why OpenJPA currently loads the dirty fields from the database (in a manner which in the logs looks like it's doing multiple database interactions!) instead only _loading_ the version (if present). 
It sounds like a bug.

> a @PostLoad must get called after loading from the database.
The spec says that @PostLoad must get called after data gets loaded from the database INTO the persistence context. If the provider is loading from the DB, but it isn't going into the context, I don't think we need to do the callback.

Also, since OpenJPA has this smart DetachedStateManager, we shouldn't need to load anything from the database on merge. We currently do (as noted above) but I think we have a bug.","12/Nov/10 17:42;struberg;Do we have someone representing the ASF on this JSR in the EG? If not I could ping a few guys on the EG or even ask on the eclipselink list.
I'd rather like to get this confirmed before we implement it the wrong way.","12/Nov/10 18:01;curtisr7;> Do we have someone representing the ASF on this JSR in the EG? 
Yes Kevin and Pinaki are both on the EG. I'll get one of them to comment on this issue early next week.

> I'd rather like to get this confirmed before we implement it the wrong way.  
Agreed.","16/Nov/10 20:58;ppoddar@apache.org;Mark,
  1. is the attached test in PostLoadTest.zip supposed to pass or fail?

  you wrote:
> Fact: a @PostLoad must get called after loading from the database. Thus I'd say that it needs to get called even if entities only got loaded partly. 
  I tend of agree. The notion of 'loaded partly' does not exist in the spce -- it is an implementation issue. 
 However, my view is that the lifecycle callback methods are tied to instance life cycle state transitions and not directly to operational  methods such as find() or merge(). Of course, an operational method may cause a life cycle state transition. For example, a PostLoad callback is invoked when an entity state is loaded from the database. But whether a merge() operation will cause an entity state be loaded from database or not can vary based on other factors. 
Hence a question such as ""does merge() must invoke postLoad()?"" may not offer a definite answer. ""Vendor X invoked postLoad() on merge()"" -- is not convincing enough  for me. 


> But the spec also defines that the _entity_ from the db needs to get posted. 

   Can you please elaborate this point? Are you suggesting that the state of the argument instance of postLoad() method should represent the database values? If that is the case, then I do not agree. The postLoad() will see the state of the instance *after* the provider has loaded the instance in to its context -- some of the properties can come from the database, some can come from the user-supplied instance  -- but the state as presented to the postLoad() method argument must be 'consistent' -- meaning it must be the exact same state that the persistence context holds and will eventually be committed if nothing changes further.

> Currently we get a mix between old and new values in @PostLoad which (I think we agree) is wrong. 

  Such a mix, if proven, is inconsistent.  But I could not see how the test you have submitted exposes such inconsistent behavior. 



","16/Nov/10 22:17;struberg;Hi Pinaki!

The test contains a test entity PostLoadListenerEntity.
This  entity contains a field 'value' which I use in the test.
If you add ONE single other value to the entity, the Object in the @PostLoad listener has a different value.

Please comment out value2 to value12 in this entity (only id and value enabled) and rerun the test - it will pass now.
Then comment value2 or any other additional field back in -> the test will fail.
This is really inconsistent and should get fixed

Btw I do not agree with you on the value of the @PostLoad data.
The spec says: 
3.5.2
""The PostLoad method for an entity is invoked after the entity has been loaded into the current persis-
tence context from the database or after the refresh operation has been applied to it.""

and for the merge:
3.1.1 ""Merge the state of the given entity into the current persistence context."" 
3.2.7.1 ""The merge operation allows for the propagation of state from detached entities onto persistent entities managed by the entity manager."" + ""If X is a detached entity, the state of X is copied onto a pre-existing managed entity instance X' of the same identity or a new managed copy X' of X is created.""

I interpret this that  the value we need to hand to the @PostLoad method ist per spec the state of the entity _before_ the merge.
The only thing we imo can take into question is if the @PostLoad needs to get called at all. Section 3.2.7 at least gives a few answers where we for sure do not need to load it - but 3.2.7.1 imo says that we should for merging detached entities:

3.2 ""A managed entity instance is an instance with a persistent identity that is currently associated with a persistence context.""

Of course you can say we don't need to go to the database to ensure the 'managed entity' has a 'persistent identity' but then you will fail if the database has been changed outside your application. Thus a load from the database is really required. 

I know that we only need to do what the spec says and not what any other JPA implementation does. But if 3 other major JPA impls act this way, than it might be a strong indicator at least ;)

txs and LieGrue,
strub","26/Nov/10 18:10;struberg;The bug doesn't appear if I use

 <property name=""openjpa.DetachState"" value=""fetch-groups""/>

So this is definitely a bug imo, because OpenJPA must return the same results regardless which detach strategy one uses.","07/Jan/11 13:16;struberg;Hi!

This is just a small summary about the discussions I had with Rick at our yesterdays debugging session.

It seems that the DetachStateManager is almost in the original state as imported by Patrick in early 2006 and might not reflect all things needed for JPA2.

The attach() in line #108 is of special interrest. It consists of 3 parts:

1.) (line #131 - #166) prepare old Values from the database to be able to restore those values in case of a rollback.
 comment: Imo this is NOT needed if openjpa.RestoreState is RESTORE_NONE!

2.) (handled in the same block somehow) if optimistic locking is used (does the whole merging make any sense for row-locking at all?): Check the version in the database to make sure that we didn't have a concurrent modification already.

3.) (line #168 - #295) perform the actual 'merging'. by setting the values from the toAttach entity into the one from the DB.

so far so good.

Now to the problematic spots. 

Depending on the situation (_loaded and _dirty states) 1.) xor 3.) fire the @PostLoad event. The logic for the lifecyle event is to get fired if all fields (or all fields of a FetchGroup if fgs are used) got set. If all fields have been made dirty in the detached entity then this will happen in 1.) If not, it will happen in 3.). The problem here is that in 1.) the entity from the DB is not complete and in 3.) has nothing to do with any load from the database, since it contains the dirty values from the toAttach entity.

It's really problematic that both the load() from the database and the attach() use the same StateManagerImpl#storeStringField() without any distinction. So those highly different tasks will both fire the same @PostLoad lifecycle event. Imo this must not happen while attaching.

Rick, are you d' accord so far?
",07/Jan/11 17:17;curtisr7;Attaching a hack for Mark to play around with.,"08/Jan/11 00:43;struberg;Hi Rick!

Here is my first take on the problem based on your initial suggestion. 

What do you think about introducing a configuration parameter like openjpa.PostLoadOnMerge ?

There is a line in the patch marking the right spot:
boolean postLoadOnMerge = true; //X make this configurable

It seems to run fine in my real world application, but I just need to start the full OpenJPA compile with tests enabled over the night. So possibly still something left to fix...

","08/Jan/11 00:53;struberg;one thing: we should possibly suppress firing of the PostLoad event if postLoadOnMerge == false when reading the dirty attributes from the db.
Because this still gets fired if all attributes have been dirty in the detached entity. Currently you sometimes get the @PostLoad called on merge, sometimes not ...","08/Jan/11 12:46;struberg;and here comes the next one, this time with a new 'openjpa.PostLoadOnMerge' configuration property.

Tests are currently running....

LieGrue,
strub","07/Dec/11 19:02;struberg;Hi!

I've now updated my patch to apply cleanly to the latest trunk!

This is tested in 2 big real world projects and works fine now since a year. This is really an important issue, because currently the POST_LOAD lifecycle listeners are really broken. They e.g. currently also being called for parts which are lazily loaded - and in this case the lifecycle listener will get completely wrong data handed over!

My patch is non-invasive because the 'fixed' handling will only be used if POST_LOAD_ON_MERGE gets enabled in persistence.xml.

If noone objects, I'll go on and commit the patch tomorrow.","09/Dec/11 00:11;kwsutter;Mark,
Your patch/commit looks pretty straight forward.  The JIRA has such a long history, I was wondering what you finally decided to resolve.  It looks like you have provided a new property (openjpa.PostLoadOnMerge) which will tell OpenJPA to call the PostLoad listener on every Merge.  If that's accurate, then some documentation updates would be good to have so that users know about this new property.  Thanks.

I also noticed that you updated the OpenJPAConfiguration file to define the OPTION_POSTLOAD_ON_MERGE string.  I don't believe these are really even used any more.  It looks like maybe this was the old (original) way to specify properties, but the updated plugin configuration is much easier -- which you also implemented.  Maybe I'm mistaken, but I don't think you need the OPTION_POSTLOAD_ON_MERGE updates.  Did you find that you required these?

And, it looks like you resolved the problem with incorrect data being dispensed to the PostLoad listener on a Merge -- iff this new option is set. Is that correct?

Thanks,
Kevin","09/Dec/11 11:47;struberg;Thanks for the review Kevin!

Indeed, the problem I faced for a long time was that PostLoad was pretty much broken, because the payload entity you get into this event was always different, depending on the situation.

I agree with what Rick and Pinaki pointed out above, that the spec is not really clear if PostLoad should get fired for a merge at all. But OpenJPA actually _did_ fire it in _some_ cases, and the entity which got handed to the event was a mixture between the entity in memory, the state on the database and the lazy-loaded delta. Again: it was not _one_ of those 3, but it was a weird mixture with some fields nulled out, etc. And it was depending on _loaded, _dirty and the detached state. So basically the PostLoad event was not usable for users once the entity got detached.

Because of that, I would be in favour to even make PostLoadOnMerge enabled by default - but that's a policy decision which is not up to me to decide. Please note that the behaviour only got changed if there is any PostLoad lifecycle listener registered on the entity at all! 
With the PostLoadOnMerge flag enabled, OpenJPA now behaves the same way as I saw with latest Hibernate and EclipseLink - I actually don't care much about those other impls, but I think it's at least not a bad thing ;)

I was not really sure about the String property based configuration, so I decided to go full route. If you say this is not supported anymore in openjpa-2.x, then we should think about Deprecating those parts at all?

Regarding the documentation - thanks for the pointer! I thought those get generated out from the JavaDoc. Will fix those parts in the doc by adding the property.

",02/Feb/12 16:59;allee8285;Close issue in preparation for 2.2.0 release.,
Blob types override column definition from @Column annotation with MySQL,OPENJPA-1870,12479005,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,joelhalbert,mikedd,03/Nov/10 16:01,09/Nov/10 13:06,14/Mar/19 03:03,05/Nov/10 15:20,2.0.2,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,"Per email to users@openjpa, an entity with this annotation :

@Column(columnDefinition=BINARY(250)) 
private byte[] blobs; 

creates a column of type BLOB when using MySQL.. This behavior was introduced in OPENJPA-740, which optimizes the blob storage based on the size of the column, but does not take into account any existing annotations. ",,,,,,,,,,,,,,,,,,,03/Nov/10 22:36;mikedd;ASF.LICENSE.NOT.GRANTED--OPENJPA-1870.diff.txt;https://issues.apache.org/jira/secure/attachment/12458767/ASF.LICENSE.NOT.GRANTED--OPENJPA-1870.diff.txt,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-11-03 22:36:12.725,,,no_permission,,,,,,,,,,,,162103,,,Tue Nov 09 13:06:23 UTC 2010,,,,,,,0|i0z8tb:,203730,,,,,,,,"03/Nov/10 22:36;mikedd;Attaching a patch. It's a bit kludgy, will commit tomorrow if no one objects. ",09/Nov/10 13:06;joelhalbert;Thanks Mike.,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException when using DataCache,OPENJPA-1867,12478886,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,02/Nov/10 13:45,09/Nov/10 14:59,14/Mar/19 03:03,02/Nov/10 14:25,2.1.0,,,,,,,,2.1.0,,,,,datacache,,,,0,,,,,,,,"We encountered a ClassCastException when loading an Entity which is part of an inheritance hierarchy and has a bi-directional relationship. This bug was introduced in OPENJPA-1801.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162100,,,Tue Nov 02 14:25:08 UTC 2010,,,,,,,0|i0z8v3:,203738,,,,,,,,02/Nov/10 14:25;curtisr7;Commited unit test and bug fix to trunk at rev.1030056.,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong exception is thrown when JoinColumn annotation is not incorrectly specified,OPENJPA-1857,12478474,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,faywang,faywang,faywang,27/Oct/10 16:17,27/Oct/10 20:58,14/Mar/19 03:03,27/Oct/10 20:58,2.1.0,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,"Consider the following scenario. Note that the referencedColumnName in Dependent5a.java does not exist in the target table. Currently OpenJPA throws PersistenceException. The correct exception should be ArgumentException indicating that         ""org.apache.openjpa.persistence.enhance.identity.Dependent5a.emp"" defines a target of ""xFIRSTNAME"" for column ""FIRSTNAME"", but that target does not exist in table ""Employee5"".

@Entity
@IdClass(DependentId5.class)
public class Dependent5a implements Serializable {

    private static final long serialVersionUID = 1L;
    @Id
    String name;
    
    @Id
    @JoinColumns({
       @JoinColumn(name=""FIRSTNAME"", referencedColumnName=""xFIRSTNAME""),
       @JoinColumn(name=""LASTNAME"", referencedColumnName=""yLASTNAME"")
    })
    @ManyToOne
    Employee5 emp;
...
}

@Entity
public class Employee5 implements Serializable {

    private static final long serialVersionUID = 1L;

    @EmbeddedId 
    EmployeeId5 empId;
...
}

@Embeddable
public class EmployeeId5 implements java.io.Serializable {

    String firstName;
    String lastName;
...
}

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162092,,,2010-10-27 16:17:33.0,,,,,,,0|i1dtvb:,288936,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Executing bulk updates should evict stale data from the DataCache,OPENJPA-1856,12478387,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,26/Oct/10 19:32,10/Jan/11 19:12,14/Mar/19 03:03,10/Jan/11 19:12,2.0.0,2.1.0,2.2.0,,,,,,2.1.0,2.2.0,,,,kernel,,,,0,,,,,,,,When executing build updates (UPDATE/DELETE) we aren't properly evicting from the DataCache. This works properly when the QueryCache is enabled.,,,,,,,,,,,,,,,,,,,10/Jan/11 17:41;curtisr7;OPENJPA-1856.patch;https://issues.apache.org/jira/secure/attachment/12467898/OPENJPA-1856.patch,26/Oct/10 20:17;curtisr7;OPENJPA-1856.patch;https://issues.apache.org/jira/secure/attachment/12458096/OPENJPA-1856.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162091,,,Mon Jan 10 17:36:07 UTC 2011,,,,,,,0|i0z8zr:,203759,,,,,,,,27/Oct/10 14:55;curtisr7;I committed a testcase and code changes to trunk on rev 1027983.,10/Jan/11 17:36;curtisr7;Reopening as this behavior should be configurable.,,,,,,,,,,,,,,,,,,,,,,,,,
the prepared query cache doesn't currently work correclty with 'SELECT IN' statements,OPENJPA-1845,12477846,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,struberg,struberg,20/Oct/10 10:27,02/Feb/12 16:58,14/Mar/19 03:03,24/May/11 14:37,2.0.1,,,,,,,,2.1.1,2.2.0,,,,jdbc,,,,0,,,,,,,,"I have a problem with upgrading from OpenJPA-2.0.0 to 2.0.1.

One of my services executes the following query (this is the 'id' I get in PreparedQueryCacheImpl#get(String id) ):

SELECT distinct e FROM Employment em, Person e WHERE em.employeeId = e.employeeId and em.orgUnitCode = :orgUnitCode AND em.employmentPosition in (:employmentPositions) AND em.start <= :startBefore AND em.end >= :endAfter ORDER BY e.familyName ASC

Somehow when I execute my service a few times with different employmentPositions params (ArrayList<String>) I still get the 'old' cached param values!

I tried to disable this behaviour in my persistence.xml with

  <property name=""openjpa.QueryCache"" value=""false""/>

but this didn't work.

Maybe this was a side effect of the ORDER BY which made this query work in 2.0.0 (caching of queries with ORDER BY got only fixed after 2.0.0), so I'd like to write a unit test for it.

As Jeremy pointed out, this can get fixed by setting <property name=""openjpa.jdbc.QuerySQLCache"" value=""false""/> in my persistence.xml.
Nontheless this is a problematic bug because it is very hard to find and lead to finding wrong data in your application (would be less problematic if it would 'just' throw an Exception).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-05-24 14:37:49.669,,,no_permission,,,,,,,,,,,,162081,,,Thu Feb 02 16:58:27 UTC 2012,,,,,,,0|i0ywp3:,201767,,,,,,,,24/May/11 14:37;mikedd;Resolving on Pinaki's behalf. ,02/Feb/12 16:58;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,,
QueryTimeoutException not thrown with Sybase,OPENJPA-1840,12477643,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,18/Oct/10 15:03,18/Oct/10 15:13,14/Mar/19 03:03,18/Oct/10 15:13,2.1.0,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,TestTimeoutException fails when running with Sybase - a generic PersistenceException is thrown instead of a QueryTimeoutException. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162077,,,2010-10-18 15:03:53.0,,,,,,,0|i0z87j:,203632,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sybase can create Foriegn Keys,OPENJPA-1838,12477545,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,16/Oct/10 18:52,16/Oct/10 18:53,14/Mar/19 03:03,16/Oct/10 18:53,2.1.0,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,SybaseDictionary explicitly removes the ability for to add FK constraints. Comments indicate that Sybase had trouble with these FK columns - but those problems are not apparent when running our unit test bucket. I suspect the problems with FK no longer manifest in recent versions of Sybase (tested with 15.0) .,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162075,,,2010-10-16 18:52:09.0,,,,,,,0|i0z85z:,203625,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ElementCollection contains Embeddable with blob value fails in Oracle,OPENJPA-1837,12477514,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,15/Oct/10 22:17,20/Oct/10 22:01,14/Mar/19 03:03,20/Oct/10 22:01,2.0.1,,,,,,,,2.0.1,,,,,jdbc,,,,0,,,,,,,,"An element collection which contains Embeddable with Lob field fails with Oracle:

<openjpa-2.1.0-SNAPSHOT-runknown fatal user error> org.apache.openjpa.persistence.ArgumentException: ""org.apache.openjpa.persistence.jdbc.annotations.EmbedOwner.embedCollection<element:class org.apache.openjpa.persistence.jdbc.annotations.EmbedValue>"" is mapped as embedded, but embedded field ""org.apache.openjpa.persistence.jdbc.annotations.EmbedOwner.embedCollection.org.apache.openjpa.persistence.jdbc.annotations.EmbedValue.blob"" is not embeddable. Embedded element/key/value types are limited to simple fields and direct relations to other persistent types. ",,,,,,,,,,,,,,,,,,,15/Oct/10 23:28;faywang;OPENJPA-1837.patch;https://issues.apache.org/jira/secure/attachment/12457311/OPENJPA-1837.patch,18/Oct/10 21:07;faywang;Openjpa-1837-1.patch;https://issues.apache.org/jira/secure/attachment/12457481/Openjpa-1837-1.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162074,,,Tue Oct 19 16:02:20 UTC 2010,,,,,,,0|i0z893:,203639,,,,,,,,"19/Oct/10 16:02;faywang;The two flags in OracleDictionary:

        maxEmbeddedBlobSize = 4000;
        maxEmbeddedClobSize = 4000;

are intended for applications using pre-11.2.0.1 jdbc driver. When these flags are set, MaxEmbeddedLobFieldStrategy will be used as for any Lob fields. The Lob field can appear in an Embeddable, which may be an element in the ElementCollection. It can also be a field in an entity.  The above exception is thrown when the Lob field is in an Embeddable and the embeddable is an element of an ElementCollection.

The limitation of 4000 is fixed in jdbc driver 11.2.0.1. The patch for this JIRA is to fix the exception for applications which still use pre-11.2.0.1 driver. ",,,,,,,,,,,,,,,,,,,,,,,,,,
dummy is not a valid column name for Sybase,OPENJPA-1835,12477478,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,15/Oct/10 14:59,23/Nov/10 17:30,14/Mar/19 03:03,19/Oct/10 17:54,2.1.0,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,"""dummy"" needs to be added to invalidColumnWordSet in SybaseDictionary. ",,,,,,,,,,,,,,OPENJPA-1897,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162072,,,2010-10-15 14:59:37.0,,,,,,,0|i1dty7:,288949,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Numeric is not a fixed size type for Sybase,OPENJPA-1832,12477366,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,14/Oct/10 15:12,14/Oct/10 15:55,14/Mar/19 03:03,14/Oct/10 15:55,2.1.0,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,Numeric should be removed from the list of fixed size types for Sybase. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162069,,,2010-10-14 15:12:18.0,,,,,,,0|i0z84v:,203620,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DataSourceFactory manipulates queryTimeout which is already in milliseconds,OPENJPA-1831,12477175,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,drwoods,drwoods,12/Oct/10 19:13,13/Jan/11 16:45,14/Mar/19 03:03,15/Oct/10 15:19,2.0.0,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,"DataSourceFactory is basically calling ConfiguringConnectionDecorator().setQueryTimeout(conf.getQueryTimeout() * 1000); when queryTimeout > 0, but JDBCConfiguration.getQueryTimeout() already returns the value as milliseconds.  For DB2 only, this causes a -
<openjpa-2.1.0-SNAPSHOT-runknown nonfatal general error> org.apache.openjpa.persistence.PersistenceException: There were errors initializing your configuration: <openjpa-2.1.0-SNAPSHOT-runknown fatal user error> org.apache.openjpa.util.UserException: A connection could not be obtained for driver class ""com.ibm.db2.jcc.DB2Driver"" and URL ""jdbc:db2://localhost:50000/tc1"". You may have specified an invalid URL.
. . .
Caused by: java.lang.IllegalArgumentException
at java.util.Timer.schedule(Timer.java:422)
at com.ibm.db2.jcc.b.tk.a(tk.java:2088)
at com.ibm.db2.jcc.b.tk.a(tk.java:557)
at com.ibm.db2.jcc.b.tk.executeQuery(tk.java:541)
at org.apache.commons.dbcp.DelegatingStatement.executeQuery(DelegatingStatement.java:208)
at org.apache.commons.dbcp.DelegatingStatement.executeQuery(DelegatingStatement.java:208)
at org.apache.openjpa.lib.jdbc.DelegatingStatement.executeQuery(DelegatingStatement.java:131)
at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingStatement.executeQuery(LoggingConnectionDecorator.java:950)
at org.apache.openjpa.lib.jdbc.DelegatingStatement.executeQuery(DelegatingStatement.java:129)
at org.apache.openjpa.lib.jdbc.DelegatingStatement.executeQuery(DelegatingStatement.java:118)
at org.apache.openjpa.jdbc.sql.DB2Dictionary.connectedConfiguration(DB2Dictionary.java:282)
at org.apache.openjpa.jdbc.sql.DBDictionary.decorate(DBDictionary.java:4784)
at org.apache.openjpa.jdbc.sql.DB2Dictionary.decorate(DB2Dictionary.java:263)
at org.apache.openjpa.lib.jdbc.DecoratingDataSource.decorate(DecoratingDataSource.java:118)
at org.apache.openjpa.lib.jdbc.DecoratingDataSource.getConnection(DecoratingDataSource.java:113)
at org.apache.openjpa.jdbc.schema.DataSourceFactory.installDBDictionary(DataSourceFactory.java:239)
... 42 more
Caused by: java.lang.RuntimeException: There were errors initializing your configuration: <openjpa-2.1.0-SNAPSHOT-runknown fatal user error> org.apache.openjpa.util.UserException: A connection could not be obtained for driver class ""com.ibm.db2.jcc.DB2Driver"" and URL ""jdbc:db2://localhost:50000/tc1"". You may have specified an invalid URL.
at org.apache.openjpa.jdbc.schema.DataSourceFactory.newConnectException(DataSourceFactory.java:261)
at org.apache.openjpa.jdbc.schema.DataSourceFactory.installDBDictionary(DataSourceFactory.java:247)
at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getConnectionFactory(JDBCConfigurationImpl.java:731)
. . .
Caused by: java.lang.IllegalArgumentException
at java.util.Timer.schedule(Timer.java:422)
at com.ibm.db2.jcc.b.tk.a(tk.java:2088)
at com.ibm.db2.jcc.b.tk.a(tk.java:557)
at com.ibm.db2.jcc.b.tk.executeQuery(tk.java:541)
at org.apache.commons.dbcp.DelegatingStatement.executeQuery(DelegatingStatement.java:208)
at org.apache.commons.dbcp.DelegatingStatement.executeQuery(DelegatingStatement.java:208)
at org.apache.openjpa.lib.jdbc.DelegatingStatement.executeQuery(DelegatingStatement.java:131)
. . .
",,,,,,,,,,,,,,,,,,,12/Oct/10 19:15;drwoods;OPENJPA-1831.diff;https://issues.apache.org/jira/secure/attachment/12456996/OPENJPA-1831.diff,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-01-13 16:45:41.872,,,no_permission,,,,,,,,,,,,162068,,,Thu Jan 13 16:45:41 UTC 2011,,,Patch Available,,,,0|i0z95r:,203786,,,,,,,,13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,,,,,,,,,,,,,,,,,,,,,,,,,,
Deserialization of EMF causes connectionPassword to be overwritten with Value.INVISIBLE,OPENJPA-1830,12477048,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,drwoods,drwoods,11/Oct/10 18:05,13/Jan/11 16:45,14/Mar/19 03:03,11/Oct/10 21:47,2.0.0,,,,,,,,2.1.0,,,,,,,,,0,,,,,,,,"ConfigurationImpl.writeExternal() serializes out the toProperties() and Map _props, which both contain the connectionPassword.  When readExternal() deserializes, the StringValue of connectionPassword gets its value set twice, which causes Value.INVISIBLE to get set as the value, which never happens if the EMF is never serialized.
",,,,,,,,,,OPENJPA-1764,,,,,,,,,11/Oct/10 19:51;drwoods;OPENJPA-1830.diff;https://issues.apache.org/jira/secure/attachment/12456886/OPENJPA-1830.diff,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-01-13 16:45:41.486,,,no_permission,,,,,,,,,,,,162067,,,Thu Jan 13 16:45:41 UTC 2011,,,Patch Available,,,,0|i0z953:,203783,,,,,,,,"11/Oct/10 18:09;drwoods;causing junit test failures due to new surefire setup, where we're setting openjpa.ConnectionPassword instead of passing it in openjpa.ConnectionProperties.","11/Oct/10 21:47;drwoods;will no longer override string values with Value.INVISIBLE of ""******"".
",13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,,,,,,,,,,,,,,,,,,,,,,,,
"Query with expression IN (collection_valued_input_parameter) should report syntax error, correct usange is  IN collection_valued_input_parameter",OPENJPA-1828,12476792,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,azuo_lee,azuo_lee,07/Oct/10 18:26,13/Jan/11 16:45,14/Mar/19 03:03,20/Oct/10 05:11,2.1.0,,,,,,,,2.1.0,,,,,,,,,0,,,,,,,,"for (int i = 0; i < 2; i ++) {
    List categories = new LinkedList();
    categories.add(""01"");
    categories.add(""02"");
    categories.add(""03"");
    Query q = entityManager.createQuery(""select v.id from Category v where v.id in (:p) order by v.id asc"");
    q.setParameter(""p"", categories);
    List results = q.getResultList();
    for (Iterator it = results.iterator(); it.hasNext(); )
         System.out.print(it.next() + "", "");
    System.out.println();
}

The above code will produce the following output:
01, 02, 03,
02, 03,

""01"" is missing when the second time the same query is executed.",openjpa-2.1.0-20101001.064809-70,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-10-18 18:00:02.492,,,no_permission,,,,,,,,,,,,162065,,,Thu Jan 13 16:45:41 UTC 2011,,,,,,,0|i0z947:,203779,,,,,,,,"18/Oct/10 18:00;fancy;1. JPA2 Spec defines the collectioin_valued_paramater usage in IN expression is:
        in_expression ::=
            {state_field_path_expression | type_discriminator} [NOT] IN
                { ( in_item {, in_item}* ) | (subquery) | collection_valued_input_parameter }

Notice that the collection_valued_input_parameter is not enclosed in parentheses.

If the input parameter is changed from ""(:p)"" to "":p"" in the query string as below, then the correct output is produced :

        ""select v.id from Category v where v.id in :p order by v.id asc""

2. Single_valued_input_parameter vs. Collection_valued_input_parameter validation was missing, which caused incorrect result
 when the second time the same query is executed.
 The fix is to validate it at runtime.
 The committed code will report ArgumentException if a single_valued_parameter is specified, but user is passing a collection value.","20/Oct/10 05:11;azuo_lee;Thanks, eliminating the enclosing parentheses solves the problem.",13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,,,,,,,,,,,,,,,,,,,,,,,,
ORDER BY will append additional column to the SELECT clause which may potentialy cause ORA-00979 error,OPENJPA-1819,12475495,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,,azuo_lee,azuo_lee,30/Sep/10 09:57,06/Jun/15 21:19,14/Mar/19 03:03,18/Oct/13 15:08,2.0.1,2.0.2,,,,,,,2.1.0,2.3.0,,,,sql,,,,0,,,,,,,,"Assuming entity Person and entity Exam has one-to-many association, the following JPQL statement:
SELECT p.id r1, p.name r2, sum(e.score) r3 FROM Exam e LEFT JOIN e.person p GROUP BY p.id, p.name ORDER BY p.id

will produce the following SQL, which is not executable if the underlining database is Oracle 9.2:
SELECT t1.id, t1.name, SUM(t0.score) AS r3, t0.person FROM exams t0, persons t1 WHERE t0.person = t1.id(+) GROUP BY t1.id, t1.name ORDER BY t0.person ASC

The additional column ""t0.person"" will cause error ORA-00979: not a GROUP BY expression.

The correct SQL should be:
SELECT t1.id, t1.name, SUM(t0.score) AS r3 FROM exams t0, persons t1 WHERE t0.person = t1.id(+) GROUP BY t1.id, t1.name ORDER BY t1.id ASC","OpenJPA 2.0
WebSphere 6.1
Oracle 9.2",,,,,,,,,,,,,,,,,,30/Sep/10 16:48;faywang;OPENJPA-1819.patch;https://issues.apache.org/jira/secure/attachment/12456026/OPENJPA-1819.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-09-30 16:02:18.526,,,no_permission,,,,,,,,,,,,69934,,,Fri Oct 18 15:08:15 UTC 2013,,,,,,,0|i1du0n:,288960,,,,,,,,"30/Sep/10 16:02;faywang;This apparently is not specific to Oracle. When running against DB2, the generated SQL is:

SELECT t1.id, t1.name, SUM(t0.score) AS r3, t0.person 
FROM Exam t0 
LEFT OUTER JOIN Person t1 ON t0.PERSON_ID = t1.id 
GROUP BY t1.id, t1.name ORDER BY t0.person ASC 

and DB2 throws the following exception:
com.ibm.db2.jcc.am.ro: DB2 SQL Error: SQLCODE=-119, SQLSTATE=42803, SQLERRMC=person, DRIVER=3.58.82",07/Oct/10 17:22;azuo_lee;Fixed in 2.1.0-20101001.064809-70.,13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,"13/Jun/11 16:19;azuo_lee;I'm afraid the issure is not fixed in 2.0.x versions, but i have to use OpenJPA with websphere 6.1 which does not support 2.1.x versions.",27/Jun/11 06:14;azuo_lee;Could any ASF user please copy the code that fixes this issure from trunk to branch 2.0.x ?,"18/Oct/13 15:08;struberg;This has been fixed in trunk already since quite some time.

Azuo, if you still have this problem in the old WebSphere version you reported it for, then I suggest creating a PMR for it and let IBM deal with it (with a pointer to this JIRA). ",,,,,,,,,,,,,,,,,,,,,
JPQL fails with Group By and Having aggregate_expression IN (subquery),OPENJPA-1814,12475061,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,faywang,faywang,24/Sep/10 18:15,12/Jan/11 23:11,14/Mar/19 03:03,12/Jan/11 23:11,1.2.2,2.1.0,,,,,,,1.2.3,1.3.0,2.0.2,2.1.0,,kernel,,,,0,,,,,,,,"The following JPQL fail:

    	String jpql = ""SELECT a.uuid from EntityA a WHERE a.name = 'test' "" + 
    	    ""GROUP BY a.date1, a.uuid "" +

(1)    ""HAVING MAX(a.date1) IN (SELECT MAX(a1.date2) from EntityA a1 WHERE a1.name = 'test') "";
(2)    ""HAVING MAX(a.date1) = (SELECT MAX(a1.date2) from EntityA a1 WHERE a1.name = 'test') "";

org.apache.openjpa.persistence.ArgumentException: Encountered ""MAX ( a .date1) IN"" at character 168, but expected: [""("", "")"", ""*"", ""+"", ""-"", ""."", ""/"", "":"", ""<"", ""<="", ""<>"", ""="", "">"", "">="", ""?"", ""ABS"", ""ALL"", ""AND"", ""ANY"", ""AS"", ""ASC"", ""AVG"", ""BETWEEN"", ""BOTH"", ""BY"", ""CONCAT"",""COUNT"", ""CURRENT_DATE"", ""CURRENT_TIME"", ""CURRENT_TIMESTAMP"", ""DELETE"", ""DESC"", ""DISTINCT"", ""EMPTY"", ""ESCAPE"", ""EXISTS"", ""FETCH"", ""FROM"", ""GROUP"", ""HAVING"", ""IN"", ""INNER"", ""IS"", ""JOIN"", ""LEADING"", ""LEFT"",""LENGTH"", ""LIKE"", ""LOCATE"", ""LOWER"", ""MAX"", ""MEMBER"", ""MIN"", ""MOD"",""NEW"", ""NOT"", ""NULL"", ""OBJECT"", ""OF"", ""OR"", ""ORDER"", ""OUTER"", ""SELECT"",
""SET"", ""SIZE"", ""SOME"", ""SQRT"", ""SUBSTRING"", ""SUM"", ""TRAILING"", ""TRIM"",""UPDATE"", ""UPPER"", ""WHERE"", <BOOLEAN_LITERAL>, <DECIMAL_LITERAL>,<IDENTIFIER>, <INTEGER_LITERAL>, <STRING_LITERAL>].
 at org.apache.openjpa.kernel.jpql.JPQL.generateParseException(JPQL.java:9566)
 at org.apache.openjpa.kernel.jpql.JPQL.jj_consume_token(JPQL.java:9443)
 at org.apache.openjpa.kernel.jpql.JPQL.conditional_primary(JPQL.java:1947)
 at org.apache.openjpa.kernel.jpql.JPQL.conditional_factor(JPQL.java:1925)
 at org.apache.openjpa.kernel.jpql.JPQL.conditional_term(JPQL.java:1791)

The fix involves two changes:
(1) jjt grammar change
(2) OpenJPA performs a preliminary validation to ensure the expression in the having clause is included in the group-by list. However, this validation checking should be done only on the LHS of the having clause (see expr1 below), not on the RHS (see expr2 below).  For example:

     Having expr1 = expr2

Only expr1 should be in the group-by list

The current visitor pattern can not tell which node to visit without massive change. The alternative is to disable the checking by OpenJPA and let the backend to determine whether the generated SQL is valid or not.


 
",Fix committed to trunk at revision #1002419.,,,,,,,,,,,,,OPENJPA-712,,,,,30/Sep/10 16:19;jpaheath;OPENJPA-1814-1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12456024/OPENJPA-1814-1.2.x.patch,24/Sep/10 19:07;faywang;OPENJPA-1814-1.patch;https://issues.apache.org/jira/secure/attachment/12455511/OPENJPA-1814-1.patch,28/Sep/10 18:53;fancy;OPENJPA-1814-2.patch;https://issues.apache.org/jira/secure/attachment/12455865/OPENJPA-1814-2.patch,24/Sep/10 18:32;faywang;OPENJPA-1814.patch;https://issues.apache.org/jira/secure/attachment/12455509/OPENJPA-1814.patch,,,,,,,,,4.0,,,,,,,,,,,,,,,,,,,2010-09-28 18:53:52.986,,,no_permission,,,,,,,,,,,,162054,,,Thu Sep 30 16:19:40 UTC 2010,,,,,,,0|i0z3wn:,202935,,,,,,,,24/Sep/10 19:07;faywang;clean up the patch,"28/Sep/10 18:53;fancy;In JPA Spec, aggregate expression is not allowed in the IN expression. The EBNF  In Section 2.4.9 of JPA spec:

 in_expression ::=
{state_field_path_expression | type_discriminator} [NOT] IN 
{ ( in_item {, in_item}* ) | (subquery) | collection_valued_input_parameter }

Therefore, the following JPQL results in syntax error:

SELECT c5.uuid
FROM pcs.common.fleet.CarLocationMessage c5
WHERE c5.railCarNumber = UPPER(:carNumber) and c5.clmArchived = false 
GROUP BY c5.sightDate, c5.uuid
HAVING MAX(c5.sightDate) IN (SELECT MAX(c6.sightDate) from pcs.common.fleet.CarLocationMessage c6 WHERE c6.railCarNumber = UPPER(:carNumber) and c6.clmArchived = false)

The above JPQL can be rewritten to use EQUAL comparison as below:

SELECT c5.uuid
FROM pcs.common.fleet.CarLocationMessage c5
WHERE c5.railCarNumber = UPPER(:carNumber) and c5.clmArchived = false 
GROUP BY c5.sightDate, c5.uuid
HAVING MAX(c5.sightDate) = (SELECT MAX(c6.sightDate) from pcs.common.fleet.CarLocationMessage c6 WHERE c6.railCarNumber = UPPER(:carNumber) and c6.clmArchived = false)

However, it still requires OPENJPA-1814-2.patch to overcome another problem in OpenJPA.
We have a rather restrictive rules for validating having/grouping clause, the patch is to avoid having/grouping validation if conditional expression involving a subquery.
In such cases, the having/grouping rules will be enforced by the backend DBMSs. Any violation would result in SQLException and would be considered as an user error.",28/Sep/10 23:43;fancy;OPENJPA-1814-2.patch committed to trunk at revision #1002419.,"30/Sep/10 16:19;jpaheath;I'm providing a patch (OPENJPA-1814-1.2.x.patch) which is for 1.2.x and it a ""backport"" of OPENJPA-1814-2.patch.

Thanks,

Heath",,,,,,,,,,,,,,,,,,,,,,,
Dynamic load of enhancer agent on Mac OS X fails,OPENJPA-1811,12474858,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,wboyce@panix.com,drwoods,22/Sep/10 19:54,13/Jan/11 16:45,14/Mar/19 03:03,22/Sep/10 20:41,2.0.0,,,,,,,,2.1.0,,,,,Enhance,UnenhancedClasses,,,0,,,,,,,,"Splitting out this item from OPENJPA-1804.
The dynamic loading of the enhancer agent on Mac OS X w/ Java 1.6.0 fails due to the packaging differences on the Mac, where instead of a tools.jar, there is a 1.6.0/Classes/classes.jar that we should be using instead.
",Mac,,,,,,,,,,,,,OPENJPA-1804,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-09-22 20:39:59.474,,,no_permission,,,,,,,,,,,,162051,,,Thu Jan 13 16:45:39 UTC 2011,,,,,,,0|i0z8mn:,203700,,,,,,,,"22/Sep/10 20:39;drwoods;Before fix -
768  db  TRACE  [main] openjpa.Enhance - org.apache.openjpa.enhance.InstrumentationFactorygetInstrumentation() _disabled: _inst:null_dynamicallyInstall:true
768  db  TRACE  [main] openjpa.Enhance - org.apache.openjpa.enhance.InstrumentationFactory.findToolsJar() -- couldn't find /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Home/lib/tools.jar
769  db  WARN   [main] openjpa.Enhance - Creating subclass for ""[class openjpatest.Group, class openjpatest.Organization, class openjpatest.AddressBook]"". This means that your application will be less efficient and will consume more memory than it would if you ran the OpenJPA enhancer. Additionally, lazy loading will not be available for one-to-one and many-to-one persistent attributes in types using field access; they will be loaded eagerly instead.


After fix -
64  db  TRACE  [main] openjpa.Runtime - org.apache.openjpa.enhance.InstrumentationFactory.getInstrumentation() _inst:null _dynamicallyInstall:true
66  db  TRACE  [main] openjpa.Runtime - org.apache.openjpa.enhance.InstrumentationFactory.findToolsJar() -- couldn't find default /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Home/lib/tools.jar
66  db  TRACE  [main] openjpa.Runtime - org.apache.openjpa.enhance.InstrumentationFactory.findToolsJar() -- found /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Classes/classes.jar
. . .
1537  db  INFO   [main] openjpa.Enhance - Creating subclass and redefining methods for ""[class openjpatest.Group, class openjpatest.Organization]"". This means that your application will be less efficient than it would if you ran the OpenJPA enhancer.
",22/Sep/10 20:41;drwoods;Committed revision 1000209.,"23/Sep/10 10:14;wboyce@panix.com;Thanks for fixing this!

I noticed that the log message says that OpenJPA will still produce subclasses for the attach API enhancer.  Is the attach API enhancer unable to actually modify the classes being loaded?","23/Sep/10 10:16;wboyce@panix.com;Definitely confused by log message 1537 since the docs say that the log message will be:

OpenJPA dynamically loaded the class enhancer. Any classes that were not enhanced at build time will be enhanced when they are loaded by the JVM.
","23/Sep/10 12:52;drwoods;This is due to the persistence.xml not listing all of the classes.  The Javaagent loaded enhancer and Dynamically loaded enhancer behave the same, in that when a <class> list is provided, then only those classes will get pre-enhanced.
    http://openjpa.apache.org/builds/latest/docs/manual/manual.html#ref_guide_pc_enhance_runtime
    Section 2.3 - ""If you declare a persistent class list, OpenJPA will only search for metadata for classes in that list. ""
I'll add the same note to Section 2.4 using OPENJPA-1804.

Once I added the other 2 classes to the persistence.xml so they were all listed -
        <class>openjpatest.AddressBook</class>
        <class>openjpatest.Group</class>
        <class>openjpatest.Organization</class>
        <class>openjpatest.EmailAddress</class>
        <class>openjpatest.HostName</class>
then your expected behavior appears -
. . .
79  db  TRACE  [main] openjpa.Runtime - org.apache.openjpa.enhance.InstrumentationFactory.getInstrumentation() _inst:null _dynamicallyInstall:true
82  db  TRACE  [main] openjpa.Runtime - org.apache.openjpa.enhance.InstrumentationFactory.findToolsJar() -- couldn't find default /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Home/lib/tools.jar
83  db  TRACE  [main] openjpa.Runtime - org.apache.openjpa.enhance.InstrumentationFactory.findToolsJar() -- found /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Classes/classes.jar
. . .
210  db  TRACE  [main] openjpa.MetaData - Found 5 classes with metadata in 7 milliseconds.
216  db  TRACE  [main] openjpa.MetaData - Clearing metadata repository ""org.apache.openjpa.meta.MetaDataRepository@761eec35"".
707  db  INFO   [main] openjpa.Runtime - OpenJPA dynamically loaded the class enhancer. Any classes that were not enhanced at build time will be enhanced when they are loaded by the JVM.
. . .
1588  db  WARN   [main] openjpa.Enhance - An exception was thrown while attempting to perform class file transformation on ""openjpatest/Group"":
<openjpa-2.1.0-SNAPSHOT-r422266:999559M fatal user error> org.apache.openjpa.util.MetaDataException: Errors encountered while resolving metadata.  See nested exceptions for details.
. . .
Caused by: <openjpa-2.1.0-SNAPSHOT-r422266:999559M nonfatal user error> org.apache.openjpa.util.MetaDataException: No metadata was found for type ""class java.lang.Object"". The class is not enhanced.
. . .
",13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,,,,,,,,,,,,,,,,,,,,,
ClassCastException when using QueryCache and Criteria API,OPENJPA-1810,12474721,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,curtisr7,curtisr7,21/Sep/10 16:41,08/Dec/10 17:00,14/Mar/19 03:03,04/Nov/10 21:06,2.0.1,2.1.0,,,,,,,2.1.0,,,,,datacache,,,,0,,,,,,,,"I found a ClassCastException when using the COUNT function, the criteria API, and the QueryCache is  enabled. I'll post a simple unit test shortly.

<openjpa-2.1.0-SNAPSHOT-r422266:984243 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Failed to execute query ""null"". Check the query syntax for correctness. See nested exception for details.
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:870)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:792)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:288)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302)
	at org.apache.openjpa.persistence.QueryImpl.getSingleResult(QueryImpl.java:326)
	at org.apache.openjpa.persistence.criteria.TestCriteria.testCount(TestCriteria.java:267)
....
Caused by: java.lang.ClassCastException: org.apache.openjpa.util.IntId incompatible with [Ljava.lang.Object;
	at org.apache.openjpa.datacache.QueryCacheStoreQuery$CachedList.get(QueryCacheStoreQuery.java:509)
	at org.apache.openjpa.lib.rop.ListResultObjectProvider.getResultObject(ListResultObjectProvider.java:55)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.getResultObject(QueryImpl.java:2073)
	at org.apache.openjpa.kernel.QueryImpl.singleResult(QueryImpl.java:1325)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1237)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1005)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:861)
	... 28 more

",,,,,,,,,,,,,,,,,,,21/Sep/10 16:42;curtisr7;OPENJPA-1810.test.patch;https://issues.apache.org/jira/secure/attachment/12455159/OPENJPA-1810.test.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162050,,,Tue Sep 21 16:42:36 UTC 2010,,,,,,,0|i0z3xb:,202938,,,,,,,,21/Sep/10 16:42;curtisr7;Attaching unit test.,,,,,,,,,,,,,,,,,,,,,,,,,,
Refresh of versioned entity locked with pessimistic locking throws incorrect exception,OPENJPA-1809,12474715,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,21/Sep/10 16:17,13/Jan/11 16:45,14/Mar/19 03:03,21/Sep/10 20:31,2.0.0,2.0.1,2.1.0,,,,,,2.1.0,,,,,,,,,0,,,,,,,,"Attempting to call em.refresh(), using javax.persistence.lock.timeout value on a locked versioned entity results in a non-fatal OptimisticLockException.  Instead, a non-fatal LockTimeoutException should be thrown by OpenJPA.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-01-13 16:45:36.653,,,no_permission,,,,,,,,,,,,162049,,,Thu Jan 13 16:45:36 UTC 2011,,,,,,,0|i0z8lb:,203694,,,,,,,,13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,,,,,,,,,,,,,,,,,,,,,,,,,,
Can NOT find meta class & can NOT insert record in the table,OPENJPA-1808,12474682,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,lilisacat,lilisacat,21/Sep/10 09:56,25/Oct/10 06:31,14/Mar/19 03:03,25/Oct/10 06:31,2.0.1,,,,,,,,,,,,,,,,,0,,,,,,,,"Hi,
    I wrote a jpa 2.0 test case.
    In the entity class Course.java:
    @ElementCollection
    @CollectionTable(name=""COURSE_COMMENTS"")
    private List<Evaluation> evaluation;

    Here member ""evaluation"" contains comments of the course in another Table:COURSE_COMMENT

    I run it on Geronimo 3.0 server(Geronimo server uses openjpa to provide its jpa service), howver, inserting record into the Table ""COURSE"" is NOT sucessful.
 
    The server gives warning such like this:
  WARN   [DefaultThreadPool 198] openjpa.MetaData - Meta class
  ""org.apache.geronimo.javaee6.jpa20.entities.Course_"" for entity class org.apach
 e.geronimo.javaee6.jpa20.entities.Course can not be registered with following ex
 ception ""java.security.PrivilegedActionException: java.lang.ClassNotFoundExcepti
  on: org.apache.geronimo.javaee6.jpa20.entities.Course_""

   Also can Not find meta class Evaluation_

   I'm not sure whether it is a problem created by OpenJPA?

    Could anyone help to have a look at it?
    Thanks in advance!

PS: I attached the code in the attachment.","Windows 7,  Geronimo server",,,,,,,,,,,,,,,,,,21/Sep/10 09:58;lilisacat;jpa2.0.zip;https://issues.apache.org/jira/secure/attachment/12455129/jpa2.0.zip,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-09-21 16:32:30.127,,,no_permission,,,,,,,,,,,,162048,,,Mon Oct 25 06:31:05 UTC 2010,,,Patch Available,,,,0|i0z8db:,203658,,,,,,,,"21/Sep/10 16:32;mikedd;Hi, 

I think you need to generate the metamodel classes for your entities [1] (specifically the Course entity), I don't see them included in the zip file you attached. 
 [1] http://openjpa.apache.org/builds/latest/docs/manual/manual.html#d0e11094

The zip file was a bit confusing too, it's compressed using 7zip's algorithm - could you rename the extension to .7z to indicate that? 

","11/Oct/10 03:30;lilisacat;Hi Michael,
    Thanks for your suggestion.
    I have no idea how to generate the metamodel classes in maven *.pom file?","12/Oct/10 00:50;mikedd;I think you can add the -A option as a compiler argument to the maven-compiler-plugin.

Or you can take a look at the openbooks example in SVN. It uses the antrun plugin and an ant build file to generate the canonical metamodel classes.

Here are links to the pom.xml and build.xml we use in openbooks: 

http://svn.apache.org/viewvc/openjpa/trunk/openjpa-examples/openbooks/pom.xml?revision=981587&view=markup
http://svn.apache.org/viewvc/openjpa/trunk/openjpa-examples/openbooks/build.xml?revision=980894&view=markup

Hope they help you get started. ","25/Oct/10 06:31;lilisacat;Hi,Michael,
    The problem is resolved.Thanks a lot!",,,,,,,,,,,,,,,,,,,,,,,
CacheStatistics misses are improperly calculated.,OPENJPA-1801,12474323,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,16/Sep/10 21:11,09/Nov/10 14:59,14/Mar/19 03:03,05/Oct/10 21:14,2.0.1,2.1.0,,,,,,,2.1.0,,,,,datacache,,,,0,,,,,,,,"In doing some testing I found that the DataCache statistics aren't calculated properly. In the case where there is a cache miss for a specific Type(Person.class), a miss (a read with no subsequent hit) is recorded for java.lang.Object.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-10-05 21:49:13.978,,,no_permission,,,,,,,,,,,,162042,,,Fri Oct 29 15:50:50 UTC 2010,,,,,,,0|i0z8tr:,203732,,,,,,,,"05/Oct/10 21:14;curtisr7;Committed changes to trunk. First off, this is a pretty major refactor and cache statistics collection isn't 100% yet. Unfortunately I don't have the time to test this as thoroughly as I would like. This is a step in the right direction and is more correct that the previous implementation, but it is still incomplete.","05/Oct/10 21:49;ppoddar@apache.org;from JavaDoc of CacheStatistics

 * All methods with Class as input argument treats null as 
 * <code>java.lang.Object</code>. All per-class statistics  depends on 
 * determining the runtime type of the instance being cached. If it is not
 * possible to determine the runtime type from the given context, the statistics
 * is registered under generic <code>java.lang.Object</code>. 
 * 
 * @since 1.3.0
","06/Oct/10 13:22;curtisr7;@Pinaki -

I came across that javadoc after I opened this JIRA, but I think in the code that I replaced we could have determined done a better job at determining the runtime type that was being cached. Either way I think we're in a better place than what we were.

I'm not sure if you looked at the changes I made, but from a high level I moved statistics calculation from the DataCache level up to the (DataCache)StoreManager level. I did this because only the StoreManager knows when a hit is really a hit. ",29/Oct/10 15:50;curtisr7;The last commit for this JIRA(1028808) is actually for OPENJPA-1844.,,,,,,,,,,,,,,,,,,,,,,,
Duplicate column created for sybase,OPENJPA-1800,12474312,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,16/Sep/10 19:36,21/Sep/10 21:23,14/Mar/19 03:03,21/Sep/10 21:15,2.0.0,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,"In order to execute FOR UPDATE statements against Sybase we create a special column named UNQ_INDEX.

Some of our schema tools cause the column to be inserted twice (in memory). I've seen this happen with testcases which use the DROP_TABLES constant - but any code that uses the following persistence property could see the same behavior :
openjpa.jdbc.SynchronizeMappings=buildSchema(ForeignKeys=true,SchemaAction='drop,add')",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162041,,,2010-09-16 19:36:03.0,,,,,,,0|i1du2f:,288968,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Result of aggregate function MAX is 0 on empty table (instead of NULL).,OPENJPA-1794,12474154,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,oakjumper,oakjumper,15/Sep/10 09:07,21/Sep/16 14:38,14/Mar/19 03:03,17/Oct/13 22:32,2.0.0,,,,,,,,2.0.2,2.1.2,2.2.1.1,2.2.3,2.3.0,query,,,,1,,,,,,,,"Below is a snippet of a test case... the max should be null, but is zero.

            Object count = em.createQuery(""Select count(p.pk) from Entity1 p where 1=1"").getSingleResult();
            Object max = em.createQuery(""Select max(p.pk) from Entity1 p where 1=1"").getSingleResult();
            System.out.println(""count:""+count+ "" max:""+max);

            > count:0 max:0
",,,,,,,,,,,,,,,,,,,23/Jul/13 15:41;techhusky;OPENJPA-1794.patch;https://issues.apache.org/jira/secure/attachment/12593711/OPENJPA-1794.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-09-15 13:48:59.16,,,no_permission,,,,,,,,,,,,162036,,,Wed Sep 10 15:17:36 UTC 2014,,,,,,,0|i1du3b:,288972,,,,,,,,"15/Sep/10 13:48;curtisr7;Per the spec : 
> If SUM, AVG, MAX, or MIN is used, and there are no values to which the aggregate function can be applied, the result of the aggregate function is NULL.

Something else to muddy the waters....
> The Java type that is contained in the result of a query using an aggregate function is as follows:
> ...
> *MAX, MIN return the type of the state field to which they are applied.

In the example detailed above, lets say the p.pk field is a primitive long... A NULL primitive is zero so in that case, it would appear that we are working properly. If p.pk is a java.lang.Long, we are not.",17/Sep/10 14:17;oakjumper;it's 0 for Integer field.,28/May/13 09:37;jensleisenberg;I'm still able to reproduce this problem. Is it planned to fix it for the current release?,23/Jul/13 15:41;techhusky;Attaching patch for 2.1.x branch for review.  I will be committing the fix to trunk soon.,"23/Jul/13 18:26;jira-bot;Commit 1506198 from [~techhusky] in branch 'openjpa/trunk'
[ https://svn.apache.org/r1506198 ]

OPENJPA-1794 aggregate function with no result set must return null","04/Oct/13 17:58;jira-bot;Commit 1529241 from [~jpaheath] in branch 'openjpa/branches/2.1.x'
[ https://svn.apache.org/r1529241 ]

OPENJPA-1794: Return null, rather than 0, on MAX function - back ported to 2.1.x Jeremy Bauer's commit to trunk.","04/Oct/13 19:15;jira-bot;Commit 1529267 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1529267 ]

OPENJPA-1794: Return null, rather than 0, on MAX function - back ported to 2.2.1.x Jeremy Bauer's commit to trunk.","04/Oct/13 19:35;jira-bot;Commit 1529273 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1529273 ]

OPENJPA-1794: Return null, rather than 0, on MAX function - back ported to 2.2.x Jeremy Bauer's commit to trunk.","04/Oct/13 22:41;jira-bot;Commit 1529340 from [~jpaheath] in branch 'openjpa/branches/2.2.1.x'
[ https://svn.apache.org/r1529340 ]

OPENJPA-1794: Return null, rather than 0, on MAX function - fixed previous 2.2.1.x commit.","04/Oct/13 22:56;jira-bot;Commit 1529343 from [~jpaheath] in branch 'openjpa/branches/2.2.x'
[ https://svn.apache.org/r1529343 ]

OPENJPA-1794: Return null, rather than 0, on MAX function - fixed previous 2.2.x commit.","10/Sep/14 15:17;jira-bot;Commit 1624026 from [~jpaheath] in branch 'openjpa/branches/2.0.x'
[ https://svn.apache.org/r1624026 ]

OPENJPA-1794: Return null, rather than 0, on MAX function - back ported to 2.0.x Jeremy Bauer's commit to trunk.",,,,,,,,,,,,,,,,
@EmbeddedId class having only one field java.sql.Data,OPENJPA-1793,12474032,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jpaheath,hiroyuki,hiroyuki,14/Sep/10 06:16,26/Oct/10 20:15,14/Mar/19 03:03,26/Oct/10 20:15,2.0.2,2.1.0,,,,,,,2.0.2,2.1.0,,,,jdbc,,,,0,,,,,,,,"@EmbeddedId class having only one field java.sql.Data

I become the error such as follows.

---------------------
Exception in thread ""main"" <openjpa-2.0.1-r422266:989424 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Failed to execute query ""SELECT m FROM Mzeiritsu m WHERE m.key.tekiyoKaishiYmd = (SELECT MAX(m2.key.tekiyoKaishiYmd) FROM Mzeiritsu m2 WHERE m2.key.tekiyoKaishiYmd < '2010-08-01')"". Check the query syntax for correctness. See nested exception for details.
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:870)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:792)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:288)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302)
	at itso.bank.entities.test.EntityTester.main(EntityTester.java:40)
Caused by: java.lang.ClassCastException: [Ljava.lang.Object; incompatible with java.util.Calendar
	at org.apache.openjpa.jdbc.sql.ResultSetResult.getObjectInternal(ResultSetResult.java:431)
	at org.apache.openjpa.jdbc.sql.AbstractResult.getObject(AbstractResult.java:696)
	at org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy.getPrimaryKeyValue(HandlerFieldStrategy.java:315)
	at org.apache.openjpa.jdbc.meta.ClassMapping.getObjectId(ClassMapping.java:187)
	at org.apache.openjpa.jdbc.meta.ClassMapping.getObjectId(ClassMapping.java:146)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.load(JDBCStoreManager.java:1020)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:280)
	at org.apache.openjpa.jdbc.sql.SelectImpl$SelectResult.load(SelectImpl.java:2344)
	at org.apache.openjpa.jdbc.sql.AbstractResult.load(AbstractResult.java:274)
	at org.apache.openjpa.jdbc.kernel.InstanceResultObjectProvider.getResultObject(InstanceResultObjectProvider.java:59)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:36)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1246)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1005)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:861)
	... 5 more
---------------------

315th line of HandlerFieldStrategy class 
field.getHandler().getResultArgument(field) 
The return value of the method  is object array.

Therefore an error occurs at a 431th line of ResultSetResult.

---------------------
[org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy]
    ....
    public Object getPrimaryKeyValue(Result res, Column[] cols, ForeignKey fk,
        JDBCStore store, Joins joins)
        throws SQLException {
        Column col;
        Object val = null;
        if (cols.length == 1) {
            col = cols[0];
            if (fk != null)
                col = fk.getColumn(col);
            val = res.getObject(col, field.getHandler().
                getResultArgument(field), joins);
        } else if (cols.length > 1) {
            Object[] vals = new Object[cols.length];
            Object[] args = (Object[]) field.getHandler().
                getResultArgument(field);
            for (int i = 0; i < vals.length; i++) {
                col = cols[i];
                if (fk != null)
                    col = fk.getColumn(col);
                vals[i] = res.getObject(col, (args == null) ? null : args[i],
                    joins);
            }
            val = vals;
        }
        return field.getHandler().toObjectValue(field, val);
    }

    ....
---------------------
---------------------
[org.apache.openjpa.jdbc.sql.ResultSetResult]
    ....
            case JavaSQLTypes.SQL_DATE:
                return getDateInternal(obj, (Calendar) arg, joins);
    ....
---------------------
",,,,,,,,,,,,,,,,,,,18/Oct/10 20:59;jpaheath;OPENJPA-1793-2.0.x.patch;https://issues.apache.org/jira/secure/attachment/12457480/OPENJPA-1793-2.0.x.patch,18/Oct/10 20:59;jpaheath;OPENJPA-1793-trunk.patch;https://issues.apache.org/jira/secure/attachment/12457479/OPENJPA-1793-trunk.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-10-14 21:21:40.083,,,no_permission,,,,,,,,,,,,162035,,,Tue Oct 26 20:15:44 UTC 2010,,,Patch Available,,,,0|i1du3j:,288973,,,,,,,,"14/Oct/10 21:21;jpaheath;I'm providing a patch for 2.0.x named OPENJPA-1793-2.0.x.patch which fixes this issue.  The fix consist of an update to HandlerFieldStrategy (HFS).  Basically, the method 'getPrimaryKeyValue' in HFS contains this 'if' block:

        if (cols.length == 1) {
            col = cols[0];
            if (fk != null)
                col = fk.getColumn(col);
            val = res.getObject(col, field.getHandler().
                getResultArgument(field), joins);
        } else if (cols.length > 1) {


The call to 'field.getHandler().getResultArgument(field)' is a problem because in most cases an Object array will be returned where the first element is 'null'.  This 'null' Object array eventually makes it way to 'ResultSetResult.getObjectInternal':

            case JavaSQLTypes.SQL_DATE:
                return getDateInternal(obj, (Calendar) arg, joins);

As you can see, we'd attempt to cast the Object array to a Calendar, thus resulting in a ClassCastException.  
The patch also contains an addition to an existing test case.  The test consists of an @Embeddable which only contains one field which is a Date object.  If I add a second field to the Embeddable object, all works fine, so the key here is to have only one column/field in the Embeddable.

Thanks,

Heath

","15/Oct/10 03:26;hiroyuki;Heath, thanks for the patch.","18/Oct/10 20:59;jpaheath;I'm providing a patch, named OPENJPA-1793-trunk.patch, for trunk.

Thanks,

Heath",26/Oct/10 16:29;drwoods;applied to 2.0.x as r1027632,26/Oct/10 20:15;drwoods;applied to trunk as r1027722,,,,,,,,,,,,,,,,,,,,,,
Problem in Firebird 2.1  with sequence creation,OPENJPA-1788,12473829,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,diegocattelan,diegocattelan,10/Sep/10 17:23,20/Sep/10 14:24,14/Mar/19 03:03,10/Sep/10 22:45,2.0.0,2.0.1,2.0.2,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,"Create a simple entity

@Entity
public class ana_anagrafica implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id;

    @SequenceGenerator(name=""ANA_ANAGRAFICA_GEN"")
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE,generator=""ANA_ANAGRAFICA_GEN"")
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }
} 

in the sequence creation the SQL returned from FirebirdDictionary is wrong,
method

@Override
    protected String getSequencesSQL(DBIdentifier schemaName, DBIdentifier sequenceName) {
        StringBuilder buf = new StringBuilder(sequenceSQL);
        if (sequenceName != null)
            buf.append(sequenceNameSQL);
        return buf.toString();
    } 

should be

@Override
    protected String getSequencesSQL(DBIdentifier schemaName, DBIdentifier sequenceName) {
        StringBuilder buf = new StringBuilder(sequenceSQL);
        if(!DBIdentifier.isNull(sequenceName)){
            buf.append(sequenceNameSQL);
        }
        return buf.toString();
    } ","FirebirdSQL 2.1.3
jaybird 2.1.6",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162030,,,2010-09-10 17:23:17.0,,,,,,,0|i0z3w7:,202933,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bean validation fails merging a new entity,OPENJPA-1787,12473823,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,techhusky,oringel,oringel,10/Sep/10 16:23,15/Oct/12 18:24,14/Mar/19 03:03,16/Mar/11 18:52,2.0.1,2.1.0,2.2.0,,,,,,2.1.1,2.2.0,,,,jpa,kernel,,,0,,,,,,,,"The bean validation is not working correctly

If you try to merge a new entity.

        EntityManager em = entityManagerFactory.createEntityManager();
        Person person = new Person();
        person.setName(""Oliver"");                               // Employee.name is annotated @NotNull 
        person = em.merge(person);                            

you get a ConstraintValidationException, although name is set. 

",,,,,,,,,,,,,,,,,,,11/Mar/11 03:53;techhusky;OPENJPA-1787_2.1.x.patch;https://issues.apache.org/jira/secure/attachment/12473363/OPENJPA-1787_2.1.x.patch,11/Mar/11 17:29;techhusky;OPENJPA-1787_jUnits_2.1.x.patch;https://issues.apache.org/jira/secure/attachment/12473408/OPENJPA-1787_jUnits_2.1.x.patch,14/Sep/10 08:15;oringel;com.example.TestEmployeeDAO.txt;https://issues.apache.org/jira/secure/attachment/12454528/com.example.TestEmployeeDAO.txt,10/Sep/10 16:28;oringel;openjpa-1787.tar;https://issues.apache.org/jira/secure/attachment/12454309/openjpa-1787.tar,02/Mar/11 18:30;oringel;testcase-openjpa-1787.tar;https://issues.apache.org/jira/secure/attachment/12472438/testcase-openjpa-1787.tar,,,,,,,,5.0,,,,,,,,,,,,,,,,,,,2010-09-13 12:56:05.408,,,no_permission,,,,,,,,,,,,162029,,,Mon Oct 15 18:24:45 UTC 2012,,,,,,,0|i09zxz:,56264,,,,,,,,10/Sep/10 16:28;oringel;Here is a testcase.,"13/Sep/10 12:56;drwoods;Can you provide more details about your application and environment?  You marked affects 2.0.1 and 2.1.0, so which jars are you using?  The openjpa-2.x.x.jar does not include the BVAL API or implementation.  If you grab the latest openjpa-all-2.1.0-SNAPSHOT.jar then that includes the Apache Geronimo Validation API and Apache Bean Validation implementation.","13/Sep/10 13:04;drwoods;So after looking at your example, I'm not sure why you opened a JIRA....
You're using Hibernate Validator 4.0.2.GA, which we support.
The Employee.name is marked with @NotNull.
But in your code snippet above, you are setting the Name, so what is the behavior you're expecting?  @NotNull should only throw an exception if you didn't call setName() before trying to merge/persist the entity.....
","13/Sep/10 13:32;oringel;OK, I think I described the issue not clear enough.

As you said right, @NotNull should only throw an exception, if name is not set. 
The problem is, that I get an exception (javax.validation.ConstraintViolationException), 
although I called setName().

Using persist instead of merge is working as expected. I added added test method to 
demonstrate this.




","13/Sep/10 21:11;drwoods;Can you attach your stack trace?  I just ran into a scenario where an entity not using Validation is causing the Apache Bean Validation provider to throw an exception due to entity.hashCode() throwing a NPE....
",14/Sep/10 08:15;oringel;Here is my test output.,"02/Mar/11 18:30;oringel;A new simple testcase without dependencies to spring, etc.","02/Mar/11 19:22;oringel;I finally found the place in the source code where the data gets lost.

If you merge a new entity the BrokerImpl first tries to attach the entity via the AttachManager.
The AttachManager uses an AttachStrategy to persist the new entity. 

Here ist the code snippet from the org.apache.openjpa.kernel.AttachStrategy class with my comments

    protected StateManagerImpl persist(AttachManager manager,
        PersistenceCapable pc, ClassMetaData meta, Object appId, 
        boolean explicit) {
        PersistenceCapable newInstance;

        if (!manager.getCopyNew())
            newInstance = pc;                                                                       <--- calling this would fix the issue 
        else if (appId == null) {
            newInstance = pc.pcNewInstance(null, false);                                <--- but this is called, pc.pcNewInstance returns an new instance, person.name is set to null
	}
        else
            newInstance = pc.pcNewInstance(null, appId, false);

        return (StateManagerImpl) manager.getBroker().persist                       <-- this calls finally BrokerImpl.persistInternal(...) and fails because person.name is null  
            (newInstance, appId, explicit, manager.getBehavior());
    }

For my testcases this issue could be fixed by replacing the first if statement with ""if (manager.getCopyNew())"".
I'm absolutely not sure, if it is really that easy. I guess not.

Maybe another good place to fix the problem is EntityManagerImpl.merge() which also sets the AttachManager's copyNew flag.

Please could someone with more insight into openjpa verify this solution.
Thanks.","08/Mar/11 21:41;mikedd;The main problem with your proposed solution is that it would change the way merge works. EntityManager.merge creates a new copy of the entity and it's the copy of the entity that becomes part of the persistence context - not the entity you passed in. Your change would eliminate the copy.

I think the real issue here is that the data hasn't been copied into the new instance before validation occurs. I'm not familiar with this code path, and I haven't had a chance to try your testcase yet, but I'd start by looking at the code where we copy the fields into a new instance. ","10/Mar/11 13:43;oringel;Hi Michael,
thank you for your answer. I thought that it would not be so easy to solve this issue. Unfortunately.

I agree with you that the main problem here is that a copy action is missing and I guess AttachStrategy.persist is the right place to add some kind of copy functionality.

I started looking into the source code of the enhanced class from the test. PersistenceCapable declares a public method to copy fields (pcCopyFields(...)).
Unfortunately you can't use in AttachStrategy.persist, because the entity to persist has no statemanager at this point (an exception InvalidStateException will be the result).

My suggestion is to modify the class enhancement and remove the StateManager check in pcCopyFields (I don't see the need for this check). 
Afterwards you can use pcCopyFields in AttachStrategy.persist by adding something like 

   ...
        if (manager.getCopyNew()) {
            int[] fields = new int[meta.getFields().length];
            for (int i = 0; i < fields.length; i++)
                fields[i] = i;
            newInstance.pcCopyFields(pc, fields);
        }
   ...

This solution works for my testcase.

As an alternative you can modify (or add an additional) newInstance to copy the data.

I have no real experience with OpenJPA. Perhaps there is a much better solution.
",10/Mar/11 15:00;curtisr7;Can you post a stack trace of the problem?,"10/Mar/11 17:36;oringel;Hi Rick,

this is the stack trace from my testcase.

2004  OpenJpaTestcase  TRACE  [main] openjpa.Runtime - An exception occurred while ending the transaction.  This exception will be re-thrown.
<openjpa-2.2.0-SNAPSHOT-r422266:1078811 fatal store error> org.apache.openjpa.util.StoreException: The transaction cannot be committed, because it was already marked for rollback only.  The transaction will be rolled back instead. The cause of the rollback-only status is reported in the embedded stack.
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:89)
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1497)
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:933)
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:565)
	at testcase.openjpa.OpenJpaTest.testValidation(OpenJpaTest.java:24)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:59)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:115)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:102)
	at org.apache.maven.surefire.Surefire.run(Surefire.java:180)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:350)
	at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1021)
Caused by: javax.validation.ConstraintViolationException: A validation constraint failure occurred for class ""testcase.openjpa.Person"".
	at org.apache.openjpa.persistence.validation.ValidatorImpl.validate(ValidatorImpl.java:282)
	at org.apache.openjpa.validation.ValidatingLifecycleEventManager.fireEvent(ValidatingLifecycleEventManager.java:122)
	at org.apache.openjpa.kernel.BrokerImpl.fireLifecycleEvent(BrokerImpl.java:790)
	at org.apache.openjpa.kernel.BrokerImpl.persistInternal(BrokerImpl.java:2606)
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2544)
	at org.apache.openjpa.kernel.AttachStrategy.persist(AttachStrategy.java:95)
	at org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:102)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:251)
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:104)
	at org.apache.openjpa.kernel.BrokerImpl.attach(BrokerImpl.java:3433)
	at org.apache.openjpa.kernel.DelegatingBroker.attach(DelegatingBroker.java:1214)
	at org.apache.openjpa.persistence.EntityManagerImpl.merge(EntityManagerImpl.java:873)
	at testcase.openjpa.OpenJpaTest.testValidation(OpenJpaTest.java:22)
	... 26 more
","10/Mar/11 19:06;techhusky;I tracked down the source of the problem.  When merging a new entity, OpenJPA persists a new ""empty"" entity, sets (or retrieves) an ID for the new entity, and then merges in the object passed in.  The problem is that the during the persist of the empty entity, a PRE_PERSIST lifecycle event gets fired, causing validation to occur.  I've found that not only is validation occurring prematurely, but OpenJPA violates the JPA specification for the PrePersist callback as well.  

<jpa 1.0 & 2.0 spec - section 3.5.2>
For entities to which the merge operation has been applied and causes the creation of newly managed instances, the PrePersist callback methods will be invoked for the managed instance after the entity state has been copied to it.
<jpa 1.0 & 2.0 spec - section 3.5.2/>

By adding this simple callback to the Person class, it showed that a PrePersist callback occurred before the entity was fully populated. 
class Person {
...

    @PrePersist
    public void prePersist() {
        System.out.println(""PrePersist getName()="" + this.getName());
    }
}

Result:  PrePersist getName()=null

I think the solution will be to disable this callback for the case where a new entity is created specifically for the purposes of a merge.  Working on a fix...",11/Mar/11 03:53;techhusky;Attaching patch for 2.1.x release that prevents the persist path from firing a premature pre-persist event on new entities produced in a merge operation.  I am seeing some jUnit failures that test order/look schema related rather than related to this change.  I am looking into those failures and producing additional test cases.,11/Mar/11 17:29;techhusky;Attached jUnits for inclusion in the bean validation integration module.,11/Mar/11 20:33;techhusky;Committed code and jUnit patches to trunk.  I was able to get clean local and server based builds today.  I'm not sure what was up yesterday.,"15/Mar/11 16:24;oringel;Perfect. You fixed the issue. Both my test case as well as my real project are working now. Thank you very much.

BTW. I found something probably wrong in the ValidatingLifecycleEventManager

...
    @Override
    public boolean hasUpdateListeners(Object source, ClassMetaData meta) {
        if (_validator == null) {            
            return super.hasUpdateListeners(source, meta);
        }
        return _validator.validating(source, LifecycleEvent.BEFORE_PERSIST) ||    <--- LifecycleEvent.BEFORE_UPDATE
            super.hasUpdateListeners(source, meta);
    }

    @Override
    public boolean hasPersistListeners(Object source, ClassMetaData meta) {
        if (_validator == null) {            
            return super.hasPersistListeners(source, meta);
        }
        return _validator.validating(source, LifecycleEvent.BEFORE_UPDATE) ||    <--- LifecycleEvent.BEFORE_PERSIST
            super.hasPersistListeners(source, meta);        
    }
...

Although it has no effect for my testcase, it looks not correct. Maybe you verify this.

","15/Mar/11 16:46;techhusky;Great!  I'm glad it fixed the problem.  I just checked the code into the 2.1.x stream as well.

Yes, the has*Listeners methods in the VLEM do look suspect.  Thanks for reporting it.  I'll do some verification and will open a new JIRA if it turns out to be a bug.  I'm about 99% certain it is...  Both pre-persist and pre-update validation are enabled by default.  So, the bug will not surface unless non-default validation groups are specified.  Looks like we are missing a test variation or three.","16/Mar/11 02:17;techhusky;It looks like the hasPersistListeners and hasUpdateListeners methods in the VLEM are implemented simply for the sake of consistency and, as far as I can tell, are not actually called within OpenJPA.  Event type checking is all within the fireEvent method itself and testing shows it to work as expected.  The hasDeleteListeners method (which is implemented correctly) does get called by JDBCStoreQuery for specific in-memory operations.  For the sake of consistency, and in the event that an external plugin may be calling these methods (they are public), I'll check in the simple code fix and some additional test cases that further verify validation is working as expected, based on the event type and specified validation group (or lack thereof).  This JIRA will be used to make these changes.","16/Mar/11 18:52;techhusky;Committed has*Listeners fix + additional testcases to trunk under rev 1082259.  I don't think this additional change necessarily needs to be backported since it doesn't appear to cause any real problem, but it certainly could be.",02/Feb/12 16:54;allee8285;Close issue in preparation for 2.2.0 release.,"08/Apr/12 04:25;rogerkeays;Did this bug fix make it into 2.2.0?

I have exactly the same problem using @Basic(optional=false)","08/Apr/12 04:38;rogerkeays;Or more accurately, when the merge cascades more than one relationship. i.e. the non-null field is

Invoice.Customer.Contact.name

and I call

merge(invoice)

The Customer validates okay, but validation annotations on the Contact all fail because the fields are null.
","09/Apr/12 18:43;kwsutter;According to Albert's comment on 02/02/2012 and the svn commit messages, this problem was resolved in the 2.2.0 release.  Are you still experiencing a similar problem with 2.2.0?  Or, were you just asking?","08/Sep/12 01:52;rogerkeays;I have this problem in 2.2.0

    <dependency>
      <groupId>org.apache.openjpa</groupId>
      <artifactId>openjpa</artifactId>
      <version>2.2.0</version>
      <scope>compile</scope>
    </dependency>",08/Sep/12 06:26;rogerkeays;I've hit this bug again with cascade merging. Validations on the nested object fail because the fields are all null. Maybe the fireEvents flag isn't properly handled when cascading?,15/Oct/12 18:24;rogerkeays;I've opened OPENJPA-2279 and attached a failing unit test for the problem I described.
Map value updates not flushed,OPENJPA-1784,12473570,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,hwellmann,hwellmann,08/Sep/10 13:31,13/Jan/11 16:45,14/Mar/19 03:03,10/Sep/10 15:36,2.0.1,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,"I have an entity with a map element collection where the map value is an Embeddable.

@Embeddable
public class LocalizedString {

    private String language;
    private String string;

    // getters and setters omitted
}

 

@Entity
public class MultilingualString {

    @Id
    private long id;

    @ElementCollection(fetch=FetchType.EAGER)
    private Map<String, LocalizedString> map = new HashMap<String, LocalizedString>();
}


Given a persistent instance m of my entity, I update a member of a given map value and then merge the modified entity:

    EntityManager em = ...;
    em.getTransaction().begin();
    m.getMap().get(""en"").setString(""foo"");
    em.merge(m)
    em.getTransaction().commit();
   
The problem is, the state change of the map does not get saved to the database. With DEBUG logging on, I can see that the flush on commit does not trigger any SQL UPDATE.

To force the update, I have to put a new value into the map instead of just changing the existing one.

    EntityManager em = ...;
    em.getTransaction().begin();
    m.getMap().put(""en""), new LocalizedString(""en"", ""foo""));
    em.merge(m)
    em.getTransaction().commit();

After this change, I do see the expected UPDATE.

My Embeddable does have hashCode() and equals() implemented such that the changed map is not equal() to the former version in either case.

This looks like a bug in the dirty-checking logic in OpenJPA.",,,,,,,,,,,,,,,,,,,08/Sep/10 13:34;hwellmann;MapUpdate.patch;https://issues.apache.org/jira/secure/attachment/12454105/MapUpdate.patch,09/Sep/10 04:40;faywang;OPENJPA-1784.patch;https://issues.apache.org/jira/secure/attachment/12454183/OPENJPA-1784.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-09-08 15:59:34.158,,,no_permission,,,,,,,,,,,,162026,,,Thu Jan 13 16:45:35 UTC 2011,,,,,,,0|i0z3vr:,202931,,,,,,,,08/Sep/10 13:34;hwellmann;The attachment MapUpdate.patch contains a unit test exhibiting the problem. A test which updates a map key passes. Another test which only update the map value fails.,"08/Sep/10 15:59;faywang;Change in persistent map are detected by OpenJPA when the the put/remove method is called. In the example, the get method is called to retrieve the value. Currently there is no way for the persistent map to know whether the value is modified or not. A new mechanism needs to be added to detect the change. ",13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,,,,,,,,,,,,,,,,,,,,,,,,
Inconsistent behaviour when fetching an Entity that has a null embeddable and the DataCache is enabled,OPENJPA-1770,12472005,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,19/Aug/10 14:31,09/Nov/10 14:59,14/Mar/19 03:03,19/Aug/10 21:39,2.0.0,2.1.0,,,,,,,2.1.0,,,,,datacache,kernel,,,0,,,,,,,,"While investigating the failures for OPENJPA-1469 I found that when the DataCache is enabled we behave differently when finding an Entity that has an empty/null embeddable. Take the following domain model:

@Entity
class A{
  @Id
  int id;
  @Embeddable
  Emb emb;
...
}

@Embeddable
class Emb{
....
}

The scenario where this is observed is when the datacache is not enabled and I persist Entity [A] with a null Emb. In a new persistence context I search for that same Entity, Emb is now an empty embeddable. In that same case when the datacache is enabled the find operation returns an Entity with a null embeddable. This is because the DataCache knows that Emb is null, when the data is retrieved from the database we don't know if it should be null or empty.

The datacache behavior is probably more correct, but it is inconsistent with the non-datacache behavior. Since the datacache is supposed to be transparent to the application I am going to make this two cases operate in the same manner. I asked posted this observation to the dev mailing list[1] but didn't receive any responses.

[1] http://openjpa.markmail.org/thread/xyytunrvcciv5ura",,,,,,,,,,OPENJPA-1469,,,,,,,,,19/Aug/10 18:59;curtisr7;OPENJPA-1770.patch;https://issues.apache.org/jira/secure/attachment/12452560/OPENJPA-1770.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162014,,,Thu Aug 19 21:39:37 UTC 2010,,,,,,,0|i0z453:,202973,,,,,,,,19/Aug/10 21:39;curtisr7;Committed revision 987321 to trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,
Broker getObjectId(...) doesn't return a proper object id for an Entity that is detached and has no DetachedStateManager,OPENJPA-1769,12471945,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,curtisr7,curtisr7,curtisr7,18/Aug/10 21:22,09/Nov/10 14:59,14/Mar/19 03:03,18/Aug/10 22:00,2.0.0,2.1.0,,,,,,,2.1.0,,,,,kernel,,,,0,,,,,,,,"While investigating test failures for OPENJPA-1469 I found that the test org.apache.openjpa.persistence.detachment.TestDetachNoStateField failed due to a bug in BrokerImpl.getObjectId(). 

The problem with the TestDetachNoStateField is that when we tried to save the relationship from a managed entity to a detached(with no DSM) we failed to get the oid of the detached Entity. In turn we weren't updating the cache properly. I added a new test case to test only the failing part of the broker.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,162013,,,Wed Aug 18 22:00:06 UTC 2010,,,,,,,0|i1du6n:,288987,,,,,,,,18/Aug/10 22:00;curtisr7;Committed revision 986963 to trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,
StackOverflowError when finding an Entity with an Eager ManyToMany relationship.,OPENJPA-1768,12471582,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,mikedd,curtisr7,curtisr7,13/Aug/10 19:48,13/Jul/11 16:11,14/Mar/19 03:03,27/Jun/11 20:59,2.0.0,2.1.0,,,,,,,2.2.0,,,,,datacache,,,,0,,,,,,,,"I ran across the following StackOverflowError when working on OPENJPA-1469. I haven't done much for analysis on this failure, but to recreate the exception set ""openjpa.DataCache"",""true"" to the test org.apache.openjpa.jdbc.kernel.TestM2MBiVersion.

java.lang.StackOverflowError
	at java.util.HashMap.getEntry(HashMap.java:508)
	at java.util.HashMap.get(HashMap.java:496)
	at org.apache.openjpa.datacache.DataCacheManagerImpl.isCachable(DataCacheManagerImpl.java:157)
	at org.apache.openjpa.datacache.DataCacheManagerImpl.selectCache(DataCacheManagerImpl.java:140)
	at org.apache.openjpa.datacache.DataCacheStoreManager.load(DataCacheStoreManager.java:414)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:117)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:3047)
	at org.apache.openjpa.kernel.StateManagerImpl.load(StateManagerImpl.java:451)
	at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:1127)
	at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:1033)
	at org.apache.openjpa.kernel.AbstractPCData.toRelationFields(AbstractPCData.java:221)
	at org.apache.openjpa.kernel.AbstractPCData.toNestedFields(AbstractPCData.java:168)
	at org.apache.openjpa.kernel.AbstractPCData.toField(AbstractPCData.java:78)
	at org.apache.openjpa.kernel.PCDataImpl.loadField(PCDataImpl.java:204)
	at org.apache.openjpa.kernel.PCDataImpl.load(PCDataImpl.java:174)
	at org.apache.openjpa.datacache.DataCacheStoreManager.load(DataCacheStoreManager.java:420)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:117)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:3047)
	at org.apache.openjpa.kernel.StateManagerImpl.load(StateManagerImpl.java:451)
	at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:1127)
	at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:1033)
	at org.apache.openjpa.kernel.AbstractPCData.toRelationFields(AbstractPCData.java:221)
	at org.apache.openjpa.kernel.AbstractPCData.toNestedFields(AbstractPCData.java:168)
	at org.apache.openjpa.kernel.AbstractPCData.toField(AbstractPCData.java:78)
	at org.apache.openjpa.kernel.PCDataImpl.loadField(PCDataImpl.java:204)
	at org.apache.openjpa.kernel.PCDataImpl.load(PCDataImpl.java:174)
	at org.apache.openjpa.datacache.DataCacheStoreManager.load(DataCacheStoreManager.java:420)
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:117)
......
	at org.apache.openjpa.kernel.DelegatingStoreManager.load(DelegatingStoreManager.java:117)
	at org.apache.openjpa.kernel.ROPStoreManager.load(ROPStoreManager.java:78)
	at org.apache.openjpa.kernel.StateManagerImpl.loadFields(StateManagerImpl.java:3047)
	at org.apache.openjpa.kernel.StateManagerImpl.load(StateManagerImpl.java:451)
	at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:1127)
	at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:1033)
	at org.apache.openjpa.kernel.AbstractPCData.toRelationFields(AbstractPCData.java:221)
	at org.apache.openjpa.kernel.AbstractPCData.toNestedFields(AbstractPCData.java:168)
	at org.apache.openjpa.kernel.AbstractPCData.toField(AbstractPCData.java:78)
	at org.apache.openjpa.kernel.PCDataImpl.loadField(PCDataImpl.java:204)
	at org.apache.openjpa.kernel.PCDataImpl.load(PCDataImpl.java:154)
	at org.apache.openjpa.datacache.DataCacheStoreManager.loadAll(DataCacheStoreManager.java:487)
	at org.apache.openjpa.kernel.DelegatingStoreManager.loadAll(DelegatingStoreManager.java:122)
	at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:1104)
	at org.apache.openjpa.kernel.BrokerImpl.findAll(BrokerImpl.java:1033)
	at org.apache.openjpa.kernel.AbstractPCData.toRelationFields(AbstractPCData.java:221)
	at org.apache.openjpa.kernel.AbstractPCData.toNestedFields(AbstractPCData.java:168)
	at org.apache.openjpa.kernel.AbstractPCData.toField(AbstractPCData.java:78)
	at org.apache.openjpa.kernel.PCDataImpl.loadField(PCDataImpl.java:204)
	at org.apache.openjpa.kernel.PCDataImpl.load(PCDataImpl.java:154)
	at org.apache.openjpa.datacache.DataCacheStoreManager.initialize(DataCacheStoreManager.java:368)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:112)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1014)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:972)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:889)
	at org.apache.openjpa.kernel.DelegatingBroker.find(DelegatingBroker.java:223)
	at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:477)
",,,,,,,,,,OPENJPA-1469,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,68168,,,Wed Jul 13 16:11:19 UTC 2011,,,,,,,0|i0yvzb:,201651,,,,,,,,13/Jul/11 16:11;curtisr7;Closing resolved issues.,,,,,,,,,,,,,,,,,,,,,,,,,,
TableGenerator doesn't properly utilize all keys when under heavy stress.,OPENJPA-1765,12471448,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,12/Aug/10 18:23,09/Nov/10 14:59,14/Mar/19 03:03,13/Sep/10 21:58,2.0.0,2.1.0,,,,,,,2.0.2,2.1.0,,,,jdbc,,,,0,,,,,,,,"TableJDBCSeq has a locking problem where multiple threads can run on top of each other resulting in all keys not being used for a given sequence. 

While unit testing a fix I also uncovered another theoretical start up problem where multiple threads can try to insert the same row into the DB resulting in a duplicate key exception.",,,,,,,,,,,,,,OPENJPA-1372,,,,,12/Aug/10 18:30;curtisr7;OPENJPA-1765.patch;https://issues.apache.org/jira/secure/attachment/12451932/OPENJPA-1765.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-08-14 11:38:36.063,,,no_permission,,,,,,,,,,,,162010,,,Mon Aug 16 23:42:37 UTC 2010,,,,,,,0|i0z8un:,203736,,,,,,,,12/Aug/10 20:17;curtisr7;Committed revision 984943 to trunk.,"14/Aug/10 11:38;milosz;Rick, is the theoretical problem the same as OPENJPA-1372?
","16/Aug/10 22:14;mikedd;Looks similar, but I think it's different. Can OPENJPA-1372 be reproduced without sharing the EM between threads? 

The added locking in this fix will prevent two EMs from getting the same sequences, I'm not sure about a single thread using the same EM. Might be worth running the test from 1372 to see if it still fails. 

",16/Aug/10 23:42;curtisr7;@Milosz - Yes I believe so. ,,,,,,,,,,,,,,,,,,,,,,,
javax.persistence.lock.scope EXTENDED doesn't properly lock join tables,OPENJPA-1762,12471141,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,curtisr7,curtisr7,09/Aug/10 19:42,11/Nov/10 17:03,14/Mar/19 03:03,11/Nov/10 17:03,2.0.1,2.1.0,,,,,,,,,,,,jdbc,,,,0,,,,,,,,"I have a simple failing unit test that exercises a small portion of the javax.persistence.lock.scope=Extended property. The failing scenario is as follows:

ManyToMany relationship between A(owner) and B.

Em1 - Find A, no lock
Em1 - Refresh A, PESSIMISTIC_FORCE_INCREMENT and javax.persistence.lock.scope=PessimisticLockScope.EXTENDED -- this SHOULD lock the join table for A_B
Em2 - Find, lock B. Remove B.  should block while trying to remove from Join table.

I will post the unit test which demonstrates the problem shortly.",Derby and DB2,,,,,,,,,,,,,,,,,,05/Nov/10 23:02;faywang;OPENJPA-1726-1.patch;https://issues.apache.org/jira/secure/attachment/12458967/OPENJPA-1726-1.patch,09/Aug/10 19:43;curtisr7;OPENJPA-1762.PATCH;https://issues.apache.org/jira/secure/attachment/12451618/OPENJPA-1762.PATCH,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-11-05 23:02:08.761,,,no_permission,,,,,,,,,,,,162007,,,Fri Nov 05 23:02:08 UTC 2010,,,,,,,0|i0z8x3:,203747,,,,,,,,05/Nov/10 23:02;faywang;This patch will fix the PessimisticLockManager by locking the join table.,,,,,,,,,,,,,,,,,,,,,,,,,,
Em.refresh(..) not refreshing from the DB when shared-cache-mode is set to ALL,OPENJPA-1757,12470664,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,02/Aug/10 18:15,20/Sep/10 15:40,14/Mar/19 03:03,09/Aug/10 17:46,2.0.0,2.1.0,,,,,,,2.1.0,,,,,,,,,0,,,,,,,,"<shared-cache-mode>ALL</shared-cache-mode> doesn't play nicely with em.refresh(...).

The following sequence doesn't work:

- Persist an Entity. 
- Start a transaction.
- Update that Entity via SQL UPDATE. 
- Commit the transaction.
- Call em.refresh(..) on the persisted entity.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:40:07.923,,,no_permission,,,,,,,,,,,,162002,,,Mon Sep 20 15:40:07 UTC 2010,,,,,,,0|i0z8i7:,203680,,,,,,,,09/Aug/10 17:46;curtisr7;Committed revision 981664 to trunk.,"20/Sep/10 15:40;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,,
"When a localized message is not found for a given key, OpenJPA should output the log arguments",OPENJPA-1756,12470597,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,pcl,pcl,01/Aug/10 21:59,20/Sep/10 15:40,14/Mar/19 03:03,01/Aug/10 23:23,,,,,,,,,,,,,,,,,,0,,,,,,,,"Currently, when Localizer.java fails to resolve a localized message key, the arguments passed to the localizer are lost when generating a default string. This is unfortunate, as the localized key often is somewhat useful in and of itself, so if we could provide additional context, a missing key would be less of a problem.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:40:07.604,,,no_permission,,,,,,,,,,,,162001,,,Mon Sep 20 15:40:07 UTC 2010,,,,,,,0|i0z8hj:,203677,,,,,,,,"20/Sep/10 15:40;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,,,
TestMixedLockManagerLockPermutation: Timing issue determines the pass/no-pass of the test case,OPENJPA-1753,12470528,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,allee8285,faywang,faywang,30/Jul/10 16:27,20/Sep/10 15:40,14/Mar/19 03:03,13/Aug/10 19:23,2.1.0,,,,,,,,2.0.1,2.1.0,,,,,,,,0,,,,,,,,"This test case spawns three threads and the pass/no pass of the test cases depends on the timing. 

	One example is TestMixedLockManagerFindPermutation.testFindReadPessimisticRead: 
        commonFindTest(
            ""testFind(Read,Commit/PessimisticRead,Rollback)"",
            LockModeType.READ, Act.CommitTx, 1, null,
            LockModeType.PESSIMISTIC_READ, Act.RollbackTx, 1, null);

	If the find by the second child [Thread-8] is executed before the jdbc commit of the update statement by the first child [Thread-7], the test will fail. Attached are the trace file for the successful run and failing run. 



",,,,,,,,,,,,,,,,,,,30/Jul/10 16:28;faywang;trace_fail.txt;https://issues.apache.org/jira/secure/attachment/12450911/trace_fail.txt,30/Jul/10 16:28;faywang;trace_success.txt;https://issues.apache.org/jira/secure/attachment/12450912/trace_success.txt,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-08-12 20:39:04.351,,,no_permission,,,,,,,,,,,,161998,,,Mon Sep 20 15:40:06 UTC 2010,,,,,,,0|i1dtkf:,288887,,,,,,,,"12/Aug/10 20:39;allee8285;Need to set postgresql.conf property max_connection >= 150, otherwise will get exception like:

TestMixedLockManagerLockPermutation.testLockWriteRead  View test details   (org.apache.openjpa.persistence.lockmgr)
    <openjpa-2.1.0-SNAPSHOT-rexported fatal store error> org.apache.openjpa.util.StoreException: Cannot create PoolableConnectionFactory (FATAL: sorry, too many clients already)
    at org.apache.openjpa.jdbc.sql.DBDictionaryFactory.newDBDictionary(DBDictionaryFactory.java:102)
    at org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl.getDBDictionaryInstance(JDBCConfigurationImpl.java:599)
","20/Sep/10 15:40;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,,
TestPessimisticLocks JUNIT test produced inconsistent behavior with various backends,OPENJPA-1752,12470490,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,30/Jul/10 04:33,20/Sep/10 15:40,14/Mar/19 03:03,20/Aug/10 00:29,2.0.1,2.1.0,,,,,,,2.1.0,,,,,jpa,,,,0,,,,,,,,"TestPessimisticLocks JUNIT tests pass all assertions for Derby backend, but failures are seen on DB2, MySQL, Oracle.
It is likely that failures may also occur on other backends.

There could be some problem in OpenJPA code in handling pessimistic lock requests.
There is also inconsistency in reporting exceptions - lock timout or query timeout should be non-fatal; but with Derby the PessimisticLockException is reported  which is considered fatal. It is also possible that the test scenarios are problematic.

TestPessisimiticLocks has 5 test cases, the last test case worked for all backend. Problem test cases are listed as below:

1.  testFindAfterQueryWithPessimisticLocks()
2.  testFindAfterQueryOrderByWithPessimisticLocks()
3.  testQueryAfterFindWithPessimisticLocks()
4.  testQueryOrderByAfterFindWithPessimisticLocks()


The failure symptoms are summarized below -   Each test contains 2 variations.
The dot notation, for example, 1.1 is the first scenario in testFindAfterQueryWithPessimisticLocks() 
Each test scenario is either expecting an exception or No exception; if no exception is reported, the SELECT sql got results from database.

 

Tests       Derby                                        DB2V9.7                                 Oracle10gXE 10.2.0.1.0            MySQL 5.1.39/JDBC 5.1.7
====================================================================================================================================
1.1         PessimisticLockException      LockTimeoutException        LockTimeoutException              LockTimeoutException
1.2         No exception                              No exception                          No exception                                No exception
2.1         PessimisticLockException      LockTimeoutException        LockTimeoutException              LockTimeoutException
2.2         No  exception                             LockTimeoutException        No exception                                LockTimeoutException
3.1         No  exception                             QueryTimeoutException       process hang                            PersistenceException: Server shutdown [code=1053, state=08S01]  
3.2         PessimisticLockException      QueryTimeoutException       process hang                            PersistenceException: Server shutdown [code=1053, state=08S01]
4.1         No  exception                             QueryTimeoutException       No exception                             QueryTimeoutException
4.2         PessimisticLockException      QueryTimeoutException       process hang                           QueryTimeoutException

NOTE: for Oracle, many test scenarios caused process to hang (test 3.1, 3.2, and 4.2) - ie. test never run to completion
      for MySQL, Server shutdown (test 3.1 and 3.2)
      here is the  stack trace:

org.apache.openjpa.persistence.PersistenceException:Server shutdown in progress {prepstmnt 33525219 SELECT t1.id, t1.name FROM Employee t0 LEFT OUTER JOIN Department t1 ON t0.FK_DEPT = t1.id WHERE (t0.id < ?) LIMIT ?, ? FOR UPDATE [params=?, ?, ?]} [code=1053, state=08S01]
<openjpa-2.1.0-SNAPSHOT-rexported fatal general error> org.apache.openjpa.persistence.PersistenceException: Server shutdown in progress {prepstmnt 33525219 SELECT t1.id, t1.name FROM Employee t0 LEFT OUTER JOIN Department t1 ON t0.FK_DEPT = t1.id WHERE (t0.id < ?) LIMIT ?, ? FOR UPDATE [params=?, ?, ?]} [code=1053, state=08S01]
FailedObject: select e.department from Employee e where e.id < 10 [java.lang.String]
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4855)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4815)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:137)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:118)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:70)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.handleCheckedException(SelectResultObjectProvider.java:155)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.handleCheckedException(QueryImpl.java:2109)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:40)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1246)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1005)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:861)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:792)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:288)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302)
	at org.apache.openjpa.persistence.lockmgr.TestPessimisticLocks.testQueryAfterFindWithPessimisticLocks(TestPessimisticLocks.java:271)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runTest(AbstractPersistenceTestCase.java:516)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:503)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:479)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:179)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: Server shutdown in progress {prepstmnt 33525219 SELECT t1.id, t1.name FROM Employee t0 LEFT OUTER JOIN Department t1 ON t0.FK_DEPT = t1.id WHERE (t0.id < ?) LIMIT ?, ? FOR UPDATE [params=?, ?, ?]} [code=1053, state=08S01]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:274)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:258)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$3(LoggingConnectionDecorator.java:257)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeQuery(LoggingConnectionDecorator.java:1176)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:278)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeQuery(JDBCStoreManager.java:1773)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:268)
	at org.apache.openjpa.jdbc.sql.SelectImpl.executeQuery(SelectImpl.java:499)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:424)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:382)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:94)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.open(QueryImpl.java:2068)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:34)
	... 30 more
NestedThrowables:
com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Server shutdown in progress
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source)
	at java.lang.reflect.Constructor.newInstance(Unknown Source)
	at com.mysql.jdbc.Util.handleNewInstance(Util.java:406)
	at com.mysql.jdbc.Util.getInstance(Util.java:381)
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:984)
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:956)
	at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3515)
	at com.mysql.jdbc.MysqlIO.nextRowFast(MysqlIO.java:1545)
	at com.mysql.jdbc.MysqlIO.nextRow(MysqlIO.java:1401)
	at com.mysql.jdbc.MysqlIO.readSingleRowSet(MysqlIO.java:2829)
	at com.mysql.jdbc.MysqlIO.getResultSet(MysqlIO.java:468)
	at com.mysql.jdbc.MysqlIO.readResultsForQueryOrUpdate(MysqlIO.java:2534)
	at com.mysql.jdbc.MysqlIO.readAllResults(MysqlIO.java:1749)
	at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2159)
	at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2554)
	at com.mysql.jdbc.PreparedStatement.executeInternal(PreparedStatement.java:1761)
	at com.mysql.jdbc.PreparedStatement.executeQuery(PreparedStatement.java:1912)
	at org.apache.commons.dbcp.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:93)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:280)
	at org.apache.openjpa.lib.jdbc.JDBCEventConnectionDecorator$EventPreparedStatement.executeQuery(JDBCEventConnectionDecorator.java:270)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:278)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeQuery(LoggingConnectionDecorator.java:1174)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:278)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeQuery(JDBCStoreManager.java:1773)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:268)
	at org.apache.openjpa.jdbc.sql.SelectImpl.executeQuery(SelectImpl.java:499)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:424)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:382)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:94)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.open(QueryImpl.java:2068)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:34)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1246)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1005)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:861)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:792)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:288)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302)
	at org.apache.openjpa.persistence.lockmgr.TestPessimisticLocks.testQueryAfterFindWithPessimisticLocks(TestPessimisticLocks.java:271)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runTest(AbstractPersistenceTestCase.java:516)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:503)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:479)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:179)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:40:06.374,,,no_permission,,,,,,,,,,,,161997,,,Mon Sep 20 15:40:06 UTC 2010,,,,,,,0|i0z8dr:,203660,,,,,,,,"02/Aug/10 20:53;fancy;After upgrading MySQL server to 5.1.49, the server shutdown problem is gone.
Test 3.1 and 3.2  reported QueryTimeoutException using  MySQL-5.1.49.

Updated test results:

Tests Derby_________________  DB2V9.7____________  Oracle10gXE 10.2.0.1.0__ MySQL 5.1.49/JDBC 5.1.7
====================================================================================================================================
1.1__  PessimisticLockException_ LockTimeoutException__ LockTimeoutException__ LockTimeoutException
1.2__  No exception____________ No exception_________ No exception__________ No exception
2.1__  PessimisticLockException_ LockTimeoutException__ LockTimeoutException___ LockTimeoutException
2.2__  No exception____________ LockTimeoutException___ No exception_________ LockTimeoutException
3.1__  No exception____________ QueryTimeoutException__ process hang________ QueryTimeoutException
3.2__  PessimisticLockException_ QueryTimeoutException___ process hang________ QueryTimeoutException
4.1__  No exception___________ QueryTimeoutException___ No exception_________ QueryTimeoutException
4.2__  PessimisticLockException_ QueryTimeoutException___ process hang________ QueryTimeoutException


The assertion failures still remain in TestPessismisticLocks JUNIT test.
Needs further investigation.","03/Aug/10 18:04;fancy;Test results for Oracle backend was inaccurate in previous comments, test 3.1 actually passed with no exceptions.
Oracle server is hanging only in test 3.2. This happens to both Oracle 10g 10.2.0.1.0 and Oracle 11g 11.1.0.6.0.

Update  test results for Oracle 10g and 11g:

Tests Derby_________________ DB2V9.7______________ Oracle10gXE & Oracle 11g ______MySQL 5.1.49/JDBC 5.1.7
====================================================================================================================================
1.1__ PessimisticLockException_ LockTimeoutException____ LockTimeoutException_________ LockTimeoutException
1.2__ No exception____________ No exception___________ No exception_________________ No exception
2.1__ PessimisticLockException_ LockTimeoutException____ LockTimeoutException_________ LockTimeoutException
2.2__ No exception____________ LockTimeoutException____ No exception________________ LockTimeoutException
3.1__ No exception____________ QueryTimeoutException___ No exception--_______________ QueryTimeoutException
3.2__ PessimisticLockException_ QueryTimeoutException____Server  hang_________________ QueryTimeoutException
4.1__ No exception___________ QueryTimeoutException____ No exception_________________ QueryTimeoutException
4.2__ PessimisticLockException_ QueryTimeoutException____ process hang________________ QueryTimeoutException ",20/Aug/10 00:28;fancy;Fixed testcase,"20/Sep/10 15:40;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,
New openbooks and image-gallery samples are not in the binary assembly,OPENJPA-1751,12470453,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,drwoods,drwoods,29/Jul/10 15:25,20/Sep/10 15:40,14/Mar/19 03:03,30/Jul/10 17:38,2.1.0,,,,,,,,2.1.0,,,,,build / infrastructure,,,,0,,,,,,,,only openjpa-examples/src is getting included in the examples subdir in the binary assembly ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:40:06.014,,,no_permission,,,,,,,,,,,,161996,,,Mon Sep 20 15:40:06 UTC 2010,,,,,,,0|i0z8e7:,203662,,,,,,,,"30/Jul/10 14:10;drwoods;Binary assembly now includes image-gallery and openbooks source.
Existing examples were moved to openjpa-examples/simple and ANT files updated with new ${root} path.","30/Jul/10 15:03;drwoods;OK, looks like the OpenBooks ANT build is causing failures on Linux....
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ------------------------------------------------------------------------
[INFO] An Ant BuildException has occured: The following error occurred while executing this line:
<http://hudson.zones.apache.org/hudson/job/OpenJPA-trunk/org.apache.openjpa.openjpa-examples$openbooks/ws/build.xml>:151: Unable to find a javac compiler;
com.sun.tools.javac.Main is not on the classpath.
Perhaps JAVA_HOME does not point to the JDK.
It is currently set to ""/home/hudson/tools/java/jdk1.6.0_20-32/jre""
","30/Jul/10 17:38;drwoods;Had to update build.xml with
    <javac fork=""true""
as workaround to Maven overriding JAVA_HOME to point to JRE.
Also, we can't upgrade to maven-antrun-plugin-1.4, as there are known problems with ${settings.localRepository} not working, but will be fixed in 1.5.
","20/Sep/10 15:40;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,
Throw exception if using datacache / synchronize mappings and specifying datasource name at EM creation.,OPENJPA-1749,12470345,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,28/Jul/10 14:18,28/Jul/10 22:08,14/Mar/19 03:03,28/Jul/10 22:08,2.0.0,,,,,,,,2.0.1,2.1.0,,,,,,,,0,,,,,,,,"Some configuration options are misleading and dangerous if the datasource JNDI location is provided at EntityManager creation time. For example the L2 cache can not be reliably used if each EntityManager may be communicating with a different schema / database instance. 

In order to prevent confusion down the road we should throw an exception when these conditions are detected. ",,,,,,,,,,,,,,OPENJPA-1551,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161994,,,2010-07-28 14:18:38.0,,,,,,,0|i0z41b:,202956,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException when a null value is set in the properties map passed to Entity.createEntityManagerFactory,OPENJPA-1746,12470042,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,rflahert,rflahert,23/Jul/10 20:06,21/Sep/11 15:09,14/Mar/19 03:03,21/Sep/11 15:09,1.2.2,,,,,,,,2.1.2,2.2.0,,,,jpa,,,,0,,,,,,,,"If a property is set with a null value in the Entity.createEntityManagerFactory, a NullPointerException is thrown due to PersistenceUnitInfoImpl's use of Properties for the _props field (which extends Hashtable which doesn't allow nulls).  Although not specifically laid out by the API, it accepts Map, which is incompatible with Properties/Hashtable in this instance.  HashMap would be the preffered type here.

Currently this was working with EclipseLink, as I set some properties to null to override defaults set in the persistence.xml file based on some dynamic criteria.",N/A,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-09-21 15:09:07.249,,,no_permission,,,,,,,,,,,,59911,,,Wed Sep 21 15:09:07 UTC 2011,,,,,,,0|i1dtlb:,288891,,,,,,,,"21/Sep/11 15:09;mikedd;Closing issues which have code changes and have not been modified for a while. 

If there is more work to be done for this issue please check whether it has already been included in an OpenJPA release. 

If the changes are in an OpenJPA release please open a new issue and link to this one. 

If the changes are not in an OpenJPA release you may reopen this issue or create a new issue. ",,,,,,,,,,,,,,,,,,,,,,,,,,
Tool configuration does not support EMF anchors,OPENJPA-1743,12469879,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,pcl,pcl,22/Jul/10 01:11,13/Jan/11 16:45,14/Mar/19 03:03,12/Oct/10 18:32,1.2.2,1.3.0,2.0.0,2.1.0,,,,,2.1.0,,,,,tooling,,,,0,,,,,,,,Invoking mappingtool with an anchor via ant does not currently work -- the anchor is ignored.,,,,,,,,,,,,,,,,,,,22/Jul/10 16:48;drwoods;OPENJPA-1743-trunk.patch;https://issues.apache.org/jira/secure/attachment/12450188/OPENJPA-1743-trunk.patch,22/Jul/10 01:41;pcl;OPENJPA-1743.patch;https://issues.apache.org/jira/secure/attachment/12450122/OPENJPA-1743.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-07-22 16:48:49.217,,,no_permission,,,,,,,,,,,,161990,,,Thu Jan 13 16:45:32 UTC 2011,,,Patch Available,,,,0|i0z84f:,203618,,,,,,,,22/Jul/10 16:48;drwoods;patch ported to trunk,13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,,,,,,,,,,,,,,,,,,,,,,,,,
Recover if connectionFactory on EntityManagerFactory is invalid but cf on EntityManager is valid. ,OPENJPA-1742,12469865,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,21/Jul/10 22:57,28/Jul/10 14:19,14/Mar/19 03:03,23/Jul/10 20:37,2.0.0,,,,,,,,2.0.1,2.1.0,,,,,,,,0,,,,,,,,"The code changes for OPENJPA-1551 require a valid JNDI name to be available for the EntityManagerFactory, we should be able to recover if the EMF has a bad JNDI location but the EM has a valid one. ",,,,,,,,,,,,,,OPENJPA-1749,OPENJPA-1551,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161989,,,2010-07-21 22:57:15.0,,,,,,,0|i0z6y7:,203428,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type expression for entites using Joined table strategy is not working properly,OPENJPA-1740,12469858,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,21/Jul/10 21:21,23/Jul/10 20:42,14/Mar/19 03:03,23/Jul/10 20:40,2.1.0,,,,,,,,2.1.0,,,,,jdbc,kernel,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,21/Jul/10 22:42;faywang;OPENJPA-1740.patch;https://issues.apache.org/jira/secure/attachment/12450108/OPENJPA-1740.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161987,,,Wed Jul 21 22:10:35 UTC 2010,,,,,,,0|i0z3y7:,202942,,,,,,,,"21/Jul/10 21:24;faywang;In a data model, where Employee inherits from Person. and Contractor/FulltimeEmployee/ParttimeEmployee inherit from Employee using Joined table strategy, the following JPQL generates wrong sqls: 
                                                                              
JPQL: SELECT p FROM Person p where TYPE(p) = Contractor

Push-down SQL:
(1) SELECT t0.OID, t1.OID, t2.OID, t3.OID, t1.name 
FROM WContractor t0 
    LEFT OUTER JOIN WEmployee t2 ON t0.OID = t2.OID 
    LEFT OUTER JOIN WPerson t1 ON t2.OID = t1.OID 
    LEFT OUTER JOIN WFulltimeEmployee t3 ON t2.OID = t3.OID 
    WHERE t2.OID IS NULL AND t0.OID IS NULL AND t3.OID IS NULL

(2) SELECT t0.OID, t2.OID, t1.OID, t3.OID, t2.name, t1.description 
FROM WContractor t0 
    LEFT OUTER JOIN WEmployee t1 ON t0.OID = t1.OID 
    INNER JOIN WPerson t2 ON t1.OID = t2.OID 
    LEFT OUTER JOIN WFulltimeEmployee t3 ON t1.OID = t3.OID 
    WHERE t0.OID IS NULL AND t3.OID IS NULL

(3) SELECT t0.OID, t1.OID, t1.name, t2.description, t0.ContractorProp1, t0.Dept_No 
FROM WContractor t0 
    INNER JOIN WEmployee t2 ON t0.OID = t2.OID 
    INNER JOIN WPerson t1 ON t2.OID = t1.OID

(4) SELECT t0.OID, t1.OID, t2.OID, t1.name, t3.description, t2.Dept_No, t2.FTEmpProp1 
FROM WPerson t1 
    INNER JOIN WEmployee t3 ON t1.OID = t3.OID 
    INNER JOIN WFulltimeEmployee t2 ON t3.OID = t2.OID, 
    WContractor t0","21/Jul/10 22:10;faywang;The patch will generate the correct SQL for the type expression:
JPQL: SELECT p FROM Person p where TYPE(p) <> Contractor

(1) SELECT t0.OID, t1.OID, t1.name, t2.description, t0.Dept_No, t0.FTEmpProp1 
FROM WFulltimeEmployee t0 
  INNER JOIN WEmployee t2 ON t0.OID = t2.OID 
  INNER JOIN WPerson t1 ON t2.OID = t1.OID WHERE (1=1)

(2) SELECT t0.OID, t1.OID, t1.name, t2.description, t0.Dept_No, t0.PTEmpProp1 
FROM WParttimeEmployee t0 
  INNER JOIN WEmployee t2 ON t0.OID = t2.OID 
  INNER JOIN WPerson t1 ON t2.OID = t1.OID WHERE (1=1)

JPQL: SELECT p FROM Person p where TYPE(p) = Contractor

(1) SELECT t0.OID, t1.OID, t1.name, t2.description, t0.ContractorProp1, t0.Dept_No 
FROM WContractor t0 
  INNER JOIN WEmployee t2 ON t0.OID = t2.OID 
  INNER JOIN WPerson t1 ON t2.OID = t1.OID WHERE (1=1)
",,,,,,,,,,,,,,,,,,,,,,,,,
Prepared SQL query does not handle collection-valued parameter of persistence-capable  objects,OPENJPA-1738,12469847,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,21/Jul/10 18:52,31/Jan/12 02:24,14/Mar/19 03:03,24/Jul/10 16:04,2.0.0,2.0.1,2.1.0,,,,,,2.1.0,,,,,performance,,,,0,,,,,,,,"Patrick Linskey wrote:
I just ran into what I believe is a bug with the prepared SQL code. In PreparedQueryImpl.reparameterize(), we have the following code:

>             if (ImplHelper.isManageable(val)) {
>                 setPersistenceCapableParameter(result, val, indices, broker);
>             } else if (val instanceof Collection) {
>                 setCollectionValuedParameter(result, (Collection)val, indices,
>                     key);
>             }

This does not work if the parameter is a collection of persistence-capable objects, as setCollectionValuedParameter assumes that the values are not PCs.

",,,,,,,,,,,,,,OPENJPA-2118,,,,,21/Jul/10 19:21;fancy;OPENJPA-1738.patch;https://issues.apache.org/jira/secure/attachment/12450084/OPENJPA-1738.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:40:05.491,,,no_permission,,,,,,,,,,,,161985,,,Mon Sep 20 15:40:05 UTC 2010,,,,,,,0|i0zbwn:,204231,,,,,,,,"20/Sep/10 15:40;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,,,
The openjpa-2.0.0.jar does not have its MANIFEST.MF has the first entry,OPENJPA-1737,12469812,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,gnt,gnt,21/Jul/10 12:17,20/Sep/10 15:40,14/Mar/19 03:03,21/Jul/10 19:01,2.0.0,,,,,,,,1.3.0,2.0.1,2.1.0,,,build / infrastructure,osgi,,,0,,,,,,,,"This is a requirement for valid jars and it causes some problems for tools that expect the manifest as the first entry.
Karaf does that in some places so that it can read the manifest from a remote location without having to download the full jar.",,,,,,,,,,,,,,,,,,,21/Jul/10 18:55;drwoods;OPENJPA-1737-13x.diff;https://issues.apache.org/jira/secure/attachment/12450080/OPENJPA-1737-13x.diff,21/Jul/10 18:55;drwoods;OPENJPA-1737-20x.diff;https://issues.apache.org/jira/secure/attachment/12450079/OPENJPA-1737-20x.diff,21/Jul/10 18:31;drwoods;OPENJPA-1737-trunk.diff;https://issues.apache.org/jira/secure/attachment/12450073/OPENJPA-1737-trunk.diff,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2010-07-21 17:47:25.53,,,no_permission,,,,,,,,,,,,161984,,,Mon Sep 20 15:40:05 UTC 2010,,,,,,,0|i0z8bb:,203649,,,,,,,,"21/Jul/10 17:47;drwoods;We're using packaging=bundle and the org.apache.felix.maven-bundle-plugin-2.0.0 to generate the final artifact, so any ideas?
","21/Jul/10 18:20;drwoods;Problem is related to how we're using maven-shade-plugin and maven-bundle-plugin together.  Some manifest info was being injected by the shade plugin, which seems to mess the ordering up.  Once I moved the injection of manifest data from the shade plugin to the bundle plugin, the manifest file is now the first file in the jar -

drwoods:openjpa/$ unzip -l target/openjpa-2.1.0-SNAPSHOT.jar 
Archive:  target/openjpa-2.1.0-SNAPSHOT.jar
  Length     Date   Time    Name
 --------    ----   ----    ----
        0  07-21-10 14:15   META-INF/
    22219  07-21-10 14:15   META-INF/MANIFEST.MF
",21/Jul/10 18:31;drwoods;Patch that corrects the manifest problem in trunk.,21/Jul/10 18:55;drwoods;Patches for 2.0.x and 1.3.0 to keep all these branches in sync,"21/Jul/10 19:01;drwoods;trunk - Committed revision 966353.
2.0.x - Committed revision 966359.
1.3.0 - Committed revision 966362.
","20/Sep/10 15:40;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,
Mappings with foreign keys as identity fields sometimes not resolved correctly,OPENJPA-1736,12469803,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,dirichs,dirichs,21/Jul/10 10:55,20/Sep/10 15:40,14/Mar/19 03:03,21/Aug/10 15:52,2.0.0,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,"This is a follow-up issue of OPENJPA-1141. The solution developed for that issue only handled some aspects of an underlying greater problem with OpenJPAs mapping algorithm. This algorithm may fail under certain circumstances involving foreign keys used as identity fields in other entities. A patch with a test case illustrating this problem is attached to this issue. The problem can probably show up with different exceptions. However, the stack trace for the supplied test case is as follows:

testEntityAsIdentityField001(org.apache.openjpa.persistence.identity.entityasidentity2.TestEntityAsIdentityFields2)  Time elapsed: 1.656 sec  <<< ERROR!
<openjpa-2.0.0-r422266:935683M fatal user error> org.apache.openjpa.persistence.ArgumentException: Errors encountered while resolving metadata.  See nested exceptions for details.
	at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:642)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:385)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:358)
	at org.apache.openjpa.meta.MetaDataRepository.resolveMeta(MetaDataRepository.java:688)
	at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:617)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaDataInternal(MetaDataRepository.java:385)
	at org.apache.openjpa.meta.MetaDataRepository.getMetaData(MetaDataRepository.java:358)
	at org.apache.openjpa.jdbc.meta.MappingRepository.getMapping(MappingRepository.java:355)
	at org.apache.openjpa.jdbc.meta.MappingTool.getMapping(MappingTool.java:679)
	at org.apache.openjpa.jdbc.meta.MappingTool.buildSchema(MappingTool.java:751)
	at org.apache.openjpa.jdbc.meta.MappingTool.run(MappingTool.java:649)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:149)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:159)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:117)
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:199)
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:156)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:213)
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:151)
	at org.apache.openjpa.persistence.identity.entityasidentity2.TestEntityAsIdentityFields2.testEntityAsIdentityField001(TestEntityAsIdentityFields2.java:16)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runTest(AbstractPersistenceTestCase.java:516)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:503)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:479)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:179)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
	at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:345)
	at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009)
Caused by: <openjpa-2.0.0-r422266:935683M fatal user error> org.apache.openjpa.persistence.ArgumentException: The id class specified by type ""class org.apache.openjpa.persistence.identity.entityasidentity2.Attendance"" does not match the primary key fields of the class.  Make sure your identity class has the same primary keys as your persistent type, including pk field types. Mismatched property: ""student""
	at org.apache.openjpa.meta.ClassMetaData.validateAppIdClassPKs(ClassMetaData.java:2205)
	at org.apache.openjpa.meta.ClassMetaData.validateAppIdClass(ClassMetaData.java:2079)
	at org.apache.openjpa.meta.ClassMetaData.validateIdentity(ClassMetaData.java:2015)
	at org.apache.openjpa.meta.ClassMetaData.validateMeta(ClassMetaData.java:1927)
	at org.apache.openjpa.meta.ClassMetaData.resolve(ClassMetaData.java:1788)
	at org.apache.openjpa.meta.MetaDataRepository.processBuffer(MetaDataRepository.java:790)
	at org.apache.openjpa.meta.MetaDataRepository.resolveMeta(MetaDataRepository.java:693)
	at org.apache.openjpa.meta.MetaDataRepository.resolve(MetaDataRepository.java:617)
	... 48 more

A proposed solution to this issue is given below.
",,,,,,,,,,,,,,,,,,,21/Jul/10 12:13;dirichs;OpenJPA-2.0.0_OJ1736.patch;https://issues.apache.org/jira/secure/attachment/12450056/OpenJPA-2.0.0_OJ1736.patch,21/Jul/10 11:00;dirichs;OpenJPA-2.0.0_OJ1736.testcase.patch;https://issues.apache.org/jira/secure/attachment/12450050/OpenJPA-2.0.0_OJ1736.testcase.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-08-21 15:52:22.457,,,no_permission,,,,,,,,,,,,161983,,,Mon Sep 20 15:40:04 UTC 2010,,,Patch Available,,,,0|i0zbwv:,204232,,,,,,,,21/Jul/10 11:00;dirichs;File OpenJPA-2.0.0_OJ1736.testcase.patch contains a test case which can be applied to the OpenJPA source and then run.,"21/Jul/10 12:13;dirichs;File OpenJPA-2.0.0_OJ1736.patch contains a proposed fix for this issue.

Basically, the patch removes the changes done for OPENJPA-1141 and replaces the InheritanceOrderedMetaDataList used in MetaDataRepository.processBuffer with a simple ArrayList<MetaData>. The assumptions accompanying this patch are:

  - The fix for OPENJPA-1141, which consisted of an elaborate reordering of metadata classes at the end of method processBuffer, does not work in all cases, see attached test case. Reason: the reordering is done too late, things may go wrong earlier in the middle of method processBuffer.

  - There is no need to use complicated structures such as InheritanceOrderedMetaDataList, as the recursive resolution method implemented by processBuffer already ensures that entities that need to be resolved before another entity may be resolved, are put into the buffer after the entity that depends on them. Thus it suffices to just process the meta data instances accumulated in the buffer in a last-in-first-out fashion.

To be honest, I am not 100% sure that the second assumption is always right. There might be convoluted cases of complex entity dependencies where this assumption is no longer valid. However, the current approach based on InheritanceOrderedMetaDataList is much worse and leads to errors quite soon (the attached test case only needs 4 entities to trigger the error). A patched version of OpenJPA runs fine with our application of ~40 entities, quite a few of them depending on other entities (inheritance as well as identities based on foreign keys). With the original OpenJPA, this problem already faced at around 20 entities with no workaround possible.

If it helps the adoption of this patch, I could assemble more complex mappings to see whether the patch continues to work or not. I am also willing to supply patches for the current trunk version as well as the 1.2-branch, if this is requested.","21/Aug/10 15:52;fancy;Thanks to Martin, your patch has been committed in r987772 (trunk), and r987773 (2.0.x).","23/Aug/10 19:50;fancy;Back out changes to 2.0.x branch.
Updates to maintenance stream 2.0.x must get approval from Michael Dick.","20/Sep/10 15:40;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,
QueryCache TIMESTAMP eviction policy doesn't evict a timed out query if it returns zero results.,OPENJPA-1727,12469473,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,16/Jul/10 17:48,20/Sep/10 15:40,14/Mar/19 03:03,09/Aug/10 18:09,2.0.0,2.1.0,,,,,,,2.1.0,,,,,,,,,0,,,,,,,,"In QueryCacheStoreQuery.checkCache() if the query result has no result, we return Collections.emptyList(). This is a problem when using the TIMESTAMP eviction policy because we skip the section of code that looks at the timestamp to evict stale entries.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:40:02.41,,,no_permission,,,,,,,,,,,,161974,,,Mon Sep 20 15:40:02 UTC 2010,,,,,,,0|i0z3z3:,202946,,,,,,,,30/Jul/10 21:03;curtisr7;Committed revision 980963 to trunk.,02/Aug/10 15:14;curtisr7;Reopening while looking at an intermittent test case failure.,"02/Aug/10 15:26;curtisr7;I'm guessing that the failure has to do with the fact that in QueryCacheStoreQuery.checkCache(...):147 we compare the timestamp of the query to the timestamp of each of the results, but when the timestamps are equal we will use the cached result. I changed the comparison so that if/when the timestamp of the query is the same as one of the results we will throw out the cached result. I'd rather error on the side of hitting the database than returning stale data.

I'm going to leave this JIRA open for a while to make sure that the test failure goes away.",09/Aug/10 18:09;curtisr7;Looks like the fix worked. Resolving this issue again.,"20/Sep/10 15:40;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,
Clean up OpenJPA test case failures for PostgreSQL,OPENJPA-1726,12469301,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,faywang,faywang,faywang,14/Jul/10 22:46,27/Apr/11 17:33,14/Mar/19 03:03,27/Jul/10 16:31,2.1.0,,,,,,,,2.1.0,,,,,,,,,0,,,,,,,,,,,,,,,,,,,,,OPENJPA-1710,OPENJPA-1985,,,,,16/Jul/10 00:16;faywang;OPENJPA-1726-2.patch;https://issues.apache.org/jira/secure/attachment/12449605/OPENJPA-1726-2.patch,15/Jul/10 22:15;faywang;OPENJPA-1726.patch;https://issues.apache.org/jira/secure/attachment/12449598/OPENJPA-1726.patch,28/Jul/10 23:26;faywang;TestMixedLockManagerFindPermutation_trace.zip;https://issues.apache.org/jira/secure/attachment/12450770/TestMixedLockManagerFindPermutation_trace.zip,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2010-07-20 14:47:01.983,,,no_permission,,,,,,,,,,,,161973,,,Wed Jul 28 23:26:49 UTC 2010,,,,,,,0|i1dtmf:,288896,,,,,,,,"15/Jul/10 22:15;faywang;TestIdClassCompanyModel.testBasicQueries fails with the following exception:

Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: ERROR: function pg_catalog.substring(character varying, bigint) does not exist
Hint: No function matches the given name and argument types. You might need to add explicit type casts.
Position: 658 {prepstmnt 795758045 SELECT t0.id, t0.DTYPE, t0.firstName, t2.id, t2.city, t2.phoneNumber, t2.postalCode, t2.state, t2.streetAddress, t0.lastName, t1.id, t3.id, t3.city, t3.phoneNumber, t3.postalCode, t3.state, t3.streetAddress, t1.name, t0.hireDate, t4.id, t4.DTYPE, t4.firstName, t4.HOMEADDRESS_ID, t4.lastName, t4.COMPANY_ID, t4.hireDate, t4.title, t4.salary, t0.title, t0.salary, t0.wage, t0.weeklyHours FROM IDC_Person t0 INNER JOIN IDC_Company t1 ON t0.COMPANY_ID = t1.id LEFT OUTER JOIN IDC_Address t2 ON t0.HOMEADDRESS_ID = t2.id LEFT OUTER JOIN IDC_Person t4 ON t0.MANAGER_ID = t4.id LEFT OUTER JOIN IDC_Address t3 ON t1.ADDRESS_ID = t3.id WHERE (((POSITION(t1.name IN SUBSTRING(?, ((? - ?) + 1))) - 1 + (? - ?)) + ?) > ?) AND t0.DTYPE IN (?, ?, ?) AND (t4.DTYPE IS NULL OR t4.DTYPE IN (?)) [params=?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?]} [code=0, state=42883]
FailedObject: select x from IDC_Employee x where locate(x.company.name, 'x', 1) > 0 [java.lang.String]

In the push-down sql:
(((POSITION(t0.firstName IN SUBSTRING(?, ((? - ?) + 1))) - 1 + (? - ?)) + ?) > ?)

OpenJPA set the parameters as follows:

        pstmt.setString(1, ""x"");
        pstmt.setLong(2, 1);
        pstmt.setInt(3, 1);
        pstmt.setLong(4, 1);
        pstmt.setInt(5, 1);
        pstmt.setInt(6, 1);
        pstmt.setLong(7, 0);

The second parameter is set to type Long, which causes the error that the function pg_catalog.substring(character varying, bigint) does not exist. It turns out the for Postgres, the start index in the locate function must be int:

http://www.postgresql.org/docs/8.1/static/functions-string.html
substring(string [from int] [for int])

The fix is to modify JPQLExpressionBuilder to create a Lit of Integer value for the locateFromIndex.

Although this fix affects all database, it is reasonable to assume that the start index in the locate function is in the integer range.","16/Jul/10 00:16;faywang;TestTypeSafeCondExpression.testTrimFunc1 and testTrimFunc2 fail in Postgres when the criteria API is used:

Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: ERROR: function pg_catalog.btrim(character varying, integer) does not exist
Hint: No function matches the given name and argument types. You might need to add explicit type casts.
Position: 8 {prepstmnt 598291031 SELECT TRIM(BOTH ? FROM t0.compName) FROM CompUser t0 WHERE (t0.name = ?) [params=?, ?]} [code=0, state=42883]

In these test cases, OpenJPA criteria API sets the trim character as the Character type, resulting in the call of PreparedStatement.setInt for the trim character (via DBDictionary.setChar). Postgres therefore throws error that function pg_catalog.btrim(character varying, integer) does not exist. The patch OPENJPA-1726-2.patch modifies the trim character  to String type to fix this problem.
","19/Jul/10 22:58;faywang;The following four OpenJPA test cases fail with the same error:

TestGeneratedValues.testDefaultValues
TestGeneratedValues.testCustomSequenceGeneratorWithIndirection
TestGeneratedValues.testUUIDGenerators
TestNonstandardMappingAnnotations.testInsertAndRetrieve

Caused by: <openjpa-2.1.0-SNAPSHOT-rexported fatal general error> org.apache.openjpa.persistence.PersistenceException: ERROR: invalid byte sequence for encoding ""UTF8"": 0x00. Hint: This error can also happen if the byte sequence does not match the encoding expected by the server, which is controlled by ""client_encoding"".

This error is caused by the two auto-generated uuid values (uuidstring and uuidT4string) In the entity, org.apache.openjpa.persistence.generationtype.GeneratedValues:  

    @GeneratedValue(generator=""uuid-string"")
    private String uuidstring;

    @GeneratedValue(generator=""uuid-type4-string"")
    private String uuidT4string;

These two fields are populated in a way that org.apache.openjpa.lib.util.UUIDGenerator first randomly generates byte[] and then converts it to a String using charset ""ISO-8859-1"". The resulting string may contain 0x00, causing invalid byte sequence for encoding ""UTF8"": 0x00. The failures are not deterministic as the UUID values are randomly generated. One way to fix this problem is to exclude Postgres from running these four test cases. Any comments are welcome.","20/Jul/10 14:47;techhusky;I ran into some issues with uuid-string and uuid-type4-string a while back.  This problem isn't specific to PostgreSQL, but looks to be even more prevalent on that platform since it stores data in UTF-8.  UTF-8 is particularly picky about character values.  To be honest, I wouldn't ever recommend the use of uuid-string or uuid-type4-string since they generate integral byte values and plug them in as character data without taking into account the character encoding of either the client or database column.  Depending on the conversion, the id may get converted to some other value or fail to convert (like we are witnessing on PostgreSQL).  A better choice would have been to convert the values to ASCII base-10 numeric characters.  This is not something we can change now though, since there may be existing applications happily running with the current generation strategy.  The use of uuid-hex or uuid-type4-hex is a much better choice since the key value includes only invariant characters.

Since this could fail intermittently on any platform a better choice might be to either discontinue testing uuid-string or uuid-type4-string (while continuing to test uuid-hex and uuid-type4-hex) or test the -string variants separately, excluding PostgreSQL.  I'm OK with either, or simply excluding the test from running on PostgreSQL as you suggested.","28/Jul/10 23:23;faywang;	The failing test cases running on Postgres are now in TestMixedLockManagerFindPermutation. This test case spawns three threads and the pass/no pass of the test cases depends on the timing.  

	One example is TestMixedLockManagerFindPermutation.testFindReadPessimisticRead when the second child thread is doing rollback: 
        commonFindTest(
            ""testFind(Read,Commit/PessimisticRead,Rollback)"",
            LockModeType.READ, Act.CommitTx, 1, null,
            LockModeType.PESSIMISTIC_READ, Act.RollbackTx, 1, null);

	In the failing trace file, you can easily see that the find by the second child [Thread-8] is before the jdbc commit of the update statement by the first child [Thread-7], even though the commit action is issued by Thread-7 before the find by Thread-8.",28/Jul/10 23:26;faywang;The zip file contains trace log for success run and failing run to illustrate the timing issue.,,,,,,,,,,,,,,,,,,,,,
Schemaname wrongly included in DBDictionary.checkNameLength after Tablename correctly truncated,OPENJPA-1725,12469241,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,roerch,roerch,14/Jul/10 09:24,17/Aug/11 08:51,14/Mar/19 03:03,11/May/11 20:57,1.2.2,1.3.0,2.0.0,2.1.0,,,,,2.1.1,2.2.0,,,,,,,,0,,,,,,,,"While enhancing and mapping files for an Oracle database the tablenames are correctly truncated after 30 characters (or whatever I write as maxTableNameLenght in the DBDictionary), the check in DBDictionary.checkNameLength includes the name of the schema which is used, therefore exceeding and failing the check for 30 characters by (length of schemaname +1) (see exception below). 

Exception in thread ""main"" <openjpa-2.0.0-r422266:935683 nonfatal user error> org.apache.openjpa.util.UserException: Table name ""TEST.LS_DETPOINT_WITH_ORIENTATIONDA"" is 35-character long. The database allows maximum 30-character for a table name.
     [java]     at org.apache.openjpa.jdbc.sql.DBDictionary.checkNameLength(DBDictionary.java:5215)
     [java]     at org.apache.openjpa.jdbc.sql.DBDictionary.getCreateTableSQL(DBDictionary.java:3304)
     [java]     at org.apache.openjpa.jdbc.sql.OracleDictionary.getCreateTableSQL(OracleDictionary.java:899)
     [java]     at org.apache.openjpa.jdbc.schema.SchemaTool.createTable(SchemaTool.java:956)
","Linux, J2SE, OracleDB 10.2.0.1, JDBC drivers 10.2.0.1, 11.2.0.1, 10.2.0.4, OpenJPA versions as listed above",,,,,,,,,,,,,OPENJPA-2038,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,64820,,,2010-07-14 09:24:35.0,,,,,,,0|i0zbwf:,204230,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem serializing DistinctResultList when EntityManager is closed,OPENJPA-1722,12469087,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,dianner,dianner,dianner,12/Jul/10 18:02,20/Sep/10 15:40,14/Mar/19 03:03,16/Aug/10 21:19,2.0.0,,,,,,,,2.0.1,2.1.0,,,,kernel,,,,0,,,,,,,,"A client application that worked earlier is now failing in 2.10, relating to the serialization of the DistinctResultList. It does a distinct query followed by a getResultList(). A DistinctResultList is returned from the query, where a DelegatingResultList used to be returned. The EntityManager is closed before the serialization occurs. It fails with the exception: org.apache.openjpa.persistence.InvalidStateException: The context has been closed.

Here's what is happening: The DistinctResultList contains a RuntimeExceptionTranslator object which contains the closed EntityManager. The writeObject() in the enclosed BrokerImpl does an assertOpen(), which issues the exception.

The DelegatingResultList also contains the RuntimeExceptionTranslator. But, it contains a writeResult() method which is called during serialization. This only attempts to write the ResultList object, not the RuntimeExceptionTranslator object.

So, I will add the writeResult() method to the DistinctResultList class. In this case, it will write an ArrayList instead of a ResultList object. This should be ok since the method signature is for a List.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-07-13 18:28:18.145,,,no_permission,,,,,,,,,,,,161970,,,Mon Sep 20 15:40:01 UTC 2010,,,,,,,0|i0z8kn:,203691,,,,,,,,"13/Jul/10 18:28;mikedd;Hi Dianne, do you have a unit test for this change? ","15/Jul/10 16:19;dianner;Hi Mike - I'm trying to figure one out, if it's possible.","15/Jul/10 20:51;mikedd;Thanks, take a look at org.apache.openjpa.lib.test.AbstractTestCase.roundtrip(Object, boolean) - to serialize the resultList. 

From your description it should just be a matter of closing the EM and then serializing and verifying that the resultlist is accurate. ","20/Sep/10 15:40;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,
Prepared SQL cache ordering problem with subqueries. ,OPENJPA-1719,12468724,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,mikedd,mikedd,07/Jul/10 15:03,20/Sep/10 15:40,14/Mar/19 03:03,26/Jul/10 15:42,2.0.0,,,,,,,,2.0.1,2.1.0,,,,,,,,0,,,,,,,,"I've found what appears to be an ordering issue with subqueries and the prepared SQL cache. The attached patch shows where I think the problem lies and adds a test method that shows the problem. 

To summarize: When the prepared SQL cache is enabled we reorder the parameter values provided by the user. If a query contains named parameters and a subquery which also contains named parameters the placement of the subquery becomes important. 

The following query will work : 
SELECT p FROM Person p WHERE p.id IN (SELECT p1.id FROM Person p1 WHERE p1.lastUpdated >= :date ) AND p.name = :name

But this one fails with a SQLDataException.
SELECT p FROM Person p WHERE  p.name = :name AND p.id IN (SELECT p1.id FROM Person p1 WHERE p1.lastUpdated >= :date )

Assuming that the query is executed something like this : 
        Query query = em.createQuery(query);
        query.setParameter(""name"", ""mike"");
        query.setParameter(""date"", new java.sql.Date(1005397));  

",,,,,,,,,,,,,,,,,,,25/Jul/10 23:18;dirichs;OpenJPA-trunk_OJ1719.testcase.patch;https://issues.apache.org/jira/secure/attachment/12450432/OpenJPA-trunk_OJ1719.testcase.patch,07/Jul/10 15:06;mikedd;sql-cache-subqordering.diff.txt;https://issues.apache.org/jira/secure/attachment/12448882/sql-cache-subqordering.diff.txt,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-07-11 20:09:09.432,,,no_permission,,,,,,,,,,,,161967,,,Mon Sep 20 15:40:00 UTC 2010,,,Patch Available,,,,0|i0zbw7:,204229,,,,,,,,07/Jul/10 15:06;mikedd;Attaching a patch that illustrates the problem using the existing TestPreparedQueryCache testcase. ,11/Jul/10 20:09;fancy;Fix checked in under trunk at revision 963139.,"24/Jul/10 20:02;dirichs;The fix as committed with revision 963139 still has bugs. An IndexOutOfBoundsException
is thrown caused by line 174 in SQLBuffer. Sample stack trace:

java.util.ArrayList.addAll(ArrayList.java:497)
org.apache.openjpa.jdbc.sql.SQLBuffer.append(SQLBuffer.java:174)
org.apache.openjpa.jdbc.sql.SQLBuffer.resolveSubselects(SQLBuffer.java:521)
org.apache.openjpa.jdbc.sql.SQLBuffer.getSQL(SQLBuffer.java:477)
org.apache.openjpa.jdbc.sql.SQLBuffer.getSQL(SQLBuffer.java:467)
org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:563)
org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:543)
org.apache.openjpa.jdbc.sql.SelectImpl.prepareStatement(SelectImpl.java:479)
org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:420)
org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:391)
org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:427)
org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:230)
org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:220)
org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:94)
org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.open(QueryImpl.java:2068)
org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:34)
org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1246)
org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1005)
org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:861)
org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:792)
org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:288)
org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:302) 
... [code outside of OpenJPA)]

The problematic line in context is (lines 169++):

                 if (buf._userIndex != null) {
                     if (_userIndex == null) {
                         _userIndex = new ArrayList();
                         _userIndex.addAll(buf._userIndex);
                     } else
                         _userIndex.addAll(paramIndex*2, buf._userIndex); // Wrong index leads to exception
                 }

These lines could be simplified to

                 if (buf._userIndex != null) {
                     if (_userIndex == null)
                         _userIndex = new ArrayList();
                       _userIndex.addAll(buf._userIndex);
                 }

because it always suffices to append the elements of buf._userIndex
to this._userIndex no matter what the paramIndex is. The structure
of _userIndex is a list where each parameter is already prepended
by its position in the sql buffer. Thus, the order of parameters in
_userIndex is unimportant.

Also, the code in line 184++ seems suspicious:

        if (_userIndex != null) {
            // fix up user parameter index
            for (int i = 0; i < _userIndex.size(); i+=2) {
                _userIndex.set(i, _userParams.indexOf(_userIndex.get(i+1)));
            }
        }

Here, the indizes in _userIndex get corrected by looking into the
_userParams - list, which contains the correct position. Not only
does this implementation rely on a certain equals()-semantic when
using _userParams.indexOf(). As I understand it, the reason for
storing the user parameters in the list _userIndex with
(position, parameter) pairs was that there may be multiple positions
for the same parameter in the resulting statement. Does the
code above really take into account these cases? I've not
tested it, but it looks suspicious. You may have a look at my
patch submitted with OPENJPA-1584 which takes a safer
approach to adjust the positions in _userIndex.

On a side note, I was a bit surprised to see many
if-statements such as in line 131:

        if (sqlIndex == _sql.length())
            _sql.append(buf._sql.toString());
        else
            _sql.insert(sqlIndex, buf._sql.toString());

This test is useless and these lines could just
be replaced with

            _sql.insert(sqlIndex, buf._sql.toString());

A similar if-statement is on line 145:

            if (paramIndex == _params.size()) {
                _params.addAll(buf._params);
                [...] // code that is duplicated below
            } else {
                _params.addAll(paramIndex, buf._params);
                [...] // mere duplication of code above
            }

The resulting code duplication made it more
troublesome than necessary to review this fix.
(Indeed, the reported IndexOutOfBounds-exception
only shows up in one branch of the line 145 if-statement,
making it harder to replicate the bug.)
","24/Jul/10 21:22;fancy;Martin Dirichs,
Could you provide a test case that reproduce the IndexOutOfBoundsException ?

Thanks.","25/Jul/10 17:53;fancy;Some debugging work validates that in what order the parameters are added to _userIndex does not matter, because the positions of the parameters in _userIndex are corrected by look up the Param object  in _userParams.

The current code block in SQLBuffer.java  (lines 169++):
(1)
                 if (buf._userIndex != null) {
                     if (_userIndex == null) {
                         _userIndex = new ArrayList();
                         _userIndex.addAll(buf._userIndex);
                     } else
                         _userIndex.addAll(paramIndex*2, buf._userIndex); // Wrong index leads to exception
                 }

Can be simplified to
(2)
                 if (buf._userIndex != null) {
                     if (_userIndex == null)
                          _userIndex = new ArrayList();
                      _userIndex.addAll(buf._userIndex);
                 } 

There should be no IndexOutOfBoundException in (1). but (2) is more simplified code.

","25/Jul/10 23:18;dirichs;You find a test case attached in file OpenJPA-trunk_OJ1719.testcase.patch.

Yes, with lines 172-174 simplified the code should work correctly.

Perhaps you also find value in my objections to code safety and code duplication stated above.","26/Jul/10 06:48;fancy;Martin,
Thank you very much for the test case, it produced the IndexOutOfBoundException.
I will commit the fix soon.","26/Jul/10 15:42;fancy;Fix checked in under trunk revision 979326.
Mike,
Could you please apply  the same fix  to 2.0.x branch ?
Thanks","20/Sep/10 15:40;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,
Multiple @OneToMany relations with common supertype are incorrectly fetched when using InheritanceType.JOINED ,OPENJPA-1718,12468723,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,prademak,prademak,07/Jul/10 15:01,13/Jul/10 12:41,14/Mar/19 03:03,13/Jul/10 12:40,2.0.0,,,,,,,,,,,,,,,,,0,,,,,,,,"I have an entity ""Event"" which has two @OneToMany relations with two entities ""Appointment"" and ""Activity"" which both have the same superclass ""Booking"".

After saving an Event with 1 Activity and 1 Appointment and retrieving it using find, the Event is returned with 2 (!) Activities and  1 Appointment.  One of these Activities seems
to contain the data of the Appointment.

I noticed that two things both seem to make it work as excepted: 
   (1) change the @Inheritance strategy to one of InheritanceType.SINGLE_TABLE or InheritanceType.TABLE_PER_CLASS
   (2) remove the @Version field from ""Event""



These are the entity configurations:  

@Entity
public final class Event  {
	@Id
	@GeneratedValue
	protected Long id;
	@Version
	protected Integer version;

	@OneToMany(cascade = ALL, mappedBy = ""event"", fetch = FetchType.EAGER)
	private List<Activity> activities = new ArrayList<Activity>();

	@OneToMany(cascade = ALL, mappedBy = ""event"", fetch = FetchType.EAGER)
	private List<Appointment> appointments = new ArrayList<Appointment>();
     ...
}

@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public class Booking {
	@Id
	@GeneratedValue
	protected Long id;

	@ManyToOne(optional = true, cascade = ALL, fetch = FetchType.EAGER)
	protected Event event;
	
	@Basic(fetch = FetchType.EAGER)
	public String name;
        ...
}

@Entity
public final class Activity extends Booking {
  ...
}

@Entity
public final class Appointment extends Booking {
  ...
}


This is the ""test"" which illustrates the problem:


public static void main(String[] args) {
		Event event = new Event();
		
		Appointment appointment = new Appointment(""APPOINTMENT"");
		appointment.setEvent(event);
		event.addAppointment(appointment);
		Activity activity = new Activity(""ACTIVITY"");
		activity.setEvent(event);
		event.addActivity(activity);
		
		System.out.println(""#activities before saving: "" + event.getActivities().size());
		System.out.println(""#appointments before saving: "" +  event.getAppointments().size());
		
		Event saved = save(event);
		System.out.println(""#activities after saving: "" + saved.getActivities().size());
		System.out.println(""#appointments after saving: "" + saved.getAppointments().size());
		
		Event found =  find(saved.getId());
		System.out.println(""#activities after find: "" + found.getActivities().size());
		System.out.println(""#appointments after find: "" + found.getAppointments().size());
	}
	
	private static Event save(Event entity) {
		entityManager.getTransaction().begin();
		Event result = entityManager.merge(entity);
		entityManager.getTransaction().commit();
		return result;
	}
	
	private static Event find(long id) {
		entityManager.getTransaction().begin();
		Event result = entityManager.find(Event.class, id);
		entityManager.getTransaction().commit();
		return result;
	}
	
	static OpenJPAEntityManager entityManager = (OpenJPAEntityManager) Persistence.createEntityManagerFactory(
			""openjpa_test"", System.getProperties()).createEntityManager();



I've attached all the files in a zip.

",,,,,,,,,,,,,,,,,,,07/Jul/10 15:51;prademak;onetomany.zip;https://issues.apache.org/jira/secure/attachment/12448886/onetomany.zip,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161966,,,Tue Jul 13 12:40:26 UTC 2010,,,,,,,0|i0zbvb:,204225,,,,,,,,"13/Jul/10 12:40;prademak;Our apologies, we found out that it was a user problem on our side, next time we will report on the user mailing first.
The problem was that we had to configure a @DiscriminatorColumn.


",,,,,,,,,,,,,,,,,,,,,,,,,,
Consider openjpa.Optimistic setting when calculating the default lock mode to apply to a named query,OPENJPA-1714,12468294,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,rgcurtis,rgcurtis,30/Jun/10 20:55,20/Sep/10 15:39,14/Mar/19 03:03,16/Aug/10 21:25,2.0.0,,,,,,,,2.0.1,,,,,,,,,0,,,,,,,,See OPENJPA-1604 for background. ,,,,,,,,,,,,,,,,,,,30/Jun/10 21:02;mikedd;OPENJPA-1714_2.0.x.patch;https://issues.apache.org/jira/secure/attachment/12448448/OPENJPA-1714_2.0.x.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-06-30 21:02:18.493,,,no_permission,,,,,,,,,,,,161964,,,Mon Sep 20 15:39:59 UTC 2010,,,,,,,0|i0z8g7:,203671,,,,,,,,30/Jun/10 21:02;mikedd;Attaching (renamed) patch from Jeremy Bauer. Jeremy originally granted a license to the ASF for inclusion in ASF works. ,"20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,,
OutOfMemory caused by EntityManagerImpl.push/popFetchPlan processing,OPENJPA-1713,12468262,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,30/Jun/10 15:29,09/Aug/10 21:35,14/Mar/19 03:03,09/Aug/10 21:32,1.1.0,1.2.2,2.0.0,,,,,,2.0.1,2.1.0,,,,kernel,,,,0,,,,,,,,"There is a leak in memory in the EntityManagerImpl push/popFetchPlan processing where fetch plan associated with the current fetch configuration is add to the _plans IdentityHashMap but never remove from it. 

    private Map<FetchConfiguration,FetchPlan> _plans = new IdentityHashMap<FetchConfiguration,FetchPlan>(1);

    public FetchPlan getFetchPlan() {
        assertNotCloseInvoked();
        _broker.lock();
        try {
            FetchConfiguration fc = _broker.getFetchConfiguration();
            FetchPlan fp = _plans.get(fc);
            if (fp == null) {
                fp = _emf.toFetchPlan(_broker, fc);
                _plans.put(fc, fp);                         <<< added to _plans
            }
            return fp;
        } finally {
            _broker.unlock();
        }
    }

    public FetchPlan pushFetchPlan() {
        assertNotCloseInvoked();
        _broker.lock();
        try {
            _broker.pushFetchConfiguration();
            return getFetchPlan();
        } finally {
            _broker.unlock();
        }
    }

    public void popFetchPlan() {
        assertNotCloseInvoked();
        _broker.lock();
        try {
            _broker.popFetchConfiguration();      <<< but never remove when the fetch plan is popped.
        } finally {
            _broker.unlock();
        }
    }

The only time _plans is cleaned up are during clear() or closed().
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-07-06 21:33:48.963,,,no_permission,,,,,,,,,,,,161963,,,Mon Aug 09 20:57:37 UTC 2010,,,,,,,0|i0z3xj:,202939,,,,,,,,06/Jul/10 21:33;mikedd;Targeting for 2.0.1.,09/Aug/10 20:57;drwoods;Is this ready to mark as resolved for 2.0.1 and trunk?  No activity since July 7th.....,,,,,,,,,,,,,,,,,,,,,,,,,
OpenJPA generates ABSTIME for a TIMESTAMP field for Postgres 8.4,OPENJPA-1710,12468078,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,bigmountainben,bigmountainben,28/Jun/10 18:36,13/Jul/11 16:11,14/Mar/19 03:03,27/Apr/11 17:33,2.0.0,,,,,,,,2.1.0,,,,,tooling,,,,0,,,,,,,,"The mapping tool (openjpa:sql maven target) generates a column of type ABSTIME on Postgres 8.4. This is wrong because
1. ABSTIME is deprecated and
2. ABSTIME has a resolution of 1s.

It should be TIMESTAMP.

The workaround is to specify

            <property name=""openjpa.jdbc.DBDictionary"" value=""TimestampTypeName=TIMESTAMP"" />

in your persistence.xml","Mac OS X, JDK 6, OpenJPA 2.0",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-04-27 17:33:11.441,,,no_permission,,,,,,,,,,,,68157,,,Wed Apr 27 17:33:11 UTC 2011,,,,,,,0|i0z0pj:,202417,,,,,,,,27/Apr/11 17:33;mikedd;Fixed in OPENJPA-1726,,,,,,,,,,,,,,,,,,,,,,,,,,
PCEnhancer incorrectly generates readExternal ,OPENJPA-1704,12467493,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,21/Jun/10 15:26,09/Feb/11 15:13,14/Mar/19 03:03,19/Jul/10 21:23,1.2.2,2.0.0,2.1.0,,,,,,1.2.3,2.0.1,2.1.0,,,kernel,,,,0,,,,,,,,"OPENJPA-1400 introduced a bug that can be encountered when reading a streamed object under the following circumstances:
- Using a serializable DetachedStateManager  (<property name=""openjpa.DetachState"" value=""fetch-groups(DetachedStateField=true)""/>) 
- The Entity needs to have a version field AND either:
  - If no inheritance, a 'proxyable' (ie: java.sql.Date, java.util.List) field with a name that is lexicographically after the version field.
  - If using inheritance, a 'proxyable' (ie: java.sql.Date, java.util.List) field in a child class.

The bug could manifest itself in a number of ways. Below is the one I was able to reproduce.
java.lang.IllegalArgumentException
	at org.apache.openjpa.persistence.inheritance.serializable.A.pcProvideField(A.java)
	at org.apache.openjpa.kernel.DetachedStateManager.proxyDetachedDeserialized(DetachedStateManager.java:438)
	at org.apache.openjpa.persistence.inheritance.serializable.A.readExternal(A.java)
	at java.io.ObjectInputStream.readExternalData(ObjectInputStream.java:1792)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1751)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1329)
	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:351)
	at org.apache.openjpa.persistence.inheritance.serializable.TestSerialization.serializeObject(TestSerialization.java:105)
	at org.apache.openjpa.persistence.inheritance.serializable.TestSerialization.testRoundTrip(TestSerialization.java:48)
	...",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161955,,,2010-06-21 15:26:03.0,,,,,,,0|i0z613:,203279,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Calling em.refresh(...) causes a WARNING message to be logged,OPENJPA-1701,12467032,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,15/Jun/10 20:44,20/Sep/10 15:39,14/Mar/19 03:03,24/Jun/10 20:44,2.1.0,,,,,,,,2.1.0,,,,,jpa,,,,0,,,,,,,,,"A nice 'feature' was added in revision 929744 which results in a WARNING being logged [1] every time em.refresh(..) is called. It appears that in that revision the default value for cacheRetrieveMode in FetchConfiguration was changed from NULL to USE.  

I haven't spent enough time looking at the code yet to figure out if the proper solution is to remove the warning, or made the default NULL again.

[1] WARN   [main] openjpa.Runtime - The setting of CacheRetrieveMode.USE is ignored and set to BYPASS for refresh operation.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:39:58.212,,,no_permission,,,,,,,,,,,,161952,,,Mon Sep 20 15:39:58 UTC 2010,,,,,,,0|i0z8jz:,203688,,,,,,,,"24/Jun/10 20:36;curtisr7;I found in my testing that if I call em.refresh() and <CacheRetrieveMode> is unspecified, or is set to USE the warning message is logged. In an application that calls em.refresh often this would flood their logs with useless messages. I mulled over the idea of changing the message from a WARNING to TRACE, but even as a developer I don't think this message would be of much use.",24/Jun/10 20:44;curtisr7;Committed revision 957709 to trunk.,"20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,
A EnumValueHandler strategy along with XmlType annotation incorrectly mapped to  XmlType  in create table DDL,OPENJPA-1697,12466817,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,12/Jun/10 15:18,08/Sep/11 12:17,14/Mar/19 03:03,22/Jun/10 19:36,2.1.0,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,"@Entity
@Table(name=""authority"")
@NamedQueries( {
               @NamedQuery(name = ""AllIonAuthorities"", query = ""SELECT x FROM IonAuthority x"")
})
public class Authority {
@Id
       @GeneratedValue(strategy = GenerationType.AUTO)
       @Column(name = ""ID"")
       private Integer id;

       @Enumerated( EnumType.STRING )
       @Column(nullable=false, length=128, updatable=true, insertable=true)
       @Persistent
       @Strategy(""org.apache.openjpa.jdbc.meta.strats.EnumValueHandler"")
       private AuthorityValues authorityName;


-----------

@XmlType(name = ""IonAuthorityValues"")
@XmlEnum
public enum AuthorityValues {

   AUTH1,
   AUTH2,


Stacktrace:

Caused by: <openjpa-2.1.0-SNAPSHOT-r422266:953182M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: ORA-00907: missing right parenthesis
 {stmnt 13803851 CREATE TABLE authority (ID NUMBER NOT NULL, authorityName XMLType(128) NOT NULL, PRIMARY KEY (ID))} [code=907, state=42000]
       at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:556)
       at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:456)
       at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:155)
       at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:159)
       at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:117)
       at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:199)
       at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:156)
       at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:213)
       at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:151)
       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
       at java.lang.reflect.Method.invoke(Method.java:597)
       at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.invokeProxyMethod(AbstractEntityManagerFactoryBean.java:423)
       at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$ManagedEntityManagerFactoryInvocationHandler.invoke(AbstractEntityManagerFactoryBean.java:485)
       at $Proxy20.createEntityManager(Unknown Source)
       at com.iontrading.ionweb.persistence.SchemaCreationHandler.start(SchemaCreationHandler.java:181)
       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
       at java.lang.reflect.Method.invoke(Method.java:597)
       at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1536)
       at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1477)
       at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1409)
       ... 27 more
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: ORA-00907: missing right parenthesis
 {stmnt 13803851 CREATE TABLE ion_authority (ID NUMBER NOT NULL, authorityName XMLType(128) NOT NULL, PRIMARY KEY (ID))} [code=907, state=42000]

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:39:57.876,,,no_permission,,,,,,,,,,,,61923,,,Mon Sep 20 15:39:57 UTC 2010,,,,,,,0|i0z91z:,203769,,,,,,,,13/Jun/10 05:09;fancy;This problem is not unique to Oracle.,"20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,,
Type discriminator for polymorphic queries limited to Single Table inheritance,OPENJPA-1696,12466801,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,12/Jun/10 02:27,20/Sep/10 15:39,14/Mar/19 03:03,24/Jul/10 16:25,2.0.0,,,,,,,,2.1.0,,,,,query,,,,0,,,,,,,,"JPA2.0 spec defines TYPE discriminator which can be used in JPQL query to return polymorphic query results. The spec is unclear that the TYPE discriminator is for Single table inheritance or it can be used for Table per class or inheritance type Joined or not.
The initial implementation in OpenJPA has limited it for Single Table inheritance, but it does not block the usage for the other 2 types of inheritance.
This resulting incorrect SQL generated and SQLExceptions.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:39:57.559,,,no_permission,,,,,,,,,,,,161948,,,Mon Sep 20 15:39:57 UTC 2010,,,,,,,0|i0z8en:,203664,,,,,,,,"20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,,,
OutOfMemoryError from CacheMarshallerImpl.setInputUrlFromResourceLocation.,OPENJPA-1695,12466780,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,rpalache,rpalache,rpalache,11/Jun/10 21:43,21/Sep/16 14:21,14/Mar/19 03:03,15/Jun/10 18:25,1.1.0,2.0.0,2.1.0,,,,,,1.2.0,2.1.0,,,,,,,,0,,,,,,,,"Caused By: <openjpa-1.1.1-SNAPSHOT-r422266:930378 fatal internal error> 
org.apache.openjpa.util.InternalException: There was an error when invoking the static getInstance method on the named factory class 
""org.apache.openjpa.abstractstore.AbstractStoreBrokerFactory"".  See the nested exception for details. 
    at org.apache.openjpa.kernel.Bootstrap.getBrokerFactory(Bootstrap.java:95) 
    at kodo.jdo.PersistenceManagerFactoryImpl.getPersistenceManagerFactory(PersistenceManagerFactoryImpl.java:41) 
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 
    at java.lang.reflect.Method.invoke(Method.java:597) 
    at javax.jdo.JDOHelper.getPersistenceManagerFactory(JDOHelper.java:534) 

caused by 

java.lang.OutOfMemoryError: Java heap space 
    at java.util.Arrays.copyOf(Arrays.java:2760) 
    at java.util.Arrays.copyOf(Arrays.java:2734) 
    at java.util.ArrayList.ensureCapacity(ArrayList.java:167) 
    at java.util.ArrayList.add(ArrayList.java:351) 
    at org.apache.openjpa.conf.CacheMarshallerImpl.setInputUrlFromResourceLocation(CacheMarshallerImpl.java:226) 
    at org.apache.openjpa.conf.CacheMarshallerImpl.endConfiguration(CacheMarshallerImpl.java:207) 
    at org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:505) 
    at org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:430) 
    at org.apache.openjpa.lib.conf.PluginListValue.instantiate(PluginListValue.java:93) 
    at org.apache.openjpa.conf.CacheMarshallersValue.instantiate(CacheMarshallersValue.java:60) 
    at org.apache.openjpa.lib.conf.ObjectValue.instantiate(ObjectValue.java:83) 
    at org.apache.openjpa.conf.CacheMarshallersValue.initialize(CacheMarshallersValue.java:117) 
    at org.apache.openjpa.conf.CacheMarshallersValue.getMarshallerById(CacheMarshallersValue.java:81) 
    at org.apache.openjpa.conf.CacheMarshallersValue.getMarshallerById(CacheMarshallersValue.java:108) 
    at org.apache.openjpa.conf.MetaDataRepositoryValue.instantiate(MetaDataRepositoryValue.java:54) 
    at org.apache.openjpa.lib.conf.ObjectValue.instantiate(ObjectValue.java:83) 
    at org.apache.openjpa.conf.OpenJPAConfigurationImpl.newMetaDataRepositoryInstance(OpenJPAConfigurationImpl.java:843) 
    at org.apache.openjpa.conf.OpenJPAConfigurationImpl.getMetaDataRepositoryInstance(OpenJPAConfigurationImpl.java:834) 
    at org.apache.openjpa.kernel.AbstractBrokerFactory.makeReadOnly(AbstractBrokerFactory.java:638) 
    at org.apache.openjpa.kernel.AbstractBrokerFactory.pool(AbstractBrokerFactory.java:131) 
    at org.apache.openjpa.abstractstore.AbstractStoreBrokerFactory.getInstance(AbstractStoreBrokerFactory.java:83) 
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 
    at java.lang.reflect.Method.invoke(Method.java:597) 
    at org.apache.openjpa.kernel.Bootstrap.invokeFactory(Bootstrap.java:124) 
    at org.apache.openjpa.kernel.Bootstrap.getBrokerFactory(Bootstrap.java:90) ",,,,,,,,,,,,,,,,,,,11/Jun/10 21:57;rpalache;OPENJPA-1695-11x.patch;https://issues.apache.org/jira/secure/attachment/12446910/OPENJPA-1695-11x.patch,11/Jun/10 21:46;rpalache;OPENJPA-1695-trunk.patch;https://issues.apache.org/jira/secure/attachment/12446908/OPENJPA-1695-trunk.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-06-15 18:30:25.619,,,no_permission,,,,,,,,,,,,38715,,,Fri Nov 18 11:00:04 UTC 2011,,,Patch Available,,,,0|i1dtpb:,288909,,,,,,,,"14/Jun/10 20:01;rpalache;This bug is introduced by openJPA change :

r657162 | pcl | 2008-05-16 12:40:46 -0600 (Fri, 16 May 2008) | 1 line
Make the CacheMarshallerImpl a bit more tolerant to different configurations.",15/Jun/10 18:30;curtisr7;Update fix / affects version fields.,"20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ","18/Nov/11 11:00;fabiand_88;Hi,
I getting the below error ""Caused By: <openjpa-1.1.1-SNAPSHOT-r422266:930378 fatal internal error>
org.apache.openjpa.util.InternalException: There was an error when invoking the static getInstance method on the named factory class""

I understood this is a bug..But how should i fix it??Please help..Im facing this problem on production server (after i installed fusion middleware 11g on solaris Sparc)

Regards
Fabian",,,,,,,,,,,,,,,,,,,,,,,
Add post creation callback to BrokerFactory,OPENJPA-1692,12466693,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,10/Jun/10 21:59,11/Oct/10 16:18,14/Mar/19 03:03,11/Oct/10 16:18,2.0.0,2.1.0,,,,,,,2.1.0,,,,,kernel,,,,0,,,,,,,,"There have been a couple instances (that come to my mind) where there was the need to do some work after creating the broker factory. Sometimes there is a necessity to ensure single threadedness @see (PersistenceProviderImpl.postBrokerFactoryInitialization(...)), other times we need to perform some additional configuration / initialization after the BrokerFactory has completed (openjpa.InitializeEagerly=true). 

I recently ran across a problem with the second case. In AbstractBrokerFactory.ctor(...) we attempt to create a broker even though the subclassed BrokerFactory hasn't able to execute it's constructor.

Example pseudo code:

abstract class AbstractBrokerFactory {
	AbstractBrokerFactory(Config c){
		// setup
		if(InitializeEagerly==true)
			this.newBroker(); <-- BAD! The subclass hasn't executed it's constructor but it may be asked to create a new broker.
	}		
}

class ConcreteBrokerFactory extends AbstractBrokerFactory {
	Config _conf;
	ConcreteBrokerFactory (Config c){
		super(c);
		// setup
		_conf = c;
	}
	newBroker(){
		_conf.getSomething(); <-- _conf IS NULL because the constructor hasn't fully executed yet.
	}
}

I propose that we need a postCreationCallBack method on the BrokerFactory interface. This will be a single place that Bootstrap can drive this 'after creation ish' work.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-06-10 22:44:07.022,,,no_permission,,,,,,,,,,,,161945,,,Mon Oct 11 16:18:18 UTC 2010,,,,,,,0|i0z3nz:,202896,,,,,,,,"10/Jun/10 22:44;ppoddar@apache.org;This is an useful suggestion. The other usage of such post-initialization method hooks can be leveraged to construct some critical internal data structures (e.g. MetaDataRepository) that are often immutable after initialization. One can initialize these structures with thread guards and then drop the guards for entire lifetime. This pattern will provide an opportunity to scale/perform faster in multi-core environment.     
JPA does provide indicators such as <metadata-complete> etc to make such pattern. ",11/Jun/10 17:51;curtisr7;My previous commit will regress OPENJPA-1491. Refactoring some code right now to take that problem into account.,11/Jun/10 19:20;curtisr7;Update fix version.,"11/Jun/10 19:21;curtisr7;@Pinaki -- Great point, but I want to keep this JIRA focused on properly designing the infrastructure for post creation callbacks and moving existing dependent code.

I opened OPENJPA-1694 as a defect for us to be more intelligent about when we can eagerly load metadata. Perhaps when doing this work we will discover that there are other cases where it makes sense to remove some of the laziness of OpenJPA for the sake of scalability.",06/Jul/10 20:06;curtisr7;Reopening this issue while I investigate some test failures.,11/Oct/10 16:18;curtisr7;Closing this JIRA as the original issue has been resolved. Will handle problem with the DataCacheManager initialization with OPENJPA-1705.,,,,,,,,,,,,,,,,,,,,,
Oracle XMLType column failed to insert/update when xml contains more than 4000 characters,OPENJPA-1691,12466672,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,milosz,kailaw,kailaw,10/Jun/10 17:31,07/Dec/18 16:24,14/Mar/19 03:03,27/Jul/11 18:39,1.2.2,2.0.0,2.0.1,,,,,,1.2.3,1.3.0,2.0.2,2.1.0,,sql,,,,0,openjpa,oracle,xmltype,,,,,"Oracle throws the following exception when XML content is greater than 4000 characters:
ORA-01461: can bind a LONG value only for insert into a LONG column","Oracle 10g, JDBC driver (ojdbc14.jar) 10.2.0.4.0, OpenJPA 1.2.2",,,,,,,,,,,,,,,,,,06/Jul/11 21:12;techhusky;OPENJPA-1691.1.2.x.patch;https://issues.apache.org/jira/secure/attachment/12485487/OPENJPA-1691.1.2.x.patch,06/Jul/11 20:39;techhusky;OPENJPA-1691_2.0.x.patch;https://issues.apache.org/jira/secure/attachment/12485482/OPENJPA-1691_2.0.x.patch,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-06-13 08:56:22.922,,,no_permission,,,,,,,,,,,,2512,,,Fri Dec 07 16:24:43 UTC 2018,,,,,,,0|i0zbuv:,204223,,,,,,,,"13/Jun/10 08:56;milosz;Some work notes:

Neither PreparedStatement.setCharacterStream(int, Reader, int) nor OraclePreparedStatement.setStringForClob(int, String) helps here.
So far I have found two methods that seem to work with data over 4000 chars:

a)
1. Prepare a statement using XMLType constructor ""insert into TORDERXML values(?, ?, ?, XMLType(?), ?, ?, ?)"" 
2. Set the value by using PreparedStatement.setClob(int, Reader). This requires JDBC 4 (JDK 6). Tried with 11.2.0.1 driver.

b)
1. Prepare a statement using XMLType constructor ""insert into TORDERXML values(?, ?, ?, XMLType(?), ?, ?, ?)"" 
2. Create a temporary CLOB, fill it with XML data (similarly to [1]) and use PreparedStatement.setClob(int, Clob) or PreparedStatement.setObject(int, Object). This requires using Oracle-specific API and the temporary CLOB should be freed after statement execution. This works with 10.2.0.4 driver but 11.2.0.1 throws a bunch of ORAs:
ORA-31011: XML parsing failed
ORA-19202: Error occurred in XML processing
LPX-00229: input source is empty
Error at line 0
ORA-06512: at ""SYS.XMLTYPE"", line 254
ORA-06512: at line 1

Neither method is a workaround for users to be applied solely in DBDictionary but requires a patch.

Kelvin, which JDK are you using?

[1] http://www.oracle.com/technology/sample_code/tech/java/codesnippet/xmldb/Example_Code.html#createclob
","14/Jun/10 13:23;kailaw;Hi Milosz,

I am using Sun JDK 1.5.0_22","03/Oct/10 21:00;milosz;The fix requires a JDBC 4 driver. There are still issues when querying over long individual XML nodes coming from obscure limits in Oracle's extractValue() function.

Note that reading XML values longer than 4000 bytes was also broken - replaced getStringVal() calls with getClobVal().

As a side effect users gained a bit of control on INSERT/UPDATE statements in DBDictionary.getMarkerForInsertUpdate method. One can do things like INSERT INTO tab(id, uppercased_name) VALUES (?, UPPER(?)).
",13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,19/Apr/11 17:38;mjarends;This issue also affects the 2.0.2 builds as well. Is there a known workaround for this issue for the 2.0.2 release?,"20/Apr/11 11:05;milosz;Mitchell, you can fix reading of XML values by extending the OracleDictionary and setting the getStringVal property to "".getClobVal()"".

For insert/update, I am afraid there might be no workaround or one is not easy. First, in your extended OracleDictionary you overrride setClobString method to use the JDBC 4 variant of setClob mentioned above. Second, you provide your own UpdateManager via openjpa.jdbc.UpdateManager property and somehow make it use your own implementation of Row interface to emit ""XMLType(?)"" in INSERT and UPDATEs.

See also a thread on users list [1] and let us know if you succeed.

[1] http://openjpa.208410.n2.nabble.com/Oracle-XMLType-fetch-problems-td6208344.html#a6252836",23/May/11 16:47;techhusky;Re-opening to post a patch for pre-2.1.x releases.,"23/May/11 16:58;techhusky;The fix for this issue in 2.1.0 involved full JDBC 4.0-level support within OpenJPA.  This is not possible on releases prior to 2.1.0 since they support Java 1.5. Thus, the same fix for this issue is not possible on pre-2.1.x releases.  Using reflection, I was able to produce a patch that works with prior releases and still compiles and works with Java 1.5.  The code reflectively calls JDBC 4.0 methods to set the XML value as a clob input reader.  JRE 1.6 and an Oracle 1.6 (ojdbc6.jar) are required.  In addition, the OracleDictionary supportsSetClob value must be set to true in order to enable the support.  If DBCP is used, at least DBCP 1.4 is required since it supports call-thru of JDBC 4.0 connection and prepared statement methods.",23/May/11 17:06;techhusky;Attached patch for 1.2.x stream,06/Jul/11 20:39;techhusky;Attached patch for 2.0.x.,"17/Aug/11 16:27;jpaheath;I'd like to add a few more details about the code changes made to 1.2.x and 2.0.x.  These details are in addition to the previous (and vitally important) details added by Jeremy.  In addition to his requirements, it should be noted that the code changes made in this JIRA are gated (enabled/disabled) via a system property.  The system property is named 'supportsSetClob' and is defined on the Oracle dictionary class.  As an example, the property can be defined as follows:

<property name=""openjpa.jdbc.DBDictionary"" value=""oracle(supportsSetClob=true)""/>           


Next, it should be noted that we expect the XML field(s) to be annotated with:                 
                                                                        
@Strategy(""org.apache.openjpa.jdbc.meta.strats.XMLValueHandler"")        
                                                                        
This allows a user to indicate that OpenJPA should use JAXB classmetadata to perform the to/from database value retrieval and storage.  In addition, using this strategy indicates there is an XMLType used to store the value in the database.  Instead, we've seen customers attempt to managing their own XML string, mapped to a string field, and expect the code changes of this JIRA to apply.  While a user has an XMLType specified in the column definition, OpenJPA cannot count on this data to detect whether the column is really an XML column in the database (the table could have been created manually with separate DDL instead of using OpenJPA's mapping tool).  
In this case, where the user is doing their own String mapping rather than using the XMLValueHandler, there are some additional settings a user may need to set/enable in order to resolve the issue addressed in this JIRA.  The necessary settings/actions are as follows:

First, it may be necessary to annotate an XML field with @Lob, as follows:                                                        
                                                                        
@Lob                                                                    
@Column(name=""CONTENTS_XML"", columnDefinition =""XMLCOLUMN XMLType"") 
private String contentsXml;                                            
                                                                        
Second, in addition to annotating the XML field with @Lob, a user may also need to set this dictionary property:                                                               
                                                                        
maxEmbeddedClobSize=-1                                                  
                                                                        
Therefore, the final DBDictionary property would be:
                                                                        
<property name=""openjpa.jdbc.DBDictionary"" value=""oracle(supportsSetClob=true,maxEmbeddedClobSize=-1)""/>           
                                                                       
                                                                         
Finally, a user may need to use the native schema factory to pick up the XMLType from the database, that property is as follows:                
                                                                        
<property name=""openjpa.jdbc.SchemaFactory"" value=""native""/>            

By enabling OpenJPA's native schema factory, the database column type can be detected as XMLType.","07/Dec/18 16:24;nezih;Hi,

I tried to apply instructions recommended by Heath Thomann but with no success. something is missing to tell OpenJpa that the column is xml.
",,,,,,,,,,,,,,,
DistinctResultList is not Serializable,OPENJPA-1690,12466570,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,ppoddar@apache.org,prademak,prademak,09/Jun/10 14:30,20/Sep/10 15:39,14/Mar/19 03:03,09/Jun/10 21:23,2.0.0,,,,,,,,2.0.1,2.1.0,,,,query,,,,0,,,,,,,,"As far as I have experienced the return types of getResultList() seem to be Serializable, therefore I would expect the same for org.apache.openjpa.kernel.DistinctResultList.
This does not seem to be the case, since I broke my remotely exposed DAO method by adding the DISTINCT keyword to the query it executes.

I can easily work around this by returning a new list based on the DistinctResultList, but to me this occurs as a minor inconsistency.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:39:56.71,,,no_permission,,,,,,,,,,,,161944,,,Mon Sep 20 15:39:56 UTC 2010,,,,,,,0|i1dtpz:,288912,,,,,,,,"20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,,,
The mapping tool does not remove user created sequences on PostgreSQL,OPENJPA-1689,12466563,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,techhusky,techhusky,techhusky,09/Jun/10 13:37,06/May/12 15:38,14/Mar/19 03:03,24/Jun/10 21:17,2.0.0,,,,,,,,2.1.0,,,,,jdbc,,,,0,,,,,,,,"As reported on the users forum:

<Christopher Schmidt>
Hi all, using OpenJPA 2.0.0 with Postgresql 8.4 JDBC4

I want to create the schema with the following property:
<property name=""openjpa.jdbc.SynchronizeMappings""
value=""buildSchema(SchemaAction='drop,add')""/>

The entity is defined as follows:

@Entity
@Table(name = ""obj_item"")
@Inheritance(strategy = InheritanceType.JOINED)
@SequenceGenerator(name = ""obj_item_id_seq"", sequenceName =
""obj_item_id_seq"", allocationSize = 1)
class ObjectItem ...

it seems that the sequence will not be dropped - so I get the
following exception:
org.apache.openjpa.persistence.PersistenceException: ERROR: relation
""obj_item_id_seq"" already exists {stmnt 1834517285 CREATE SEQUENCE
obj_item_id_seq START WITH 1} [code=0, state=42P07]
       at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:556)...
</Christopher Schmidt>

<Jeremy Bauer>
As it turns out, I don't think this problem is the same as OPENJPA-1259.  There is special code in the PostgresDictionary that treats sequences suffixed with ""_SEQ"" as system managed sequences.  The comment in PostgresDictionary.isSystemSequence reads:

        // filter out generated sequences used for bigserial cols, which are
        // of the form <table>_<col>_seq

This explains why the same code worked for me on DB2.  Are you able to modify the sequence name?  (ex. sequenceName = ""seq_obj_item_id"")  If not, please file a new JIRA.   It may/should be possible to make the code a bit smarter by actually verifying _seq suffixed sequences are for a bigserial column[1] instead of just making the assumption.

[1] http://www.postgresql.org/docs/8.4/static/datatype-numeric.html#DATATYPE-SERIAL
</Jeremy Bauer>

I have a simple testcase that demonstrates the problem and only spent a very brief amount of time looking into a fix.  Ideally, OpenJPA should be able to identify user created vs. system created sequences with suffix ""_seq"" and behave appropriately.",PostgreSQL 8.4,,,,,,,,,,,,,OPENJPA-2005,,,,,11/Jun/10 18:47;techhusky;OPENJPA-1689_test.patch;https://issues.apache.org/jira/secure/attachment/12446888/OPENJPA-1689_test.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:39:56.322,,,no_permission,,,,,,,,,,,,161943,,,Mon Sep 20 15:39:56 UTC 2010,,,,,,,0|i1dtq7:,288913,,,,,,,,11/Jun/10 18:47;techhusky;Attaching junit that demonstrates this issue.,"24/Jun/10 21:17;techhusky;I added a fix that will correct this issue in most cases.  There is still some quirkiness if/when table or column names contain underscores.  The code makes an attempt at resolving owned sequences in that case, but it could incorrectly identify a sequence as a db owned sequence.  If that happens, the sequence will not get removed during the drop phase.  Still, the best solution is to not create sequences suffixed with _seq, if possible.","20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,
Persistence of Dynamic and Generic Type,OPENJPA-1686,12466413,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,08/Jun/10 01:49,21/Sep/11 15:09,14/Mar/19 03:03,21/Sep/11 15:09,,,,,,,,,2.1.2,2.2.0,,,,,,,,0,,,,,,,,"Persistence of semi-structured data has attracted lot of attention lately -- especially for web centric applications where flexibility/malleability of data structure trumps the benefits of strongly-typed, schema-oriented relational database.

OpenJPA as a leading object persistence solution must have a comprehensive story (or may be epic in Agile nomenclature is more appropriate for this issue) for persistence of semi-structured data.

This umbrella issue will explore two major aspects of this broad technical problem

a) Mapping semi-structured data to Relational database 
b) Mapping semi-structured data to non-Relational database


Mapping semi-structured data to Relational database:
    OpenJPA has traditionally offered various degree of type support for persistent data -- starting from the decalred persistent type such as @Entity to the weakest namely a serialized blob. The capability of interest in this regard is the support of the intermediate form between these extremes where a persistent state/relation can be declared merely as persistce capable instead of its exact type. This support is also relevant for generic types where the exact type is only known at run-time instance at design time. 
    
   OpenJPA documentation and examples of this feature had been thin -- and hence less exeercised. Moreover, I believe that this support has regressed while introducing numerous new feature for JPA 2.0. So one aspect of this issue will explore the extent of support for persistence capable types and document them appropriately.

   A simple and commonly used way to model a dynamic data structure is name-value pair. However, this simple Java modeling technique has several alternatives to be mapped into a relation database. One component of this issue will explore 
OpenJPA's support for persisting and querying name-value pairs and document them for future usage as many forum users have raised technical question or expressed interest in name-value pairs. 


Mapping semi-structured data to non-Relational database
  The current surge of interest in this area also has revived an ancient discussion -- what is the applicability/advantage of non-relational data store? Several interesting non-relational databases such as BigTable, Cassandra, HBase, MongoDB, neo4j had proven their merits and been widely investigated. OpenJPA is uniquely capable to integrate JPA application model on top of these non-relational databases. Because OpenJPA architecture cleanly distinguished between object life cycle management and data store interaction and query expressions (in its early days -- OpenJPA developed an interface to a object database). The second aspect of this issue will explore this option by developing a connector to one (or more, if time permits) non-relational database(s).  

   ",,180,180,,0%,180,180,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-09-21 15:09:08.162,,,no_permission,,,,,,,,,,,,59910,,,Wed Sep 21 15:09:08 UTC 2011,,,,,,,0|i0zbvr:,204227,,,,,,,,"21/Sep/11 15:09;mikedd;Closing issues which have code changes and have not been modified for a while. 

If there is more work to be done for this issue please check whether it has already been included in an OpenJPA release. 

If the changes are in an OpenJPA release please open a new issue and link to this one. 

If the changes are not in an OpenJPA release you may reopen this issue or create a new issue. ",,,,,,,,,,,,,,,,,,,,,,,,,,
Comma delimited validation groups defined in persistence.xml do not handle whitespace,OPENJPA-1685,12466359,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,techhusky,techhusky,07/Jun/10 15:22,08/Jun/10 16:45,14/Mar/19 03:03,08/Jun/10 16:44,2.0.0,,,,,,,,2.1.0,,,,,validation,,,11/Jun/10 00:00,0,,,,,,,,"When specifying a comma delimited list of validation groups in the persistence.xml and exception is thrown if extra whitespace (spaces, line feeds) are included in the list.  Instead, whitespace should be discarded when building the list of validation groups.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161940,,,Tue Jun 08 16:44:54 UTC 2010,,,,,,,0|i0z3mn:,202890,,,,,,,,08/Jun/10 16:44;techhusky;Fixed under rev 952730.,,,,,,,,,,,,,,,,,,,,,,,,,,
Why string encoding of OpenJPA Identity instances for LongId differes from other built-in identity types?,OPENJPA-1683,12466260,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,05/Jun/10 17:03,12/Jan/11 22:46,14/Mar/19 03:03,12/Jan/11 22:46,,,,,,,,,2.1.0,,,,,kernel,,,,0,,,,,,,,"How the built-in classes for persistent identity value encodes as itself as a String is critical/significant -- because 
a) the encoded string often is decoded to extract the original value for instance look up
b) for untyped persistence capable instances, the encoded string carries the actual class name -- and hence is important to instantiate the actual instance during loading from database

Unfortunately, this important decision about encoding-decoding of identity value is *not* emphasized with methods such as encode()/decode() on OpenJPAId but encoding is done with ubiquitous Object.toString() and decoding is burried in code lines.  
  
While it is perhaps important to review this scheme, the immediate issue at hand is somewhat narrower and as follows:

  The root *abstract* class OpenJPAId has the following toString() implementation
    public String toString() {
        return type.getName() + ""-"" + getIdObject();
    }
   
   The concrete implementation such as IntId or FloatId overwrites this behavior as follows:

    IntId.java:
           private final int key;

    public String toString() {
        return String.valueOf(key);
    }

   FloatId.java:
           private final float key;
    public String toString() {
        return Float.toString(key);
    }

  Apart from the subtle difference (but why), they look to be following the same principle, i.e. just stringify the value.

  But the interesting part is LongId *does not* have a toString() method.
  Hence its toString() form is dictated by its abstract super class OpenJPAId which appends the class name with a dash character to the actual long value of the identity.

  I can not figure out the reason of this anomaly  for long identifier as opposed to other Short/Integer or Float etc.
  The risk  of simply adding a toString() to LongId that is in line with other id types, of course, a) breaking any existing application that may be assuming the previous  encoding
b) the unknown original reason behind *not* overwriting LongId.toString() method

   Can someone please, please answer/shed some light? 

   It is critical for some direction I am pursuing to support generic/templated types where exact types are not determinable at compile/design time.

   Without an answer, I will commit the change on LongId to have a toString() method. 
+
+    public String toString() {
+        return String.valueOf(key);
+    }



",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-01-12 22:46:41.988,,,no_permission,,,,,,,,,,,,161939,,,Wed Jan 12 22:46:41 UTC 2011,,,,,,,0|i0z3nj:,202894,,,,,,,,12/Jan/11 22:46;mikedd;Please open another issue if there is more work to be done here. ,,,,,,,,,,,,,,,,,,,,,,,,,,
TestSimpleXmlEntity.testId failed with invalid DB2 create table SQL statement,OPENJPA-1682,12466193,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,allee8285,allee8285,04/Jun/10 16:08,16/Aug/12 22:13,14/Mar/19 03:03,16/Aug/12 22:13,2.1.0,,,,,,,,1.2.3,2.0.2,2.1.0,,,sql,,,,0,,,,,,,,"TestSimpleXmlEntity.testId starts failing with the following exception against DB2:

TestSimpleXmlEntity.testId  View test details   (org.apache.openjpa.persistence.xml)
    <openjpa-2.1.0-SNAPSHOT-r422266:951071 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: DB2 SQL Error: SQLCODE=-542, SQLSTATE=42831, SQLERRMC=NICKNAME_XML, DRIVER=3.50.152 {stmnt 65405926 CREATE TABLE NickNames_xml (A_ID_xml INTEGER NOT NULL, nickName_xml VARCHAR(20), CONSTRAINT U_NCKNXML_A_ID_XML UNIQUE (A_ID_xml, nickName_xml))} [code=-542, state=42831]
    at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:556)
    at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:456)
    Please wait... Show details »
    « Hide details
    <openjpa-2.1.0-SNAPSHOT-r422266:951071 nonfatal general error> org.apache.openjpa.persistence.PersistenceException: DB2 SQL Error: SQLCODE=-542, SQLSTATE=42831, SQLERRMC=NICKNAME_XML, DRIVER=3.50.152 {stmnt 65405926 CREATE TABLE NickNames_xml (A_ID_xml INTEGER NOT NULL, nickName_xml VARCHAR(20), CONSTRAINT U_NCKNXML_A_ID_XML UNIQUE (A_ID_xml, nickName_xml))} [code=-542, state=42831]
    at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:556)
    at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:456)
    at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:155)
    at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:159)
    at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.newBrokerImpl(JDBCBrokerFactory.java:117)
    at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:199)
    at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:156)
    at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:213)
    at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:151)
    at org.apache.openjpa.persistence.test.SingleEMTestCase.setUp(SingleEMTestCase.java:47)
    at org.apache.openjpa.persistence.xml.TestSimpleXmlEntity.setUp(TestSimpleXmlEntity.java:28)
    at junit.framework.TestCase.runBare(TestCase.java:125)
    at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:503)
    at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:479)
    at junit.framework.TestResult$1.protect(TestResult.java:106)
    at junit.framework.TestResult.runProtected(TestResult.java:124)
    at junit.framework.TestResult.run(TestResult.java:109)
    at junit.framework.TestCase.run(TestCase.java:118)
    at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:179)
    at junit.framework.TestSuite.runTest(TestSuite.java:208)
    at junit.framework.TestSuite.run(TestSuite.java:203)
    at sun.reflect.GeneratedMethodAccessor52.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)
    at java.lang.reflect.Method.invoke(Method.java:600)
    at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
    at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
    at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
    at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)
    at java.lang.reflect.Method.invoke(Method.java:600)
    at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:345)
    at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009)
    Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: DB2 SQL Error: SQLCODE=-542, SQLSTATE=42831, SQLERRMC=NICKNAME_XML, DRIVER=3.50.152 {stmnt 65405926 CREATE TABLE NickNames_xml (A_ID_xml INTEGER NOT NULL, nickName_xml VARCHAR(20), CONSTRAINT U_NCKNXML_A_ID_XML UNIQUE (A_ID_xml, nickName_xml))} [code=-542, state=42831]
    at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:257)
    at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:241)
    at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$700(LoggingConnectionDecorator.java:70)
    at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingStatement.executeUpdate(LoggingConnectionDecorator.java:951)
    at org.apache.openjpa.lib.jdbc.DelegatingStatement.executeUpdate(DelegatingStatement.java:136)
    at org.apache.openjpa.jdbc.schema.SchemaTool.executeSQL(SchemaTool.java:1200)
    at org.apache.openjpa.jdbc.schema.SchemaTool.createTable(SchemaTool.java:956)
    at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:533)
    at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:348)
    at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:325)
    at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:504)
    ... 33 more

The create table constraint  requires nickName_xml be ""NOT NULL""

Albert Lee",,,,,,,,,,,,,,,,,,,07/Jun/10 16:20;ppoddar@apache.org;OPENJPA-1682.01.txt;https://issues.apache.org/jira/secure/attachment/12446497/OPENJPA-1682.01.txt,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-06-07 15:45:32.225,,,no_permission,,,,,,,,,,,,161938,,,Mon Jun 07 16:20:16 UTC 2010,,,,,,,0|i0zbxr:,204236,,,,,,,,"05/Jun/10 23:41;allee8285;Not sure why the following commit associate to this issue?

ASF  	#935970  	Tue Apr 20 11:58:23 EDT 2010  	ppoddar  	 OPENJPA-1682: Merge doc change from trunk
                                                                                                                                 Files Changed
                                                                                                                                 MODIFY /openjpa/branches/2.0.x/openjpa-project/src/doc/manual/jpa_overview_criteria.xml ","05/Jun/10 23:44;allee8285;This regression is introduced under r941362 as part of the OPENJPA-1387 commit where Unique.addColumn() method was removed, hence the col.setNotNull(true) is not enforced.

Albert Lee.

","06/Jun/10 18:49;allee8285;Tests Result from before and after r941362.
------------------------------
openjpa.trunk.941084

Results :

Failed tests:
  testQueryQualifiedId(org.apache.openjpa.persistence.jdbc.maps.spec_10_1_27_ex4.TestSpec10_1_27_Ex4)

Tests in error:
  testGroupByEmbed(org.apache.openjpa.persistence.embed.TestEmbeddable)
  testMultiThreadedNativeSequences(org.apache.openjpa.persistence.sequence.TestSequence)
  testSimple(org.apache.openjpa.persistence.kernel.TestSavepoints)

Tests run: 2451, Failures: 1, Errors: 3, Skipped: 0
------------------------------
openjpa.trunk.941362

Results :

Failed tests:
  testQueryQualifiedId(org.apache.openjpa.persistence.jdbc.maps.spec_10_1_27_ex4.TestSpec10_1_27_Ex4)

Tests in error:
  testId(org.apache.openjpa.persistence.xml.TestSimpleXmlEntity)
  testNamedQueryInXmlNamedEntity(org.apache.openjpa.persistence.xml.TestSimpleXmlEntity)
  testNamedQueryInXmlUsingShortClassName(org.apache.openjpa.persistence.xml.TestSimpleXmlEntity)
  testNamedEntityInDynamicQuery(org.apache.openjpa.persistence.xml.TestSimpleXmlEntity)
  testShortClassNameInDynamicQuery(org.apache.openjpa.persistence.xml.TestSimpleXmlEntity)
  testOverriddenEntityName(org.apache.openjpa.persistence.xml.TestXmlOverrideEntity)
  testOptionalAttributeOverride(org.apache.openjpa.persistence.xml.TestXmlOverrideEntity)
  testColumnOverride(org.apache.openjpa.persistence.xml.TestXmlOverrideEntity)
  testTableName(org.apache.openjpa.persistence.delimited.identifiers.TestDelimitedIdentifiers)
  testMultiThreadedNativeSequences(org.apache.openjpa.persistence.sequence.TestSequence)
  testCreateF(org.apache.openjpa.persistence.delimited.identifiers.noschema.TestNoSchemaManualDelimId)
  testCreateF2(org.apache.openjpa.persistence.delimited.identifiers.noschema.TestNoSchemaManualDelimId)
  testTableName(org.apache.openjpa.persistence.delimited.identifiers.xml.TestXmlDelimitedIdentifiers)
  testBasicEmbedAttrOverride(org.apache.openjpa.persistence.embed.attrOverrides.TestAttrOverridesXml)
  testXMLEntityWithAnnotatedOverrideEmbed(org.apache.openjpa.persistence.embed.attrOverrides.TestAttrOverridesXml
  testMapping(org.apache.openjpa.persistence.jdbc.unique.TestUniqueConstraint)
  testMixedOrmAnno(org.apache.openjpa.persistence.TestMixedMappingLocation)
  testSimple(org.apache.openjpa.persistence.kernel.TestSavepoints)
  testMapping(org.apache.openjpa.persistence.jdbc.unique.TestUniqueConstraintWithXMLDescriptor)
  testCreateF(org.apache.openjpa.persistence.delimited.identifiers.TestManualDelimId)
  testCreateF2(org.apache.openjpa.persistence.delimited.identifiers.TestManualDelimId)
  testMapping(org.apache.openjpa.persistence.jdbc.unique.TestNamedUniqueConstraint)
  testNullOnOptionalFieldIsAllowed(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testNullOnNonOptionalFieldIsDisallowed(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testNotNullOnOptionalFieldIsAllowed(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testNotNullOnNonOptionalFieldIsAllowed(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testNullOnNullableColumnAllowed(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testNullOnNonNullableColumnIsDisallowed(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testNotNullOnNullableColumnIsAllowed(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testNotNullOnNonNullableColumnIsAllowed(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testNullOnOptionalBlobFieldIsAllowed(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testNullOnNonOptionalBlobFieldIsDisallowed(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testNullOnNullableBlobColumnAllowed(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testNullOnNonNullableBlobColumnIsDisallowed(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testX(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testUniqueStringColumnCanBeNull(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testUniqueStringColumnAsNull(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testUniqueStringColumnAsEmpty(org.apache.openjpa.persistence.nullity.TestBasicFieldNullity)
  testMapping(org.apache.openjpa.persistence.jdbc.unique.TestNamedUniqueConstraintWithXMLDescriptor)

Tests run: 2454, Failures: 1, Errors: 39, Skipped: 0
","07/Jun/10 15:45;ppoddar@apache.org;Can an unique column be nullable? The answer seems to vary across databases.

The observed DB2 error -542 points that DB2 does not allow a unique column to be nullable.
""  column-name CANNOT BE A COLUMN OF A PRIMARY KEY, A UNIQUE CONSTRAINT, OR A PARENT KEY BECAUSE IT CAN CONTAIN NULL VALUES
Explanation : The code is used to report that a column identified in a PRIMARY KEY, a UNIQUE constraint clause, or a parent key (via a REFERENCES clause) is defined to allow null values.""

While MySQL seems to allow a null value on a column with unique constraint.

OpenJPA currently works in a way that an unique constraint on a column *does not imply* any nullability -- positive or negative.
Earlier (prior to revision 941362), we forced that an unique constraint on a column *does imply* non-nullability. But OPENJPA-1387 made the point that unique constraint should not imply non-nullable -- whch I tend to agree and hence revision 941362 removed the implication.

But as the current issue shows, we need to make this implication database dependent.  




 
",07/Jun/10 16:20;ppoddar@apache.org;Patch for database specific decision on whether to non-nullify  a column on which a unique constraint has been placed.,,,,,,,,,,,,,,,,,,,,,,
Index name too long for DB2 zOS when schema is present,OPENJPA-1679,12465997,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,02/Jun/10 19:22,02/Jun/10 19:26,14/Mar/19 03:03,02/Jun/10 19:25,2.0.0,,,,,,,,2.0.1,,,,,jdbc,,,,0,,,,,,,,"OPENJPA-1596 has already been marked as fixed in 2.0.0-beta3.  A new JIRA is open for any additional changes in openjpa 2.0.0. Otherwise, the 2.0.1 release notes will not denote that this change was included.",,,,,,,,,,OPENJPA-1596,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161935,,,Wed Jun 02 19:25:37 UTC 2010,,,,,,,0|i0yzif:,202223,,,,,,,,02/Jun/10 19:25;faywang;Fix is checked in (r-950604) via JIRA-1596 to openjpa 2.0 branch. ,,,,,,,,,,,,,,,,,,,,,,,,,,
SQL Parameter values may contain sensitive information and should not be logged by default.,OPENJPA-1678,12465979,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,mikedd,mikedd,mikedd,02/Jun/10 16:35,15/Nov/10 16:24,14/Mar/19 03:03,15/Jul/10 21:03,1.0.3,1.1.0,1.2.2,2.0.0,2.1.0,,,,1.0.4,1.2.3,1.3.0,2.0.1,2.1.0,,,,,0,,,,,,,,"The values for parameters used in our SQL statements may contain sensitive information (e.g. social security numbers). By default these values are printed in the exception message and in SQL trace. Having the values printed can be a great help when debugging an application - but presents a risk when used in production. 

To resolve the issue I propose to disable printing the parameter values by default. The parameter values will still be tracked internally - but will not be displayed in exception messages or trace unless the following property is set :
<property name=""openjpa.ConnectionFactoryProperties"" value=""printParameters=true""/>
",,,,,,,,,,,,,OPENJPA-1886,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-06-02 18:44:28.978,,,no_permission,,,,,,,,,,,,161934,,,Wed Jun 09 19:01:23 UTC 2010,,,,,,,0|i0z3n3:,202892,,,,,,,,"02/Jun/10 18:44;allee8285;I wonder should we use openjpa.Log instead of introduce a new property

  i.e. <property name=""openjpa.Log"" value=""DefaultLevel=TRACE,printParameters=true""/>

Albert Lee.","02/Jun/10 18:52;mikedd;I thought about that too. The problem is that it isn't just logging that we're concerned with - we need to alter the toString on LoggingConnectionDecorator.LoggingPreparedStatement (from memory) LoggingConnectionDecorator is already aware of some of this - there's a trackParameters property which does similar things - but it's not quite what we need here.. 

What I hadn't considered (until now) is skipping the LoggingConnectionDecorator unless this property is enabled. That might work - not sure offhand what it would do to the rest of SQL or JDBC logging though. ","03/Jun/10 14:26;mikedd;I've tried it two ways. One uses openjpa.Log to control whether parameters are printed, the other uses openjpa.ConnectionFactoryProperties. 

The openjpa.Log approach is just a proof of concept. The changes will have to ripple through to any of our LogFactory classes -  I just skipped that and cast to LogFactoryImpl. 

The openjpa.CFProperties approach is a bit leaner and less intrusive (I'm leaning this way at the moment).","03/Jun/10 22:37;ppoddar@apache.org;I think parameter tracing is useful.
Here is my suggestion on usage

                  <property name=""openjpa.Log"" value=""SQL=DEBUG""/>

In general DEBUG a new log level finer than TRACE. And DEBUG can be non-localized (what Rick wanted TRACE to be).
","04/Jun/10 14:38;mikedd;Hi Pinaki,

I think this is orthogonal to the level of tracing used. While it's often useful in conjunction with other tracing the two should not be tied together. You should be able to see parameters in your exception text (if you so desire) without enabling logging for example. 

I'm not entirely sold on introducing a new log level in service either. For the time being I'm going to treat this as a bug with openjpa.ConnectionFactoryProperties.TrackParameters and fix it that way (the cfProps patch). ","09/Jun/10 19:01;mikedd;Upon further review I'm leaning towards a separate parameter, also on ConnectionFactoryProperties - since this will be in service releases I'd rather not take the risk of affecting behavior or change the meaning of track parameters for any existing applications.  ",,,,,,,,,,,,,,,,,,,,,
PCClassFileTransformer.transform causing NPE when class name is null,OPENJPA-1676,12465795,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,croos,croos,31/May/10 15:44,20/Sep/10 15:39,14/Mar/19 03:03,13/Jul/10 15:11,2.0.0,2.1.0,,,,,,,2.1.0,,,,,kernel,,,,0,,,,,,,,"openjpa  WARN   [AWT-EventQueue-0] openjpa.Enhance - An exception was thrown while attempting to perform class file transformation on ""null"":
java.lang.NullPointerException
	at org.apache.openjpa.enhance.PCClassFileTransformer.needsEnhance(PCClassFileTransformer.java:175)
	at org.apache.openjpa.enhance.PCClassFileTransformer.transform0(PCClassFileTransformer.java:132)
	at org.apache.openjpa.enhance.PCClassFileTransformer.transform(PCClassFileTransformer.java:120)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:169)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:365)
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:616)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:466)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader.defineClass(TemplatesImpl.java:126)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.defineTransletClasses(TemplatesImpl.java:312)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getTransletInstance(TemplatesImpl.java:349)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.newTransformer(TemplatesImpl.java:382)
	at net.sourceforge.jeuclid.DOMBuilder.createTransformer(DOMBuilder.java:95)
	at net.sourceforge.jeuclid.DOMBuilder.<init>(DOMBuilder.java:75)
	at net.sourceforge.jeuclid.DOMBuilder$SingletonHolder.<clinit>(DOMBuilder.java:53)
	at net.sourceforge.jeuclid.DOMBuilder.getInstance(DOMBuilder.java:110)
	at net.sourceforge.jeuclid.layout.JEuclidView.<init>(JEuclidView.java:75)



The code causing the error is in the JVM, because defineClass is called with a null class name:

static final class TransletClassLoader extends ClassLoader {
	TransletClassLoader(ClassLoader parent) {
	    super(parent);
	}

        /**
         * Access to final protected superclass member from outer class.
         */
	Class defineClass(final byte[] b) {
====>            return defineClass(null, b, 0, b.length);    <=====
	}
    }
",jdk1.6.20,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-07-13 15:11:30.863,,,no_permission,,,,,,,,,,,,161932,,,Mon Sep 20 15:39:55 UTC 2010,,,,,,,0|i0z3m7:,202888,,,,,,,,13/Jul/10 15:11;curtisr7;Committed revision 963752 to trunk,"20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,,
PCRegistry memory leak when using MetaDataRepository preloading.,OPENJPA-1670,12464903,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,19/May/10 15:48,20/Sep/10 15:39,14/Mar/19 03:03,19/May/10 18:42,1.2.2,2.0.0,,,,,,,2.1.0,,,,,kernel,,,,0,,,,,,,,When using MetaDataRepository preloading the MetaDataRepository is registered twice as a RegisterClassListener with the PCRegistry but both registrations aren't removed when the EMF is closed.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:39:55.444,,,no_permission,,,,,,,,,,,,73846,,,Mon Sep 20 15:39:55 UTC 2010,,,,,,,0|i0z8c7:,203653,,,,,,,,19/May/10 18:42;curtisr7;Committed revision 946332 to trunk.,"20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,,
User's ''DBDictionary.sequenceSQL' setting not being honored on zOS ,OPENJPA-1668,12464706,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,jpaheath,jpaheath,jpaheath,17/May/10 18:08,20/Sep/10 15:39,14/Mar/19 03:03,12/Aug/10 22:07,1.0.3,1.2.2,2.0.0,,,,,,1.2.3,1.3.0,2.0.1,2.1.0,,,,,,0,,,,,,,,"When setting/overriding the 'DBDictionary.sequenceSQL' value via a property in the persistence.xml file, as follows:

	<property name=""openjpa.jdbc.DBDictionary"" value=""db2(sequenceSQL='SELECT SCHEMA AS SEQUENCE_SCHEMA, NAME AS SEQUENCE_NAME FROM CIDB2.SYSSEQUENCES')""/>                                                        

this value is not used when running DB2 on zOS.  Rather, the 'default for zOS' is used, i.e.: ""SELECT SCHEMA AS SEQUENCE_SCHEMA, NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES"";.  

To understand how this is happening, let me describe how 'sequenceSQL' is defined/set at runtime.  First, the ctor of DB2Dictionary is called, and the variable is set to a default:

        sequenceSQL = ""SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, ""
            + ""SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES"";

After the DB2Dictionary ctor is called, openJPA assigns to 'sequenceSQL' the value defined in the system property.  So at this point things are all good and the variable is set to what is defined in the prop.  Where things go awry is when the method DB2Dictionary.connectedConfiguration is called.  In the method there is some platform specific code which is executed which overwrites the sequenceSQL value:

       // platform specific settings
        switch (db2ServerType) {
        case  db2ZOSV8xOrLater:
		........
            sequenceSQL = ""SELECT SCHEMA AS SEQUENCE_SCHEMA, ""
                + ""NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES"";

Thanks,

Heath",,,,,,,,,,,,,,,,,,,09/Aug/10 16:50;jpaheath;OPENJPA-1668-1.2.x.patch.txt;https://issues.apache.org/jira/secure/attachment/12451600/OPENJPA-1668-1.2.x.patch.txt,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-05-18 19:07:58.036,,,no_permission,,,,,,,,,,,,161925,,,Mon Sep 20 15:39:55 UTC 2010,,,,,,,0|i1dtsf:,288923,,,,,,,,"18/May/10 19:07;mikedd;This is a case where I wish we had a separate DBDictionary class for Z/OS (although we can't detect it until we have a connection so that would pose its own challenges). 

That said we shouldn't override user settings - the connectedConfiguration method needs to take user settings into account before overwriting the variables. AFAIK there isn't a good way to detect whether a config property was set by the user or just accepted the default value though - so solving the problem might be more kludgy than we'd like. 

I'd vote for checking whether sequenceSQL has the default value in connectedConfiguration. If it has the default we'll go ahead and override with a z/os default. If it isn't the default we'll leave it alone (maybe issue a trace statement). 

Any other ideas I've missed? ",09/Aug/10 16:50;jpaheath;I'm attaching a patch (OPENJPA-1668-1.2.x.patch.txt) for 1.2.x.,"20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,
Incorrect column type for LOB streaming in MySQL,OPENJPA-1667,12464618,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,milosz,milosz,milosz,16/May/10 11:56,13/Jan/11 16:45,14/Mar/19 03:03,26/May/10 09:58,1.3.0,2.0.0,,,,,,,1.3.0,2.1.0,,,,sql,,,,0,,,,,,,,"After the changes made in OPENJPA-740, a LOB streaming field is mapped to TINYBLOB instead of BLOB in MySQL. This is because column size is -1 and in MySQLDictionary.getColumnType we assume that only size = 0 means ""size unknown"". Adding a check for -1 will probably resolve the issue.
",MySQL 5.1.30,,,,,,,,,,,,,OPENJPA-740,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-01-13 16:45:27.863,,,no_permission,,,,,,,,,,,,161924,,,Thu Jan 13 16:45:27 UTC 2011,,,,,,,0|i1dtsn:,288924,,,,,,,,13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,,,,,,,,,,,,,,,,,,,,,,,,,,
Problems when using auto incrementing colums that start at zero ,OPENJPA-1665,12464360,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,12/May/10 16:08,23/Mar/11 14:26,14/Mar/19 03:03,23/Mar/11 14:26,2.0.0,,,,,,,,1.2.3,1.3.0,2.0.2,2.1.0,,,,,,0,,,,,,,,"This issue was reported on the users mailing list[1].

The issue is that it is possible when using auto generated ids that there is a current entity in the persistence context that has an id of zero, and by default when a new entity is created it also has an id of zero. When persisting the second entity, OpenJPA incorrectly detects that there are multiple entities with the same id in the context even though the new id doesn't have an id from the database yet.

[1]http://openjpa.208410.n2.nabble.com/An-object-of-type-src-StatusUpdate-with-oid-0-already-exists-in-this-context-another-cannot-be-persi-td5030272.html#a5030272",,,,,,,,,,,,,,OPENJPA-1066,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-05-15 17:09:05.758,,,no_permission,,,,,,,,,,,,161922,,,Wed Mar 23 14:26:32 UTC 2011,,,,,,,0|i0z5hb:,203190,,,,,,,,"12/May/10 19:35;curtisr7;Committed revision 943638 to trunk.

Updated BrokerImpl to skip checks for duplicate ids when they are auto generated. Also added a new test case to exercise this code path.","15/May/10 17:09;milosz;Changing Fix Version to 2.1.0 since code has been committed to trunk.
","20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",22/Mar/11 20:23;jpaheath;Committed changes to 2.0.x under revision 1084264.,23/Mar/11 14:26;mikedd;Looks like the 2.0.2 changes were made under r1084264. ,,,,,,,,,,,,,,,,,,,,,,
Postgres connection throws NPE with null properties,OPENJPA-1657,12464147,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,10/May/10 15:45,02/Feb/12 16:30,14/Mar/19 03:03,27/Apr/11 21:26,,,,,,,,,2.1.1,2.2.0,,,,,,,,0,,,,,,,,"DataSource.getConnection(String url, Properties p) throws NPE on null Properties. An empty property instead is better because any exception to establish connection is more informative.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-02-02 16:30:13.671,,,no_permission,,,,,,,,,,,,161914,,,Thu Feb 02 16:30:13 UTC 2012,,,,,,,0|i1dttr:,288929,,,,,,,,02/Feb/12 16:30;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,,,,,,,,,,,,
Unique colums automatically defined as non-nullable (part 2),OPENJPA-1651,12463784,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,struberg,struberg,05/May/10 15:46,02/Feb/12 16:29,14/Mar/19 03:03,12/Dec/11 16:59,,,,,,,,,2.2.0,,,,,,,,,3,,,,,,,,Continuing the discussion from OPENJPA-1387. The original issue was closed and marked as shipped in OpenJPA 2.0.0 (one of the betas) - it should not appear in 2.0.1 as well - thus the need for a new issue. ,,,,,,,,,,,,OPENJPA-1387,,,,,,,05/May/10 15:48;mikedd;openjpa-test.zip;https://issues.apache.org/jira/secure/attachment/12443724/openjpa-test.zip,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-05-05 15:47:35.542,,,no_permission,,,,,,,,,,,,161908,,,Thu Feb 02 16:29:39 UTC 2012,,,,,,,0|i1dt4f:,288815,,,,,,,,"05/May/10 15:47;mikedd;Re posting Mark's comments :
A few tips on my sample project: 
The NOT NULL can be checked by simply executing 
$> mvn openjpa:sql 
which generates the database creation SQL script in 
./target/database.sql 

to execute the project you need to create the database upfront in MySQL with 
create database TestDb; 
user 'root' with no password is assumed (persistence.xml) 

After 
$> mvn clean install 
you will see the myString column as empty string instead of NULL when doing a 
mysql> select * from NullFieldTable; 
+----+----------+ 
| PK | myString | 
+----+----------+ 
| 1 | | 
+----+----------+ 
1 row in set (0.00 sec) ","21/Jul/10 12:20;dirichs;What exactly is still holding back the resolution of this issue? I noticed that the changes made for the precessor OPENJPA-1387 were rolled back. Now that a newer version of Derby is used in the build process, it should be easy to fix this. Or is it because of compatibility considerations? If so, a switch could be added to support the old behaviour (which, as I see it, is really a bug, not a feature).","12/Sep/10 12:39;agurkas;Dear openjpa developers. This is a serious and long standing bug which is still not fixed in openjpa 2.0.1.
The problem is some people using openjpa might not realize that openjpa is setting unique fields to not null without any warning and the consequences can be horrible.
In some particular scenarious one might not find records in the database even if those do exist (imagine this happening in production database for more excitement)
Let me show one simple example.

@Entity
@Table(uniqueConstraints = { @UniqueConstraint(columnNames = { ""a"", ""b"" }) })
public class TestEntity 
{
	@ManyToOne
	@JoinColumn(nullable = true, name = ""a"")
	private EntityA a;     //optional

	@ManyToOne
	@JoinColumn(nullable = false, name = ""b"")
	private EntityB b;     //required

        //getters setters ommited for readability
}


        @Test
	public void test()  {

                EntityB b = getEntityBService().find(1);
		TestEntity entity = new TestEntity();
		entity.setB(b);
		getTestEntityService().save(entity);

//so record is saved in database with a = 0 not a = NULL value as expected and b = 1
//now try to find this TestEntity  by unique constraints meaning  by EntityA == null and EntityB with id = 1

                EntityA a = null;
		EntityB b = getEntityBService().find(1);
		TestEntity entity = getTestEntityService().findByAB(a, b);
		Assert.assertNotNull(entity); 

//result is FAILURE  entity not found

this is underlying openjpa generated sql that shows why it fails

SELECT (... ommited...) FROM TestEntity t0 LEFT OUTER JOIN EntityA t1 ON t0.a = t1.id LEFT OUTER JOIN EntityB t2 ON t0.b = t2.id WHERE (t0.a IS NULL AND t0.b = 1)

it cannot be found in the TestEntity table as we have 0 not a NULL value for optional entity a 

to avoid this we do run our tool to fix database structure to avoid this and possibly other scenarios but a openjpa fix would be nice to have.

regards



","04/Apr/11 15:59;rade.martinovic;Today I have encountered this issue in OpenJPA 2.0.1. The test scenario is exactly the same as agurkas described.

Is there a wordaround for this?","05/Apr/11 15:20;rade.martinovic;Today I have tried the test scenario that agurkas described with OpenJPA 2.1.0 and it seems that the issue has been remedied in the latest release. 

Maybe now this small patch should be backported to all previos versions?","05/Apr/11 15:52;struberg;Rade, could you please also run  your tests against a 2.2.0-SNAPSHOT? txs!","12/Dec/11 16:59;struberg;I verified the behaviour with MySQL today and it works now with my test project. I also tried to implement unit tests in openjpa-persistence-jdbc, but that doesn't work because derby (which is used in the unit tests) doesn't support NOT NULL values for UNIQUE indexes.

See the following discussion on the derby user list:
http://mail-archives.apache.org/mod_mbox/db-derby-dev/200511.mbox/%3C20051102114053.GB7614@atum01.norway.sun.com%3E","13/Dec/11 14:38;drwoods;Mark, did you include the tests anyway and just set them to only run on Oracle for now?
","13/Dec/11 15:44;struberg;Nope sorry, I reverted it. But if you point me to how I can provide a test which only runs against MySQL, Oracle, etc then I can redo my work pretty easily (~2hrs of work). I basically did put the logic I had in the attached openjpa-test.zip and moved it to openjpa-persistence-jdbc unique tests.

I also duplicated the Entity to make sure that both @Column(unique=true) and @UniqueColumns on the whole table are tested.","15/Dec/11 22:16;drwoods;Different ways depending on which abstract testcase you use -

Annotation - org.apache.openjpa.persistence.test.DatabasePlatform

org.apache.openjpa.persistence.jdbc.meta.TestLocators.testSmallBLOBs()
    if (getCurrentPlatform() == AbstractTestCase.Platform.ORACLE) {

org.apache.openjpa.persistence.jdbc.query.TestHintedQuery.testHintedQuery()
    if (dict instanceof MySQLDictionary)

Believe there is one other annotation that we created for JUnits, but couldn't find it with a quick search.
","19/Dec/11 10:21;milosz;I guess Donald meant setUnsupportedDatabases and setSupportedDatabases methods in the SingleEMFTestCase.

I am afraid the getCurrentPlatform() might not work.
",02/Feb/12 16:29;allee8285;Close issue in preparation for 2.2.0 release.,,,,,,,,,,,,,,,
Adding a slice dynamically should be done via persistence unit only,OPENJPA-1650,12463708,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,04/May/10 21:32,21/Sep/11 15:09,14/Mar/19 03:03,21/Sep/11 15:09,,,,,,,,,2.1.2,2.2.0,,,,,,,,0,,,,,,,,"Current support for adding a new Slice dynamically exists at three places

DistributedBrokerFactory.addSlice(String name, Map properties)
DistributedConfiguration.addSlice(String name, Map properties)
DistributedBroker.addSlice(String name, Map properties)

This is confusing. A new slice should *only* be added via DistributedBrokerFactory.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-09-21 15:09:07.451,,,no_permission,,,,,,,,,,,,59912,,,Wed Sep 21 15:09:07 UTC 2011,,,,,,,0|i0z0uv:,202441,,,,,,,,"21/Sep/11 15:09;mikedd;Closing issues which have code changes and have not been modified for a while. 

If there is more work to be done for this issue please check whether it has already been included in an OpenJPA release. 

If the changes are in an OpenJPA release please open a new issue and link to this one. 

If the changes are not in an OpenJPA release you may reopen this issue or create a new issue. ",,,,,,,,,,,,,,,,,,,,,,,,,,
DataCacheManager initialization still isn't thread safe.,OPENJPA-1646,12463567,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,03/May/10 15:46,02/Jun/16 12:08,14/Mar/19 03:03,03/May/10 15:56,1.2.2,2.0.0,,,,,,,2.1.0,,,,,datacache,,,,0,,,,,,,,OPENJPA-1559 reduced the timing window but the problem still exists.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-09-20 15:39:52.593,,,no_permission,,,,,,,,,,,,161904,,,Thu Jun 02 12:08:58 UTC 2016,,,,,,,0|i0z8br:,203651,,,,,,,,"03/May/10 15:56;curtisr7;Committed revision 940490 to trunk.

This fix involved moving DataCacheManager init to EMF creation, rather than performing double checked locking in OpenJPAConfigurationImpl.","20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ","02/Jun/16 10:48;arissadobe;there still is an issue with the initialization when done concurrently:

The dataCacheManager is constructed AND published here:
https://github.com/apache/openjpa/blob/ee299cc0bd0942ef8da2156c36e342a443bb46a0/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java#L685

this means that it can then be read in line 683 before initialize is called
","02/Jun/16 12:08;curtisr7;> there still is an issue with the initialization when done concurrently:

Please explain further?

As I mentioned, DataCacheManager init happens at EMF creation and that operation by nature is single threaded. Are you seeing a problem, or just scanning for double checked locking?",,,,,,,,,,,,,,,,,,,,,,,
Null field values after calling EntityManager.remove(),OPENJPA-1644,12463425,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,leoisiah,leoisiah,30/Apr/10 10:48,10/Apr/13 21:12,14/Mar/19 03:03,10/Apr/13 21:12,1.2.2,2.0.0,,,,,,,1.2.3,2.1.0,,,,,,,,0,,,,,,,,"Fields of an entity instance are nulled after calling EntityManager.remove() on an instance.

For example, I have an entity class named User. I persist and then remove an instance of User.

//
// EntityManager em is initialized before the following code
//

em.getTransaction().begin();
User user = new User();
user.setName(""name1"");
em.persist(user);
em.getTransaction().commit();
System.out.println(user.getName); // will print out name1
em.getTransaction().begin();
em.remove(user);
em.getTransaction().commit();
System.out.println(user.getName); // will print out null (oh no!) 

After I persist and remove the same instance of User, it's fields became null. I believe this shouldn't be the case as Section ""3.2.3 Removal"" of the 2.0 spec states:

""After an entity has been removed, its state (except for generated state) will be that of the entity at the point at which the remove operation was called.""",,,,,,,,,,,,,,,,,,,01/May/10 22:17;curtisr7;OPENJPA-1644.patch;https://issues.apache.org/jira/secure/attachment/12443395/OPENJPA-1644.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-05-01 22:17:08.499,,,no_permission,,,,,,,,,,,,161902,,,Thu Jan 13 16:45:27 UTC 2011,,,,,,,0|i0z3uv:,202927,,,,,,,,"01/May/10 22:17;curtisr7;This patch fixes the reported behavior, but I'm not sure what all it will break(Although all current unit tests pass).

I need to do some more testing before it is committed.","11/Oct/10 15:50;curtisr7;I did some research as to why we were clearing out the fields of an Entity after deleting it and it appears that it is something that has been with us from the JDO days. Per the JDO spec: 

""A persistent-deleted instance transitions to transient at commit. During the transition, its persistent fields are written with their Java default values....""The net of that is that after an instance is deleted, the provider must clear out all fields of that Entity.

The JPA 2.0 spec states something along these lines :  ""After an entity has been removed, its state (except for generated state) will be that of the entity at the point at which the remove operation was called."" I'll be committing changes shortly to support the JPA spec.

",13/Jan/11 16:45;mikedd;Closing issue which has been resolved for some time. If you believe the issue is not resolved please reopen or open a new issue. ,,,,,,,,,,,,,,,,,,,,,,,,
SybaseDictionary should try both JDBC column names and Sybase specific column names,OPENJPA-1641,12463123,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,27/Apr/10 16:20,14/Jun/10 17:53,14/Mar/19 03:03,14/Jun/10 17:53,,,,,,,,,1.2.3,1.3.0,2.0.1,2.1.0,,,,,,0,,,,,,,,OPENJPA-1326 updated the Sybase dictionary to use Sybase specific column names when inspecting ForiegnKeys and Indexes. While this works with some configurations of Sybase there are some which only use the JDBC names.,,,,,,,,,,,,,,,,,,,27/Apr/10 20:28;mikedd;OPENJPA-1641.1.2.x.patch.txt;https://issues.apache.org/jira/secure/attachment/12442993/OPENJPA-1641.1.2.x.patch.txt,27/Apr/10 20:28;mikedd;OPENJPA-1641.1.3.x.patch.txt;https://issues.apache.org/jira/secure/attachment/12442994/OPENJPA-1641.1.3.x.patch.txt,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161899,,,2010-04-27 16:20:37.0,,,,,,,0|i1dt5b:,288819,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Loading JAXB meta data when using MetaDataRepository preloading isn't thead safe.,OPENJPA-1634,12462443,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,19/Apr/10 15:24,20/Sep/10 15:39,14/Mar/19 03:03,01/May/10 19:01,2.0.0,2.1.0,,,,,,,2.1.0,,,,,kernel,,,,0,,,,,,,,"This problem was originally reported in OPENJPA-1631 where a NPE was fixed, but this JIRA will be used to fix the root problem.",,,,,,,,,,,,,,,,,,,20/Apr/10 18:17;curtisr7;OPENJPA-1634.patch;https://issues.apache.org/jira/secure/attachment/12442336/OPENJPA-1634.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-04-20 21:18:36.409,,,no_permission,,,,,,,,,,,,161892,,,Mon Sep 20 15:39:51 UTC 2010,,,,,,,0|i0z8cn:,203655,,,,,,,,"20/Apr/10 18:17;curtisr7;Attaching a patch that refactors some of the JAXB parsing code to allow for easier preloading. This seems safe enough, but I'm wonder if I missed something with my changes.","20/Apr/10 21:18;fancy;1. NULL pointer check for 'cls'  the following code block:

+        // Preload XML MetaData
+        for(Class<?> cls : loaded){
+            ClassMetaData cmd = getCachedMetaData(cls);
+            getXMLMetaData(cls);
+            for(FieldMetaData fmd : cmd.getFields()){
+                getXMLMetaData(fmd.getDeclaredType());
+            }
+        }

2. please verify the patch passes JUnit test TestXMLCustomerOrder in org.apache.openjpa.persistence.xmlmapping.query.
    I can not recall the rational behaind the  method signature of 
         getXMLMetaData(FieldMetaData fmd) in AbstractExpresionBuilder.traversePath() 

If twith the path,  TestXMLCustomerOrder passes, then it is OK to change the method signiture.",01/May/10 19:01;curtisr7;Committed revision 940093 to trunk.,"20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,
MetaDataRepository preload doesn't load JAXB meta data,OPENJPA-1631,12461982,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,13/Apr/10 19:48,09/Aug/13 21:27,14/Mar/19 03:03,15/Apr/10 16:41,1.2.2,2.0.0-beta3,,,,,,,2.0.0,,,,,,,,,0,,,,,,,,"The MetaDataRepository preloading doesn't process JAXB xml meta data on EMF creation, resulting in a condition where multiple threads can trample on each other. AnnotationPersistenceXMLMetaDataParser.parse(..) isn't thread-safe and relied on the MetaDataRepository to enforce synchronization. After preloading is complete, all locks are removed from the MetaDataRepository and in turn AnnotationPersistenceXMLMetaDataParser can have some threading problems.

Caused by: java.lang.NullPointerException
        at org.apache.openjpa.lib.util.J2DoPrivHelper$56.run(J2DoPrivHelper.java:1163)
        at org.apache.openjpa.lib.util.J2DoPrivHelper$56.run(J2DoPrivHelper.java:1161)
        at java.security.AccessController.doPrivileged(AccessController.java:202)
        at org.apache.openjpa.persistence.AnnotationPersistenceXMLMetaDataParser.parseXMLClassAnnotations(AnnotationPersistenceXMLMetaDataParser.java:175)
        at org.apache.openjpa.persistence.AnnotationPersistenceXMLMetaDataParser.parse(AnnotationPersistenceXMLMetaDataParser.java:163)
        at org.apache.openjpa.persistence.PersistenceMetaDataFactory.loadXMLMetaData(PersistenceMetaDataFactory.java:579)
        at org.apache.openjpa.meta.MetaDataRepository.getXMLMetaDataInternal(MetaDataRepository.java:2376)
        at org.apache.openjpa.meta.MetaDataRepository.getXMLMetaData(MetaDataRepository.java:2364)
        at org.apache.openjpa.kernel.exps.AbstractExpressionBuilder.traversePath(AbstractExpressionBuilder.java:315)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getPath(JPQLExpressionBuilder.java:1941)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getPathOrConstant(JPQLExpressionBuilder.java:1861)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.eval(JPQLExpressionBuilder.java:1169)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getValue(JPQLExpressionBuilder.java:2054)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getValue(JPQLExpressionBuilder.java:2040)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.eval(JPQLExpressionBuilder.java:1055)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getExpression(JPQLExpressionBuilder.java:1970)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.eval(JPQLExpressionBuilder.java:997)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.evalWhereClause(JPQLExpressionBuilder.java:668)
        at org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.getQueryExpressions(JPQLExpressionBuilder.java:297)
        at org.apache.openjpa.kernel.jpql.JPQLParser.eval(JPQLParser.java:67)",,,,,,,,,,,,,,OPENJPA-1634,,,,,13/Apr/10 20:38;curtisr7;ASF.LICENSE.NOT.GRANTED--OPENJPA-1631.patch;https://issues.apache.org/jira/secure/attachment/12441649/ASF.LICENSE.NOT.GRANTED--OPENJPA-1631.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-04-14 00:30:01.866,,,no_permission,,,,,,,,,,,,161890,,,Fri Aug 09 21:27:36 UTC 2013,,,,,,,0|i0z7xz:,203589,,,,,,,,13/Apr/10 20:38;curtisr7;Add synchronization to AnnotationPersistenceXMLMetaDataParser.parse() method to make it thread safe.,14/Apr/10 00:30;fancy;The patch looks good.,14/Apr/10 18:37;curtisr7;Committed revision 934100 to trunk.,15/Apr/10 16:41;curtisr7;Committed revision 934480 to 2.0.x.,15/Apr/10 21:25;drwoods;Don't need Fix Version of 2.1.0 since 2.0.0 hasn't been released yet....,"09/Aug/13 21:27;jira-bot;Commit 1512501 from [~jpaheath] in branch 'openjpa/branches/1.2.x'
[ https://svn.apache.org/r1512501 ]

OPENJPA-1631: Add synchronization to AnnotationPersistenceXMLMetaDataParser.parse() method to make it thread safe - back ported to 1.2.x Rick Curtis' trunk changes.",,,,,,,,,,,,,,,,,,,,,
NPE in MetaDataRepository when preloading is enabled under heavy stress.,OPENJPA-1630,12461981,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,curtisr7,curtisr7,13/Apr/10 19:33,22/Apr/10 20:30,14/Mar/19 03:03,15/Apr/10 16:43,1.2.2,2.0.0,2.0.0-beta3,2.0.1,2.1.0,,,,2.0.0,,,,,kernel,,,,0,,,,,,,,"A timing window exists in the MetaDataRepository where the following[1] NPE can be encountered. It is incorrect to assume that calling processRegisteredClasses at the end of preload would process all registered classes. As it turns out, that call does process all registered classes that this instance of the MDR cares about. The problem comes in when after the MDR is preloaded, Entities that belong to a different PU are registered with the PCRegistry and they are added to the _registered list. 

[1] Caused by: java.lang.NullPointerException
        at org.apache.openjpa.meta.MetaDataRepository.processRegisteredClasses(MetaDataRepository.java:1622)
        at org.apache.openjpa.meta.ClassMetaData.getPCSubclasses(ClassMetaData.java:364)
        at org.apache.openjpa.meta.ClassMetaData.getPCSubclassMetaDatas(ClassMetaData.java:381)
        at org.apache.openjpa.meta.ClassMetaData.getMappedPCSubclassMetaDatas(ClassMetaData.java:403)
        at org.apache.openjpa.jdbc.meta.ClassMapping.getMappedPCSubclassMappings(ClassMapping.java:628)
        at org.apache.openjpa.jdbc.meta.ClassMapping.getIndependentAssignableMappings(ClassMapping.java:667)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:380)
        at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:342)
        at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.initialize(WsJpaJDBCStoreManager.java:147)
        at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:112)
        at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
        at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1005)
        at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:963)
        ... 46 more",,,,,,,,,,,,,,,,,,,13/Apr/10 19:37;curtisr7;ASF.LICENSE.NOT.GRANTED--OPENJPA-1630.patch;https://issues.apache.org/jira/secure/attachment/12441638/ASF.LICENSE.NOT.GRANTED--OPENJPA-1630.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-04-15 21:25:02.309,,,no_permission,,,,,,,,,,,,161889,,,Thu Apr 15 21:25:02 UTC 2010,,,,,,,0|i0z3qv:,202909,,,,,,,,"13/Apr/10 19:37;curtisr7;There are a couple of ways to fix this problem. The easiest is to always lock on the _registered list when mutating, regardless of whether or not _locking is set.

The not so easy, but probably more correct solution is to only add classes to the _registered list that each MDR cares about. I'm leaning toward the first solution for the 2.0.x branch due to stability concerns and I'll investigate fixing it differently in trunk.",14/Apr/10 18:40;curtisr7;Committed revision 934103 to trunk.,15/Apr/10 16:43;curtisr7;Committed revision 934478 to 2.0.X. ,15/Apr/10 21:25;drwoods;Don't need Fix Version of 2.1.0 since 2.0.0 hasn't been released yet....,,,,,,,,,,,,,,,,,,,,,,,
ORderBy with @ElementJoinColumn and EmbeddedId uses wrong columns in SQL,OPENJPA-1627,12461804,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,mmcgovern,mmcgovern,12/Apr/10 10:21,12/Jan/11 22:41,14/Mar/19 03:03,12/Jan/11 22:41,2.0.0-beta3,,,,,,,,2.1.0,,,,,sql,,,,0,,,,,,,,"Typical bank example, Account with Transactions. It is a legacy db so Transaction has compound key - represented by TransactionId class.

The problem is that the order by in the generated SQL is for columns mapped in the transaction entity NOT the TransacionId as expected.

So the Account class has the following fragment....

	@OneToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST})
	@ElementJoinColumn(name=""maccno"", referencedColumnName=""maccno"")
	@OrderBy(value = ""_id._processDate ASC, _id._tranSequenceNumber ASC"")
	private LinkedList<Transaction> _transactions;


_processDate and _tranSequenceNumber are defined in the TransactionId class.

Transaction has the following fragment....

	@EmbeddedId
	private TransactionId _id;
	
	@Column(name = ""mtrancde"")
	private int _transactionCode;
	
	@Column(name = ""mamount"")
	private BigDecimal _amount;
	
	@Column(name = ""mdesc"")
	private String _description;
	

	@Column(name = ""mactdate"")
	private Date _actualDate;
	
	@Column(name = ""mbranch"")
	private int _branch;


And TransactionId defines the primary key columns....

@Embeddable
public class TransactionId {
	
	@Column(name = ""maccno"")
	private String _accountNumber;
	
	@Column(name = ""mprocdate"")
	private Date _processDate;
	
	@Column(name = ""mtranseqno"")
	private int _tranSequenceNumber;



However the generated SQL is doing order by on columns mapped in Transaction:

executing prepstmnt 23188098 SELECT t0.maccno, t0.mprocdate, t0.mtranseqno, t0.mactdate, t0.mamount, t0.mbranch, t0.mchqcash, t0.mdesc,
 t0.mtmnlno, t0.mtrancde, t0.mtrnfeed 
FROM transaction t0 
WHERE t0.maccno = ? 
ORDER BY t0.mamount ASC, t0.mbranch ASC [params=(String) 000734123]

(no idea why it chose mamount, mbranch)
The last line should be:

ORDER BY t0.mprocdate ASC, t0.mtranseqno ASC [params=(String) 000734123]

Thanks

Michael",Windows 7 32 bit / Oracle XE,,,,,,,,,,,,,,,,,,12/Apr/10 19:46;faywang;ASF.LICENSE.NOT.GRANTED--OPENJPA-1627.patch;https://issues.apache.org/jira/secure/attachment/12441536/ASF.LICENSE.NOT.GRANTED--OPENJPA-1627.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-04-12 19:46:47.977,,,no_permission,,,,,,,,,,,,161886,,,Mon Apr 19 16:57:41 UTC 2010,,,Patch Available,,,,0|i0z3s7:,202915,,,,,,,,"12/Apr/10 19:46;faywang;Hi Mike, can you test if the attached patch fix your problem? Thanks.

","19/Apr/10 14:47;mmcgovern;

Fay - thanks - that works very well.


 		 	   		  
_________________________________________________________________
Need a new place to live? Find it on Domain.com.au
http://clk.atdmt.com/NMN/go/157631292/direct/01/
","19/Apr/10 16:57;drwoods;the fix has been checked into trunk (2.1)
will decide later if we want this in 2.0.1",,,,,,,,,,,,,,,,,,,,,,,,
ParseException when specified name of QueryCache,OPENJPA-1626,12461787,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,curtisr7,amy,amy,12/Apr/10 03:09,20/Sep/10 15:39,14/Mar/19 03:03,14/Jul/10 20:16,1.1.0,,,,,,,,2.1.0,,,,,datacache,,,,0,,,,,,,,"When specifying name of QueryCache like
        Map propsMap = new HashMap();
        propsMap.put(""openjpa.DataCache"", ""true"");
        propsMap.put(""openjpa.QueryCache"", ""true(name=\""default\"")"");
        propsMap.put(""openjpa.RemoteCommitProvider"", ""sjvm"");
        _pmf = getEmf(propsMap);

There will be a ParseException
<openjpa-1.1.1-SNAPSHOT-r422266:930378M nonfatal general error> org.apache.openjpa.persistence.PersistenceException: There was an error while setting up the configuration plugin option ""QueryCache"". The plugin was of type ""org.apache.openjpa.datacache.ConcurrentQueryCache"". Setter methods for the following plugin properties were not available in that type: [name]. Possible plugin properties are: [CacheSize, FailFast, SoftReferenceSize].
Ensure that your plugin configuration string uses key values that correspond to setter methods in the plugin class.
        at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:196)
        at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)
        at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:199)
        at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:152)
        at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:1)
        at org.apache.openjpa.persistence.datacache.TestQueryResultSize.test(TestQueryResultSize.java:61)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at junit.framework.TestCase.runTest(TestCase.java:154)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at org.apache.openjpa.persistence.test.PersistenceTestCase.run(PersistenceTestCase.java:144)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:177)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:334)
        at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:980)
Caused by: org.apache.openjpa.lib.util.ParseException: There was an error while setting up the configuration plugin option ""QueryCache"". The plugin was of type ""org.apache.openjpa.datacache.ConcurrentQueryCache"". Setter methods for the following plugin properties were not available in that type: [name]. Possible plugin properties are: [CacheSize, FailFast, SoftReferenceSize].
Ensure that your plugin configuration string uses key values that correspond to setter methods in the plugin class.
        at org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:502)
        at org.apache.openjpa.lib.conf.Configurations.configureInstance(Configurations.java:430)
        at org.apache.openjpa.lib.conf.PluginValue.instantiate(PluginValue.java:103)
        at org.apache.openjpa.lib.conf.ObjectValue.instantiate(ObjectValue.java:83)
        at org.apache.openjpa.datacache.DataCacheManagerImpl.initialize(DataCacheManagerImpl.java:52)
        at org.apache.openjpa.conf.OpenJPAConfigurationImpl.getDataCacheManagerInstance(OpenJPAConfigurationImpl.java:614)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.initializeBroker(AbstractBrokerFactory.java:211)
        at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:190)
        ... 32 more","java version ""1.5.0_14""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_14-b03)
Java HotSpot(TM) Client VM (build 1.5.0_14-b03, mixed mode, sharing)

Windows XP",,,,,,,,,,,,,,,,,,12/Apr/10 03:15;amy;ASF.LICENSE.NOT.GRANTED--OPENJPA-1626.patch;https://issues.apache.org/jira/secure/attachment/12441444/ASF.LICENSE.NOT.GRANTED--OPENJPA-1626.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-07-14 20:16:52.261,,,no_permission,,,,,,,,,,,,161885,,,Mon Sep 20 15:39:51 UTC 2010,,,,,,,0|i1dt73:,288827,,,,,,,,12/Apr/10 03:15;amy;PATCH for branch 1.1.x,14/Jul/10 20:16;curtisr7;Committed revision 964170 to trunk,"20/Sep/10 15:39;mikedd;Closing issues which have been resolved for some time. If the problem persists, please reopen. ",,,,,,,,,,,,,,,,,,,,,,,,
Inconsistent creation of StateManagerImpl in BrokerImpl,OPENJPA-1625,12461714,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,10/Apr/10 15:08,22/Apr/10 20:30,14/Mar/19 03:03,10/Apr/10 21:27,2.0.0,,,,,,,,2.0.0,,,,,kernel,,,,0,,,,,,,,"In BrokerImpl, the StateManagerImpl is not created consistently using newStateManagerImpl, making it difficult to extend StateManagerImpl and BrokerImpl. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-04-10 21:27:59.174,,,no_permission,,,,,,,,,,,,161884,,,Sat Apr 10 21:27:59 UTC 2010,,,,,,,0|i0z7on:,203547,,,,,,,,10/Apr/10 21:27;drwoods;merged into 2.0.x,,,,,,,,,,,,,,,,,,,,,,,,,,
Exception during factory creation due to javax.persistence.transactionType,OPENJPA-1618,12461547,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,florianbruckner,florianbruckner,08/Apr/10 16:41,22/Apr/10 20:30,14/Mar/19 03:03,08/Apr/10 19:50,2.0.0-beta3,,,,,,,,2.0.0,,,,,,,,,0,,,,,,,,"With the folliowing code:

		emProperties.put(""javax.persistence.transactionType"", ""RESOURCE_LOCAL"");
		EntityManagerFactory factory = Persistence.createEntityManagerFactory(""myPu"", emProperties);

This exception is thrown:

Provider named org.apache.openjpa.persistence.PersistenceProviderImpl threw unexpected exception at create EntityManagerFactory: 
java.lang.IllegalArgumentException
java.lang.IllegalArgumentException: No enum const class javax.persistence.spi.PersistenceUnitTransactionType.JAVAX.PERSISTENCE.TRANSACTIONTYPE
	at java.lang.Enum.valueOf(Enum.java:196)
	at org.apache.openjpa.persistence.JPAProperties.getEnumValue(JPAProperties.java:207)
	at org.apache.openjpa.persistence.JPAProperties.getEnumValue(JPAProperties.java:190)
	at org.apache.openjpa.persistence.PersistenceUnitInfoImpl.fromUserProperties(PersistenceUnitInfoImpl.java:310)
	at org.apache.openjpa.persistence.PersistenceProductDerivation$ConfigurationParser.endElement(PersistenceProductDerivation.java:804)
	at org.apache.openjpa.lib.meta.XMLMetaDataParser.endElement(XMLMetaDataParser.java:456)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:601)
	at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.endElement(XMLSchemaValidator.java:795)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanEndElement(XMLDocumentFragmentScannerImpl.java:1774)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2930)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:140)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:510)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:807)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:107)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205)
	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522)
	at javax.xml.parsers.SAXParser.parse(SAXParser.java:395)
	at org.apache.openjpa.lib.meta.XMLMetaDataParser.parseNewResource(XMLMetaDataParser.java:393)
	at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:334)
	at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:311)
	at org.apache.openjpa.lib.meta.XMLMetaDataParser.parse(XMLMetaDataParser.java:284)
	at org.apache.openjpa.persistence.PersistenceProductDerivation$ConfigurationParser.parse(PersistenceProductDerivation.java:741)
	at org.apache.openjpa.persistence.PersistenceProductDerivation.parseResources(PersistenceProductDerivation.java:550)
	at org.apache.openjpa.persistence.PersistenceProductDerivation.load(PersistenceProductDerivation.java:520)
	at org.apache.openjpa.persistence.PersistenceProductDerivation.load(PersistenceProductDerivation.java:334)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:89)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:154)
	at org.apache.openjpa.persistence.PersistenceProviderImpl.createEntityManagerFactory(PersistenceProviderImpl.java:65)
	at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:110)
	at com.dreikraft.persistence.SyncSchema.testSetOwner(SyncSchema.java:32)


due to the following code in PersistenceUnitInfoImpl:

          else if (JPAProperties.TRANSACTION_TYPE.equals(key)) {
                setTransactionType(JPAProperties.getEnumValue(PersistenceUnitTransactionType.class, key));

which quite clearly should use the value to lookup the enum value, and not the key.","Windows XP SP3, Java 1.6.0_19",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-04-08 17:00:14.926,,,no_permission,,,,,,,,,,,,161877,,,Thu Apr 08 19:50:59 UTC 2010,,,,,,,0|i0z3p3:,202901,,,,,,,,"08/Apr/10 17:00;kwsutter;Oops, nice catch!",08/Apr/10 18:55;kwsutter;Looks like Pinaki beat me to the commit...  Please go ahead and get this into the 2.0 release as well.  Thanks.,08/Apr/10 19:50;drwoods;merged into 2.0.x as r932079,,,,,,,,,,,,,,,,,,,,,,,,
Wrong PersistentAttributeType returned for @Embedded types,OPENJPA-1611,12461098,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,oringel,oringel,03/Apr/10 16:40,22/Apr/10 20:30,14/Mar/19 03:03,11/Apr/10 13:30,2.0.0,,,,,,,,2.0.0,,,,,jpa,,,,0,,,,,,,,"Attribute.getPersistentAttributeType() should return PersistentAttributeType.EMBEDDED for @Embedded types. 
It returns PersistentAttributeType.ONE_TO_ONE now.

I guess this also has effects on Attribute.isAssociation() which returns true for @Embedded types.",,,,,,,,,,,,,,,,,,,03/Apr/10 16:41;oringel;openjpa-1611.tar;https://issues.apache.org/jira/secure/attachment/12440697/openjpa-1611.tar,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-04-04 17:30:57.626,,,no_permission,,,,,,,,,,,,38614,,,Mon Apr 05 10:32:21 UTC 2010,,,Patch Available,,,,0|i0z7yv:,203593,,,,,,,,03/Apr/10 16:41;oringel;Here is the test case.,"04/Apr/10 17:30;faywang;Hi Oliver, can you check if the fix resolve your problem?","05/Apr/10 10:32;oringel;Hi Fay,
I made a test with the latest snapshot (2.1.0-SNAPSHOT). 
Attribute.getPersistentAttributeType() is returning the correct value now.

But I think you have to fix Attribute.isAssociation() too. It should return false for @Embedded types. 
Maybe my above description was not clear enough.
",,,,,,,,,,,,,,,,,,,,,,,,
PessimisticLockException instead of LockTimeoutException thrown on DB2V9 for ZOS,OPENJPA-1609,12460975,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fyrewyld,fyrewyld,fyrewyld,01/Apr/10 22:21,22/Apr/10 20:30,14/Mar/19 03:03,07/Apr/10 20:04,2.0.0,,,,,,,,2.0.0,2.1.0,,,,,,,,0,,,,,,,,"I am observing the following problem while working with OpenJPA 2.x on DB2v91 for z/OS:

When performing a EntityManager.find() with a lock timeout property set, I'm expecting to receive a LockTimeoutException if my find operation fails to fetch the data from the database within the specified timeout period.  Instead of getting the LockTimeoutException, I am getting a PessimisticLockException -- an Exception that is considerably more severe then is expected.

I looked at the stack trace, and found the following information:

**Exception: Caught unexpected exception from find.
    org.apache.openjpa.persistence.PessimisticLockException:Unable to obtain an object lock on ""null [java.lang.String]"".
FailedObject: 1 [org.apache.openjpa.util.IntId] [java.lang.String]
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4809)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4787)
	at org.apache.openjpa.jdbc.sql.DB2Dictionary.newStoreException(DB2Dictionary.java:563)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:136)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:86)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:339)
	at com.ibm.ws.persistence.jdbc.kernel.WsJpaJDBCStoreManager.initialize(WsJpaJDBCStoreManager.java:147)
	at org.apache.openjpa.kernel.DelegatingStoreManager.initialize(DelegatingStoreManager.java:111)
	at org.apache.openjpa.kernel.ROPStoreManager.initialize(ROPStoreManager.java:57)
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:1005)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:963)
	at org.apache.openjpa.kernel.BrokerImpl.find(BrokerImpl.java:880)
	at org.apache.openjpa.kernel.DelegatingBroker.find(DelegatingBroker.java:222)
	at org.apache.openjpa.persistence.EntityManagerImpl.find(EntityManagerImpl.java:496)
	at suite.r80.base.jpaspec.entitymanager.testlogic.FindLockTestLogic.testScenarioL009(FindLockTestLogic.java:2150)
...
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: DB2 SQL Error: SQLCODE=-913, SQLSTATE=57033, SQLERRMC=00C9008E;00000304;DSN00292.JPA20EME.X'00000002'.X'01', DRIVER=3.57.91 {prepstmnt 2135785293 SELECT t0.version, t1.id, t1.version, t1.ENTITYALAZY_ID, t1.strData, t0.strData FROM JPA20EMEntityA t0 LEFT OUTER JOIN JPA20EMEntityC t1 ON t0.id = t1.ENTITYA_ID WHERE t0.id = ?  optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 1]} [code=-913, state=57033]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:257)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:241)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$700(LoggingConnectionDecorator.java:70)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection$LoggingPreparedStatement.executeQuery(LoggingConnectionDecorator.java:1063)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:278)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$CancelPreparedStatement.executeQuery(JDBCStoreManager.java:1706)
	at org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:268)
	at org.apache.openjpa.jdbc.sql.SelectImpl.executeQuery(SelectImpl.java:471)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:396)
	at com.ibm.ws.persistence.jdbc.sql.SelectImpl.execute(SelectImpl.java:77)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:354)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.getInitializeStateResult(JDBCStoreManager.java:577)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initializeState(JDBCStoreManager.java:379)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager.initialize(JDBCStoreManager.java:334)
	... 43 more

The problem is that OpenJPA does not properly process the combination of SQLCODE=-913, SQLSTATE=57033, and SQLERRMC=00C9008E.
The RedBook ""DB2 for z/OS Stored Procedures: Through the CALL and Beyond"" page 188 states:

-913
UNSUCCESSFUL EXECUTION CAUSED BY DEADLOCK OR TIMEOUT. REASON CODE reason-code, TYPE 
OF RESOURCE resource-type, AND RESOURCE NAME resource-name

Explanation: The application was the victim in a deadlock or experienced a time-out. The
reason code indicates whether a deadlock or time-out occurred.

SQLERRD(3) also contains the reason-code which indicates whether a deadlock or time-out 
occurred. The most common reason codes are:

00C90088 - deadlock 
00C9008E - time-out

Response: The application should either commit or roll back to the previous COMMIT. Then,
generally, the application should terminate. See message DSNT376I in DB2 UDB for z/OS
Version 8 Messages and Codes, GC18-7422, for possible ways to avoid future deadlocks or
time-outs.

The error being reported by DB2V9 on zOS is ""SQLCODE=-913, SQLSTATE=57033, SQLERRMC=00C9008E"", which indicates that
the reason for the unsuccessful execution is a Timeout, not a Deadlock.  

Presently, the DB2Dictionary.isFatalException() method does not support that combination.

I've made a change to the isFatalException() method that considers that error combination, and the expected LockTimeoutException now surfaces.  I will post the patch on to this JIRA in a few minutes.",DB2V91 on z/OS,,,,,,,,,,,,,,,,,,07/Apr/10 17:49;fyrewyld;OpenJPA-1609.patch;https://issues.apache.org/jira/secure/attachment/12441062/OpenJPA-1609.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161869,,,2010-04-01 22:21:46.0,,,Patch Available,,,,0|i0z80f:,203600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PESSIMISTIC_WRITE is not working in Informix,OPENJPA-1608,12460960,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,01/Apr/10 17:26,20/Feb/15 21:10,14/Mar/19 03:03,05/Apr/10 16:00,2.0.0,,,,,,,,2.0.0,,,,,jdbc,,,,0,,,,,,,,"The following call:

	district = em.find(DistrictJPA.class, key, LockModeType.PESSIMISTIC_WRITE);

	generates SELECT ... FOR UPDATE .

	However, in the default isolation level (read committed). Informix does not lock the row, causing a lot of duplicate key errors. The work around is for the application to explicitly set the property below in the persistence.xml:

	<property name=""openjpa.jdbc.TransactionIsolation"" value=""repeatable-read"" />

	According to the spec 3.4.4, footnote:

	For example, a persistence provider may use an underlying database platform's SELECT FOR UPDATE statements to implement pessimistic locking if that construct provides appropriate semantics, or the provider may use an isolation level of repeatable read.

	It appears that the persistence provider must implements PESSIMISTIC_WRITE semantics transparently to the application. ",,,,,,,,,,,,,,OPENJPA-2570,,,,,01/Apr/10 22:30;faywang;OPENJPA-1608.patch;https://issues.apache.org/jira/secure/attachment/12440550/OPENJPA-1608.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-04-02 17:06:06.485,,,no_permission,,,,,,,,,,,,38568,,,Mon Apr 05 16:00:26 UTC 2010,,,Patch Available,,,,0|i0z9hr:,203840,,,,,,,,"01/Apr/10 20:19;faywang;Changing the isolation level to repeatable read globally can reduce the concurrency. Changing it in the middle when PESSIMISTIC LOCK is specified is not allowed in the XA transaction. Another workaround for informix is to execute ""SET ENVIRONMENT RETAINUPDATELOCKS 'ALL'"" statement before executing the ""SELECT ... FOR UPDATE"" as show below:

    public static void main (String a[]) throws Exception {
        Connection conn = getConnection();
        conn.setAutoCommit(false);
        conn.setTransactionIsolation(   Connection.TRANSACTION_READ_UNCOMMITTED);
         String retainLocks = ""SET ENVIRONMENT RETAINUPDATELOCKS 'ALL'"";
         PreparedStatement pstmt2 = conn.prepareStatement(retainLocks);
         pstmt2.executeUpdate();
            
         String sql = ""select version from STOCK where S_I_ID = 8808 and S_W_ID = 9 for update"";
         PreparedStatement pstmt1 = conn.prepareStatement(sql);
         ResultSet rs1 = pstmt1.executeQuery();
            
         while (rs1.next()) {
                int version = rs1.getInt(1);
                System.out.println(""version = "" + version);
         }
         rs1.close();
         conn.commit();
      } 

http://publib.boulder.ibm.com/infocenter/idshelp/v115/index.jsp?topic=/com.ibm.sqls.doc/ids_sqs_2038.htm
 
","02/Apr/10 17:06;mikedd;Patch looks good Fay, go for it. ",05/Apr/10 16:00;faywang;The pessimistic write lock can still be a potential problem for other databases where select for update is only effective in certain isolation levels. The current patch is to fix informix only.,,,,,,,,,,,,,,,,,,,,,,,,
ReverseMappingTool (SchemaGenerator) bug,OPENJPA-1605,12460829,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,techhusky,leo.tu,leo.tu,31/Mar/10 15:51,22/Apr/10 20:30,14/Mar/19 03:03,15/Apr/10 19:47,2.0.0-beta3,,,,,,,,2.0.0,,,,,,,,,0,,,,,,,,"org.apache.openjpa.jdbc.schema.SchemaGenerator.java
=============================================
...
...
public void generateTables(DBIdentifier schemaName, DBIdentifier tableName,
        Connection conn, DatabaseMetaData meta) {
   ...
 Table table;
 DBIdentifier tableSchema = DBIdentifier.NULL;
 for (int i = 0; cols != null && i < cols.length; i++) {
        if (DBIdentifier.isNull(tableName) || tableName.equals(""%"")) { <---  bug code line
                tableName = cols[i].getTableIdentifier(); <---  bug code line
        }
...
...
 }
}


if parameter  tableName is null, than tableName is always been set the first column table Identifier 
  --> ""cols[0].getTableIdentifier() ""
this cause only generate first table class file with wrong columns.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-04-05 21:03:06.079,,,no_permission,,,,,,,,,,,,161867,,,Thu Apr 15 21:23:03 UTC 2010,,,,,,,0|i0z3u7:,202924,,,,,,,,"05/Apr/10 21:03;curtisr7;If possible, please post a unit test exhibiting the bug that you've pointed out.","06/Apr/10 13:52;leo.tu;Hi Rick Curtis, bellow is my unit test:


(1) Create Table for Testing:
==============================================
CREATE DATABASE `abc`;

DROP TABLE IF EXISTS `abc`.`mycompany`;
CREATE TABLE  `abc`.`mycompany` (
  `COMPANY_ID` varchar(20) NOT NULL,
  `ENGNAME` varchar(100) default NULL,
  `COUNTRY` varchar(5) default NULL,
  `CITY` varchar(20) default NULL,
  `ZIP` varchar(10) default NULL,
  `PHONE` varchar(40) default NULL,
  PRIMARY KEY  (`COMPANY_ID`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

DROP TABLE IF EXISTS `abc`.`mycompany_emp`;
CREATE TABLE  `abc`.`mycompany_emp` (
  `COMPANY_ID` varchar(20) NOT NULL,
  `EMPNAME` varchar(50) NOT NULL default '',
  `ROLE` varchar(30) default NULL,
  `EMAIL` varchar(100) default NULL,
  `ERP_ID` varchar(10) default NULL,
  PRIMARY KEY  (`COMPANY_ID`,`EMPNAME`),
  CONSTRAINT `COMPANY_EMP_FK1` FOREIGN KEY (`COMPANY_ID`) REFERENCES `mycompany` (`COMPANY_ID`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

DROP TABLE IF EXISTS `abc`.`myrole`;
CREATE TABLE  `abc`.`myrole` (
  `ROLE_ID` varchar(30) NOT NULL,
  `USER_ID` varchar(30) NOT NULL default '',
  `IS_ENABLE` varchar(1) default NULL,
  `LOCATION` varchar(30) default NULL,
  PRIMARY KEY  (`ROLE_ID`,`USER_ID`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;



(2) ANT build.xml for Testing:
==============================================
<?xml version=""1.0"" encoding=""UTF-8""?>
<project name=""test"" default=""reverse-schema-test"">

	<property name=""jdbc.driver"" value=""com.mysql.jdbc.Driver"" />
	<property name=""jdbc.url"" value=""jdbc:mysql://localhost:3306/abc"" />
	<property name=""jdbc.username"" value=""test"" />
	<property name=""jdbc.password"" value=""test123"" />
	<property name=""jdbc.package"" value=""db.model.test"" />
		
	<property name=""project.path"" value=""${basedir}"" />
	<property name=""webapp.path"" location=""${project.path}/WebContent"" />
	<property name=""java.classes.output.path"" location=""${webapp.path}/WEB-INF/classes"" />
	<property name=""java.code.src_auto_gen_test"" value=""${project.path}/src_auto_gen_test"" />

	<!-- echo -->
	<echo>ant.version=[${ant.version}]</echo>
	<echo>ant.java.version=[${ant.java.version}]</echo>
	<echo>java.home=[${java.home}]</echo>
	<!--
	<echo>basedir=[${basedir}]</echo>
	<echo>project.path=[${project.path}]</echo>
	<echo>webapp.path=[${webapp.path}]</echo>
	<echo>java.classes.output.path=[${java.classes.output.path}]</echo>
	-->

	<!-- classpath -->
	<path id=""default.classpath"">

		<!-- for openjpa-1.2.2 -->		
		<!--
		<fileset dir=""D:/download/apache-java/OpenJPA/apache-openjpa-1.2.2-binary/apache-openjpa-1.2.2"">
			<include name=""openjpa-1.2.2.jar"" />
			<include name=""lib/*.jar"" />
		</fileset>
		-->

		<!-- for openjpa-2.0.0-beta3 -->		
		<fileset dir=""D:/download/apache-java/OpenJPA/apache-openjpa-2.0.0-beta3-binary/apache-openjpa-2.0.0-beta3"">
			<include name=""openjpa-2.0.0-beta3.jar"" />
			<include name=""lib/*.jar"" />
		</fileset>		

		<!-- for jdbc -->
		<fileset dir=""D:/download/MS-SQL/mysql-connector-java-5.1.12"">
			<include name=""mysql-connector-java-5.1.12-bin.jar"" />
		</fileset>

		<pathelement location=""${java.classes.output.path}"" />
	</path>

	<taskdef name=""reversemappingtool"" classname=""org.apache.openjpa.jdbc.ant.ReverseMappingToolTask"">
		<classpath refid=""default.classpath"" />
	</taskdef>

	<target name=""reverse-schema-test"" depends="""" description=""Generate java files from the database schema"">
		<delete dir=""${java.code.src_auto_gen_test}"" />
		<mkdir dir=""${java.code.src_auto_gen_test}"" />
		<delete file=""${project.path}/orm.xml"" />

		<reversemappingtool inverseRelations=""true"" package=""${jdbc.package}"" directory=""${java.code.src_auto_gen_test}"" innerIdentityClasses=""true"" useBuiltinIdentityClass=""false"" identityClassSuffix=""Pk"" nullableAsObject=""true"" generateAnnotations=""true"" useSchemaName=""false"" detachable=""true"" useGenericCollections=""true"">
			<config connectiondrivername=""${jdbc.driver}"" connectionurl=""${jdbc.url}"" connectionusername=""${jdbc.username}"" connectionpassword=""${jdbc.password}"" />
			<codeformat tabSpaces=""4"" spaceBeforeParen=""false"" braceOnSameLine=""true"" />
		</reversemappingtool>
	</target>
	
</project>



(3) ANT build log message for version: ""openjpa-1.2.2""  
(<path id=""default.classpath"">
   ... 
  <include name=""openjpa-1.2.2.jar"" />
   ... 
</path>)

==============================================
Buildfile: D:\developer\workspace-soho\magic-web\build_test.xml
     [echo] ant.version=[Apache Ant version 1.7.1 compiled on June 27 2008]
     [echo] ant.java.version=[1.6]
     [echo] java.home=[C:\Program Files\Java\jre6]
reverse-schema-test:
    [mkdir] Created dir: D:\developer\workspace-soho\magic-web\src_auto_gen_test
   [delete] Deleting: D:\developer\workspace-soho\magic-web\orm.xml
[reversemappingtool] 62  server-pu  INFO   [main] openjpa.Tool - The reverse mapping tool will run on the database.  The tool is gathering schema information; this process may take some time.  Enable the org.apache.openjpa.jdbc.Schema logging category to see messages about schema data.
[reversemappingtool] 125  server-pu  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.MySQLDictionary"".
[reversemappingtool] 984  server-pu  INFO   [main] openjpa.Tool - ReverseMappingTool : generating classes.
[reversemappingtool] 1328  server-pu  INFO   [main] openjpa.Tool - Generating annotations.
[reversemappingtool] 1359  server-pu  INFO   [main] openjpa.MetaData - Writing class ""db.model.test.Mycompany"".
[reversemappingtool] 1375  server-pu  INFO   [main] openjpa.MetaData - Writing class ""db.model.test.MycompanyEmp"".
[reversemappingtool] 1375  server-pu  INFO   [main] openjpa.MetaData - Writing class ""db.model.test.Myrole"".
[reversemappingtool] 1390  server-pu  INFO   [main] openjpa.Tool - Writing generated class source code.
[reversemappingtool] 1390  server-pu  INFO   [main] openjpa.MetaData - Writing java code for generated type ""db.model.test.Mycompany"".
[reversemappingtool] 1406  server-pu  INFO   [main] openjpa.Enhance - Generating an application id for type ""class db.model.test.Mycompany"".
[reversemappingtool] 1453  server-pu  INFO   [main] openjpa.MetaData - Writing java code for generated type ""db.model.test.MycompanyEmp"".
[reversemappingtool] 1453  server-pu  INFO   [main] openjpa.Enhance - Generating an application id for type ""class db.model.test.MycompanyEmp"".
[reversemappingtool] 1453  server-pu  INFO   [main] openjpa.MetaData - Writing java code for generated type ""db.model.test.Myrole"".
[reversemappingtool] 1453  server-pu  INFO   [main] openjpa.Enhance - Generating an application id for type ""class db.model.test.Myrole"".
[reversemappingtool] 1468  server-pu  INFO   [main] openjpa.Tool - Writing generated metadata.
[reversemappingtool] 1500  server-pu  INFO   [main] openjpa.MetaData - Writing to file ""orm.xml"".
[reversemappingtool] 1515  server-pu  INFO   [main] openjpa.MetaData - Writing class ""db.model.test.Mycompany"".
[reversemappingtool] 1531  server-pu  INFO   [main] openjpa.MetaData - Writing class ""db.model.test.MycompanyEmp"".
[reversemappingtool] 1531  server-pu  INFO   [main] openjpa.MetaData - Writing class ""db.model.test.Myrole"".
BUILD SUCCESSFUL
Total time: 2 seconds



(4) ANT build log message for version: ""openjpa-2.0.0-beta3"" 
(<path id=""default.classpath"">
   ... 
  <include name=""openjpa-2.0.0-beta3.jar"" />
   ... 
</path>)
==============================================
Buildfile: D:\developer\workspace-soho\magic-web\build_test.xml
     [echo] ant.version=[Apache Ant version 1.7.1 compiled on June 27 2008]
     [echo] ant.java.version=[1.6]
     [echo] java.home=[C:\Program Files\Java\jre6]
reverse-schema-test:
    [mkdir] Created dir: D:\developer\workspace-soho\magic-web\src_auto_gen_test
   [delete] Deleting: D:\developer\workspace-soho\magic-web\orm.xml
[reversemappingtool] 93  server-pu  INFO   [main] openjpa.Tool - The reverse mapping tool will run on the database.  The tool is gathering schema information; this process may take some time.  Enable the org.apache.openjpa.jdbc.Schema logging category to see messages about schema data.
[reversemappingtool] 406  server-pu  INFO   [main] openjpa.jdbc.JDBC - Using dictionary class ""org.apache.openjpa.jdbc.sql.MySQLDictionary"".
[reversemappingtool] 1343  server-pu  INFO   [main] openjpa.Tool - ReverseMappingTool : generating classes.
[reversemappingtool] 1640  server-pu  INFO   [main] openjpa.Tool - Generating annotations.
[reversemappingtool] 1656  server-pu  INFO   [main] openjpa.MetaData - Writing class ""db.model.test.Mycompany"".
[reversemappingtool] 1687  server-pu  INFO   [main] openjpa.Tool - Writing generated class source code.
[reversemappingtool] 1687  server-pu  INFO   [main] openjpa.MetaData - Writing java code for generated type ""db.model.test.Mycompany"".
[reversemappingtool] 1718  server-pu  INFO   [main] openjpa.Enhance - Generating an application id for type ""class db.model.test.Mycompany"".
[reversemappingtool] 1765  server-pu  INFO   [main] openjpa.Tool - Writing generated metadata.
[reversemappingtool] 1796  server-pu  INFO   [main] openjpa.MetaData - Writing to file ""orm.xml"".
[reversemappingtool] 1828  server-pu  INFO   [main] openjpa.MetaData - Writing class ""db.model.test.Mycompany"".
BUILD SUCCESSFUL
Total time: 3 seconds



(5) /META-INF/persistence.xml
==============================================
<?xml version=""1.0"" encoding=""UTF-8"" ?>
<persistence xmlns=""http://java.sun.com/xml/ns/persistence"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
	xsi:schemaLocation=""http://java.sun.com/xml/ns/persistence
        http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd""
	version=""1.0"">

	<persistence-unit name=""server-pu"" transaction-type=""RESOURCE_LOCAL"">
		<provider>org.apache.openjpa.persistence.PersistenceProviderImpl</provider>
		<properties>
			<property name=""openjpa.jdbc.DBDictionary"" value=""storeCharsAsNumbers=false"" />
			<property name=""openjpa.jdbc.SynchronizeMappings"" value=""false"" />
			<property name=""openjpa.Log"" value=""SQL=TRACE""></property>
			<property name=""openjpa.ConnectionFactoryProperties"" value=""PrettyPrint=true,PrettyPrintLineLength=72""></property>
  	   </properties>

	</persistence-unit>
</persistence>


**********************************************
(6) Result
==>  version: ""openjpa-1.2.2""  is correct,  generate three java class files.
i.e, ""Mycompany ""

@Entity
@Table(name=""mycompany"")
@IdClass(db.model.test.Mycompany.Pk.class)
public class Mycompany {
    @Basic
    @Column(length=20)
    private String city;

    @Id
    @Column(name=""COMPANY_ID"", length=20)
    private String companyId;

    @Basic
    @Column(length=5)
    private String country;

    @Basic
    @Column(length=100)
    private String engname;

    @OneToMany(targetEntity=db.model.test.MycompanyEmp.class, mappedBy=""mycompany"", cascade=CascadeType.MERGE)
    private Set<MycompanyEmp> mycompanyEmps = new HashSet<MycompanyEmp>();

    @Basic
    @Column(length=40)
    private String phone;

    @Basic
    @Column(length=10)
    private String zip;


    public Mycompany() {
    }
...
}


==>  version: ""openjpa-2.0.0-beta3""  is incorrect, generate only one file:
i.e, ""Mycompany "" with wrong columns

/**
 * Auto-generated by:
 * org.apache.openjpa.jdbc.meta.ReverseMappingTool$AnnotatedCodeGenerator
 */
@Entity
@Table(name=""mycompany"")
@IdClass(db.model.test.Mycompany.Pk.class)
public class Mycompany {
    @Basic
    @Column(length=20)
    private String city;

    @Id
    @Column(name=""COMPANY_ID"", length=20)
    private String companyId;

    @Basic
    @Column(length=5)
    private String country;

    @Basic
    @Column(length=100)
    private String email;

    @Basic
    @Column(nullable=false, length=50)
    private String empname;

    @Basic
    @Column(length=100)
    private String engname;

    @Basic
    @Column(name=""ERP_ID"", length=10)
    private String erpId;

    @Basic
    @Column(name=""IS_ENABLE"", length=1)
    private String isEnable;

    @Basic
    @Column(length=30)
    private String location;

    @Basic
    @Column(length=40)
    private String phone;

    @Basic
    @Column(length=30)
    private String role;

    @Basic
    @Column(name=""ROLE_ID"", nullable=false, length=30)
    private String roleId;

    @Basic
    @Column(name=""USER_ID"", nullable=false, length=30)
    private String userId;

    @Basic
    @Column(length=10)
    private String zip;


    public Mycompany() {
    }
...
}
","15/Apr/10 19:47;techhusky;Fixed in 2.0.x branch and trunk.  Leo - Thanks for reporting this problem and for the test case.  This problem was breaking one of the reverse mapping example, so it can be verified by running that example.",15/Apr/10 21:23;drwoods;Only need Fix Version of 2.0.0,,,,,,,,,,,,,,,,,,,,,,,
"Setting PessimisticLockManager fails to append ""for update clause"" to the select statement",OPENJPA-1604,12460738,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,curtisr7,faywang,faywang,30/Mar/10 20:44,30/Jun/10 21:00,14/Mar/19 03:03,10/Apr/10 17:41,2.0.0,,,,,,,,2.0.0,,,,,,,,,0,,,,,,,," I ran a testcase against openjpa 1.2, and found that the ""for update"" clause is appended to the SQL when

 		<property name=""openjpa.LockManager"" value=""pessimistic""/>

	is added to the persistence.xml without calling: 

		 q.setLockMode(LockModeType.PESSIMISTIC_WRITE);

However, this behavior changes when running against trunk level code",,,,,,,,,,,,,OPENJPA-1714,,,,,,08/Apr/10 19:05;curtisr7;OPENJPA-1604-2.0.x.patch;https://issues.apache.org/jira/secure/attachment/12441199/OPENJPA-1604-2.0.x.patch,08/Apr/10 19:05;curtisr7;OPENJPA-1604-trunk.patch;https://issues.apache.org/jira/secure/attachment/12441198/OPENJPA-1604-trunk.patch,26/Apr/10 19:53;techhusky;OPENJPA-1604_optimistic_fix_2.0.x.patch;https://issues.apache.org/jira/secure/attachment/12442891/OPENJPA-1604_optimistic_fix_2.0.x.patch,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2010-03-31 16:31:35.412,,,no_permission,,,,,,,,,,,,161866,,,Mon Apr 26 19:53:14 UTC 2010,,,Patch Available,,,,0|i0yxlr:,201914,,,,,,,,"31/Mar/10 16:31;ppoddar@apache.org;The setting of lock modes based on current lock manager seems to be ambiguous at few places both in usage and in design/code.

From a usage point of view, 
  a) setting a specific lock manager be it pessimistic or optimistic should impose a specific default read and write lock level for all queries. 
  b) that default level can be overwritten by 
       i) setting query.setLockMode()
      ii) setting lockMode attribute of @NamedQuery
     iii) setting query hints
      iv) passing lock properties in find() etc.

  c) the semantics of a joint specification such as 
        <property name=""openjpa.LockManager"" value=""pessimistic""/>
        <property name=""openjpa.Optimistc"" value=""true""/>
      also appears confusing/contradictory. We should either detect specification that are contradictory or clarify what such apparently contradictory specifications imply.

From a design/code point of view,
   a) setting a FetchPlan.Lock hint during annotation parsing does not look good to me. We have reasonable data structures to capture meta information on a query and that seems to be the right place for lock information rather than a fetch plan hint.
   b) the default read/write lock levels should be dictated by the currently active lock manager. LockManager.beginTransaction() seems to be one correct place to populate the fetch configuration with these levels. Outside transaction, fetch plan initialization should take current Lock Manager into consideration to set its read/write lock levels.
   c) OpenJPAConfiguration should impose consistency between LockManager and setOptimistic() 
  
","08/Apr/10 18:34;curtisr7;After digging into this problem I concur with Pinaki's assessment that the lock modes / lock configuration has numerous issues. I'm posting a patch that will only address the backward compatibility issue. 

The root issue at hand is that in JPA 1.0 a named query had a default lock mode of READ (by OpenJPA's definition, not the spec), but per the 2.0 spec the default lock mode is NONE.

Ideally when we are parsing annotations in AnnotationPersistenceMetaDataParser we could differentiate between a named query which has specified the lockMode vs a default lockMode. Since that doesn't seem to be possible, I'm proposing that if we detect that we're using a pessimistic lock manager and the lockMode is none, we will promote that lock to a READ lock.

This approach will restore backward compatibility, but will exclude one use case. When using a pessimistic lock manager on 2.0 you will be unable to configure a NamedQuery with the lockMode of NONE. ",08/Apr/10 18:55;curtisr7;I just noticed that my patch still has some test debug in it... I'll update it shortly.,"09/Apr/10 16:19;ppoddar@apache.org;Some of the tests such as executing a NamedQuery with lock outside a transaction should raise an error has been @AllowFailured.
Please add the reason/explanatory texts to @AllowFailure why that is done/required. ","10/Apr/10 17:41;drwoods;Code checked into 2.0.0, so marking it resolved for the release notes.
If more work is required, please open a new issue and link it to this one.",12/Apr/10 14:40;curtisr7;@Pinaki -- See OPENJPA-1629 regarding the @AllowFailure.,26/Apr/10 19:53;techhusky;Attaching a patch for 2.0.x which takes into account the Optimistic setting when calculating the default lock mode to apply to a named query.  This must occur in order to maintain 1.x behavior.,,,,,,,,,,,,,,,,,,,,
Query with lock mode set to PESSIMISTIC_WRITE does not have for update clause attached to the sql when runs twice,OPENJPA-1602,12460578,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,ppoddar@apache.org,faywang,faywang,29/Mar/10 18:04,22/Apr/10 20:30,14/Mar/19 03:03,07/Apr/10 16:26,2.0.0,,,,,,,,2.0.0,,,,,jdbc,,,,0,,,,,,,,"The following test case executes query two times. 

The sql generated for the first time:
sql = SELECT t0.KEYNAME, t0.KEYVAL FROM KEYGEN t0 WHERE (t0.KEYNAME = ?)  optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS

The sql generated for the second time:
sql = SELECT t0.KEYNAME, t0.KEYVAL FROM KEYGEN t0 WHERE (t0.KEYNAME = ?)


   public void testKeyGen() {
        EntityManager em = emf.createEntityManager();
        KeyGenEntity key = null;
        em.getTransaction().begin();
        for (int i = 0;i < 2; i++) {
            Query q = em.createNamedQuery(""getStationKeyForUpdate"");
            q.setLockMode(LockModeType.PESSIMISTIC_WRITE);
            q.setParameter(""keyname"", keyName);
            try {
                key = (KeyGenEntity) q.getSingleResult();
                em.refresh(key);
            }
            catch (NoResultException e) {
                // No keys found for this name - create a new one
                int keyVal = 0;
                key = new KeyGenEntity(keyName, keyVal);
                em.persist(key);
                em.lock(key, LockModeType.PESSIMISTIC_WRITE);
            }

            int keyVal = key.getKeyval();
            key.setKeyval(keyVal +  1);
        }
        em.getTransaction().commit();
    }
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-03-30 19:24:58.304,,,no_permission,,,,,,,,,,,,161864,,,Tue Mar 30 19:24:58 UTC 2010,,,,,,,0|i0ywen:,201720,,,,,,,,"29/Mar/10 19:41;faywang;The following is the KeyGenEntity.java:

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.NamedQuery;
import javax.persistence.Table;

/**
 * Handles key gen generation for a number of cases.
 *
 */
@Entity
@Table(name=""KEYGEN"")
@NamedQuery(name=""getStationKeyForUpdate"",
query=""select kg from KeyGenEntity as kg where kg.keyname = :keyname"")
public class KeyGenEntity {

@Id
@Column(name=""KEYNAME"")
private String keyname;
@Column(name=""KEYVAL"")
private int keyval;

public String getKeyname() {
return keyname;
}

public void setKeyname(String keyname) {
this.keyname = keyname;
}

public int getKeyval() {
return keyval;
}

public void setKeyval(int keyval) {
this.keyval = keyval;
}

public KeyGenEntity() {
}

public KeyGenEntity(String keyname, int keyval) {
super();
this.keyname = keyname;
this.keyval = keyval;
}
} ",30/Mar/10 19:24;drwoods;showing as affects/fix for 2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,
Cache mode properties passes in to em.find and lock methods are not transient,OPENJPA-1599,12460186,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,allee8285,allee8285,allee8285,25/Mar/10 03:13,22/Apr/10 20:30,14/Mar/19 03:03,10/Apr/10 21:26,2.0.0,2.0.0-beta2,2.0.0-beta3,,,,,,2.0.0,,,,,jpa,,,,0,,,,,,,,"Cache mode properties passes in to em.find and lock methods are not transient and permanently
set to the entity manager, which caused subsequent em operations to use the undesired
cache mode.

    public <T> T find(Class<T> cls, Object oid, LockModeType mode, Map<String, Object> properties) {
        assertNotCloseInvoked();
        configureCurrentCacheModes(getFetchPlan(), properties);  <<---- pushFetchPlan call should be performed first before the getFetchPlan
        configureCurrentFetchPlan(pushFetchPlan(), properties, mode, true);
        try {
            oid = _broker.newObjectId(cls, oid);
            return (T) _broker.find(oid, true, this);
        } finally {
            popFetchPlan();
        }
    }
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-04-10 21:26:09.307,,,no_permission,,,,,,,,,,,,161861,,,Sat Apr 10 21:26:09 UTC 2010,,,,,,,0|i0z3tr:,202922,,,,,,,,"25/Mar/10 22:51;allee8285;Cache*Mode property processing in em method call modified (removed) the processed property from user's input properties Map, which is not part of the em contract and potentially causes application side effect.","10/Apr/10 21:26;drwoods;Code checked into 2.0.0, so marking it resolved for the release notes.
If more work is required, please open a new issue and link it to this one.
",,,,,,,,,,,,,,,,,,,,,,,,,
Need Compatibility setting for new OPENJPA-1097 Proxies and DetachedStateField behavior,OPENJPA-1597,12460114,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Critical,Fixed,drwoods,drwoods,drwoods,24/Mar/10 15:04,22/Apr/10 20:30,14/Mar/19 03:03,05/Apr/10 16:24,2.0.0-beta3,,,,,,,,1.3.0,2.0.0,,,,integration,jpa,UnenhancedClasses,,0,,,,,,,,"Need Compatibility setting for new Proxies and DetachedStateField behavior introduced in OPENJPA-1097 for legacy 1.0 persistence.xml apps, that rely on old behavior that using DetachedStateField=true would remove $proxy usage when serialized, but the new behavior is to keep the $proxy usage since we are serializing the StateManager into the object....
",,,,,,,,,,,,,,,,,,,05/Apr/10 15:48;drwoods;OPENJPA-1597-12x-code.patch;https://issues.apache.org/jira/secure/attachment/12440768/OPENJPA-1597-12x-code.patch,26/Mar/10 12:22;drwoods;OPENJPA-1597-12x-tests.patch;https://issues.apache.org/jira/secure/attachment/12439875/OPENJPA-1597-12x-tests.patch,05/Apr/10 15:12;drwoods;OPENJPA-1597-13x-doc.patch;https://issues.apache.org/jira/secure/attachment/12440760/OPENJPA-1597-13x-doc.patch,01/Apr/10 02:25;drwoods;OPENJPA-1597-13x.patch;https://issues.apache.org/jira/secure/attachment/12440434/OPENJPA-1597-13x.patch,27/Mar/10 20:54;drwoods;OPENJPA-1597-20x-20100327.patch;https://issues.apache.org/jira/secure/attachment/12439985/OPENJPA-1597-20x-20100327.patch,29/Mar/10 17:59;drwoods;OPENJPA-1597-20x-docs.patch;https://issues.apache.org/jira/secure/attachment/12440084/OPENJPA-1597-20x-docs.patch,26/Mar/10 12:21;drwoods;OPENJPA-1597-20x-tests-fix.patch;https://issues.apache.org/jira/secure/attachment/12439871/OPENJPA-1597-20x-tests-fix.patch,25/Mar/10 15:00;drwoods;OPENJPA-1597-20x-tests.patch;https://issues.apache.org/jira/secure/attachment/12439782/OPENJPA-1597-20x-tests.patch,27/Mar/10 20:25;drwoods;OPENJPA-1597-trunk-20100327.patch;https://issues.apache.org/jira/secure/attachment/12439981/OPENJPA-1597-trunk-20100327.patch,27/Mar/10 20:25;drwoods;OPENJPA-1597-trunk-compat.patch;https://issues.apache.org/jira/secure/attachment/12439980/OPENJPA-1597-trunk-compat.patch,26/Mar/10 12:21;drwoods;OPENJPA-1597-trunk-tests-fix.patch;https://issues.apache.org/jira/secure/attachment/12439872/OPENJPA-1597-trunk-tests-fix.patch,25/Mar/10 15:00;drwoods;OPENJPA-1597-trunk-tests.patch;https://issues.apache.org/jira/secure/attachment/12439781/OPENJPA-1597-trunk-tests.patch,12.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161859,,,Mon Apr 05 16:24:57 UTC 2010,,,,,,,0|i0ywe7:,201718,,,,,,,,25/Mar/10 15:00;drwoods;Tests to verify any code changes fix the reported problem by allowing prior proxy behavior.,"26/Mar/10 12:21;drwoods;Patches to fix test failure when run with other tests due to entity/table name collisions.
Already checked into trunk as 927506 and 2.0.x as r927521.
",26/Mar/10 12:22;drwoods;Version of tests for 1.2.x showing expected behavior for 1.0 apps.,"27/Mar/10 20:25;drwoods;Patches that add a new openjpa.Compatibility flag of IgnoreDetachedStateFieldForProxySerialization, which when 2.0 apps set to TRUE, will use the old 1.0 behavior for Proxies.writeReplace(), along with automatically using the old behavior for 1.0 apps.
Patch file 20100327 reverts a previous addition of removing proxies when they are detached, which broke a detach/merge scenario when using proxied List collections.
",27/Mar/10 20:54;drwoods;compat+20100327 patches ported from trunk and combined into one patch and committed as r928271,29/Mar/10 17:59;drwoods;Doc updates for new Compatibility option.,"01/Apr/10 02:25;drwoods;Add Compatibility option to use new 2.0 behavior of removing proxy classes unless DetachedStateField=true, but default is still the old behavior.",05/Apr/10 15:12;drwoods;Update to 1.3.x docs to mention $proxy problem during serialization and how to use the new compatibility property.,"05/Apr/10 15:48;drwoods;Patch that adds the openjpa.Compatibility property and behavior for IgnoreDetachedStateFieldForProxySerialization, along with doc and test updates.",05/Apr/10 16:24;drwoods;Default behavior updated in 2.0.  Prior 1.3.x requires usage of Compatibility property to use the new behavior.  Patch attached for 1.2.x if we ever decide to apply it there.,,,,,,,,,,,,,,,,,
Index name too long for DB2 zOS,OPENJPA-1596,12460029,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,faywang,faywang,23/Mar/10 18:39,02/Jun/10 19:23,14/Mar/19 03:03,23/Mar/10 19:29,2.0.0-beta2,,,,,,,,2.0.0-beta3,,,,,jdbc,,,,0,,,,,,,,"When running JPA on DB2 zOS v9, the following exception is thrown:

Exception in thread ""main"" <openjpa-2.0.0-SNAPSHOT-r422266:832587 nonfatal user error> org.apache.openjpa.persistence.ArgumentException: Index name ""OPENJPA_SEQUENCE_TABLE_IDX"" is 26-character long. The database allows maximum 18-character for an index name. 
	at org.apache.openjpa.jdbc.sql.DBDictionary.checkNameLength(DBDictionary.java:5021)
	at org.apache.openjpa.jdbc.sql.DBDictionary.getCreateIndexSQL(DBDictionary.java:3429)
	at org.apache.openjpa.jdbc.schema.SchemaTool.createIndex(SchemaTool.java:1017)
	at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:565)
	at org.apache.openjpa.jdbc.schema.SchemaTool.add(SchemaTool.java:345)
	at org.apache.openjpa.jdbc.schema.SchemaTool.run(SchemaTool.java:322)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:501)
	at org.apache.openjpa.jdbc.meta.MappingTool.record(MappingTool.java:453)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:155)
	at org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory.synchronizeMappings(JDBCBrokerFactory.java:159)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161858,,,2010-03-23 18:39:47.0,,,,,,,0|i0z3e7:,202852,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Agent enhancer doesn't work with Tomcat,OPENJPA-1590,12459850,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,struberg,techhusky,techhusky,22/Mar/10 12:38,06/Jun/15 14:25,14/Mar/19 03:03,05/Apr/15 06:21,2.0.0-M3,2.1.1,2.2.0,,,,,,2.4.0,,,,,integration,UnenhancedClasses,,,0,,,,,,,,"Originally reported as OPENJPA-1410 - Class linkage exception when creating an EMF with OpenJPA M3

Experimentation and a quick search for similar issues is showing that use of the OpenJPA's agent enhancer with Tomcat never worked?!? The agent gets tied to the base class loader and enhances classes available to that loader at startup. Each app has their own lazily instantiated class loader. Enhancement has already taken place by the time those loaders get instantiated. This looked like a regression, but it it is actually a separate and much larger issue than the one raised in this JIRA. I will not pursue that issue at this time. 

Please verify that you no longer see the original problem/exception with latest 2.0 build. If you were relying on runtime enhancement you will need to re-enable it by specifying:
<property name=""openjpa.RuntimeUnenhancedClasses"" value=""supported""/>

A more recommended solution is to enhance your entities at build time and set -
<property name=""openjpa.DynamicEnhancementAgent"" value=""false""/>
<property name=""openjpa.RuntimeUnenhancedClasses"" value=""unsupported""/> 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-02-02 18:22:24.799,,,no_permission,,,,,,,,,,,,161853,,,Sun Apr 05 06:21:09 UTC 2015,,,,,,,0|i1dt9j:,288838,,,,,,,,02/Feb/12 18:22;allee8285;Move fix version to 2.3.0 in preparation for 2.2.0 release.,05/Apr/15 06:21;struberg;works fine in 2.4.0,,,,,,,,,,,,,,,,,,,,,,,,,
modify 925451 revision for setProperty processing for enums,OPENJPA-1588,12459770,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,kwsutter,kwsutter,kwsutter,20/Mar/10 22:46,29/Mar/10 23:17,14/Mar/19 03:03,21/Mar/10 00:20,2.0.0,,,,,,,,2.0.0-beta3,,,,,jpa,,,21/Mar/10 00:00,0,,,,,,,,"SVN revision 925451 was a little too much.  The changes now allow for the processing of the enum properties, javax.persistence.cache.retrieveMode and javax.persistence.cache.storeMode, which is good.  But, it also introduced the acceptance of the javax.persistence.sharedCache.mode.  But, this property is only valid when creating the EMF and, thus, does not have to be processed in this code path.

I am also correcting the spelling of the convertToKernelValue method (it was missing the ""r"" in Kernel).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161851,,,2010-03-20 22:46:28.0,,,,,,,0|i0z3d3:,202847,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PreparedQuery gives wrong result if query has subquery and parameters are used in both main select and subselect,OPENJPA-1584,12459550,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,fancy,fancy,18/Mar/10 17:57,24/Jul/10 16:23,14/Mar/19 03:03,24/Jul/10 16:23,2.0.0,,,,,,,,2.1.0,,,,,performance,,,,1,,,,,,,,"a back-to-back of the following JPQL query providing different set of parameter values, 
the second execution gives wrong answer.

 ""select o from OrderJPA o where o.OrderId in (select max(o1.OrderId) from OrderJPA o1 where ((o1.CustomerId = :customerId) and (o1.DistrictId = :districtId) and (o1.WarehouseId = :warehouseId))) and (o.CustomerId = :customerId) and (o.DistrictId = :districtId) and (o.WarehouseId = :warehouseId)""

SQL trace shown the first time query execution, let say customerId=339, districtId=3, warehouseId=23, then query returns 1 row:

the SQL trace looked fine:

[3/16/10 17:40:36:831 CDT] 00000045 OpenJPA       3   openjpa.jdbc.SQL: Trace: <t 241897067, conn 1981117973> executing prepstmnt 1547852866 SELECT t0.O_D_ID, t0.O_ID, t0.O_W_ID, t0.VERSION, t0.O_ALL_LOCAL, t0.O_CARRIER_ID, t0.O_C_ID, t0.O_ENTRY_D, t0.O_OL_CNT FROM ORDERS t0 WHERE (t0.O_ID IN (SELECT MAX(t1.O_ID) FROM ORDERS t1 WHERE (t1.O_C_ID = ? AND t1.O_D_ID = ? AND t1.O_W_ID = ?) ) AND t0.O_C_ID = ? AND t0.O_D_ID = ? AND t0.O_W_ID = ?)  optimize for 1 row [params=(short) 339, (short) 3, (short) 23, (short) 339, (short) 3, (short) 23]

On the next execution of the same JPQL, the PreparedQueryImpl (which is cached before) gets reused.
In processing user provided parameters, for example, customerId=2967, districtId=5, warehouseId=22,
It is observed that the parameter values are incorrect: the last 3 values were incorrectly copied from the previously cached version.


[3/16/10 17:45:42:411 CDT] 00000043 OpenJPA       3   openjpa.jdbc.SQL: Trace: <t 195496871, conn 1706649017> executing prepstmnt 1531796301 SELECT t0.O_D_ID, t0.O_ID, t0.O_W_ID, t0.VERSION, t0.O_ALL_LOCAL, t0.O_CARRIER_ID, t0.O_C_ID, t0.O_ENTRY_D, t0.O_OL_CNT FROM ORDERS t0 WHERE (t0.O_ID IN (SELECT MAX(t1.O_ID) FROM ORDERS t1 WHERE (t1.O_C_ID = ? AND t1.O_D_ID = ? AND t1.O_W_ID = ?) ) AND t0.O_C_ID = ? AND t0.O_D_ID = ? AND t0.O_W_ID = ?)  optimize for 1 row [params=(short) 2967, (short) 5, (short) 22, (short) 339, (short) 3, (short) 23]

",,,,,,,,,,,,,,,,,,,22/Jul/10 15:23;dirichs;OpenJPA-2.0.0_OJ1584.patch;https://issues.apache.org/jira/secure/attachment/12450179/OpenJPA-2.0.0_OJ1584.patch,,,,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-07-22 15:23:53.817,,,no_permission,,,,,,,,,,,,161847,,,Sat Jul 24 16:23:37 UTC 2010,,,,,,,0|i0zbu7:,204220,,,,,,,,"22/Jul/10 15:23;dirichs;A modification to SQLBuffer has been committed in revision 925036 which supposedly corrected this issue. However, the committed change also has problems. The problem arises during the construction of a prepared statement when sub-selects are added to the main statement. In particular, the indexes of user parameters have to be adapted to their new positions within the resulting statement (which consists of the main statement and the sub-select). File org.apache.openjpa.jdbc.sql.SQLBuffer contains the following lines, which were committed with revision 925036 (lines 170++):

            // modify this buffer's user parameter index
            int otherSize = buf._userIndex.size()/2;
            for (int i = 0; i < _userIndex.size(); i+=2) {
                int newIndex = ((Integer)_userIndex.get(i)).intValue() + otherSize;
                _userIndex.set(i, newIndex);
            }
            // append the other buffer's user parameters to this one
            for (int i = 0; i < buf._userIndex.size(); i+=2) {
                Object otherIndex = buf._userIndex.get(i);
                Object otherParam = buf._userIndex.get(i+1);
                _userIndex.add(otherIndex);
                _userIndex.add(otherParam);
            }            

This code assumes that the sub-select user parameters, which are stored in buf._userIndex, always reside at positions in the combined statement before all the parameters of the main statement. If this is the case, the above code works (almost) correctly: All user parameters of the main statement get their indexes adapted, all sub-select user parameters are just copied without change. The code is only almost correct in this case, because the index offset calculation done with
int otherSize = buf._userIndex.size()/2;
is misguided - the offset should really be the number of all parameters (including non-user parameters) of the sub-select, not only the user parameters.

The correct code is given below:

            // modify this buffer's user parameter index for all parameters
            // at or behind paramIndex, which is the insertion position
            int otherSize = buf._params.size();
            for (int i = 0; i < _userIndex.size(); i+=2) {
                int oldIndex = ((Integer)_userIndex.get(i)).intValue();
                if (oldIndex >= paramIndex)
                    _userIndex.set(i, oldIndex + otherSize);
            }
            // append the other buffer's user parameters to this one, their
            // position adapted according to the insertion position
            for (int i = 0; i < buf._userIndex.size(); i+=2) {
                int otherIndex = ((Integer) buf._userIndex.get(i)).intValue();
                Object otherParam = buf._userIndex.get(i+1);
                _userIndex.add(otherIndex + paramIndex);
                _userIndex.add(otherParam);
            }            

Here, the insertion position at where the sub-select parameters get inserted into the main statement is propertly taken into account (paramIndex). User parameters of the main statement which reside before the insertion position remain unchanged, the position of all others gets offset by the number of parameters of the sub-select. The sub-select user parameters in turn are moved by an amount equal to the insertion position.

A corresponding patch OpenJPA-2.0.0_OJ1584.patch containing the correct version of the code is attached. It would be better though to also add a new test method to TestPreparedQueryCache. If my help is welcome, I can create such a test case and supply it as well.","22/Jul/10 17:18;drwoods;Additional tests are always welcomed :-)
",24/Jul/10 16:23;fancy;Resolved in  OPENJPA-1719 and OPENJPA-1738,,,,,,,,,,,,,,,,,,,,,,,,
Update by query fails on entities using Timestamp as Version field,OPENJPA-1583,12459537,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,18/Mar/10 16:55,10/Apr/13 21:11,14/Mar/19 03:03,10/Apr/13 21:11,,,,,,,,,1.2.3,2.0.0-beta3,,,,,,,,0,,,,,,,,Update by query fails when an entity is using Timestamped version field,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161846,,,2010-03-18 16:55:14.0,,,,,,,0|i06c9z:,34923,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
getCache() should throw IllegalStateException if the EMF has been closed. ,OPENJPA-1581,12459524,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Minor,Fixed,mikedd,mikedd,mikedd,18/Mar/10 14:29,23/Mar/10 18:33,14/Mar/19 03:03,22/Mar/10 17:26,,,,,,,,,2.0.0-beta3,,,,,,,,,0,,,,,,,,"Per javadoc for EntityManagerFactory.getCache(): 

 /**

     * Access the cache that is associated with the entity manager 

     * factory (the ""second level cache"").

     * @return instance of the Cache interface

     * @throws IllegalStateException if the entity manager factory

     * has been closed

     */

    public Cache getCache();

Throwing a new IllegalStateException is trivial, but throwing the same exception we do for other operations on a closed factory is a bit more involved. 

Short reason : 
* BrokerFactory.assertOpen() is not public, and the saved exception (used when trace is enabled) is also not available outside of AbstractBrokerFactory. 
* EMFImpl.getCache() caches the cache. The same object implements the JPA cache interface and the OpenJPA StoreCache interface. Historically getting the StoreCache does not require the EMF to be open (this may be an oversight). 


",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161844,,,2010-03-18 14:29:48.0,,,,,,,0|i1dtav:,288844,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using firstResult and maxResults in queries is not working properly,OPENJPA-1580,12459395,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,oringel,oringel,17/Mar/10 16:35,23/Mar/10 18:34,14/Mar/19 03:03,19/Mar/10 15:19,2.0.0-beta2,,,,,,,,2.0.0-beta3,,,,,,,,,0,,,,,,,,"Hi again,
I try to implement a paged resultset using the firstResult and maxResults method of the Query class. It seems that this is not working as expected. 

Here is the relevant part of the logging.

DEBUG,Query,main] Executing query: select s from SimpleEntity s order by s.id
[DEBUG,SQL,main] <t 2132679615, conn 651497704> executing prepstmnt 558185842 SELECT LIMIT 0 2 t0.id, t0.version, t0.base, t0.street, t0.my_name FROM some_objects t0 ORDER BY t0.id ASC
[DEBUG,Query,main] Executing query: select s from SimpleEntity s order by s.id
[DEBUG,SQL,main] <t 2132679615, conn 651497704> executing prepstmnt 2094184728 SELECT LIMIT 0 2 t0.id, t0.version, t0.base, t0.street, t0.my_name FROM some_objects t0 ORDER BY t0.id ASC

Both queries are identical. So my guess is once more the trouble comes from the query cache.
","Ubuntu 9.10, Maven 2.2.1, Spring 3.0.1 ",,,,,,,,,,,,,,,,,,18/Mar/10 23:13;faywang;OPENJPA-1580.patch;https://issues.apache.org/jira/secure/attachment/12439222/OPENJPA-1580.patch,17/Mar/10 16:36;oringel;openjpa1580.tar;https://issues.apache.org/jira/secure/attachment/12439046/openjpa1580.tar,,,,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-03-17 16:55:48.677,,,no_permission,,,,,,,,,,,,161843,,,Fri Mar 19 14:34:26 UTC 2010,,,,,,,0|i0z9if:,203843,,,,,,,,17/Mar/10 16:36;oringel;Here is the test case.,"17/Mar/10 16:55;faywang;Hi Oliver, could you attache a test case or code snippet?","17/Mar/10 16:56;faywang;Sorry, i just found out your attached test case.","18/Mar/10 18:02;faywang;Yes, this is again related to the cache. A patch will be posted soon.","19/Mar/10 14:34;oringel;Hi Fay, your patch fixed the bug. Thanks.",,,,,,,,,,,,,,,,,,,,,,
CacheStoreMode.REFRESH is not recognized,OPENJPA-1578,12459264,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,16/Mar/10 14:29,29/Mar/10 23:17,14/Mar/19 03:03,22/Mar/10 18:15,2.0.0-beta2,,,,,,,,2.0.0-beta3,,,,,datacache,,,,0,,,,,,,,CacheStoreMode.REFRESH property is not being used properly for entities to update the L2 cache.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161841,,,2010-03-16 14:29:00.0,,,,,,,0|i0yzvr:,202283,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using @Strategy in Queries not working properly,OPENJPA-1577,12459253,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,faywang,oringel,oringel,16/Mar/10 09:54,29/Mar/10 23:17,14/Mar/19 03:03,22/Mar/10 18:56,2.0.0-beta2,,,,,,,,2.0.0-beta3,,,,,,,,,0,,,,,,,,"I try to use a field that is annotated with @Strategy in a Query. 

I expected that everytime the query is executed the toDataStoreValue method of the ValueHandler is called to prepare the correct values for the SQL query.
This is only happens once. The next time the Query is executed the ValueHandler is not called.

Here is the interesting part of the logging 

1st call:
[DEBUG,Query,main] Executing query: [select s from SimpleEntity s where s.base = :base and s.name = :name] with parameters: {name=james, base=1}
toDataStoreValue: 1
[DEBUG,SQL,main] <t 805562662, conn 2071272094> executing prepstmnt 1531692262 SELECT t0.id, t0.version, t0.base, t0.street, t0.my_name FROM some_objects t0 WHERE (t0.base = ? AND t0.my_name = ?) [params=(String) base1, (String) james]

2nd call: 
[DEBUG,Query,main] Executing query: [select s from SimpleEntity s where s.base = :base and s.name = :name] with parameters: {0=2, 1=henry}
[DEBUG,SQL,main] <t 805562662, conn 2071272094> executing prepstmnt 106030716 SELECT t0.id, t0.version, t0.base, t0.street, t0.my_name FROM some_objects t0 WHERE (t0.base = ? AND t0.my_name = ?) [params=(String) 2, (String) henry]

You can see that the parameter list has changed after the first call. Some kind of transformation (caching?) prevents calling the ValueHandler again.
This is only a vague presumption.","Ubuntu 9.10, Maven 2.2.1, Spring 3.0.1",,,,,,,,,,,,,,,,,,16/Mar/10 20:54;faywang;OPENJPA-1577-1.patch;https://issues.apache.org/jira/secure/attachment/12438960/OPENJPA-1577-1.patch,16/Mar/10 20:21;faywang;OPENJPA-1577.patch;https://issues.apache.org/jira/secure/attachment/12438956/OPENJPA-1577.patch,16/Mar/10 09:57;oringel;openjpa1577.tar;https://issues.apache.org/jira/secure/attachment/12438911/openjpa1577.tar,,,,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2010-03-16 16:37:48.261,,,no_permission,,,,,,,,,,,,161840,,,Wed Mar 17 16:47:24 UTC 2010,,,Patch Available,,,,0|i0z3fz:,202860,,,,,,,,16/Mar/10 09:57;oringel;Here is the test case.,16/Mar/10 16:37;faywang;I can reproduce this problem. Will take a look.,"16/Mar/10 20:21;faywang;Yes, this problem is due to the query cache. The patch disables the cache for queries that make use of user-defined strategy.",16/Mar/10 20:54;faywang;This patch is based on the latest trunk level code. ,"16/Mar/10 23:44;faywang;Hi Oliver, can you try to see if it works for your query?","17/Mar/10 13:26;oringel;The patch fixed the issue. My queries are working now. Again, thanks for the help.

One questions. Is disabling the query cache the final solution? 
It would be nice if that would not be necessary and I guess that should be possible. 
","17/Mar/10 16:47;faywang;Yes, it is possible to not to disable query cache. We will explore this possibility.",,,,,,,,,,,,,,,,,,,,
maven plugin broken as of 3/16/2010 2:30 AM PST using openjpa-2.0.0-SNAPSHOT ,OPENJPA-1576,12459251,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,,sqqqas,sqqqas,16/Mar/10 09:51,23/Mar/10 18:33,14/Mar/19 03:03,16/Mar/10 21:47,2.0.0,,,,,,,,2.0.0-beta3,,,,,,,,,0,maven,,,,,,,"maven plugin broken as of 3/16/2010 2:30 AM PST using openjpa-2.0.0-SNAPSHOT

maven repo checksums also fail.  :(

tested using vmware rollback of march 13 maven tree, mvn -o install succeeds with given pom, maven will seek out and replace openjpa-2.0.0-SNAPSHOT with non-working version as of this ticket creation.  [dump below]
 


[INFO]    task-segment: [openjpa:enhance]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing openjpa:enhance
[WARNING] Removing: enhance from forked lifecycle, to prevent recursive invocation.
[INFO] [resources:resources {execution: default-resources}]
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 3 resources
[INFO] snapshot org.apache.openjpa:openjpa-lib:2.0.0-SNAPSHOT: checking for updates from openjpa-internal
[WARNING] repository metadata for: 'snapshot org.apache.openjpa:openjpa-lib:2.0.0-SNAPSHOT' could not be retrieved from
 repository: openjpa-internal due to an error: Connection failed: Repository path /internal-repository does not exist, 
and cannot be created.
[INFO] Repository 'openjpa-internal' will be blacklisted
[INFO] [compiler:compile {execution: default-compile}]
[INFO] Nothing to compile - all classes are up to date
[INFO] [openjpa:enhance {execution: default-cli}]
[FATAL ERROR] org.codehaus.mojo.openjpa.OpenJpaEnhancerMojo#execute() caused a linkage error (java.lang.NoClassDefFound
Error) and may be out-of-date. Check the realms:
[FATAL ERROR] Plugin realm = app0.child-container[org.codehaus.mojo:openjpa-maven-plugin:1.0]
urls[0] = file:/home/kiosk/.m2/repository/org/codehaus/mojo/openjpa-maven-plugin/1.0/openjpa-maven-plugin-1.0.jar
urls[1] = file:/home/kiosk/.m2/repository/org/apache/openjpa/openjpa/2.0.0-SNAPSHOT/openjpa-2.0.0-SNAPSHOT.jar
urls[2] = file:/home/kiosk/.m2/repository/commons-logging/commons-logging/1.0.4/commons-logging-1.0.4.jar
urls[3] = file:/home/kiosk/.m2/repository/commons-lang/commons-lang/2.1/commons-lang-2.1.jar
urls[4] = file:/home/kiosk/.m2/repository/commons-collections/commons-collections/3.2.1/commons-collections-3.2.1.jar
urls[5] = file:/home/kiosk/.m2/repository/net/sourceforge/serp/serp/1.13.1/serp-1.13.1.jar
urls[6] = file:/home/kiosk/.m2/repository/junit/junit/3.8.2/junit-3.8.2.jar
urls[7] = file:/home/kiosk/.m2/repository/org/apache/geronimo/specs/geronimo-jms_1.1_spec/1.1.1/geronimo-jms_1.1_spec-1
.1.1.jar
urls[8] = file:/home/kiosk/.m2/repository/org/apache/geronimo/specs/geronimo-jta_1.1_spec/1.1.1/geronimo-jta_1.1_spec-1
.1.1.jar
urls[9] = file:/home/kiosk/.m2/repository/commons-pool/commons-pool/1.5.3/commons-pool-1.5.3.jar
urls[10] = file:/home/kiosk/.m2/repository/org/apache/geronimo/specs/geronimo-jpa_2.0_spec/1.0/geronimo-jpa_2.0_spec-1.
0.jar
urls[11] = file:/home/kiosk/.m2/repository/org/codehaus/plexus/plexus-utils/1.5.7/plexus-utils-1.5.7.jar
urls[12] = file:/home/kiosk/.m2/repository/org/codehaus/plexus/plexus-classworlds/1.2-alpha-13/plexus-classworlds-1.2-a
lpha-13.jar
urls[13] = file:/home/kiosk/.m2/repository/log4j/log4j/1.2.14/log4j-1.2.14.jar
[FATAL ERROR] Container realm = plexus.core
urls[0] = file:/home/kiosk/apache-maven-2.2.1/lib/maven-2.2.1-uber.jar
[INFO] ------------------------------------------------------------------------
[ERROR] FATAL ERROR
[INFO] ------------------------------------------------------------------------
[INFO] org/apache/openjpa/lib/util/Options
org.apache.openjpa.lib.util.Options
[INFO] ------------------------------------------------------------------------
[INFO] Trace
java.lang.NoClassDefFoundError: org/apache/openjpa/lib/util/Options
        at org.codehaus.mojo.openjpa.OpenJpaEnhancerMojo.getOptions(OpenJpaEnhancerMojo.java:96)
        at org.codehaus.mojo.openjpa.OpenJpaEnhancerMojo.enhance(OpenJpaEnhancerMojo.java:114)
        at org.codehaus.mojo.openjpa.OpenJpaEnhancerMojo.execute(OpenJpaEnhancerMojo.java:86)
        at org.apache.maven.plugin.DefaultPluginManager.executeMojo(DefaultPluginManager.java:490)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoals(DefaultLifecycleExecutor.java:694)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeStandaloneGoal(DefaultLifecycleExecutor.java:569)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoal(DefaultLifecycleExecutor.java:539)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalAndHandleFailures(DefaultLifecycleExecutor.ja
va:387)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeTaskSegments(DefaultLifecycleExecutor.java:348)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.execute(DefaultLifecycleExecutor.java:180)
        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:328)
        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:138)
        at org.apache.maven.cli.MavenCli.main(MavenCli.java:362)
        at org.apache.maven.cli.compat.CompatibleMain.main(CompatibleMain.java:60)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315)
        at org.codehaus.classworlds.Launcher.launch(Launcher.java:255)
        at org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:430)
        at org.codehaus.classworlds.Launcher.main(Launcher.java:375)
Caused by: java.lang.ClassNotFoundException: org.apache.openjpa.lib.util.Options
        at java.net.URLClassLoader$1.run(URLClassLoader.java:200)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:307)
        at org.codehaus.classworlds.RealmClassLoader.loadClassDirect(RealmClassLoader.java:195)
        at org.codehaus.classworlds.DefaultClassRealm.loadClass(DefaultClassRealm.java:255)
        at org.codehaus.classworlds.DefaultClassRealm.loadClass(DefaultClassRealm.java:274)
        at org.codehaus.classworlds.RealmClassLoader.loadClass(RealmClassLoader.java:214)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:252)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:320)
        ... 22 more
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3 seconds
[INFO] Finished at: Tue Mar 16 01:36:32 PST 2010
[INFO] Final Memory: 18M/155M
[INFO] ------------------------------------------------------------------------
kiosk@kiosk:~/laptopsanytime/laptopsanytime-model$ ",any,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-03-16 13:46:10.456,,,no_permission,,,,,,,,,,,,161839,,,Wed Mar 17 12:40:35 UTC 2010,,,,,,,0|i0z3fb:,202857,,,,,,,,"16/Mar/10 13:46;drwoods;The ""openjpa-maven-plugin"" is developed over at Codehaus in the Mojo project and is not part of the Apache OpenJPA builds or distributions -
    http://mojo.codehaus.org/openjpa-maven-plugin/index.html
Please open a issue in their JIRA -
    http://jira.codehaus.org/browse/MOJO
","16/Mar/10 14:02;drwoods;When you report the problem to the Mojo JIRA, can you also include the pom.xml fragment showing how you configured the openjpa-maven-plugin?  Make sure you include a dependency on groupId=org.apache.openjpa, artifactId=openjpa and version=2.0.0-SNAPSHOT or 2.0.0-beta2 like -
    <build>
    . . .
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>openjpa-maven-plugin</artifactId>
                <version>1.0</version>
                <configuration>
                    <!-- next 2 are optional and specific to your project -->
                    <includes>org/apache/openjpa/integration/daytrader/*Bean.class</includes>
                    <excludes>org/apache/openjpa/persistence/**/*.class</excludes>
                    <addDefaultConstructor>true</addDefaultConstructor>
                    <enforcePropertyRestrictions>true</enforcePropertyRestrictions>
                </configuration>
                <executions>
                    <execution>
                        <id>enhancer</id>
                        <phase>process-classes</phase>
                        <goals>
                            <goal>enhance</goal>
                        </goals>
                    </execution>
                </executions>
                <dependencies>
                    <dependency>
                        <groupId>org.apache.openjpa</groupId>
                        <artifactId>openjpa</artifactId>
                        <version>2.0.0-SNAPSHOT</version>
                    </dependency>
                </dependencies>
            </plugin>
    . . .
    </build>

Also, what version of Maven and JDK are you using?
The Options class is still there and hasn't been changed since 3/22/09 -
   drwoods:trunk/$ svn log openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Options.java --limit 4
   ------------------------------------------------------------------------
   r757278 | mikedd | 2009-03-22 19:37:24 -0400 (Sun, 22 Mar 2009) | 1 line
   OPENJPA-896. Setting eol-style:native and removing windows eol characters from source files.

so it sounds like a configuration problem in your build, as I can use the openjpa-maven-plugin with the latest 2.0.0-SNAPSHOT code built locally yesterday on my Mac....
","16/Mar/10 20:42;sqqqas;cop out. 

""using openjpa-2.0.0-SNAPSHOT"" does not imply we are using your personal svn build.  it's a repo upload issue based on maven fetching SNAPSHOT dependencies.

here's my 4-month old pom fragment.  the plugin didn't change in the past 3 days, just the SNAPSHOT element.

            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>openjpa-maven-plugin</artifactId>
                <version>1.0</version>
                <configuration>
                    <includes>**/*.class</includes>
                    <addDefaultConstructor>true</addDefaultConstructor>
                    <enforcePropertyRestrictions>false</enforcePropertyRestrictions>

                    <!--Pass additional properties to the Plugin here-->
                    <toolProperties>
                        <properties>
                            <!--<property name=""ConnectionURL"" value=""jdbc:derby:/derby/auth""/>-->
                            <property name=""ConnectionDriverName"" value=""org.apache.derby.jdbc.ClientDataSource""/>
                            <property name=""Log"" value=""SQL=TRACE,INFO""/>
                        </properties>

                    </toolProperties>

                </configuration>
                <executions>
                    <execution>
                        <id>enhancer</id>
                        <phase>process-classes</phase>
                        <goals>
                            <goal>enhance</goal>
                        </goals>
                    </execution>
                </executions>
                <dependencies>
                    <dependency>
                        <groupId>org.apache.openjpa</groupId>
                        <artifactId>openjpa</artifactId>
                        <version>2.0.0-SNAPSHOT</version>
                    </dependency>
                </dependencies>
            </plugin>

if i switch to using openjpa-all i get classloader conflicts ","16/Mar/10 21:47;sqqqas;the problem has resolved itself and likely represents poor transactional updates of the maven repo evident by checksum failures on the maven fetch process which is 

a) using SNAPSHOT in the version
b) fetching SNAPSHOT versions dailly 
c) probably fetching nightly updates being incomplete during nightly builds of dependant projects.

i see no mention of where to point maven at the beta2 release on the main website to reduce this potential race condition, having a beta2 suffix version instead of SNAPSHOT would allow the team to focus on testing of that release instead of a nightly snapshot that may be half-uploaded at the time of client dependency resolution at large.","17/Mar/10 12:40;drwoods;The 2.0.0-beta2 is an official release, so it is on the default maven central (repo1.maven.org) and all of it's mirrors around the world....  No special <repository> configuration is needed in your builds.  Just use openjpa.version=2.0.0-beta2 instead of 2.0.0-SNAPSHOT.

And yes, the Apache Snapshot repo can be unreliable at times, due to the shear load on it.....
",,,,,,,,,,,,,,,,,,,,,,
Query parameter on externalized field breaks Prepared Query Cache,OPENJPA-1575,12459182,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,ppoddar@apache.org,ppoddar@apache.org,ppoddar@apache.org,15/Mar/10 20:07,26/Apr/11 03:35,14/Mar/19 03:03,15/Mar/10 21:26,2.0.0-beta2,,,,,,,,2.0.0-beta3,,,,,kernel,query,,,0,,,,,,,,"If field value has been externalized and the query is using a parameter for that field, caching its SQL breaks because re-parametrization of the SQL can not externalize the user supplied parameter value through the field. The worse is the query is cached anyway and its parameter substituted with (wrong) non-externalized, user-supplied value -- resulting in wrong result.
Currently we will detect such usage and exclude the the query being cached.
However, we can consider a mechanics to capture the parametrized fields in a query expression tree and appropriately pass the user values through the fields' externalizer in future. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,no_permission,,,,,,,,,,,,161838,,,2010-03-15 20:07:26.0,,,,,,,0|i0z5lb:,203208,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect SQL for HAVING = entity variable,OPENJPA-1573,12459149,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,fancy,dianner,dianner,15/Mar/10 14:27,29/Mar/10 23:17,14/Mar/19 03:03,16/Mar/10 06:31,2.0.0-beta2,,,,,,,,2.0.0-beta3,,,,,,,,,0,,,,,,,,"I added the following query to test case TestSpec10_1_26:

        query = ""select VALUE(e) from Department1 d, "" +
        "" in (d.empMap) e "" +
        ""group by VALUE(e) "" +
        ""having VALUE(e) = :emp1"";
        q = em.createQuery(query).setParameter(""emp1"", e1);

I also tried the following, which should be equivalent:

        query = ""select e from Department1 d, "" +
            "" in (d.empMap) e "" +
            ""group by e "" +
            ""having e = :emp1"";
        q = em.createQuery(query).setParameter(""emp1"", e1);        

Both failed with the following:

<openjpa-2.0.0-SNAPSHOT-r422266:922946M fatal general error> org.apache.openjpa.persistence.PersistenceException: Column T2.EMPID is referenced in the HAVING clause but is not in the GROUP BY list. {SELECT t1.empId, t1.dept_id FROM T6D1 t0 INNER JOIN T6E1 t1 ON t0.deptId = t1.dept_id INNER JOIN T6E1 t2 ON t0.deptId = t2.dept_id GROUP BY t1.empId, t1.dept_id HAVING t2.empId = ?} [code=30000, state=42X24]
	at org.apache.openjpa.jdbc.sql.DBDictionary.narrow(DBDictionary.java:4823)
	at org.apache.openjpa.jdbc.sql.DBDictionary.newStoreException(DBDictionary.java:4783)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:137)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:118)
	at org.apache.openjpa.jdbc.sql.SQLExceptions.getStore(SQLExceptions.java:70)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.handleCheckedException(SelectResultObjectProvider.java:155)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.handleCheckedException(QueryImpl.java:2101)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:40)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1243)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1004)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:860)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:791)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:290)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:304)
	at org.apache.openjpa.persistence.jdbc.maps.spec_10_1_26_ex0.TestSpec10_1_26.queryQualifiedId(TestSpec10_1_26.java:151)
	at org.apache.openjpa.persistence.jdbc.maps.spec_10_1_26_ex0.TestSpec10_1_26.testQueryQualifiedId(TestSpec10_1_26.java:76)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)
	at java.lang.reflect.Method.invoke(Method.java:600)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runTest(AbstractPersistenceTestCase.java:516)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:503)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:479)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:179)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
Caused by: org.apache.openjpa.lib.jdbc.ReportingSQLException: Column T2.EMPID is referenced in the HAVING clause but is not in the GROUP BY list. {SELECT t1.empId, t1.dept_id FROM T6D1 t0 INNER JOIN T6E1 t1 ON t0.deptId = t1.dept_id INNER JOIN T6E1 t2 ON t0.deptId = t2.dept_id GROUP BY t1.empId, t1.dept_id HAVING t2.empId = ?} [code=30000, state=42X24]
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:257)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.wrap(LoggingConnectionDecorator.java:237)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator.access$000(LoggingConnectionDecorator.java:70)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:289)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:186)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:155)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:186)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1600)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:175)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:549)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:529)
	at org.apache.openjpa.jdbc.sql.SelectImpl.prepareStatement(SelectImpl.java:450)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:391)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:363)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:427)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:230)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:220)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:94)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.open(QueryImpl.java:2060)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:34)
	... 31 more
NestedThrowables:
java.sql.SQLSyntaxErrorException: Column T2.EMPID is referenced in the HAVING clause but is not in the GROUP BY list.
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)
	at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.<init>(Unknown Source)
	at org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)
	at org.apache.commons.dbcp.DelegatingConnection.prepareStatement(DelegatingConnection.java:262)
	at org.apache.commons.dbcp.PoolingDataSource$PoolGuardConnectionWrapper.prepareStatement(PoolingDataSource.java:307)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:188)
	at org.apache.openjpa.lib.jdbc.JDBCEventConnectionDecorator$EventConnection.prepareStatement(JDBCEventConnectionDecorator.java:200)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:186)
	at org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator$LoggingConnection.prepareStatement(LoggingConnectionDecorator.java:286)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:186)
	at org.apache.openjpa.lib.jdbc.ConfiguringConnectionDecorator$ConfiguringConnection.prepareStatement(ConfiguringConnectionDecorator.java:155)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:186)
	at org.apache.openjpa.jdbc.kernel.JDBCStoreManager$RefCountConnection.prepareStatement(JDBCStoreManager.java:1600)
	at org.apache.openjpa.lib.jdbc.DelegatingConnection.prepareStatement(DelegatingConnection.java:175)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:549)
	at org.apache.openjpa.jdbc.sql.SQLBuffer.prepareStatement(SQLBuffer.java:529)
	at org.apache.openjpa.jdbc.sql.SelectImpl.prepareStatement(SelectImpl.java:450)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:391)
	at org.apache.openjpa.jdbc.sql.SelectImpl.execute(SelectImpl.java:363)
	at org.apache.openjpa.jdbc.sql.LogicalUnion$UnionSelect.execute(LogicalUnion.java:427)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:230)
	at org.apache.openjpa.jdbc.sql.LogicalUnion.execute(LogicalUnion.java:220)
	at org.apache.openjpa.jdbc.kernel.SelectResultObjectProvider.open(SelectResultObjectProvider.java:94)
	at org.apache.openjpa.kernel.QueryImpl$PackingResultObjectProvider.open(QueryImpl.java:2060)
	at org.apache.openjpa.lib.rop.EagerResultList.<init>(EagerResultList.java:34)
	at org.apache.openjpa.kernel.QueryImpl.toResult(QueryImpl.java:1243)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:1004)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:860)
	at org.apache.openjpa.kernel.QueryImpl.execute(QueryImpl.java:791)
	at org.apache.openjpa.kernel.DelegatingQuery.execute(DelegatingQuery.java:542)
	at org.apache.openjpa.persistence.QueryImpl.execute(QueryImpl.java:290)
	at org.apache.openjpa.persistence.QueryImpl.getResultList(QueryImpl.java:304)
	at org.apache.openjpa.persistence.jdbc.maps.spec_10_1_26_ex0.TestSpec10_1_26.queryQualifiedId(TestSpec10_1_26.java:151)
	at org.apache.openjpa.persistence.jdbc.maps.spec_10_1_26_ex0.TestSpec10_1_26.testQueryQualifiedId(TestSpec10_1_26.java:76)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)
	at java.lang.reflect.Method.invoke(Method.java:600)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runTest(AbstractPersistenceTestCase.java:516)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:503)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.runBare(AbstractPersistenceTestCase.java:479)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.apache.openjpa.persistence.test.AbstractPersistenceTestCase.run(AbstractPersistenceTestCase.java:179)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
Caused by: java.sql.SQLException: Column T2.EMPID is referenced in the HAVING clause but is not in the GROUP BY list.
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)
	... 63 more
Caused by: ERROR 42X24: Column T2.EMPID is referenced in the HAVING clause but is not in the GROUP BY list.
	at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)
	at org.apache.derby.impl.sql.compile.GroupByNode.addNewColumnsForAggregation(Unknown Source)
	at org.apache.derby.impl.sql.compile.GroupByNode.addAggregates(Unknown Source)
	at org.apache.derby.impl.sql.compile.GroupByNode.init(Unknown Source)
	at org.apache.derby.iapi.sql.compile.NodeFactory.getNode(Unknown Source)
	at org.apache.derby.impl.sql.compile.SelectNode.genProjectRestrict(Unknown Source)
	at org.apache.derby.impl.sql.compile.SelectNode.modifyAccessPaths(Unknown Source)
	at org.apache.derby.impl.sql.compile.DMLStatementNode.optimizeStatement(Unknown Source)
	at org.apache.derby.impl.sql.compile.CursorNode.optimizeStatement(Unknown Source)
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(Unknown Source)
	at org.apache.derby.impl.sql.GenericStatement.prepare(Unknown Source)
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(Unknown Source)
	... 57 more

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-03-16 06:31:37.399,,,no_permission,,,,,,,,,,,,161836,,,Tue Mar 16 06:31:37 UTC 2010,,,,,,,0|i0zbtz:,204219,,,,,,,,16/Mar/10 06:31;fancy;Fix checked under trunk svn r923589,,,,,,,,,,,,,,,,,,,,,,,,,,
The change in the element collection is not persisted to the database during merging a detached entity,OPENJPA-1571,12459108,Bug,Closed,OPENJPA,OpenJPA,software,struberg,"Implementation of Java persistence, including the Java Persistence API JSR-220 (JPA 1.0) and JSR-317 (JPA 2.0).",http://openjpa.apache.org,Major,Fixed,drwoods,faywang,faywang,15/Mar/10 08:17,29/Mar/10 23:17,14/Mar/19 03:03,21/Mar/10 00:10,2.0.0-beta2,,,,,,,,2.0.0-beta3,,,,,,,,,0,,,,,,,,"Given an entity:

@Entity
public class EntityB {

    @Id
    private int id; 
    
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = ""setIntegerTable"", joinColumns = @JoinColumn(name = ""parent_id""))
    @Column(name = ""value"")
    private Set<Integer> intVals;

...
}

The following test scenario 

        EntityB b1 = em.find(EntityB.class, id);
        em.clear();
        b1.getIntVals().remove(new Integer(1));
        b1.getIntVals().add(new Integer(2)); 
        
        em.getTransaction().begin();
        EntityB b2 = em.merge(b1);
        em.getTransaction().commit();
        em.clear();

        EntityB b3 = em.find(EntityB.class, id);
        Set<Integer> intVals = b3.getIntVals();
        ==> this intVals still only contains Integer(1), not Integer(2).

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-03-15 16:48:12.704,,,no_permission,,,,,,,,,,,,161834,,,Mon Mar 22 18:50:24 UTC 2010,,,,,,,0|i0z3h3:,202865,,,,,,,,"15/Mar/10 16:48;drwoods;This is the new behavior as implemented in OPENJPA-1097, in that the EM.clear() was not removing all $proxy classes, which caused them to be included when serialized.",21/Mar/10 00:10;drwoods;Fixed by r925416 checked in using OPENJPA-1097.,"22/Mar/10 18:50;to_rowe;Fix verified on Linux AMD64 SE6 with Derby running JSE, web, and EJB scenarios.",,,,,,,,,,,,,,,,,,,,,,,,
